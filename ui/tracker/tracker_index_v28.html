<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BenchSight Tracker v27.0</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<style>
:root {
  --bg: #0a0e14; --panel: #131920; --card: #1a222c; --input: #0d1117;
  --border: #2a3441; --accent: #00d4aa; --accent2: #00b4d8;
  --success: #10b981; --warn: #f59e0b; --danger: #ef4444;
  --text: #e2e8f0; --muted: #64748b; --home: #3b82f6; --away: #ef4444;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: 'SF Mono', monospace; background: var(--bg); color: var(--text); font-size: 11px; overflow: hidden; height: 100vh; }
:root {
  --left-panel-width: 220px;
  --right-panel-width: 320px;
  --base-font-size: 11px;
}
.app { display: grid; grid-template-rows: 36px 1fr; height: 100vh; }
.header { background: var(--panel); border-bottom: 1px solid var(--border); padding: 0 8px; display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
.header h1 { font-size: 12px; background: linear-gradient(135deg, var(--accent), var(--accent2)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
.main { display: grid; grid-template-columns: var(--left-panel-width) 1fr var(--right-panel-width); height: 100%; overflow: hidden; }
.panel { background: var(--panel); border-right: 1px solid var(--border); display: flex; flex-direction: column; overflow: hidden; position: relative; min-width: 150px; }
.panel:last-child { border-right: none; border-left: 1px solid var(--border); }

/* v23.8: Responsive layout adjustments */
@media (max-width: 1400px) {
  :root {
    --left-panel-width: 200px;
    --right-panel-width: 300px;
    --base-font-size: 10px;
  }
}

@media (max-width: 1200px) {
  :root {
    --left-panel-width: 180px;
    --right-panel-width: 280px;
    --base-font-size: 9px;
  }
  .header { font-size: 9px; }
  .panel-header { font-size: 8px; }
}

@media (max-width: 1000px) {
  .main { grid-template-columns: 160px 1fr 240px; }
  :root {
    --left-panel-width: 160px;
    --right-panel-width: 240px;
  }
}

@media (max-height: 700px) {
  .panel-body { max-height: calc(100vh - 150px) !important; }
}
.panel-header { background: var(--card); padding: 4px 8px; font-size: 9px; font-weight: 600; text-transform: uppercase; color: var(--accent); border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; }
.panel-body { flex: 1; overflow-y: auto; padding: 6px; }
select, input, button { font-family: inherit; font-size: 10px; background: var(--input); border: 1px solid var(--border); color: var(--text); padding: 4px 6px; border-radius: 3px; }
select:focus, input:focus { border-color: var(--accent); outline: none; }
button { cursor: pointer; } button:hover { background: var(--card); border-color: var(--accent); }
.btn-sm { padding: 2px 5px; font-size: 9px; }
.btn-sm.active { background: var(--accent); color: #000; }
#quickDetailRow .btn-sm.active { background: var(--accent); color: #000; font-weight: bold; }
.btn-primary { background: var(--accent); color: #000; border-color: var(--accent); }
.btn-success { background: var(--success); color: #fff; }
.btn-danger { background: var(--danger); color: #fff; }
kbd { background: var(--bg); border: 1px solid var(--border); padding: 0 3px; border-radius: 2px; font-size: 8px; color: var(--muted); }
.form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 4px; }
.form-row.tri { grid-template-columns: 1fr 1fr 1fr; }
.form-group { display: flex; flex-direction: column; gap: 1px; }
.form-group label { font-size: 7px; color: var(--muted); text-transform: uppercase; }
.form-group select, .form-group input { width: 100%; }

/* Resize handles - v23.8: Enhanced for modular layout */
.resize-handle { position: absolute; background: transparent; z-index: 10; }
.resize-handle:hover { background: var(--accent); opacity: 0.5; }
.resize-handle.right { right: 0; top: 0; width: 4px; height: 100%; cursor: ew-resize; }
.resize-handle.left { left: 0; top: 0; width: 4px; height: 100%; cursor: ew-resize; }
.resize-handle.active { background: var(--accent); opacity: 0.8; }

/* Header */
.game-select { width: 200px; }
.game-search { background: var(--input); border: 1px solid var(--border); color: var(--text); padding: 4px 8px; border-radius: 3px; width: 150px; font-size: 10px; }
.clock { font-size: 16px; font-weight: 700; color: var(--accent); background: var(--bg); padding: 2px 8px; border-radius: 3px; border: 1px solid var(--border); }
.score { font-size: 14px; font-weight: 700; }
.score-h { color: var(--home); } .score-a { color: var(--away); }
.period-btns { display: flex; gap: 2px; }
.period-btn { padding: 2px 6px; } .period-btn.active { background: var(--accent); color: #000; }
.header-right { margin-left: auto; display: flex; gap: 6px; align-items: center; }
.status { font-size: 8px; color: var(--muted); }
.save-ind { font-size: 7px; padding: 1px 4px; border-radius: 4px; background: var(--card); }
.save-ind.saving { background: var(--warn); color: #000; }
.save-ind.saved { background: var(--success); color: #fff; }
.conn { font-size: 7px; padding: 1px 4px; border-radius: 8px; }
.conn.on { background: var(--success); color: #fff; } .conn.off { background: var(--muted); color: #fff; }

/* Shift Panel */
.team-sec { margin-bottom: 8px; }
.team-hdr { display: flex; justify-content: space-between; align-items: center; padding: 3px 6px; background: var(--card); border-radius: 3px; margin-bottom: 3px; }
.team-hdr h4 { font-size: 9px; display: flex; align-items: center; gap: 4px; }
.team-dot { width: 8px; height: 8px; border-radius: 50%; }
.slots { display: grid; grid-template-columns: 20px 1fr; gap: 2px; margin-bottom: 2px; }
.slot-lbl { font-size: 7px; color: var(--muted); display: flex; align-items: center; }
.slot-row { display: flex; gap: 2px; }
.slot { flex: 1; min-height: 24px; border-radius: 3px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; border: 2px solid var(--border); background: var(--input); font-size: 10px; position: relative; transition: transform 0.1s, box-shadow 0.1s; }
.slot .num { font-weight: 700; } .slot .name { font-size: 6px; color: var(--muted); max-width: 40px; overflow: hidden; text-overflow: ellipsis; }
.slot.filled { border-color: var(--success); background: var(--card); cursor: grab; }
.slot.filled:active { cursor: grabbing; }
.slot.selected { box-shadow: 0 0 0 2px var(--accent); }
.slot.drag-over { border-color: var(--accent); background: rgba(0,212,170,0.2); transform: scale(1.05); }
.slot.dragging { opacity: 0.5; transform: scale(0.95); }
.slot .clear-x { position: absolute; top: -4px; right: -4px; width: 14px; height: 14px; border-radius: 50%; background: var(--danger); color: #fff; font-size: 10px; line-height: 14px; text-align: center; cursor: pointer; display: none; border: 1px solid var(--bg); z-index: 5; }
.slot.filled:hover .clear-x { display: block; }
.slot .clear-x:hover { background: #dc2626; transform: scale(1.1); }

/* Save Location UI */
.save-location-box { background: var(--card); border: 1px solid var(--border); border-radius: 4px; padding: 8px; margin-bottom: 8px; }
.save-location-box .folder-display { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
.save-location-box .folder-path { flex: 1; background: var(--bg); border: 1px solid var(--border); border-radius: 3px; padding: 6px 8px; font-size: 10px; color: var(--text); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.save-location-box .folder-path.empty { color: var(--muted); font-style: italic; }
.save-location-box .folder-actions { display: flex; gap: 4px; }
.save-location-box .folder-status { font-size: 9px; color: var(--muted); margin-top: 4px; }
.save-location-box .folder-status.ready { color: var(--success); }
.save-location-box .folder-status.error { color: var(--danger); }
.roster { background: var(--card); border-radius: 3px; padding: 3px; max-height: 100px; overflow-y: auto; }
.roster-group { margin-bottom: 4px; }
.roster-group-label { font-size: 7px; color: var(--accent); text-transform: uppercase; display: block; margin-bottom: 2px; }
.roster-btn { padding: 2px 4px; font-size: 8px; border-radius: 2px; cursor: pointer; border: 1px solid var(--border); background: var(--input); display: inline-flex; flex-direction: column; align-items: center; min-width: 36px; margin: 1px; }
.roster-btn .num { font-weight: 700; } .roster-btn .name { font-size: 6px; color: var(--muted); }
.roster-btn .rating { font-size: 6px; color: var(--accent); background: var(--bg); padding: 0 2px; border-radius: 2px; margin-top: 1px; }
.roster-btn:hover { background: var(--accent); color: #000; }
.roster-btn.on-ice { opacity: 0.3; }
.shift-times { display: grid; grid-template-columns: 1fr 1fr; gap: 3px; margin-top: 4px; padding: 4px; background: var(--card); border-radius: 3px; }
.shift-times label { font-size: 6px; color: var(--muted); }
.shift-actions { display: flex; gap: 3px; margin-top: 4px; }
.shift-actions button { flex: 1; padding: 6px; font-size: 9px; }

/* Center - Rink */
.center { display: flex; flex-direction: column; background: var(--panel); overflow-y: auto; }
.video-section { border-bottom: 2px solid var(--accent); }
.video-section .speed-btn.active { background: var(--accent); color: #000; }
.video-toggle-bar:hover { background: var(--panel); }
.rink-wrap { flex: 1; display: flex; align-items: center; justify-content: center; padding: 8px; position: relative; min-height: 300px; max-height: 450px; }
.rink-container { position: relative; display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; height: 100%; max-width: 100%; }
.rink-wrap.with-net { flex-direction: row; gap: 16px; align-items: flex-start; }
.rink-wrap.with-net .rink-container { flex: 1 1 auto; min-width: 0; max-width: calc(100% - 140px); }
.rink-wrap:not(.with-net) .rink-container { flex: 0 0 auto; }
#rinkSvg { max-width: 100%; max-height: 100%; cursor: crosshair; }
#rinkSvg.panning { cursor: grabbing !important; }
.mode-ind { position: absolute; top: 6px; left: 50%; transform: translateX(-50%); padding: 3px 10px; border-radius: 12px; font-size: 9px; font-weight: 600; border: 2px solid; }
.mode-ind.puck { background: #000; color: #fff; border-color: #fff; }
.mode-ind.player { background: var(--accent); color: #000; border-color: var(--accent); }
.xy-controls { display: flex; gap: 4px; padding: 4px 8px; background: var(--card); border-top: 1px solid var(--border); align-items: center; flex-wrap: wrap; justify-content: center; }
.xy-btn { padding: 2px 6px; font-size: 9px; } .xy-btn.active { background: var(--accent); color: #000; }
.xy-slots { display: flex; gap: 1px; }
.xy-slot { width: 18px; height: 18px; border-radius: 2px; display: flex; align-items: center; justify-content: center; font-size: 8px; cursor: pointer; border: 1px solid var(--border); background: var(--input); position: relative; }
.xy-slot.has { background: var(--success); color: #fff; } .xy-slot.active { box-shadow: 0 0 0 2px var(--accent); }
@keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }
.xy-player-sel { min-width: 80px; font-size: 9px; }

/* Event List */
.evt-list { border-top: 1px solid var(--border); flex: 0 0 auto; min-height: 120px; max-height: 280px; overflow-y: auto; background: var(--card); }
.evt-header { display: grid; grid-template-columns: 35px 45px 100px 1fr 20px; gap: 2px; padding: 2px 6px; background: var(--card); font-size: 7px; color: var(--muted); position: sticky; top: 0; }
/* v20.4: Expanded columns - #, Sh, Lnk, Time, AdjTime, VideoTime, T, TeamName, Type, Detail1, Detail2, Z, S, EvtP, OppP, PD1, PD2, PS, XY, ‚≠ê, üìù, ‚úèÔ∏è */
.evt-item { display: grid; grid-template-columns: 30px 30px 22px 22px 20px 48px 48px 48px 14px 46px 30px 58px 58px 14px 12px 30px 30px 46px 46px 12px 12px 12px 30px 30px; gap: 1px; padding: 2px 3px; border-bottom: 1px solid var(--border); font-size: 7px; cursor: pointer; align-items: center; }
.evt-item { display: grid; grid-template-columns: 30px 30px 22px 22px 20px 48px 48px 48px 14px 46px 30px 58px 58px 14px 12px 30px 30px 46px 46px 12px 12px 12px 30px 30px; gap: 1px; padding: 2px 3px; border-bottom: 1px solid var(--border); font-size: 7px; cursor: pointer; align-items: center; }
.evt-move-btns { display: flex; flex-direction: column; gap: 1px; }
.evt-move-btns button { padding: 1px 3px; font-size: 8px; line-height: 1; min-height: auto; }
/* v20.4: Event log filter row */
.evt-filter-row { display: flex; flex-wrap: wrap; gap: 4px; padding: 4px 6px; background: var(--panel); border-bottom: 1px solid var(--border); align-items: center; }
.evt-filter-row select, .evt-filter-row input { font-size: 8px; padding: 2px 4px; background: var(--card); border: 1px solid var(--border); color: var(--text); border-radius: 3px; }
.evt-filter-row select { max-width: 80px; }
.evt-filter-row input { width: 40px; }
.evt-filter-row label { font-size: 7px; color: var(--muted); margin-right: 2px; }
.evt-filter-row .filter-group { display: flex; align-items: center; gap: 2px; }
.evt-filter-row .btn-clear { font-size: 8px; padding: 2px 6px; background: var(--danger); color: white; border: none; border-radius: 3px; cursor: pointer; }
.evt-item:hover { background: var(--panel); }
.evt-item.active { background: rgba(0,212,170,0.1); }
.evt-item.event-highlight { background: rgba(59,130,246,0.2); border-left: 3px solid var(--accent); font-weight: 600; } /* v23.8: Highlight target event */
.evt-item.goal-context { border-left: 2px solid var(--success); } /* v23.6: Goal in goals+context filter */
.evt-item.event-goal { background: rgba(59, 130, 246, 0.15); border-left: 2px solid rgba(59, 130, 246, 0.5); } /* v23.7: Highlight all goals with lighter blue */
.evt-item.event-team-warning { background: rgba(251,191,36,0.15); border-left: 3px solid var(--warn); } /* Team validation warning */
.evt-item .idx { color: var(--accent); font-family: monospace; font-size: 7px; }
.evt-item .seq { color: var(--accent2); font-family: monospace; font-size: 6px; }
.evt-item .link { color: var(--warn); font-family: monospace; font-size: 6px; }
.evt-item .time { color: var(--muted); font-size: 7px; }
.evt-item .team { font-weight: bold; font-size: 7px; }
.evt-item .type { font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 7px; }
.evt-item .detail { color: var(--muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 6px; }
.evt-item .zone { color: var(--accent2); font-size: 6px; }
.evt-item .success { color: var(--success); font-size: 7px; }
.evt-item .evtp { font-size: 6px; color: var(--accent); font-family: monospace; }
.evt-item .oppp { font-size: 6px; color: var(--muted); font-family: monospace; }
.evt-item .pd1 { font-size: 5px; color: var(--muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.evt-item .psucc { font-size: 6px; color: var(--success); }
.evt-item .xy-dot { color: var(--accent); font-size: 10px; font-weight: bold; }
.evt-item .hl { color: var(--warn); }

/* Right Panel - Event Entry */
.team-toggle { display: flex; gap: 2px; margin-bottom: 4px; }
.team-toggle button { flex: 1; padding: 5px; font-size: 9px; }
.team-toggle .swap-btn { flex: 0 0 28px; background: var(--card); border: 1px solid var(--border); font-size: 12px; padding: 2px; }
.team-toggle .swap-btn:hover { background: var(--accent); color: #000; }
.team-toggle .home.active { background: var(--home); color: #fff; }
.team-toggle .away.active { background: var(--away); color: #fff; }
.evt-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 2px; margin-bottom: 6px; }
.evt-btn { padding: 4px 2px; display: flex; flex-direction: column; align-items: center; font-size: 8px; border-radius: 3px; }
.evt-btn kbd { font-size: 7px; } .evt-btn.active { background: var(--accent); color: #000; }
.section { margin-bottom: 6px; }
.section-title { font-size: 8px; color: var(--muted); margin-bottom: 2px; display: flex; justify-content: space-between; }
.player-list { background: var(--card); border-radius: 3px; padding: 3px; min-height: 28px; }
.player-chip { display: inline-flex; align-items: center; gap: 2px; padding: 2px 5px; margin: 1px; border-radius: 3px; font-size: 9px; cursor: grab; border: 1px solid var(--border); background: var(--input); transition: transform 0.1s, opacity 0.1s; }
.player-chip:active { cursor: grabbing; }
.player-chip.dragging { opacity: 0.5; transform: scale(0.95); }
.player-chip.drag-over { transform: scale(1.05); box-shadow: 0 0 0 2px var(--accent); }
.player-chip .role-num { font-size: 7px; color: var(--muted); background: var(--bg); padding: 0 3px; border-radius: 2px; margin-right: 2px; }
.player-chip.evt { border-color: var(--accent); background: rgba(0,212,170,0.1); }
.player-chip.evt .role-num { color: var(--accent); }
.player-chip.opp { border-color: var(--danger); background: rgba(239,68,68,0.1); }
.player-chip.opp .role-num { color: var(--danger); }
.player-list { background: var(--card); border-radius: 3px; padding: 3px; min-height: 28px; }
.player-list.drag-target { background: rgba(0,212,170,0.1); border: 1px dashed var(--accent); }
.player-chip.selected { box-shadow: 0 0 0 2px var(--warn); }
.player-chip .num { font-weight: 700; }
.player-chip .su { font-size: 7px; padding: 0 2px; border-radius: 2px; margin-left: 2px; }
.player-chip .su.s { background: var(--success); color: #fff; }
.player-chip .su.u { background: var(--danger); color: #fff; }
.player-chip .remove { color: var(--muted); margin-left: 2px; } .player-chip .remove:hover { color: var(--danger); }
.quick-add { display: flex; flex-wrap: wrap; gap: 2px; padding: 3px; background: var(--card); border-radius: 3px; }
.quick-add button { padding: 2px 4px; font-size: 8px; min-width: 24px; }
.quick-add button.in-evt { background: var(--accent); color: #000; }
.quick-add button.recent { border: 2px solid var(--warning); box-shadow: 0 0 4px var(--warning); }
.player-details { background: var(--card); border-radius: 3px; padding: 4px; margin-top: 4px; font-size: 8px; }
.player-details h5 { color: var(--accent); margin-bottom: 3px; font-size: 9px; }
.log-actions { display: flex; gap: 3px; margin-top: 6px; }
.log-actions button { flex: 1; padding: 8px; font-size: 10px; }

/* Zone indicator */
.zone-ind { display: inline-block; padding: 2px 6px; border-radius: 3px; font-size: 8px; font-weight: bold; margin-left: 4px; }
.zone-ind.o { background: var(--success); color: #fff; }
.zone-ind.d { background: var(--danger); color: #fff; }
.zone-ind.n { background: var(--warn); color: #000; }

/* Modals */
.overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.85); display: none; align-items: center; justify-content: center; z-index: 10000; visibility: hidden; opacity: 0; transition: opacity 0.2s, visibility 0.2s; }
.overlay.show { display: flex !important; visibility: visible !important; opacity: 1 !important; z-index: 10000 !important; }
.modal { background: var(--panel); border: 1px solid var(--border); border-radius: 6px; padding: 12px; min-width: 400px; max-width: 600px; max-height: 80vh; overflow-y: auto; position: relative; z-index: 10001; }
.modal h3 { font-size: 12px; color: var(--accent); margin-bottom: 8px; }
.modal-actions { display: flex; gap: 4px; margin-top: 10px; }
.modal-actions button { flex: 1; }
/* v20.5: Mapping modal for import validation */
.mapping-modal { min-width: 700px; max-width: 900px; }
.mapping-modal h3 { font-size: 14px; margin-bottom: 12px; }
.mapping-modal .summary { font-size: 11px; color: var(--muted); margin-bottom: 10px; }
.mapping-table { width: 100%; border-collapse: collapse; font-size: 10px; margin: 10px 0; }
.mapping-table th { background: var(--card); color: var(--accent); padding: 6px 8px; text-align: left; border: 1px solid var(--border); }
.mapping-table td { padding: 6px 8px; border: 1px solid var(--border); }
.mapping-table tr:hover { background: rgba(0,212,255,0.1); }
.mapping-table .field { color: var(--muted); font-size: 9px; }
.mapping-table .original { color: var(--warn); font-family: monospace; }
.mapping-table .matched { color: var(--success); font-family: monospace; }
.mapping-table .no-match { color: var(--danger); }
.mapping-table select { font-size: 9px; padding: 2px 4px; max-width: 180px; background: var(--card); border: 1px solid var(--border); color: var(--text); }
.mapping-table .score { font-size: 9px; color: var(--muted); }
.mapping-legend { display: flex; gap: 15px; font-size: 9px; margin: 8px 0; }
.mapping-legend span { display: flex; align-items: center; gap: 4px; }
.mapping-legend .dot { width: 8px; height: 8px; border-radius: 50%; }
.mapping-legend .dot.exact { background: var(--success); }
.mapping-legend .dot.fuzzy { background: var(--accent); }
.mapping-legend .dot.none { background: var(--danger); }
.mapping-legend .dot.custom { background: var(--warn); }
.mapping-table input[type="checkbox"] { margin-right: 4px; }
.mapping-table tr.selected { background: rgba(0,212,255,0.2); }
.mapping-filters { display: flex; gap: 10px; margin-bottom: 10px; flex-wrap: wrap; align-items: center; }
.mapping-filters input, .mapping-filters select { font-size: 10px; padding: 4px 6px; background: var(--card); border: 1px solid var(--border); color: var(--text); }
.mapping-batch-actions { display: flex; gap: 8px; margin: 10px 0; padding: 8px; background: var(--card); border: 1px solid var(--border); border-radius: 4px; }
.mapping-batch-actions button { font-size: 10px; padding: 4px 8px; }
.modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 999; }
.mapping-modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1000; }

/* Edit Modal Specific */
.edit-player-row { display: flex; gap: 4px; align-items: center; padding: 4px; background: var(--input); border-radius: 3px; margin-bottom: 4px; }
.edit-player-row .pnum { font-weight: bold; min-width: 50px; }
.edit-player-row select, .edit-player-row input { flex: 1; }
.edit-xy-grid { display: flex; gap: 2px; flex-wrap: wrap; margin-top: 4px; }
.edit-xy-btn { width: 24px; height: 24px; border-radius: 3px; display: flex; align-items: center; justify-content: center; font-size: 8px; cursor: pointer; }
.edit-xy-btn.has { background: var(--success); color: #fff; }

/* Toast */
.toast { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); background: var(--card); border: 1px solid var(--border); padding: 6px 14px; border-radius: 4px; font-size: 10px; z-index: 200; opacity: 0; transition: opacity 0.2s; }
.toast.show { opacity: 1; }
.toast.success { border-color: var(--success); color: var(--success); }
.toast.error { border-color: var(--danger); color: var(--danger); }

/* XY Tooltip v5 */
.xy-tooltip { position: absolute; background: rgba(0,0,0,0.9); color: #fff; padding: 6px 10px; border-radius: 4px; font-size: 10px; pointer-events: none; z-index: 100; white-space: nowrap; transform: translate(-50%, -100%); margin-top: -8px; }
.xy-tooltip::after { content: ''; position: absolute; bottom: -4px; left: 50%; transform: translateX(-50%); border-left: 5px solid transparent; border-right: 5px solid transparent; border-top: 5px solid rgba(0,0,0,0.9); }

/* Clear All Buttons v5 */
.clear-all-btn { padding: 4px 8px; font-size: 8px; background: var(--danger); color: #fff; border: none; border-radius: 3px; cursor: pointer; margin-left: 4px; }
.clear-all-btn:hover { background: #dc2626; }

/* Auto-popup checkbox v5 */
.auto-popup-row { display: flex; align-items: center; gap: 8px; margin: 8px 0; padding: 6px; background: var(--card); border-radius: 4px; font-size: 9px; }
.auto-popup-row input[type="checkbox"] { margin: 0; }

/* Enhanced player chip inline edit v5 */
.player-chip { position: relative; }
.player-chip .inline-edit { position: absolute; top: 100%; left: 0; background: var(--panel); border: 1px solid var(--accent); border-radius: 4px; padding: 4px; z-index: 50; min-width: 150px; display: none; }
.player-chip:hover .inline-edit.active { display: block; }

/* Collapsible sections */
.collapsible-section { margin-bottom: 4px; }
.collapsible-header { display: flex; justify-content: space-between; align-items: center; padding: 4px 6px; background: var(--card); border: 1px solid var(--border); border-radius: 3px; cursor: pointer; font-size: 8px; user-select: none; }
.collapsible-header:hover { background: var(--panel); }
.collapsible-icon { font-size: 8px; color: var(--muted); transition: transform 0.2s; margin-left: 4px; }
.collapsible-content:not(.show) { display: none; }
.collapsible-content.show { display: block !important; }
.collapsible-content.show[style*="flex"] { display: flex !important; }
.collapsible-content[style*="display:flex"].show { display: flex !important; }

/* Hotkey indicator flash v5 */
.hotkey-flash { animation: hotkey-pulse 0.3s ease-out; }
@keyframes hotkey-pulse { 0% { box-shadow: 0 0 0 0 rgba(0,212,170,0.5); } 100% { box-shadow: 0 0 0 10px rgba(0,212,170,0); } }

/* Event type colors v5 */
.evt-btn[data-type="Goal"] { border-color: #22c55e !important; }
.evt-btn[data-type="Goal"].active { background: #22c55e !important; }
.evt-btn[data-type="Shot"] { border-color: #3b82f6 !important; }
.evt-btn[data-type="Shot"].active { background: #3b82f6 !important; }
.evt-btn[data-type="Penalty"] { border-color: #ef4444 !important; }
.evt-btn[data-type="Penalty"].active { background: #ef4444 !important; }
.evt-btn[data-type="Turnover"] { border-color: #f59e0b !important; }
.evt-btn[data-type="Turnover"].active { background: #f59e0b !important; }

/* Quick stats bar v5 */
.quick-stats { display: flex; gap: 8px; padding: 4px 8px; background: var(--card); font-size: 9px; border-bottom: 1px solid var(--border); }
.quick-stat { display: flex; align-items: center; gap: 4px; }
.quick-stat .label { color: var(--muted); }
.quick-stat .value { font-weight: bold; color: var(--accent); }

/* Period indicator enhanced v5 */
.period-btn.active { background: var(--accent); color: #000; font-weight: bold; }

/* Shift strength indicator v5 */
.strength-indicator { padding: 2px 6px; border-radius: 3px; font-size: 9px; font-weight: bold; }
.strength-indicator.pp { background: rgba(34,197,94,0.2); color: #22c55e; }
.strength-indicator.pk { background: rgba(239,68,68,0.2); color: #ef4444; }
.strength-indicator.even { background: rgba(100,116,139,0.2); color: #94a3b8; }

/* v6: Period filter tabs */
.period-filter-tabs { display: flex; gap: 2px; padding: 4px 8px; background: var(--bg); border-bottom: 1px solid var(--border); }
.period-filter-tab { padding: 2px 8px; font-size: 8px; border: 1px solid var(--border); border-radius: 3px; cursor: pointer; background: var(--input); color: var(--muted); }
.period-filter-tab.active { background: var(--accent); color: #000; border-color: var(--accent); }

/* v6: Line presets */
.line-presets { padding: 4px 8px; background: var(--card); border-bottom: 1px solid var(--border); font-size: 8px; }
.preset-row { display: flex; gap: 4px; align-items: center; margin-bottom: 2px; }
.preset-btn { padding: 2px 6px; font-size: 8px; border-radius: 3px; cursor: pointer; border: 1px solid var(--border); background: var(--input); }
.preset-btn:hover { background: var(--accent); color: #000; }
.preset-btn.active { border-color: var(--success); }

/* v6: Compact mode */
.compact-mode .panel-body { padding: 4px; }
.compact-mode .team-sec { margin-bottom: 4px; }
.compact-mode .team-hdr { padding: 2px 4px; margin-bottom: 2px; }
.compact-mode .slots { margin-bottom: 1px; }
.compact-mode .slot { min-height: 20px; font-size: 9px; }
.compact-mode .roster { max-height: 60px; padding: 2px; }
.compact-mode .roster-btn { padding: 1px 2px; font-size: 7px; min-width: 28px; }
.compact-mode .quick-stats { padding: 2px 8px; }

/* v6: Selected player indicator */
.selected-player-slot { box-shadow: 0 0 0 2px var(--accent), 0 0 8px var(--accent); }
.player-selector { display: inline-flex; align-items: center; gap: 2px; padding: 1px 4px; border-radius: 3px; font-size: 8px; cursor: pointer; border: 1px solid var(--border); }
.player-selector.selected { background: var(--accent); color: #000; border-color: var(--accent); }
</style>
</head>
<body>
<div class="app">
  <!-- Header -->
  <header class="header">
    <h1 style="display:flex;align-items:center;gap:8px;">
      <a href="https://benchsight.io" target="_blank" style="color:var(--accent);text-decoration:none;display:flex;align-items:center;gap:4px;" title="Visit BenchSight.io">
        <span>üèí BenchSight</span>
      </a>
      <select id="versionSelector" onchange="handleVersionChange(this.value)" style="font-size:12px;padding:2px 6px;background:var(--bg);border:1px solid var(--border);border-radius:3px;color:var(--accent);font-weight:bold;cursor:pointer;">
        <option value="v26.0" selected>v26.0</option>
        <option value="v25.0">v25.0</option>
        <option value="v24.0">v24.0</option>
        <option value="v23.7">v23.7</option>
        <option value="v23.6">v23.6</option>
        <option value="v23.5">v23.5</option>
      </select>
      <span id="gameLinks" style="font-size:8px;display:none;gap:6px;margin-left:8px;opacity:0.7;">
        <a href="#" id="noradLink" target="_blank" style="color:var(--muted);text-decoration:none;display:none;" title="View game on Norad Hockey">üìä Norad</a>
        <a href="#" id="benchsightGameLink" target="_blank" style="color:var(--muted);text-decoration:none;display:none;" title="View game on BenchSight">üîó Game</a>
      </span>
    </h1>
    <div style="display:flex;gap:4px;align-items:center;">
      <input type="text" id="gameSearch" class="game-search" placeholder="üîç Search games..." oninput="filterGames(this.value)">
      <select id="gameSelect" class="game-select" onchange="selectGame(this.value)"></select>
      <button class="btn-sm" onclick="loadGames()" title="Reload Games">üîÑ</button>
    </div>
    <div class="period-btns">
      <button class="period-btn active" data-p="1" onclick="setPeriod(1)" title="Period 1">P1</button>
      <button class="period-btn" data-p="2" onclick="setPeriod(2)" title="Period 2">P2</button>
      <button class="period-btn" data-p="3" onclick="setPeriod(3)" title="Period 3">P3</button>
      <button class="period-btn" data-p="OT" onclick="setPeriod('OT')" title="Overtime">OT</button>
      <span id="periodLengthIndicator" style="font-size:9px;color:var(--muted);margin-left:4px;" title="Current period length">(18m)</span>
      <button id="flipZonesBtn" onclick="flipZones()" title="Flip which end home attacks in P1 (for beer league variable benches)" style="margin-left:8px;padding:2px 6px;font-size:10px;background:#374151;">‚ü∑ Flip</button>
      <button class="btn-sm" onclick="showPeriodEndChecklist()" title="Period checklist & verification" style="font-size:9px;">üìã Check</button>
      <button class="btn-sm" onclick="setVideoOffset()" title="Set video sync offset" style="font-size:9px;">üé¨ Sync</button>
    </div>
    <span class="score"><span class="score-h" id="scoreH">0</span> - <span class="score-a" id="scoreA">0</span></span>
    <input type="text" class="clock" id="clock" value="18:00" style="width:60px;text-align:center;" onchange="updateClock()" oninput="autoFormatTime(this)">
    <span id="workTimerDisplay" style="font-size:11px;color:var(--accent);padding:2px 8px;background:var(--card);border-radius:3px;border:1px solid var(--border);min-width:80px;text-align:center;" title="Active work time (auto-pauses after 2 min inactivity)">‚è±Ô∏è 0:00</span>
    <div class="header-right">
      <span class="save-ind" id="saveInd">--</span>
      <input type="number" id="autoSaveIntHeader" value="300" min="30" max="3600" step="30" 
             style="width:60px;padding:2px 4px;font-size:11px;margin-right:4px;background:var(--card);border:1px solid var(--border);border-radius:3px;color:var(--text);" 
             title="Auto-save interval (seconds)" 
             onchange="startAutoSave(); toast('Auto-save interval updated', 'info');">
      <button class="btn-sm" onclick="manualSave()" title="Save Now">üíæ</button>
      <button class="btn-sm" onclick="openLoadGameModal()" title="Load Existing Game">üìÇ</button>
      <button class="btn-sm" onclick="openVerifyModal()" title="Verify Goals">‚úÖ</button>
      <button class="btn-sm" onclick="openVideoTimingModal()" title="Video Timing">üé¨</button>
      <button class="btn-sm" onclick="openHighlightVideosModal()" title="Highlight Videos">‚≠ê</button>
      <span class="conn off" id="connStatus">OFFLINE</span>
      <button class="btn-sm" onclick="openSettings()" title="Settings & Configuration">‚öôÔ∏è</button>
      <button class="btn-sm" onclick="openHelp()" title="Quick Help (?)">‚ùì</button>
      <button class="btn-sm" onclick="openUserGuide()" title="Full User Guide" style="background:var(--accent);color:#000;">üìñ</button>
      <button class="btn-sm btn-success" onclick="exportData()" title="Export game data to Excel">üì• Export Excel</button>
      <button class="btn-sm btn-success" onclick="exportToCSV()" title="Export to CSV (multiple files)">üì• Export CSV</button>
      <button class="btn-sm" style="background:#6366f1;" onclick="document.getElementById('importFileInput').click()" title="Import game data from Excel">üì§ Import</button>
      <input type="file" id="importFileInput" accept=".xlsx,.xls" style="display:none" onchange="importExcel(this.files[0])">
    </div>
  </header>
  
  <!-- Quick Stats Bar (v5) -->
  <div class="quick-stats" id="quickStatsBar">
    <div class="quick-stat"><span class="label">Events:</span><span class="value" id="qsEvents">0</span></div>
    <div class="quick-stat"><span class="label">Shifts:</span><span class="value" id="qsShifts">0</span></div>
    <div class="quick-stat"><span class="label">SOG:</span><span class="value" id="qsSOG">0-0</span></div>
    <div class="quick-stat"><span class="label">FO:</span><span class="value" id="qsFO">0-0</span></div>
    <div class="quick-stat"><span class="label">PEN:</span><span class="value" id="qsPEN">0-0</span></div>
    <div class="quick-stat" style="margin-left:auto;"><span class="label">Strength:</span><span class="value strength-indicator even" id="qsStrength">5v5</span></div>
  </div>
  
  <!-- v23.5: Workflow Bars -->
  <div class="workflow-bars" style="padding:4px 8px;background:var(--panel);border-bottom:1px solid var(--border);display:flex;flex-wrap:wrap;gap:8px;align-items:center;font-size:10px;">
    <!-- Possession -->
    <div style="display:flex;align-items:center;gap:4px;">
      <span style="color:var(--muted);font-size:8px;">POSS:</span>
          <button class="btn-sm" onclick="setPossession('home')" style="padding:2px 6px;background:var(--home);color:#fff;font-size:9px;" title="Set possession to Home team">H</button>
      <div id="possessionDisplay" style="display:flex;align-items:center;width:80px;font-size:9px;">
        <span style="color:var(--home);">50%</span>
        <div style="flex:1;height:6px;background:var(--away);border-radius:3px;margin:0 4px;overflow:hidden;">
          <div style="width:50%;height:100%;background:var(--home);"></div>
        </div>
        <span style="color:var(--away);">50%</span>
      </div>
          <button class="btn-sm" onclick="setPossession('away')" style="padding:2px 6px;background:var(--away);color:#fff;font-size:9px;" title="Set possession to Away team">A</button>
      <button class="btn-sm" onclick="resetPossessionTimers()" style="padding:2px 4px;font-size:8px;" title="Reset">‚Ü∫</button>
    </div>
    
    <span style="color:var(--border);">|</span>
    
    <!-- Penalty Box -->
    <div style="display:flex;align-items:center;gap:4px;">
      <span style="color:var(--muted);font-size:8px;">BOX:</span>
      <div id="penaltyBoxDisplay" style="display:flex;gap:4px;">
        <span style="font-size:9px;color:var(--muted);">No penalties</span>
      </div>
    </div>
    
    <span style="color:var(--border);">|</span>
    
    <!-- Quick Actions -->
    <div style="display:flex;align-items:center;gap:4px;">
      <button class="btn-sm" id="undoBtn" onclick="undo()" style="padding:2px 6px;font-size:9px;" title="Undo (Ctrl+Z)" disabled>‚Ü© Undo</button>
      <button class="btn-sm" id="batchSelectBtn" onclick="toggleBatchSelectMode()" style="padding:2px 6px;font-size:9px;" title="Batch select events">‚òë Batch</button>
      <button class="btn-sm" onclick="toggleKeyboardXYMode()" style="padding:2px 6px;font-size:9px;" title="WASD to move, Enter to place">‚å® XY</button>
      <button class="btn-sm" onclick="toggleStatsOverlay()" style="padding:2px 6px;font-size:9px;" title="Show stats on video">üìä</button>
      <button class="btn-sm" onclick="addQuickNote()" style="padding:2px 6px;font-size:9px;" title="Add note to event">üìù</button>
    </div>
    
    <span style="color:var(--border);">|</span>
    
    <!-- Recent Players -->
    <div style="display:flex;align-items:center;gap:4px;flex:1;">
      <span style="color:var(--muted);font-size:8px;">RECENT:</span>
      <div id="recentPlayersBar" style="display:flex;gap:2px;flex-wrap:wrap;">
        <span style="font-size:8px;color:var(--muted);">Recent players appear here</span>
      </div>
    </div>
  </div>
  
  <!-- v23.5: Event Queue & Suggestions -->
  <div style="display:flex;gap:8px;padding:4px 8px;background:var(--card);border-bottom:1px solid var(--border);align-items:center;min-height:24px;">
    <div id="eventSuggestions" style="display:flex;align-items:center;gap:4px;"></div>
    <div id="eventQueueDisplay" style="display:flex;align-items:center;gap:4px;flex-wrap:wrap;margin-left:auto;"></div>
    <button class="btn-sm" onclick="toggleSuggestions()" style="padding:2px 4px;font-size:8px;" title="Toggle suggestions">üí°</button>
  </div>
  
  <!-- v23.5: Speed Tools Bar -->
  <div style="display:flex;gap:8px;padding:3px 8px;background:var(--panel);border-bottom:1px solid var(--border);align-items:center;font-size:9px;">
    <!-- Mode Toggles -->
    <div style="display:flex;align-items:center;gap:2px;">
      <span style="color:var(--muted);font-size:8px;">MODE:</span>
      <button class="btn-sm" id="mirrorModeBtn" onclick="toggleMirrorMode()" style="padding:2px 5px;font-size:8px;" title="Auto-flip XY for P2">üîÑ Mirror</button>
      <button class="btn-sm" onclick="toggleAutoZone()" style="padding:2px 5px;font-size:8px;" title="Auto-set zone from XY">üéØ AutoZ</button>
      <button class="btn-sm" onclick="toggleGoalieAutoAdd()" style="padding:2px 5px;font-size:8px;" title="Auto-Add Goalie: When enabled, automatically adds the opposing team's goalie as an opponent player when you log Shot, Goal, Save, or Rebound events. Saves time by not having to manually add the goalie each time.">ü•Ö AutoG</button>
      <button class="btn-sm" onclick="toggleNumpadMode()" style="padding:2px 5px;font-size:8px;" title="Use numpad for player slots">üî¢ Numpad</button>
    </div>
    
    <span style="color:var(--border);">|</span>
    
    <!-- Quick Stoppages -->
    <div style="display:flex;align-items:center;gap:2px;">
      <span style="color:var(--muted);font-size:8px;">STOP:</span>
      <button class="btn-sm" onclick="quickIcing('home')" style="padding:2px 5px;font-size:8px;background:var(--home);color:#fff;" title="Quick Icing - Home">Ice-H</button>
      <button class="btn-sm" onclick="quickIcing('away')" style="padding:2px 5px;font-size:8px;background:var(--away);color:#fff;" title="Quick Icing - Away">Ice-A</button>
      <button class="btn-sm" onclick="quickOffside()" style="padding:2px 5px;font-size:8px;" title="Quick Offside">Offside</button>
    </div>
    
    <span style="color:var(--border);">|</span>
    
    <!-- Strength Quick -->
    <div style="display:flex;align-items:center;gap:2px;">
      <span style="color:var(--muted);font-size:8px;">STR:</span>
      <button class="btn-sm strength-btn" data-strength="5v5" onclick="setStrength('5v5')" style="padding:2px 5px;font-size:8px;" title="Set strength: 5v5 (Even)">5v5</button>
      <button class="btn-sm strength-btn" data-strength="5v4" onclick="setStrength('5v4')" style="padding:2px 5px;font-size:8px;background:var(--success);" title="Set strength: 5v4 (Power Play)">PP</button>
      <button class="btn-sm strength-btn" data-strength="4v5" onclick="setStrength('4v5')" style="padding:2px 5px;font-size:8px;background:var(--danger);" title="Set strength: 4v5 (Penalty Kill)">PK</button>
      <button class="btn-sm strength-btn" data-strength="4v4" onclick="setStrength('4v4')" style="padding:2px 5px;font-size:8px;" title="Set strength: 4v4">4v4</button>
    </div>
    
    <span style="color:var(--border);">|</span>
    
    <!-- Empty Net & Tools -->
    <div style="display:flex;align-items:center;gap:2px;">
      <button class="btn-sm" onclick="toggleEmptyNet('home')" style="padding:2px 5px;font-size:8px;" title="Home empty net">EN-H</button>
      <button class="btn-sm" onclick="toggleEmptyNet('away')" style="padding:2px 5px;font-size:8px;" title="Away empty net">EN-A</button>
      <span id="emptyNetIndicator" style="display:none;font-weight:bold;padding:0 4px;"></span>
    </div>
    
    <span style="color:var(--border);">|</span>
    
    <!-- Analysis Tools -->
    <div style="display:flex;align-items:center;gap:2px;">
      <button class="btn-sm" onclick="findEventGaps()" style="padding:2px 5px;font-size:8px;" title="Find gaps in coverage">üîç Gaps</button>
      <button class="btn-sm" onclick="runConsistencyCheck()" style="padding:2px 5px;font-size:8px;" title="Check for issues">‚úÖ Check</button>
      <button class="btn-sm" onclick="toggleShotChartOverlay()" style="padding:2px 5px;font-size:8px;" title="Shot Chart Overlay: Display all tracked shots on the rink visualization. Goals appear in green, shots on goal in team colors. Helps visualize shot locations and patterns throughout the game.">üìç Shots</button>
    </div>
    
    <span style="color:var(--border);">|</span>
    
    <!-- Macros & Tools -->
    <div style="display:flex;align-items:center;gap:2px;">
      <button class="btn-sm" id="macroRecordBtn" onclick="recordingMacro ? stopRecordingMacro() : startRecordingMacro()" style="padding:2px 5px;font-size:8px;" title="Record event macro">‚è∫ Rec</button>
      <button class="btn-sm" onclick="showMacroManager()" style="padding:2px 5px;font-size:8px;" title="Manage macros">üé¨ Macros</button>
      <button class="btn-sm" onclick="toggleFloatingVideo()" style="padding:2px 5px;font-size:8px;" title="Floating video window">üì∫ Float</button>
    </div>
    
    <span style="color:var(--border);">|</span>
    
    <!-- Progress -->
    <div id="progressBar" style="min-width:100px;"></div>
  </div>

  <!-- Main -->
  <div class="main">
    <!-- Left: Shifts -->
    <div class="panel" id="leftPanel">
      <div class="resize-handle right" onmousedown="startResize(event, 'left')"></div>
      <div class="panel-header">
        <span>Shift Tracking</span>
        <button class="btn-sm" onclick="toggleCompactMode()" title="Toggle Compact Mode">‚äü</button>
      </div>
      <!-- v6: Line Presets - Collapsible -->
      <div class="collapsible-section">
        <div class="collapsible-header" onclick="toggleCollapsible('linePresetsBar')">
          <span style="color:var(--muted);">LINE PRESETS</span>
          <span class="collapsible-icon" id="linePresetsBarIcon">‚ñº</span>
        </div>
        <div class="line-presets collapsible-content show" id="linePresetsBar" style="display:flex !important;">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:2px;">
            <button class="btn-sm" onclick="openLinePresetModal()" title="Line presets">‚öôÔ∏è</button>
          </div>
          <div class="preset-row">
            <button class="preset-btn" onclick="loadPreset('home','F1')" title="Load Home F1 preset">F1</button>
            <button class="preset-btn" onclick="loadPreset('home','F2')" title="Load Home F2 preset">F2</button>
            <button class="preset-btn" onclick="loadPreset('home','F3')" title="Load Home F3 preset">F3</button>
            <button class="preset-btn" onclick="loadPreset('home','D1')" title="Load Home D1 preset">D1</button>
            <button class="preset-btn" onclick="loadPreset('home','D2')" title="Load Home D2 preset">D2</button>
            <span style="color:var(--muted);font-size:7px;">Home</span>
          </div>
          <div class="preset-row">
            <button class="preset-btn" onclick="loadPreset('away','F1')" title="Load Away F1 preset">F1</button>
            <button class="preset-btn" onclick="loadPreset('away','F2')" title="Load Away F2 preset">F2</button>
            <button class="preset-btn" onclick="loadPreset('away','F3')" title="Load Away F3 preset">F3</button>
            <button class="preset-btn" onclick="loadPreset('away','D1')" title="Load Away D1 preset">D1</button>
            <button class="preset-btn" onclick="loadPreset('away','D2')" title="Load Away D2 preset">D2</button>
            <span style="color:var(--muted);font-size:7px;">Away</span>
          </div>
        </div>
      </div>
      <div class="panel-body">
        <!-- Home Team -->
        <div class="team-sec">
          <div class="team-hdr">
            <h4><img id="homeLogoImg" src="" alt="" style="height:20px;width:auto;margin-right:4px;display:none;vertical-align:middle;" onerror="this.style.display='none'" onload="this.style.display='inline'"><span class="team-dot" id="homeDot" style="background:var(--home)"></span><span id="homeLbl">Home</span></h4>
            <button class="btn-sm" onclick="clearSlots('home')" title="Clear all home team slots">Clear</button>
          </div>
          <div class="slots"><span class="slot-lbl">F</span><div class="slot-row" id="homeF"></div></div>
          <div class="slots"><span class="slot-lbl">D</span><div class="slot-row" id="homeD"></div></div>
          <div class="slots"><span class="slot-lbl">G</span><div class="slot-row" id="homeG"></div></div>
          <div class="roster" id="homeRoster"></div>
        </div>
        <!-- Away Team -->
        <div class="team-sec">
          <div class="team-hdr">
            <h4><img id="awayLogoImg" src="" alt="" style="height:20px;width:auto;margin-right:4px;display:none;vertical-align:middle;" onerror="this.style.display='none'" onload="this.style.display='inline'"><span class="team-dot" id="awayDot" style="background:var(--away)"></span><span id="awayLbl">Away</span></h4>
            <button class="btn-sm" onclick="clearSlots('away')" title="Clear all away team slots">Clear</button>
          </div>
          <div class="slots"><span class="slot-lbl">F</span><div class="slot-row" id="awayF"></div></div>
          <div class="slots"><span class="slot-lbl">D</span><div class="slot-row" id="awayD"></div></div>
          <div class="slots"><span class="slot-lbl">G</span><div class="slot-row" id="awayG"></div></div>
          <div class="roster" id="awayRoster"></div>
        </div>
        <!-- Shift Times -->
        <div class="shift-times">
          <div class="form-group"><label>Start Type</label><select id="shiftStartType"></select></div>
          <div class="form-group"><label>Stop Type</label><select id="shiftStopType"></select></div>
          <div class="form-group"><label>Start</label><input type="text" id="shiftStart" value="18:00" oninput="autoFormatTime(this)"></div>
          <div class="form-group"><label>End</label><input type="text" id="shiftEnd" value="" oninput="autoFormatTime(this)"></div>
        </div>
        <div class="shift-actions">
          <button class="btn-success" onclick="logShift()" title="Log current shift (L key)">Log Shift <kbd>L</kbd></button>
        </div>
        <!-- Shift Log -->
        <div class="log-container" style="margin-top:8px;">
          <div class="panel-header" style="font-size:8px;display:flex;justify-content:space-between;">
            <span>Shift Log</span>
            <span>
              <button class="btn-sm" onclick="addNewShift()" title="Add New Shift" style="background:var(--success);">‚ûï</button>
              <button class="clear-all-btn" onclick="clearAllShifts()" title="Clear All Shifts">üóëÔ∏è All</button>
              <button class="btn-sm" onclick="showAllShifts()" title="View all shifts in modal">View All</button>
            </span>
          </div>
          <!-- v6: Period filter tabs -->
          <div class="period-filter-tabs">
            <button class="period-filter-tab active" data-filter="all" onclick="filterShiftLog('all')" title="Show all shifts">ALL</button>
            <button class="period-filter-tab" data-filter="1" onclick="filterShiftLog('1')" title="Show Period 1 shifts">P1</button>
            <button class="period-filter-tab" data-filter="2" onclick="filterShiftLog('2')" title="Show Period 2 shifts">P2</button>
            <button class="period-filter-tab" data-filter="3" onclick="filterShiftLog('3')" title="Show Period 3 shifts">P3</button>
            <button class="period-filter-tab" data-filter="OT" onclick="filterShiftLog('OT')" title="Show Overtime shifts">OT</button>
            <button class="period-filter-tab" data-filter="issues" onclick="filterShiftLog('issues')" title="Show shifts with issues">‚ö†Ô∏è Issues</button>
          </div>
          <div class="log-header" style="grid-template-columns: 25px 25px 40px 40px 60px;">
            <span>#</span><span>P</span><span>Start</span><span>End</span><span>Type</span>
          </div>
          <!-- v23.8: Player search for shift log -->
          <div style="padding:4px 8px;background:var(--card);border-bottom:1px solid var(--border);">
            <input type="text" id="shiftLogPlayerSearch" placeholder="üîç Search by player # or name..." style="width:100%;font-size:9px;padding:4px 8px;border:1px solid var(--border);border-radius:4px;background:var(--bg);color:var(--text);" oninput="filterShiftLogByPlayer(this.value)" title="Search shifts by player jersey number or name (searches all shift players)">
          </div>
          <div id="shiftLogBody" style="max-height:200px;overflow-y:auto;"></div>
        </div>
        <!-- v23.8: Box Score Button - moved to header for visibility -->
        <div style="margin-top:8px;padding:6px;background:var(--accent);border-radius:4px;">
          <button class="btn-sm" onclick="showFullBoxScore()" style="width:100%;font-weight:bold;background:#fff;color:var(--accent);font-size:11px;padding:6px;" title="Show full box score with all player stats">üìä FULL BOX SCORE</button>
        </div>
        <!-- Player Box Score -->
        <div class="box-score" style="margin-top:8px;background:var(--card);border-radius:4px;padding:6px;">
          <div style="font-size:8px;color:var(--muted);margin-bottom:4px;">
            <span>PLAYER STATS</span>
          </div>
          <div id="playerBoxScore" style="max-height:120px;overflow-y:auto;">
            <table style="width:100%;font-size:8px;border-collapse:collapse;">
              <thead>
                <tr style="color:var(--muted);">
                  <td>#</td><td>Name</td><td>G</td><td>A</td><td>SOG</td><td>TOI</td>
                </tr>
              </thead>
              <tbody id="playerBoxBody"></tbody>
            </table>
          </div>
        </div>
        <!-- Team Summary -->
        <div class="team-summary" style="margin-top:4px;background:var(--card);border-radius:4px;padding:4px;font-size:8px;">
          <div style="display:flex;justify-content:space-between;">
            <span><span id="teamSumHome">HOME</span>: <strong id="teamSumHomeScore">0</strong></span>
            <span><span id="teamSumAway">AWAY</span>: <strong id="teamSumAwayScore">0</strong></span>
          </div>
          <div style="display:flex;justify-content:space-between;color:var(--muted);margin-top:2px;">
            <span>SOG: <span id="teamSumHomeSOG">0</span></span>
            <span>SOG: <span id="teamSumAwaySOG">0</span></span>
          </div>
        </div>
      </div>
    </div>

    <!-- Center: Rink -->
    <div class="center">
      <!-- v15.01: VIDEO PLAYER SECTION -->
      <div class="video-section" id="videoSection" style="display:none;">
        <div class="video-header" style="display:flex;justify-content:space-between;align-items:center;padding:4px 8px;background:var(--card);border-bottom:1px solid var(--border);">
          <div style="display:flex;align-items:center;gap:8px;">
            <span style="font-size:10px;font-weight:600;color:var(--accent);">üé¨ VIDEO</span>
            <select id="videoSourceSelect" onchange="switchVideoSource()" style="font-size:9px;width:120px;">
              <option value="">-- Sources --</option>
            </select>
            <button class="btn-sm" onclick="showAddVideoModal()" title="Add Video Source">+</button>
            <input type="file" id="videoFileInput" accept="video/*" style="display:none;" onchange="loadVideoFromFile(event)">
            <button class="btn-sm" onclick="document.getElementById('videoFileInput').click()" title="Load local file">üìÅ</button>
            <button class="btn-sm" onclick="showVideoSourcesManager()" title="Manage video sources">‚öôÔ∏è</button>
          </div>
          <div style="display:flex;align-items:center;gap:4px;">
            <!-- Video source hotkey buttons -->
            <div id="videoHotkeyBar" style="display:flex;gap:2px;margin-right:8px;"></div>
            <span id="videoTimeDisplay" style="font-size:12px;font-family:monospace;color:var(--accent);background:var(--bg);padding:2px 6px;border-radius:3px;">00:00:00</span>
            <span style="color:var(--muted);font-size:8px;">‚Üí</span>
            <span id="gameTimeFromVideo" style="font-size:10px;font-family:monospace;color:var(--warn);">P1 20:00</span>
            <button class="btn-sm" onclick="toggleVideoSection()" title="Minimize">‚ñº</button>
          </div>
        </div>
        <div id="videoPlayerContainer" style="position:relative;width:100%;height:200px;background:#000;overflow:hidden;">
          <!-- YouTube or HTML5 video will be inserted here -->
          <div id="videoPlaceholder" style="display:flex;align-items:center;justify-content:center;height:100%;color:var(--muted);font-size:11px;">
            No video loaded. Click + or üìÅ to add a video.
          </div>
          <div id="youtubePlayer" style="display:none;width:100%;height:100%;"></div>
          <video id="localVideoPlayer" style="display:none;width:100%;height:100%;" controls></video>
        </div>
        <!-- Video Scrub Bar -->
        <div id="videoScrubBar" style="padding:2px 8px;background:var(--card);"></div>
        <div class="video-controls" style="display:flex;gap:4px;padding:4px 8px;background:var(--card);border-top:1px solid var(--border);align-items:center;flex-wrap:wrap;">
          <!-- Playback controls -->
          <button class="btn-sm" onclick="videoSeek(-10)" title="Back 10s (Shift+‚Üê)">‚è™10</button>
          <button class="btn-sm" onclick="videoSeek(-1)" title="Back 1s (‚Üê)">‚óÄ1</button>
          <button class="btn-sm" onclick="videoFrameStep(-1)" title="Back 1 frame">|‚óÄ</button>
          <button class="btn-sm btn-primary" onclick="videoPlayPause()" id="videoPlayBtn" title="Play/Pause (Space)">‚ñ∂</button>
          <button class="btn-sm" onclick="videoFrameStep(1)" title="Forward 1 frame">‚ñ∂|</button>
          <button class="btn-sm" onclick="videoSeek(1)" title="Forward 1s">1‚ñ∂</button>
          <button class="btn-sm" onclick="videoSeek(10)" title="Forward 10s">10‚è©</button>
          
          <span style="color:var(--border);">|</span>
          
          <!-- Speed controls -->
          <span style="font-size:8px;color:var(--muted);">Speed:</span>
          <button class="btn-sm speed-btn" onclick="setVideoSpeed(0.25)" data-speed="0.25" title="Set video speed: 0.25x">0.25x</button>
          <button class="btn-sm speed-btn" onclick="setVideoSpeed(0.5)" data-speed="0.5" title="Set video speed: 0.5x">0.5x</button>
          <button class="btn-sm speed-btn active" onclick="setVideoSpeed(1)" data-speed="1" title="Set video speed: 1x (normal)">1x</button>
          <button class="btn-sm speed-btn" onclick="setVideoSpeed(1.5)" data-speed="1.5" title="Set video speed: 1.5x">1.5x</button>
          <button class="btn-sm speed-btn" onclick="setVideoSpeed(2)" data-speed="2" title="Set video speed: 2x">2x</button>
          
          <span style="color:var(--border);">|</span>
          
          <!-- Time sync controls -->
          <label style="font-size:8px;color:var(--muted);display:flex;align-items:center;gap:2px;">
            <input type="checkbox" id="videoAutoSync" checked onchange="toggleVideoAutoSync()"> Auto-sync times
          </label>
          <button class="btn-sm" onclick="captureStartTime()" title="Set event/shift START to current video time">üìç Start</button>
          <button class="btn-sm" onclick="captureEndTime()" title="Set event/shift END to current video time">üìç End</button>
          
          <span style="color:var(--border);">|</span>
          
          <!-- Zoom controls -->
          <span style="font-size:8px;color:var(--muted);">Zoom:</span>
          <button class="btn-sm" onclick="videoZoomOut()" title="Zoom out (-)">‚àí</button>
          <button class="btn-sm" onclick="videoZoomReset()" title="Reset zoom (0)">1:1</button>
          <button class="btn-sm" onclick="videoZoomIn()" title="Zoom in (+)">+</button>
          
          <span style="color:var(--border);">|</span>
          
          <!-- Hotkeys -->
          <span style="font-size:7px;color:var(--muted);">Keys: <kbd>Space</kbd>=play <kbd>‚Üê‚Üí</kbd>=¬±1s <kbd>‚áß‚Üê‚Üí</kbd>=¬±10s <kbd>;'</kbd>=frame <kbd>+-</kbd>=zoom</span>
        </div>
        <!-- Game Markers -->
        <div class="video-markers" style="display:flex;gap:4px;padding:4px 8px;background:var(--panel);border-top:1px solid var(--border);align-items:center;">
          <span style="font-size:8px;color:var(--muted);">Game Markers:</span>
          <button class="btn-sm" onclick="setGameMarker('P1Start')" title="Mark P1 puck drop">P1üèí</button>
          <button class="btn-sm" onclick="setGameMarker('P1End')" title="Mark P1 end">P1üõë</button>
          <button class="btn-sm" onclick="setGameMarker('P2Start')" title="Mark P2 puck drop">P2üèí</button>
          <button class="btn-sm" onclick="setGameMarker('P2End')" title="Mark P2 end">P2üõë</button>
          <button class="btn-sm" onclick="setGameMarker('P3Start')" title="Mark P3 puck drop">P3üèí</button>
          <button class="btn-sm" onclick="setGameMarker('P3End')" title="Mark P3 end">P3üõë</button>
          <button class="btn-sm" onclick="setGameMarker('OTStart')" title="Mark OT puck drop">OTüèí</button>
          <button class="btn-sm" onclick="addStoppageMarker()" title="Add stoppage (timeout, injury, etc)">‚è∏Ô∏è+</button>
          <span style="margin-left:auto;font-size:8px;color:var(--muted);" id="markerStatus">No markers set</span>
        </div>
      </div>
      <!-- Video Toggle Bar (shown when minimized) -->
      <div class="video-toggle-bar" id="videoToggleBar" style="display:flex;justify-content:space-between;align-items:center;padding:2px 8px;background:var(--card);border-bottom:1px solid var(--border);cursor:pointer;" onclick="toggleVideoSection()">
        <span style="font-size:9px;color:var(--accent);">üé¨ VIDEO</span>
        <span id="videoMiniTime" style="font-size:10px;font-family:monospace;color:var(--muted);">--:--:--</span>
        <span style="font-size:8px;color:var(--muted);">‚ñ≤ Expand</span>
      </div>
      
      <div class="rink-wrap" id="rinkWrapContainer">
        <div class="rink-container">
          <div class="mode-ind puck" id="modeInd">üèí PUCK</div>
          <div class="xy-tooltip" id="xyTooltip" style="display:none;"></div>
          <svg id="rinkSvg" viewBox="0 0 200 85">
          <defs>
            <linearGradient id="iceGrad" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" style="stop-color:#f0f9ff;stop-opacity:1"/>
              <stop offset="50%" style="stop-color:#e0f2fe;stop-opacity:1"/>
              <stop offset="100%" style="stop-color:#f0f9ff;stop-opacity:1"/>
            </linearGradient>
            <pattern id="iceTexture" patternUnits="userSpaceOnUse" width="4" height="4">
              <rect width="4" height="4" fill="#e0f2fe" opacity="0.3"/>
              <circle cx="1" cy="1" r="0.3" fill="#fff" opacity="0.4"/>
            </pattern>
          </defs>
          
          <!-- Ice surface -->
          <rect x="0" y="0" width="200" height="85" fill="url(#iceGrad)" rx="14" ry="14"/>
          <rect x="0" y="0" width="200" height="85" fill="url(#iceTexture)" rx="14" ry="14"/>
          <!-- Boards -->
          <rect x="0" y="0" width="200" height="85" fill="none" rx="14" ry="14" stroke="#1f2937" stroke-width="2"/>
          
          <!-- Blue lines -->
          <rect x="74" y="0" width="2" height="85" fill="#1e40af"/>
          <rect x="124" y="0" width="2" height="85" fill="#1e40af"/>
          
          <!-- Red center line (dashed) -->
          <line x1="100" y1="0" x2="100" y2="85" stroke="#dc2626" stroke-width="1.5" stroke-dasharray="4,2"/>
          
          <!-- Goal lines -->
          <line x1="11" y1="0" x2="11" y2="85" stroke="#dc2626" stroke-width="1"/>
          <line x1="189" y1="0" x2="189" y2="85" stroke="#dc2626" stroke-width="1"/>
          
          <!-- Center ice logo -->
          <circle cx="100" cy="42.5" r="10" fill="rgba(30,58,138,0.08)" stroke="none"/>
          <image href="https://www.noradhockey.com/wp-content/uploads/2022/05/New-NORAD-Logo-White.png" x="88" y="31" width="24" height="23" preserveAspectRatio="xMidYMid meet"/>
          
          <!-- Center circle -->
          <circle cx="100" cy="42.5" r="15" fill="none" stroke="#1e40af" stroke-width="1"/>
          <circle cx="100" cy="42.5" r="1" fill="#1e40af"/>
          
          <!-- Left zone circles -->
          <circle cx="31" cy="22" r="15" fill="none" stroke="#dc2626" stroke-width="0.8"/>
          <circle cx="31" cy="22" r="1" fill="#dc2626"/>
          <circle cx="31" cy="63" r="15" fill="none" stroke="#dc2626" stroke-width="0.8"/>
          <circle cx="31" cy="63" r="1" fill="#dc2626"/>
          
          <!-- Right zone circles -->
          <circle cx="169" cy="22" r="15" fill="none" stroke="#dc2626" stroke-width="0.8"/>
          <circle cx="169" cy="22" r="1" fill="#dc2626"/>
          <circle cx="169" cy="63" r="15" fill="none" stroke="#dc2626" stroke-width="0.8"/>
          <circle cx="169" cy="63" r="1" fill="#dc2626"/>
          
          <!-- Neutral zone dots -->
          <circle cx="80" cy="22" r="1" fill="#dc2626"/>
          <circle cx="80" cy="63" r="1" fill="#dc2626"/>
          <circle cx="120" cy="22" r="1" fill="#dc2626"/>
          <circle cx="120" cy="63" r="1" fill="#dc2626"/>
          
          <!-- Creases - NHL standard: 8ft wide, 4.5ft deep (scaled: 4 wide, 2.25 deep) -->
          <path d="M 11 38.5 L 15 38.5 A 4 4 0 0 1 15 46.5 L 11 46.5 Z" fill="rgba(59,130,246,0.25)" stroke="#3b82f6" stroke-width="0.8"/>
          <path d="M 189 38.5 L 185 38.5 A 4 4 0 0 0 185 46.5 L 189 46.5 Z" fill="rgba(59,130,246,0.25)" stroke="#3b82f6" stroke-width="0.8"/>
          
          <!-- Left goal -->
          <rect x="7" y="39" width="4" height="7" fill="#111827" stroke="#f8fafc" stroke-width="0.5"/>
          <line x1="7" y1="40" x2="10" y2="42.5" stroke="#374151" stroke-width="0.3"/>
          <line x1="7" y1="45" x2="10" y2="42.5" stroke="#374151" stroke-width="0.3"/>
          
          <!-- Right goal -->
          <rect x="189" y="39" width="4" height="7" fill="#111827" stroke="#f8fafc" stroke-width="0.5"/>
          <line x1="193" y1="40" x2="190" y2="42.5" stroke="#374151" stroke-width="0.3"/>
          <line x1="193" y1="45" x2="190" y2="42.5" stroke="#374151" stroke-width="0.3"/>
          
          <!-- Trapezoids -->
          <path d="M 0 28 L 11 34 L 11 51 L 0 57" fill="none" stroke="#dc2626" stroke-width="0.5"/>
          <path d="M 200 28 L 189 34 L 189 51 L 200 57" fill="none" stroke="#dc2626" stroke-width="0.5"/>
          
          <!-- Zone labels -->
          <text x="43" y="81" font-size="3.5" fill="#64748b" text-anchor="middle" id="leftZoneLbl">AWAY OFF</text>
          <text x="100" y="81" font-size="3.5" fill="#64748b" text-anchor="middle">NEUTRAL</text>
          <text x="157" y="81" font-size="3.5" fill="#64748b" text-anchor="middle" id="rightZoneLbl">HOME OFF</text>
          
          <!-- Markers -->
          <g id="markers"></g>
        </svg>
        </div>
        <!-- v24.0: Net visualization for Shot/Goal events -->
        <div id="netVisualizationContainer" style="display:none;width:150px;background:var(--card);border:1px solid var(--border);border-radius:4px;padding:8px;">
          <div style="font-size:9px;color:var(--accent);margin-bottom:4px;text-align:center;font-weight:bold;">ü•Ö NET</div>
          <div style="position:relative;">
            <svg id="netSvg" viewBox="0 0 100 100" style="width:100%;cursor:crosshair;" onmousemove="handleNetHover(event)" onmouseleave="hideNetTooltip()" onclick="handleNetClick(event)">
              <!-- Net background (ice) -->
              <rect x="0" y="0" width="100" height="100" fill="rgba(240,249,255,0.2)" stroke="#64748b" stroke-width="0.5"/>
              
              <!-- Net opening: 6ft wide x 4ft tall, centered at (50, 50) -->
              <!-- Opening rectangle: x=20-80 (60 units wide), y=30-70 (40 units tall) -->
              <!-- Center is at (50, 50) = (0,0) in relative coordinates -->
              
              <!-- Left post (vertical) -->
              <line x1="20" y1="30" x2="20" y2="70" stroke="#ffffff" stroke-width="2" stroke-linecap="round"/>
              <!-- Right post (vertical) -->
              <line x1="80" y1="30" x2="80" y2="70" stroke="#ffffff" stroke-width="2" stroke-linecap="round"/>
              <!-- Crossbar (horizontal top) -->
              <line x1="20" y1="30" x2="80" y2="30" stroke="#ffffff" stroke-width="2" stroke-linecap="round"/>
              
              <!-- Net mesh pattern (vertical lines) -->
              <line x1="25" y1="30" x2="25" y2="70" stroke="#94a3b8" stroke-width="0.4" opacity="0.6"/>
              <line x1="30" y1="30" x2="30" y2="70" stroke="#94a3b8" stroke-width="0.4" opacity="0.6"/>
              <line x1="35" y1="30" x2="35" y2="70" stroke="#94a3b8" stroke-width="0.4" opacity="0.6"/>
              <line x1="40" y1="30" x2="40" y2="70" stroke="#94a3b8" stroke-width="0.4" opacity="0.6"/>
              <line x1="45" y1="30" x2="45" y2="70" stroke="#94a3b8" stroke-width="0.4" opacity="0.6"/>
              <line x1="50" y1="30" x2="50" y2="70" stroke="#cbd5e1" stroke-width="0.5" opacity="0.8"/>
              <line x1="55" y1="30" x2="55" y2="70" stroke="#94a3b8" stroke-width="0.4" opacity="0.6"/>
              <line x1="60" y1="30" x2="60" y2="70" stroke="#94a3b8" stroke-width="0.4" opacity="0.6"/>
              <line x1="65" y1="30" x2="65" y2="70" stroke="#94a3b8" stroke-width="0.4" opacity="0.6"/>
              <line x1="70" y1="30" x2="70" y2="70" stroke="#94a3b8" stroke-width="0.4" opacity="0.6"/>
              <line x1="75" y1="30" x2="75" y2="70" stroke="#94a3b8" stroke-width="0.4" opacity="0.6"/>
              
              <!-- Net mesh pattern (horizontal lines) -->
              <line x1="20" y1="35" x2="80" y2="35" stroke="#94a3b8" stroke-width="0.4" opacity="0.6"/>
              <line x1="20" y1="40" x2="80" y2="40" stroke="#94a3b8" stroke-width="0.4" opacity="0.6"/>
              <line x1="20" y1="45" x2="80" y2="45" stroke="#94a3b8" stroke-width="0.4" opacity="0.6"/>
              <line x1="20" y1="50" x2="80" y2="50" stroke="#cbd5e1" stroke-width="0.5" opacity="0.8"/>
              <line x1="20" y1="55" x2="80" y2="55" stroke="#94a3b8" stroke-width="0.4" opacity="0.6"/>
              <line x1="20" y1="60" x2="80" y2="60" stroke="#94a3b8" stroke-width="0.4" opacity="0.6"/>
              <line x1="20" y1="65" x2="80" y2="65" stroke="#94a3b8" stroke-width="0.4" opacity="0.6"/>
              
              <!-- Center crosshair (0,0) -->
              <line x1="50" y1="30" x2="50" y2="70" stroke="#00d4ff" stroke-width="0.5" opacity="0.5" stroke-dasharray="2,2"/>
              <line x1="20" y1="50" x2="80" y2="50" stroke="#00d4ff" stroke-width="0.5" opacity="0.5" stroke-dasharray="2,2"/>
              <circle cx="50" cy="50" r="1" fill="#00d4ff" opacity="0.7"/>
              
              <!-- Net markers (shot locations) -->
              <g id="netMarkers"></g>
            </svg>
            <div id="netTooltip" style="position:absolute;top:4px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.8);color:#fff;padding:2px 6px;border-radius:3px;font-size:8px;pointer-events:none;display:none;z-index:1000;white-space:nowrap;"></div>
          </div>
          <div style="font-size:7px;color:var(--muted);margin-top:4px;text-align:center;">Click to place shot location<br/>Center (0,0) at middle of net</div>
        </div>
      </div>
      <div class="xy-controls">
        <button class="xy-btn active" id="puckModeBtn" onclick="setXYMode('puck')" title="Place puck position (multiple clicks = trajectory)">üèí Puck</button>
        <button class="xy-btn" id="playerModeBtn" onclick="setXYMode('player')" title="Place player positions">üë§ Player</button>
        <select class="xy-player-sel" id="xyPlayerSel" onchange="selectXYPlayer(this.value)" title="Select player to place XY"></select>
        <span style="color:var(--muted);font-size:8px;margin-left:4px;">Slot:</span>
        <div class="xy-slots" id="xySlots"></div>
        <span id="xySlotIndicator" style="font-size:9px;color:var(--accent);margin-left:2px;">‚Üí auto-advance</span>
        <button class="btn-sm" onclick="undoLastXY()" title="Undo last XY placement (Ctrl+Z)">‚Ü©</button>
        <button class="btn-sm btn-danger" onclick="clearCurrentXY()" title="Clear current item XY">‚úï</button>
        <button class="btn-sm" onclick="copyAllXYData()" title="Copy all XY data (puck and all players) for current event">üìã Copy XY</button>
        <button class="btn-sm" onclick="pasteAllXYData()" title="Paste XY data (puck and all players) to current event">üìÑ Paste XY</button>
        <button class="btn-sm" onclick="clearRink()" title="Clear all markers from rink">üóë</button>
        <span style="margin-left:4px;font-size:8px;color:var(--muted);">Hist:</span>
        <input type="number" id="xyHistCnt" value="5" min="0" max="20" style="width:30px;font-size:9px;" onchange="renderMarkers()" title="Past events to show">
        <span style="margin-left:8px;font-size:8px;color:var(--muted);border-left:1px solid var(--border);padding-left:8px;">Zoom:</span>
        <button class="btn-sm" id="rinkZoomInBtn" onclick="rinkZoomIn()" title="Zoom in (or scroll)">üîç+</button>
        <button class="btn-sm" id="rinkZoomOutBtn" onclick="rinkZoomOut()" title="Zoom out (or scroll)">üîç-</button>
        <button class="btn-sm" id="rinkZoomResetBtn" onclick="rinkZoomReset()" title="Reset zoom and pan">‚åÇ Reset</button>
        <button class="btn-sm" id="rinkZoomLockBtn" onclick="toggleRinkZoomLock()" title="Lock/unlock zoom and pan">üîí</button>
        <span id="rinkZoomLevel" style="font-size:8px;color:var(--accent);margin-left:4px;">100%</span>
        <span style="font-size:7px;color:var(--muted);margin-left:4px;" title="Shift+Click or Middle Mouse to pan">Pan: Shift+Click</span>
      </div>
      <!-- v23.4: Timeline Scrub -->
      <div id="timelineScrub" style="display:flex;gap:2px;margin:4px 0;padding:4px;background:var(--panel);border-radius:4px;overflow-x:auto;overflow-y:visible;max-width:100%;position:relative;z-index:1;">
        <span style="font-size:8px;color:var(--muted);white-space:nowrap;flex-shrink:0;">Timeline:</span>
        <div id="timelineEvents" style="display:flex;gap:1px;flex:1;min-width:0;overflow-x:auto;overflow-y:visible;"></div>
      </div>
      <!-- Event List -->
      <div class="evt-list" id="eventLogSection">
        <div class="evt-header" style="display:flex;justify-content:space-between;align-items:center;">
          <!-- v20.4: Header columns now match expanded body columns -->
          <span style="display:flex;align-items:center;gap:4px;">
            <button class="btn-sm" onclick="showFullBoxScore()" title="Full Box Score" style="background:var(--accent);color:#fff;font-weight:bold;padding:4px 8px;">üìä Box</button>
            <button class="btn-sm" onclick="toggleEventLog()" title="Toggle Event Log">üìù</button>
            <span id="evtLogHeader" style="display:grid;grid-template-columns:30px 22px 22px 20px 48px 48px 14px 46px 30px 58px 58px 14px 12px 30px 30px 46px 46px 12px 12px 12px;gap:1px;flex:1;font-size:6px;">
              <span>‚Üï</span><span>#</span><span>Sh</span><span>Lnk</span><span>Time</span><span>Adj</span><span>T</span><span>Type</span><span>PIM</span><span>Detail1</span><span>Detail2</span><span>Z</span><span>S</span><span>EvtP</span><span>OppP</span><span>PD1</span><span>PD2</span><span>PS</span><span>XY</span><span>‚≠ê</span>
            </span>
          </span>
          <span>
            <button class="btn-sm" onclick="addNewEvent()" title="Add New Event" style="background:var(--success);">‚ûï</button>
            <button class="clear-all-btn" onclick="clearAllEvents()" title="Clear All Events">üóëÔ∏è All</button>
            <button class="btn-sm" onclick="showAllEvents()" style="margin-left:4px;" title="Show all events in modal">All</button>
          </span>
        </div>
        <!-- v23.6: Sticky filter container - wraps all filters so they stay visible when scrolling -->
        <div style="position:sticky;top:0;z-index:10;background:var(--bg);">
          <!-- v6: Period filter tabs for events -->
          <div class="period-filter-tabs" style="position:relative;top:0;">
            <button class="period-filter-tab active" data-filter="all" onclick="filterEventLog('all')" title="Show all periods">ALL</button>
            <button class="period-filter-tab" data-filter="1" onclick="filterEventLog('1')" title="Show Period 1 events">P1</button>
            <button class="period-filter-tab" data-filter="2" onclick="filterEventLog('2')" title="Show Period 2 events">P2</button>
            <button class="period-filter-tab" data-filter="3" onclick="filterEventLog('3')" title="Show Period 3 events">P3</button>
            <button class="period-filter-tab" data-filter="OT" onclick="filterEventLog('OT')" title="Show Overtime events">OT</button>
            <button class="period-filter-tab" data-filter="goals_context" onclick="filterEventLog('goals_context')" title="Show goals with 10 events before and 3 events after each goal">üéØ Goals+10/3</button>
            <button class="period-filter-tab" data-filter="event_type_context" onclick="filterEventLog('event_type_context')" title="Filter by event type/details with context (like goals filter)">üîç Type+Context</button>
            <button class="period-filter-tab" data-filter="issues" onclick="filterEventLog('issues')" title="Show events with issues (missing data, invalid time, team validation)">‚ö†Ô∏è Issues</button>
            <button class="period-filter-tab" data-filter="xy_highlights" onclick="filterEventLog('xy_highlights')" title="Show events with XY data or highlights">üìç XY/‚≠ê</button>
            <button class="period-filter-tab" data-filter="chains" onclick="openEventChainStats()" title="View event chain statistics (Shot>Save, Pass>Turnover, etc.)">üîó Chains</button>
          </div>
          <!-- v23.6: Goal selector for goals_context filter -->
          <div id="goalSelectorContainer" style="display:none;padding:4px 8px;background:var(--card);border-bottom:1px solid var(--border);">
            <div style="display:flex;gap:4px;align-items:center;">
              <label style="font-size:9px;color:var(--muted);">Select Goal:</label>
              <select id="goalSelector" onchange="selectGoalForContext(this.value)" style="flex:1;font-size:9px;padding:4px;border:1px solid var(--border);border-radius:4px;background:var(--bg);color:var(--text);">
                <option value="">All Goals</option>
              </select>
              <button class="btn-sm" onclick="navigateGoalContext(-1)" title="Previous Goal (‚Üê)" style="font-size:8px;padding:2px 6px;">‚óÄ</button>
              <button class="btn-sm" onclick="navigateGoalContext(1)" title="Next Goal (‚Üí)" style="font-size:8px;padding:2px 6px;">‚ñ∂</button>
            </div>
          </div>
          <!-- v23.8: Event type context filter (similar to goals) -->
          <div id="eventTypeContextContainer" style="display:none;padding:4px 8px;background:var(--card);border-bottom:1px solid var(--border);">
            <div style="display:flex;gap:4px;align-items:center;flex-wrap:wrap;">
              <label style="font-size:9px;color:var(--muted);">Event Type:</label>
              <select id="eventTypeContextFilter" onchange="updateEventTypeContextFilter()" style="flex:1;min-width:120px;font-size:9px;padding:4px;border:1px solid var(--border);border-radius:4px;background:var(--bg);color:var(--text);">
                <option value="">Select Type...</option>
              </select>
              <label style="font-size:9px;color:var(--muted);">Detail1:</label>
              <select id="eventDetail1ContextFilter" onchange="updateEventTypeContextFilter()" style="flex:1;min-width:120px;font-size:9px;padding:4px;border:1px solid var(--border);border-radius:4px;background:var(--bg);color:var(--text);">
                <option value="">All</option>
              </select>
              <label style="font-size:9px;color:var(--muted);">Show:</label>
              <input type="number" id="eventContextBefore" min="0" max="50" value="10" style="width:50px;font-size:9px;padding:2px 4px;border:1px solid var(--border);border-radius:3px;background:var(--bg);color:var(--text);" title="Events before">
              <span style="font-size:8px;color:var(--muted);">before</span>
              <input type="number" id="eventContextAfter" min="0" max="50" value="3" style="width:50px;font-size:9px;padding:2px 4px;border:1px solid var(--border);border-radius:3px;background:var(--bg);color:var(--text);" title="Events after">
              <span style="font-size:8px;color:var(--muted);">after</span>
              <label style="font-size:9px;color:var(--muted);">Select Event:</label>
              <select id="eventTypeSelector" onchange="selectEventForContext(this.value)" style="flex:1;min-width:200px;font-size:9px;padding:4px;border:1px solid var(--border);border-radius:4px;background:var(--bg);color:var(--text);">
                <option value="">All Events</option>
              </select>
              <button class="btn-sm" onclick="navigateEventContext(-1)" title="Previous (‚Üê)" style="font-size:8px;padding:2px 6px;">‚óÄ</button>
              <button class="btn-sm" onclick="navigateEventContext(1)" title="Next (‚Üí)" style="font-size:8px;padding:2px 6px;">‚ñ∂</button>
            </div>
          </div>
          <!-- v23.8: Issues filter by type -->
          <div id="issueTypeFilterContainer" style="display:none;padding:4px 8px;background:var(--card);border-bottom:1px solid var(--border);">
            <div style="display:flex;gap:4px;align-items:center;">
              <label style="font-size:9px;color:var(--muted);">Issue Type:</label>
              <select id="issueTypeFilter" onchange="applyIssueTypeFilter()" style="flex:1;font-size:9px;padding:4px;border:1px solid var(--border);border-radius:4px;background:var(--bg);color:var(--text);">
                <option value="">All Issues</option>
                <option value="time_invalid">Invalid Time (Start > End)</option>
                <option value="time_missing">Missing Time</option>
                <option value="data_missing">Missing Required Data</option>
                <option value="team_validation">Team Validation Warning</option>
              </select>
              <button class="btn-sm btn-danger" onclick="massSwapInvalidTimes()" title="Swap start/end times for all events where start > end" style="font-size:8px;padding:2px 6px;white-space:nowrap;">üîÑ Swap Times</button>
            </div>
          </div>
          <!-- v23.8: Player search for event log -->
          <div style="padding:4px 8px;background:var(--card);border-bottom:1px solid var(--border);">
            <input type="text" id="eventLogPlayerSearch" placeholder="üîç Search by player # or name..." style="width:100%;font-size:9px;padding:4px 8px;border:1px solid var(--border);border-radius:4px;background:var(--bg);color:var(--text);" oninput="filterEventLogByPlayer(this.value)" title="Search events by player jersey number or name (searches all event/opp players)">
          </div>
          <!-- v20.4: Advanced filter row -->
          <div class="evt-filter-row" id="evtFilterRow" style="position:relative;top:0;">
          <div class="filter-group">
            <label>Type:</label>
            <select id="filterEvtType" onchange="applyEventFilters()">
              <option value="">All</option>
            </select>
          </div>
          <div class="filter-group">
            <label>Detail1:</label>
            <select id="filterEvtDetail1" onchange="applyEventFilters()">
              <option value="">All</option>
            </select>
          </div>
          <div class="filter-group">
            <label>Detail2:</label>
            <select id="filterEvtDetail2" onchange="applyEventFilters()">
              <option value="">All</option>
            </select>
          </div>
          <div class="filter-group">
            <label>PD1:</label>
            <select id="filterPlayDetail1" onchange="applyEventFilters()">
              <option value="">All</option>
            </select>
          </div>
          <div class="filter-group">
            <label>PD2:</label>
            <select id="filterPlayDetail2" onchange="applyEventFilters()">
              <option value="">All</option>
            </select>
          </div>
          <div class="filter-group">
            <label>Team:</label>
            <select id="filterEvtTeam" onchange="applyEventFilters()">
              <option value="">All</option>
              <option value="home">Home</option>
              <option value="away">Away</option>
            </select>
          </div>
          <div class="filter-group">
            <label>Evt#:</label>
            <input type="number" id="filterEvtIdx" min="1" placeholder="#" onchange="applyEventFilters()">
          </div>
          <div class="filter-group">
            <label>Show X before:</label>
            <input type="number" id="filterEventsBefore" min="0" max="50" placeholder="0" value="0" style="width:50px;" onchange="applyEventFilters()" title="Show X events before the found event">
          </div>
          <div class="filter-group">
            <label>Show X after:</label>
            <input type="number" id="filterEventsAfter" min="0" max="50" placeholder="0" value="0" style="width:50px;" onchange="applyEventFilters()" title="Show X events after the found event">
          </div>
          <div class="filter-group">
            <label>Link#:</label>
            <input type="number" id="filterLinkIdx" min="1" placeholder="#" onchange="applyEventFilters()">
          </div>
          <div class="filter-group">
            <label>Shift#:</label>
            <input type="number" id="filterShiftIdx" min="1" placeholder="#" onchange="applyEventFilters()">
          </div>
          <button class="btn-clear" onclick="clearEventFilters()">Clear</button>
        </div>
        </div>
        <!-- End sticky filter container -->
        <div id="evtListBody" style="max-height:300px;overflow-y:auto;"></div>
      </div>
      <!-- Next Play Suggestions -->
      <div class="next-play-bar" style="background:var(--card);padding:4px 8px;border-top:1px solid var(--border);">
        <span style="font-size:8px;color:var(--muted);">NEXT:</span>
        <span id="nextPlaySuggestions" style="font-size:9px;"></span>
      </div>
      <!-- v16.02: Box Score moved here - more visible below events -->
      <div class="center-box-score" style="background:var(--card);padding:8px;border-top:2px solid var(--accent);border-bottom:2px solid var(--accent);">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
          <span style="font-size:11px;color:var(--accent);font-weight:bold;">üìä BOX SCORE</span>
          <button class="btn-sm" onclick="showFullBoxScore()" style="font-weight:bold;background:var(--accent);color:#fff;padding:4px 12px;" title="Show full box score with all player stats">Full Box Score</button>
        </div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;font-size:10px;">
          <div style="text-align:center;">
            <span id="centerBoxHome" style="font-weight:bold;color:var(--home);">HOME</span>
            <span style="font-size:20px;font-weight:bold;display:block;" id="centerBoxHomeScore">0</span>
            <span style="font-size:8px;color:var(--muted);">SOG: <span id="centerBoxHomeSOG">0</span></span>
          </div>
          <div style="text-align:center;">
            <span id="centerBoxAway" style="font-weight:bold;color:var(--away);">AWAY</span>
            <span style="font-size:20px;font-weight:bold;display:block;" id="centerBoxAwayScore">0</span>
            <span style="font-size:8px;color:var(--muted);">SOG: <span id="centerBoxAwaySOG">0</span></span>
          </div>
        </div>
      </div>
    </div>

    <!-- Right: Event Entry -->
    <div class="panel" id="rightPanel">
      <div class="resize-handle right" style="left:0;right:auto;" onmousedown="startResize(event, 'right')"></div>
      <div class="panel-header"><span>Event Entry</span><span id="zoneDisplay"></span></div>
      <div class="panel-body">
        <!-- Team Toggle -->
        <div class="team-toggle">
          <button class="home active" id="evtHomeLbl" onclick="setEvtTeam('home')" title="Set event team to Home">Home</button>
          <button class="swap-btn" onclick="swapEvtTeam()" title="Swap Event/Opp Teams">‚áÑ</button>
          <button class="away" id="evtAwayLbl" onclick="setEvtTeam('away')" title="Set event team to Away">Away</button>
        </div>
        <!-- Event Types -->
        <div class="evt-grid" id="evtTypeGrid"></div>
        <!-- Quick Faceoff (v23.3) - Collapsible -->
        <div class="collapsible-section">
          <div class="collapsible-header" onclick="toggleCollapsible('quickFaceoffRow')">
            <span style="font-size:8px;color:var(--muted);">FO:</span>
            <span class="collapsible-icon" id="quickFaceoffRowIcon">‚ñº</span>
          </div>
          <div id="quickFaceoffRow" class="collapsible-content show" style="display:flex !important;gap:4px;margin:4px 0;padding:4px;background:var(--panel);border-radius:4px;">
            <button class="btn-sm" onclick="quickFaceoff('o','evt')" title="Offensive zone, Won" style="flex:1;font-size:9px;">O-Win</button>
            <button class="btn-sm" onclick="quickFaceoff('o','opp')" title="Offensive zone, Lost" style="flex:1;font-size:9px;">O-Loss</button>
            <button class="btn-sm" onclick="quickFaceoff('n','evt')" title="Neutral zone, Won" style="flex:1;font-size:9px;">N-Win</button>
            <button class="btn-sm" onclick="quickFaceoff('n','opp')" title="Neutral zone, Lost" style="flex:1;font-size:9px;">N-Loss</button>
            <button class="btn-sm" onclick="quickFaceoff('d','evt')" title="Defensive zone, Won" style="flex:1;font-size:9px;">D-Win</button>
            <button class="btn-sm" onclick="quickFaceoff('d','opp')" title="Defensive zone, Lost" style="flex:1;font-size:9px;">D-Loss</button>
          </div>
        </div>
        <!-- Quick Stoppage (v23.4) - Collapsible -->
        <div class="collapsible-section">
          <div class="collapsible-header" onclick="toggleCollapsible('quickStoppageRow')">
            <span style="font-size:8px;color:var(--muted);">STOP:</span>
            <span class="collapsible-icon" id="quickStoppageRowIcon">‚ñº</span>
          </div>
          <div id="quickStoppageRow" class="collapsible-content show" style="display:flex !important;gap:4px;margin:4px 0;padding:4px;background:var(--panel);border-radius:4px;">
            <button class="btn-sm" onclick="quickStoppage('Icing')" title="Icing" style="flex:1;font-size:9px;">üßä Icing</button>
            <button class="btn-sm" onclick="quickStoppage('Offside')" title="Offside" style="flex:1;font-size:9px;">üö´ Offside</button>
            <button class="btn-sm" onclick="quickStoppage('PuckOutOfPlay')" title="Puck out of play" style="flex:1;font-size:9px;">üèí Out</button>
            <button class="btn-sm" onclick="quickStoppage('Timeout')" title="Timeout" style="flex:1;font-size:9px;">‚è∏Ô∏è T/O</button>
            <button class="btn-sm" onclick="quickStoppage('GoalieFreeze')" title="Goalie freeze" style="flex:1;font-size:9px;">ü•Ö Freeze</button>
          </div>
        </div>
        <!-- Quick Penalty (v23.3) - Collapsible -->
        <div class="collapsible-section">
          <div class="collapsible-header" onclick="toggleCollapsible('quickPenaltyRow')">
            <span style="font-size:8px;color:var(--muted);">PEN:</span>
            <span class="collapsible-icon" id="quickPenaltyRowIcon">‚ñº</span>
          </div>
          <div id="quickPenaltyRow" class="collapsible-content show" style="display:flex !important;gap:4px;margin:4px 0;padding:4px;background:var(--panel);border-radius:4px;">
            <select id="quickPenPlayer" style="flex:2;font-size:9px;"><option value="">Player #</option></select>
            <select id="quickPenType" style="flex:2;font-size:9px;">
              <option value="">Type</option>
              <option value="Penalty_Tripping">Tripping</option>
              <option value="Penalty_Hooking">Hooking</option>
              <option value="Penalty_Slashing">Slashing</option>
              <option value="Penalty_Holding">Holding</option>
              <option value="Penalty_Interference">Interference</option>
              <option value="Penalty_HighSticking">High Stick</option>
              <option value="Penalty_Roughing">Roughing</option>
              <option value="Penalty_CrossChecking">Cross-Check</option>
              <option value="Penalty_Boarding">Boarding</option>
              <option value="Penalty_Other">Other</option>
            </select>
            <button class="btn-sm" onclick="quickPenalty()" title="Log penalty" style="background:var(--danger);color:#fff;">+Pen</button>
          </div>
        </div>
        <!-- Power Play Timer (v23.4) -->
        <div id="ppTimerRow" style="display:none;gap:4px;margin:4px 0;padding:6px 8px;background:linear-gradient(90deg,var(--home),var(--away));border-radius:4px;color:#fff;font-weight:bold;align-items:center;">
          <span id="ppTimerTeam" style="font-size:10px;">PP:</span>
          <span id="ppTimerDisplay" style="font-size:14px;margin-left:8px;">3:00</span>
          <input type="number" id="ppMinutes" value="3" min="1" max="5" style="width:35px;margin-left:8px;font-size:10px;" title="Penalty minutes" onchange="updatePPMinutes()">
          <span style="font-size:8px;">min</span>
          <button class="btn-sm" onclick="endPowerPlay()" style="margin-left:auto;background:#fff;color:#000;font-size:9px;" title="End power play timer">End PP</button>
        </div>
        <!-- Quick Modes (v23.3) -->
        <div style="display:flex;gap:4px;margin:4px 0;">
          <button class="btn-sm" id="shotChartModeBtn" onclick="toggleShotChartMode()" title="Shot Chart Mode: Enable to quickly log shots by clicking on the rink. Automatically sets event type to Shot and creates shot events at click locations. Great for rapid shot tracking during fast-paced sequences." style="flex:1;font-size:9px;">üéØ Shot Mode</button>
          <button class="btn-sm" id="possessionModeBtn" onclick="togglePossessionMode()" title="Possession Mode: Track continuous possession chains. Automatically links events together and sets event type to Possession. Enables sequence mode to track the full possession sequence from start to finish." style="flex:1;font-size:9px;">üèí Poss Mode</button>
          <button class="btn-sm" onclick="undoLastEvent()" title="Undo last event (Ctrl+Shift+Z)" style="flex:1;font-size:9px;background:var(--warning);color:#000;">‚Ü©Ô∏è Undo</button>
          <button class="btn-sm" onclick="manualReindexEvents()" title="Re-sort events by time" style="flex:1;font-size:9px;">üî¢ Reindex</button>
        </div>
        <!-- Event Templates (v23.4) - Collapsible -->
        <div class="collapsible-section">
          <div class="collapsible-header" onclick="toggleCollapsible('eventTemplatesRow')">
            <span style="font-size:8px;color:var(--muted);">TEMPLATES:</span>
            <span class="collapsible-icon" id="eventTemplatesRowIcon">‚ñº</span>
          </div>
          <div id="eventTemplatesRow" class="collapsible-content show" style="display:flex !important;gap:4px;margin:4px 0;">
            <select id="eventTemplates" style="flex:1;font-size:9px;">
              <option value="">üìã Templates...</option>
              <option value="dumpAndChase">Dump & Chase</option>
              <option value="cyclePlay">Cycle Play</option>
              <option value="breakout">Breakout</option>
              <option value="forecheck">Forecheck</option>
              <option value="oddManRush">Odd-Man Rush</option>
            </select>
            <button class="btn-sm" onclick="applyTemplate()" title="Apply selected template" style="font-size:9px;">Apply</button>
            <button class="btn-sm" onclick="saveAsChainPreset()" title="Save current event as chain preset" style="font-size:9px;">üíæ Save</button>
          </div>
        </div>
        <!-- Validation Row (v23.4) -->
        <div style="display:flex;gap:4px;margin:4px 0;">
          <button class="btn-sm" onclick="validateAgainstGameData()" title="Validate vs fact_gameroster & dim_schedule" style="flex:1;font-size:9px;">üîç Validate</button>
        </div>
        <!-- Quick Chains (v23.4) - Multi-event sequences -->
        <div style="display:flex;gap:2px;margin:4px 0;flex-wrap:wrap;">
          <span style="font-size:8px;color:var(--muted);align-self:center;">Chains:</span>
          <button class="btn-sm" onclick="startQuickChain('controlledEntry')" title="Zone Entry ‚Üí Possession" style="font-size:8px;">Entry</button>
          <button class="btn-sm" onclick="startQuickChain('dumpIn')" title="Dump ‚Üí Forecheck" style="font-size:8px;">Dump</button>
          <button class="btn-sm" onclick="startQuickChain('shotSequence')" title="Shot ‚Üí Save ‚Üí Rebound" style="font-size:8px;">Shot+</button>
          <button class="btn-sm" onclick="startQuickChain('breakout')" title="Breakout ‚Üí Pass ‚Üí Exit" style="font-size:8px;">Break</button>
          <button class="btn-sm" onclick="startQuickChain('ppCycle')" title="PP Cycle ‚Üí Pass ‚Üí Shot" style="font-size:8px;">PP</button>
        </div>
        <!-- v23.5: Quick Queue - log time only, fill details later -->
        <div style="display:flex;gap:2px;margin:4px 0;flex-wrap:wrap;">
          <span style="font-size:8px;color:var(--warn);align-self:center;" title="Quick mark events, fill details later">Queue:</span>
          <button class="btn-sm" onclick="quickQueueEvent('Shot')" style="font-size:8px;background:var(--warn);color:#000;" title="Quick queue: Shot">Sh</button>
          <button class="btn-sm" onclick="quickQueueEvent('Pass')" style="font-size:8px;background:var(--warn);color:#000;" title="Quick queue: Pass">Pa</button>
          <button class="btn-sm" onclick="quickQueueEvent('Turnover')" style="font-size:8px;background:var(--warn);color:#000;" title="Quick queue: Turnover">TO</button>
          <button class="btn-sm" onclick="quickQueueEvent('Hit')" style="font-size:8px;background:var(--warn);color:#000;" title="Quick queue: Hit">Hi</button>
          <button class="btn-sm" onclick="quickQueueEvent('Zone_Entry_Exit')" style="font-size:8px;background:var(--warn);color:#000;" title="Quick queue: Zone Entry/Exit">ZE</button>
          <button class="btn-sm" onclick="clearEventQueue()" style="font-size:8px;" title="Clear queue">‚úï</button>
        </div>
        <!-- Event Details -->
        <div class="form-row">
          <div class="form-group"><label>Detail 1</label><select id="evtD1" onchange="onD1Change()"></select></div>
          <div class="form-group"><label>Detail 2</label><select id="evtD2"></select></div>
        </div>
        <!-- Quick Detail Buttons (v23.4) - changes based on event type -->
        <div id="quickDetailRow" style="display:flex;gap:2px;margin:4px 0;flex-wrap:wrap;"></div>
        <!-- Hidden selects for compatibility -->
        <select id="evtZone" style="display:none;"><option value="">--</option><option value="o">Offensive</option><option value="d">Defensive</option><option value="n">Neutral</option></select>
        <select id="evtSuccess" style="display:none;"><option value="">--</option><option value="s">Success</option><option value="u">Unsuccess</option></select>
        <div class="form-row tri">
          <div class="form-group">
            <label>Zone</label>
            <div style="display:flex;gap:2px;">
              <button class="btn-sm zone-btn" onclick="setZone('o')" data-zone="o" title="Offensive" style="flex:1;font-size:9px;">O</button>
              <button class="btn-sm zone-btn" onclick="setZone('n')" data-zone="n" title="Neutral" style="flex:1;font-size:9px;">N</button>
              <button class="btn-sm zone-btn" onclick="setZone('d')" data-zone="d" title="Defensive" style="flex:1;font-size:9px;">D</button>
            </div>
          </div>
          <div class="form-group">
            <label>Success</label>
            <div style="display:flex;gap:2px;">
              <button class="btn-sm success-btn" onclick="setSuccess('s')" data-success="s" title="Success" style="flex:1;font-size:9px;background:var(--success);color:#fff;">‚úì</button>
              <button class="btn-sm success-btn" onclick="setSuccess('u')" data-success="u" title="Unsuccess" style="flex:1;font-size:9px;background:var(--danger);color:#fff;">‚úó</button>
            </div>
          </div>
          <div class="form-group">
            <label>Strength <button class="btn-sm" onclick="autoStrength()" title="Auto-detect from slots">‚ö°</button></label>
            <select id="evtStrength"><option value="5v5">5v5</option><option value="5v4">5v4 PP</option><option value="4v5">4v5 PK</option><option value="4v4">4v4</option><option value="3v3">3v3</option><option value="ENG">ENG</option><option value="ENA">ENA</option></select>
          </div>
        </div>
        <div class="form-row">
          <div class="form-group"><label>Start Time</label><input type="text" id="evtStartTime" placeholder="MM:SS" oninput="autoFormatTime(this); onStartTimeChange()"></div>
          <div class="form-group"><label>End Time</label><input type="text" id="evtEndTime" placeholder="MM:SS (auto)" oninput="autoFormatTime(this)"></div>
        </div>
        <!-- Event Players -->
        <div class="section">
          <div class="section-title" style="display:flex;justify-content:space-between;align-items:center;">
            <span>Event Players (on puck)</span>
            <div style="display:flex;gap:2px;">
              <button class="btn-sm" onclick="addAllOnIce()" title="Add all on-ice players">+All</button>
              <button class="btn-sm" onclick="copyPlayersFromLast()" title="Copy players from last event">üìã</button>
              <button class="btn-sm" onclick="placeAllHere()" title="Place ALL players at last puck XY" style="background:var(--accent);color:#000;">üìç All Here</button>
              <button class="btn-sm" id="seqModeBtn" onclick="toggleSequenceMode()" title="Sequence Mode: Automatically links consecutive events together. When enabled, each new event links to the previous one, creating a play sequence. Useful for tracking multi-event plays like passes leading to shots, or zone entries leading to possession.">üîó</button>
            </div>
          </div>
          <div class="player-list" id="evtPlayers" ondragover="handleListDragOver(event)" ondragleave="handleListDragLeave(event)" ondrop="handleListDrop(event, 'evt')" style="max-height:150px;overflow-y:auto;"></div>
          <div class="quick-add" id="evtQuickAdd"></div>
          <!-- Jersey number input -->
          <div style="display:flex;gap:4px;margin-top:4px;">
            <input type="text" id="jerseyNumInput" placeholder="Jersey #" style="width:60px;font-size:10px;" onkeypress="if(event.key==='Enter'){quickAddByNumber(parseInt(this.value));this.value='';return false;}">
            <button class="btn-sm" onclick="quickAddByNumber(parseInt(document.getElementById('jerseyNumInput').value));document.getElementById('jerseyNumInput').value='';" title="Add by jersey #">+#</button>
          </div>
        </div>
        <div class="section" style="position:sticky;bottom:0;background:var(--bg);z-index:10;padding-top:4px;">
          <div class="section-title"><span>Opposing Players</span></div>
          <div class="player-list" id="oppPlayers" ondragover="handleListDragOver(event)" ondragleave="handleListDragLeave(event)" ondrop="handleListDrop(event, 'opp')" style="max-height:120px;overflow-y:auto;"></div>
          <div class="quick-add" id="oppQuickAdd"></div>
        </div>
        <!-- Player Details -->
        <div class="player-details" id="playerDetails" style="display:none;max-height:300px;overflow-y:auto;background:var(--card);padding:8px;border-radius:4px;margin-top:4px;">
          <h5 id="pdPlayerNum">#0 Player</h5>
          <div class="form-row">
            <!-- v16.02: Searchable play detail dropdowns using input with datalist -->
            <div class="form-group">
              <label>Play Detail 1</label>
              <input list="pdPlayD1List" id="pdPlayD1" style="width:100%;" onchange="updatePlayerDetail('playD1', this.value); updatePlayD2()" placeholder="Type to search...">
              <datalist id="pdPlayD1List"></datalist>
            </div>
            <div class="form-group">
              <label>Play Detail 2</label>
              <input list="pdPlayD2List" id="pdPlayD2" style="width:100%;" onchange="updatePlayerDetail('playD2', this.value)" placeholder="Type to search...">
              <datalist id="pdPlayD2List"></datalist>
            </div>
          </div>
          <div class="form-row">
            <div class="form-group"><label>Success <button class="btn-sm" onclick="derivePlayerSuccess()" title="Auto from event">‚ö°</button></label><select id="pdPlaySuccess" onchange="updatePlayerDetail('playSuccess', this.value)"><option value="">--</option><option value="s">S</option><option value="u">U</option></select></div>
            <div class="form-group"><label>Pressured By <button class="btn-sm" onclick="autoCalcPressure()" title="Auto from XY">‚ö°</button></label><select id="pdPressure" onchange="updatePlayerDetail('pressure', this.value)"><option value="">--</option></select></div>
          </div>
          <!-- v16: Side of Puck -->
          <div class="form-row">
            <div class="form-group">
              <label>Side of Puck <button class="btn-sm" onclick="autoSideOfPuck()" title="Auto-detect from zone">‚ö°</button></label>
              <select id="pdSideOfPuck" onchange="updatePlayerDetail('sideOfPuck', this.value)">
                <option value="">--</option>
                <option value="Offensive">Offensive</option>
                <option value="Defensive">Defensive</option>
              </select>
            </div>
            <div class="form-group"><label>&nbsp;</label><span style="font-size:8px;color:var(--muted);line-height:26px;">Relative to player's team</span></div>
          </div>
        </div>
        <!-- Linked Event & Highlight -->
        <div class="linked-event-bar" style="background:var(--card);padding:4px 8px;border-radius:4px;margin-top:6px;font-size:9px;display:flex;align-items:center;gap:8px;">
          <span style="color:var(--muted);">Link:</span>
          <select id="linkedEvtSelect" style="flex:1;" onchange="onLinkedEvtChange()">
            <option value="">-- None --</option>
          </select>
          <span id="linkedEvtInfo" style="color:var(--accent);font-size:8px;"></span>
          <label style="display:flex;align-items:center;gap:4px;cursor:pointer;margin-left:auto;">
            <input type="checkbox" id="isHighlight" onchange="toggleHighlightFields()"> ‚≠ê Highlight
          </label>
        </div>
        <!-- Video URL for highlights (v23.7) -->
        <div id="highlightVideoUrlRow" style="display:none;margin-top:4px;">
          <div class="form-group">
            <label style="font-size:8px;color:var(--muted);">YouTube URL for this highlight:</label>
            <input type="text" id="evtVideoUrl" placeholder="https://youtube.com/watch?v=..." style="width:100%;font-size:9px;">
          </div>
        </div>
        <!-- Quick Time Buttons (v5) + Time Nudge (v6) -->
        <div style="display:flex;gap:4px;margin-top:4px;align-items:center;flex-wrap:wrap;">
          <button class="btn-sm" onclick="copyClockToStart()" title="Copy clock to start time">‚è±Ô∏è‚ÜíStart</button>
          <button class="btn-sm" onclick="copyClockToEnd()" title="Copy clock to end time">‚è±Ô∏è‚ÜíEnd</button>
          <button class="btn-sm" onclick="copyLastEventTime()" title="Copy last event's end time">üìã Last</button>
          <!-- v6: Time nudge buttons with variable increment -->
          <span style="color:var(--muted);font-size:8px;margin-left:4px;">¬±</span>
          <input type="number" id="timeNudgeAmount" value="5" min="1" max="60" style="width:30px;font-size:9px;padding:2px;" title="Nudge seconds">
          <button class="btn-sm" onclick="nudgeStartTime(-1)" title="Subtract from start time">-S</button>
          <button class="btn-sm" onclick="nudgeStartTime(1)" title="Add to start time">+S</button>
          <button class="btn-sm" onclick="nudgeEndTime(-1)" title="Subtract from end time">-E</button>
          <button class="btn-sm" onclick="nudgeEndTime(1)" title="Add to end time">+E</button>
          <label style="display:flex;align-items:center;gap:4px;font-size:8px;margin-left:8px;cursor:pointer;" title="Skip confirmation popup">
            <input type="checkbox" id="skipConfirm"> Quick log
          </label>
          <label style="display:flex;align-items:center;gap:4px;font-size:8px;margin-left:auto;cursor:pointer;">
            <input type="checkbox" id="autoEditNext"> Auto-edit next
          </label>
        </div>
        <!-- Actions - v23.8: Sticky at bottom for visibility -->
        <div class="log-actions" style="position:sticky;bottom:0;background:var(--bg);z-index:20;padding-top:8px;border-top:2px solid var(--accent);margin-top:8px;">
          <button type="button" class="btn-success" onclick="logEvent(); return false;" style="font-size:12px;font-weight:bold;padding:8px 16px;flex:1;" title="Log current event (Enter key)">Log Event <kbd>Enter</kbd></button>
          <button onclick="clearEvent()" style="padding:8px 12px;">Clear <kbd>Esc</kbd></button>
          <button class="btn-sm" onclick="duplicateLastEvent()" title="Duplicate last event" style="padding:8px 12px;">üìã Dup</button>
          <button class="btn-sm" onclick="logEventDirect()" title="Log without confirmation (Shift+Enter)" style="padding:8px 12px;">‚ö° Quick</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- v23.9: Event Chain Templates Manager Modal -->
<div class="overlay" id="eventTemplatesManagerModal" style="display:none;"></div>
<div class="overlay" id="customRulesManagerModal" style="display:none;"></div>
<div class="overlay" id="customLinkingRulesManagerModal" style="display:none;"></div>
<!-- v24.0: Event Chain Statistics Modal -->
<div class="overlay" id="eventChainStatsModal" style="display:none;"></div>

<!-- Settings Modal -->
<div class="overlay" id="settingsModal">
  <div class="modal">
    <h3>‚öôÔ∏è Settings</h3>
    <div style="margin-bottom:16px;">
      <button class="btn-sm" onclick="openEventTemplatesManager()" style="width:100%;margin-bottom:8px;">üîó Manage Event Chain Templates</button>
      <p style="font-size:9px;color:var(--muted);">Define templates that auto-suggest next events based on triggers (e.g., Shot On Net ‚Üí Save)</p>
    </div>
    <div style="margin-bottom:16px;">
      <button class="btn-sm" onclick="openCustomRulesManager()" style="width:100%;margin-bottom:8px;">‚öôÔ∏è Manage Custom Rules</button>
      <p style="font-size:9px;color:var(--muted);">Define custom logic for auto-zone, auto-success, field mappings (e.g., all zone_entry_carried ‚Üí O zone)</p>
    </div>
    <div style="margin-bottom:16px;">
      <button class="btn-sm" onclick="openCustomLinkingRulesManager()" style="width:100%;margin-bottom:8px;">üîó Manage Custom Linking Rules</button>
      <p style="font-size:9px;color:var(--muted);">Define auto-linking rules: if event A (and conditions) happens, then link to event B</p>
    </div>
    <div style="margin-bottom:16px;">
      <label style="font-size:10px;display:block;margin-bottom:4px;">Event Click Mode</label>
      <select id="eventClickMode" onchange="S.eventClickMode = this.value; localStorage.setItem('bs_eventClickMode', this.value);" style="width:100%;font-size:9px;">
        <option value="modal">Modal (default)</option>
        <option value="sidePanel">Side Panel</option>
        <option value="xyDrawing">XY Drawing Mode</option>
      </select>
      <p style="font-size:8px;color:var(--muted);margin-top:2px;">How events open when clicked</p>
    </div>
    <div style="margin-bottom:16px;">
      <label style="font-size:10px;display:block;margin-bottom:4px;">XY Edit Mode</label>
      <select id="xyEditMode" onchange="S.xyEditMode = this.value; localStorage.setItem('bs_xyEditMode', this.value);" style="width:100%;font-size:9px;">
        <option value="modal">Modal (default)</option>
        <option value="sidePanel">Side Panel</option>
        <option value="direct">Direct Drawing</option>
      </select>
      <p style="font-size:8px;color:var(--muted);margin-top:2px;">How XY data is edited</p>
    </div>
    <div style="margin-bottom:16px;">
      <label style="font-size:10px;display:flex;align-items:center;gap:6px;">
        <input type="checkbox" id="xyCarryOverEnabled" onchange="S.xyCarryOverEnabled = this.checked; localStorage.setItem('bs_xyCarryOverEnabled', this.checked);" checked>
        <span>Carry Over XY End Point to Next Event</span>
      </label>
      <p style="font-size:8px;color:var(--muted);margin-top:2px;margin-left:22px;">When enabled, copies last XY point from previous event if all players match</p>
    </div>
    <hr style="border:none;border-top:1px solid var(--border);margin:16px 0;">
    <div class="form-group" style="margin-bottom:8px;">
      <label>Supabase URL</label>
      <input type="text" id="sbUrl" placeholder="https://xxx.supabase.co" style="width:100%;">
    </div>
    <div class="form-group" style="margin-bottom:8px;">
      <label>Supabase Anon Key</label>
      <input type="password" id="sbKey" placeholder="eyJ..." style="width:100%;">
    </div>
    <div class="form-row">
      <div class="form-group"><label>Auto-save (sec)</label><input type="number" id="autoSaveInt" value="300"></div>
      <div class="form-group"><label>Pressure Distance (ft)</label><input type="number" id="pressureDist" value="10"></div>
    </div>
    <!-- v23.5: Per-period lengths -->
    <div style="margin:8px 0;">
      <label style="font-size:10px;color:var(--muted);display:block;margin-bottom:4px;">Period Lengths (minutes)</label>
      <div style="display:flex;gap:8px;">
        <div class="form-group" style="flex:1;">
          <label style="font-size:9px;">P1</label>
          <input type="number" id="periodLength1" value="18" min="5" max="25" style="width:100%;" onchange="updatePeriodLengthsFromUI()">
        </div>
        <div class="form-group" style="flex:1;">
          <label style="font-size:9px;">P2</label>
          <input type="number" id="periodLength2" value="18" min="5" max="25" style="width:100%;" onchange="updatePeriodLengthsFromUI()">
        </div>
        <div class="form-group" style="flex:1;">
          <label style="font-size:9px;">P3</label>
          <input type="number" id="periodLength3" value="18" min="5" max="25" style="width:100%;" onchange="updatePeriodLengthsFromUI()">
        </div>
        <div class="form-group" style="flex:1;">
          <label style="font-size:9px;">OT</label>
          <input type="number" id="periodLengthOT" value="5" min="3" max="20" style="width:100%;" onchange="updatePeriodLengthsFromUI()">
        </div>
      </div>
    </div>
    <!-- v23.8: Penalty Lengths -->
    <div style="margin:8px 0;">
      <label style="font-size:10px;color:var(--muted);display:block;margin-bottom:4px;">Penalty Lengths (minutes)</label>
      <div style="display:flex;gap:8px;">
        <div class="form-group" style="flex:1;">
          <label style="font-size:9px;">Minor</label>
          <input type="number" id="penaltyLengthMinor" value="3" min="1" max="10" style="width:100%;" onchange="updatePenaltyLengthsFromUI()">
        </div>
        <div class="form-group" style="flex:1;">
          <label style="font-size:9px;">Major</label>
          <input type="number" id="penaltyLengthMajor" value="6" min="1" max="10" style="width:100%;" onchange="updatePenaltyLengthsFromUI()">
        </div>
        <div class="form-group" style="flex:1;">
          <label style="font-size:9px;">Misconduct</label>
          <input type="number" id="penaltyLengthMisconduct" value="10" min="1" max="20" style="width:100%;" onchange="updatePenaltyLengthsFromUI()">
        </div>
      </div>
    </div>
    <!-- Hidden for backward compatibility -->
    <input type="hidden" id="periodLength" value="18">
    <input type="hidden" id="otLength" value="5">
      <div class="form-group" style="margin-bottom:8px;">
      <label>Default Game Folder</label>
      <div class="save-location-box">
        <div class="folder-display">
          <div class="folder-path empty" id="defaultFolderPath">No default folder selected</div>
          <div class="folder-actions">
            <button class="btn-sm btn-primary" onclick="promptForDefaultDirectory()" title="Select default folder where game folders will be created">üìÅ Choose</button>
            <button class="btn-sm" onclick="clearDefaultFolder()" title="Clear default folder">‚úï</button>
          </div>
        </div>
        <div class="folder-status" id="defaultFolderStatus">
          üí° Select a default folder. Game folders (named by game ID) will be created automatically when loading games.
        </div>
      </div>
      <div class="form-group" style="margin-bottom:8px;margin-top:12px;">
      <label>Save Location (Auto-saves)</label>
      <div class="save-location-box">
        <div class="folder-display">
          <div class="folder-path empty" id="saveFolderPath">No folder selected - using localStorage only</div>
          <div class="folder-actions">
            <button class="btn-sm btn-primary" onclick="promptForSaveDirectory()" title="Select folder for auto-saves and backups">üìÅ Choose</button>
            <button class="btn-sm" onclick="clearSaveFolder()" title="Clear selected folder">‚úï</button>
          </div>
        </div>
        <div class="folder-status" id="saveFolderStatus">
          üí° Select a folder to enable auto-saves and backups (saved to 'bkup' folder, keeps last 10)
        </div>
        <div style="margin-top:8px;display:flex;gap:4px;">
          <button class="btn-sm btn-success" onclick="manualSave()" id="quickSaveBtn" style="flex:1;">
            üíæ Save Now
          </button>
        </div>
      </div>
      <p style="font-size:8px;color:var(--muted);margin-top:4px;">
        <strong>Note:</strong> Game data auto-saves to browser storage every <span id="autoSaveDisplay">30</span>s. 
        Use "Quick Save" or "Export" to create an Excel file.
      </p>
      <div style="margin-top:8px;padding:8px;background:var(--success-bg);border-radius:4px;border-left:3px solid var(--success);">
        <p style="font-size:9px;color:var(--success);margin:0;">
          ‚úÖ <strong>v26.0:</strong> Auto-backup enabled - JSON backups are automatically created on every auto-save (unlimited backups).
          Backups are saved to the game folder's "backups" subfolder (or selected save folder) and include all data: events, shifts, rosters, settings, and more.
        </p>
      </div>
      <div style="margin-top:8px;display:flex;gap:4px;flex-wrap:wrap;">
        <button class="btn-sm btn-warning" onclick="document.getElementById('importBackupFile').click()" style="flex:1;min-width:150px;" title="Restore game data (events, shifts, rosters, etc.) from JSON backup file">
          üîÑ Restore from Backup
        </button>
        <button class="btn-sm btn-warning" onclick="browseBackupsFolder()" style="flex:1;min-width:150px;" title="Browse backups folder and select a backup to restore">
          üìÇ Browse Backups Folder
        </button>
        <input type="file" id="importBackupFile" accept=".json" style="display:none;" onchange="restoreFromBackup(event)">
      </div>
    </div>
    <!-- v23.8: Data Import/Export Section -->
    <div style="margin-top:12px;padding-top:12px;border-top:1px solid var(--border);">
      <label style="font-size:11px;font-weight:600;color:var(--text);display:block;margin-bottom:8px;">üìä Data Import/Export</label>
      <div style="display:flex;flex-direction:column;gap:6px;">
        <div style="display:flex;gap:6px;flex-wrap:wrap;">
          <button class="btn-sm" onclick="exportSettings()" title="Export all settings, presets, chains" style="flex:1;min-width:120px;">üì§ Export Settings</button>
          <button class="btn-sm" onclick="document.getElementById('importSettingsFile').click()" title="Import settings from JSON" style="flex:1;min-width:120px;">üì• Import Settings</button>
          <input type="file" id="importSettingsFile" accept=".json" style="display:none;" onchange="importSettings(event)">
        </div>
        <div style="display:flex;gap:6px;flex-wrap:wrap;">
          <button class="btn-sm" onclick="document.getElementById('importRosterFile').click()" title="Import roster from Excel (.xlsx)" style="flex:1;min-width:120px;">üìã Import Roster</button>
          <input type="file" id="importRosterFile" accept=".xlsx,.xls,.csv" style="display:none;" onchange="importRosterFromFile(event)">
          <button class="btn-sm" onclick="showManualRosterEntry()" title="Manually enter roster" style="flex:1;min-width:120px;">‚úèÔ∏è Manual Roster</button>
        </div>
      </div>
      <p style="font-size:8px;color:var(--muted);margin-top:6px;">
        Export/import settings, presets, and chains. Import rosters from Excel or enter manually.
      </p>
    </div>
    <!-- v23.8: localStorage Backup/Restore Section -->
    <div style="margin-top:12px;padding-top:12px;border-top:1px solid var(--border);">
      <label style="font-size:11px;font-weight:600;color:var(--text);display:block;margin-bottom:8px;">üíæ localStorage Backup/Restore</label>
      <div style="display:flex;flex-direction:column;gap:6px;">
        <div style="display:flex;gap:6px;flex-wrap:wrap;">
          <button class="btn-sm" onclick="exportLocalStorage()" title="Export all localStorage data to file" style="flex:1;min-width:120px;">üíæ Export localStorage</button>
          <button class="btn-sm" onclick="document.getElementById('importLocalStorageFile').click()" title="Import and restore localStorage from file" style="flex:1;min-width:120px;">üì• Restore localStorage</button>
          <input type="file" id="importLocalStorageFile" accept=".json" style="display:none;" onchange="importLocalStorage(event)">
        </div>
      </div>
      <p style="font-size:8px;color:var(--muted);margin-top:6px;">
        Export all localStorage data (settings, custom rules, mappings, etc.) to a file for backup. Restore from file to recover all saved data.
      </p>
    </div>
    <div style="margin-top:12px;padding-top:8px;border-top:1px solid var(--border);">
      <button class="btn-danger" onclick="clearAllData()" style="width:100%;">üóëÔ∏è Clear All Game Data</button>
      <p style="font-size:8px;color:var(--muted);margin-top:4px;">Removes all events, shifts, and saved data for current game</p>
    </div>
    <div class="modal-actions">
      <button onclick="testConn()" title="Test Supabase connection">Test Connection</button>
      <button class="btn-primary" onclick="saveSettings()">Save</button>
      <button onclick="closeSettings()">Cancel</button>
    </div>
  </div>
</div>

<!-- Help/Instructions Modal -->
<div class="overlay" id="helpModal">
  <div class="modal" style="min-width:700px;max-height:85vh;overflow-y:auto;">
    <h3>‚ùì Instructions & Hotkeys (v26.0)</h3>

    <!-- User Guide Link -->
    <div style="background:linear-gradient(90deg,var(--accent),var(--home));padding:10px 15px;border-radius:6px;margin-bottom:12px;display:flex;justify-content:space-between;align-items:center;">
      <div>
        <span style="font-size:12px;font-weight:bold;color:#000;">üìñ Complete User Guide Available</span>
        <p style="font-size:9px;color:#000;margin:2px 0 0 0;opacity:0.8;">Full documentation with workflows, tips & best practices</p>
      </div>
      <button class="btn-sm" onclick="window.open('TRACKER_USER_GUIDE_v25.0.md', '_blank')" style="background:#000;color:#fff;font-size:10px;">Open Guide</button>
    </div>

    <!-- Quick Feature Explanations -->
    <div style="background:var(--card);padding:12px;border-radius:6px;margin-bottom:12px;border-left:4px solid var(--accent);">
      <h4 style="color:var(--accent);margin:0 0 8px 0;font-size:12px;">üéØ Key Features Explained</h4>
      <div style="font-size:10px;line-height:1.6;">
        <p style="margin:4px 0;"><strong>üéØ Shot Mode:</strong> Enable to quickly log shots by clicking on the rink. Automatically sets event type to Shot and creates shot events at click locations. Great for rapid shot tracking during fast-paced sequences.</p>
        <p style="margin:4px 0;"><strong>üèí Possession Mode:</strong> Track continuous possession chains. Automatically links events together and sets event type to Possession. Enables sequence mode to track the full possession sequence from start to finish.</p>
        <p style="margin:4px 0;"><strong>üîó Sequence Mode:</strong> Automatically links consecutive events together. When enabled, each new event links to the previous one, creating a play sequence. Useful for tracking multi-event plays like passes leading to shots.</p>
        <p style="margin:4px 0;"><strong>ü•Ö Auto-Add Goalie:</strong> When enabled, automatically adds the opposing team's goalie as an opponent player when you log Shot, Goal, Save, or Rebound events. Saves time by not having to manually add the goalie each time.</p>
        <p style="margin:4px 0;"><strong>üìç Shot Chart Overlay:</strong> Display all tracked shots on the rink visualization. Goals appear in green, shots on goal in team colors. Helps visualize shot locations and patterns throughout the game.</p>
        <p style="margin:4px 0;"><strong>üîÑ Mirror Mode:</strong> Auto-flip XY coordinates for period 2 (when teams switch ends). No need to mentally flip coordinates when placing players/puck.</p>
        <p style="margin:4px 0;"><strong>üéØ Auto Zone:</strong> Automatically sets zone based on where you click on the rink. Click offensive end ‚Üí Zone = O, defensive end ‚Üí Zone = D.</p>
        <p style="margin:4px 0;"><strong>üîó Event Chain Templates:</strong> Define templates that auto-suggest/create next events based on triggers. Example: Shot On Net ‚Üí automatically suggests Save event. Access via Settings ‚Üí Manage Event Chain Templates.</p>
        <p style="margin:4px 0;"><strong>üîÑ XY Auto-Sync:</strong> For possession events (Zone Entry/Exit Rush, Possession), puck XY automatically syncs with event_player_1 XY (and vice versa). Edit either one and the other updates automatically.</p>
        <p style="margin:4px 0;"><strong>‚úì Log & Next:</strong> In the confirmation modal, use "Log & Next" button (or Ctrl+L) to log the event and automatically create the next linked event from templates. Saves time for common sequences like Shot‚ÜíSave.</p>
        <p style="margin:4px 0;"><strong>üîó Linked Event XY:</strong> When events are linked, XY data (puck and all players) automatically propagates to all linked events in the chain. Ensures consistent tracking across multi-event sequences.</p>
      </div>
    </div>
    
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;">
      <!-- Keyboard Shortcuts -->
      <div>
        <h4 style="color:var(--accent);margin-bottom:8px;font-size:12px;">‚å®Ô∏è Keyboard Shortcuts</h4>
        <table style="font-size:10px;width:100%;">
          <tr><td style="padding:2px 8px;"><kbd>Enter</kbd></td><td>Save current event (shows confirmation)</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Shift+Enter</kbd></td><td>Quick log (no confirmation)</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Ctrl+L</kbd> / <kbd>Cmd+L</kbd></td><td>Log & auto-create next linked event (in confirm modal)</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Escape</kbd></td><td>Cancel / Close modals</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>L</kbd></td><td>Log shift</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>E</kbd></td><td>End shift (set end time)</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Q</kbd></td><td>Quick line change</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Tab</kbd></td><td>Toggle Puck/Player mode</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>`</kbd></td><td>Switch to Puck XY mode</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>H</kbd> / <kbd>A</kbd></td><td>Set team Home/Away</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Shift+S</kbd></td><td>Swap Event/Opp Teams</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>1-6</kbd></td><td>Select Event Player 1-6</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Alt+1-6</kbd></td><td>Select Opp Player 1-6</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Backspace</kbd></td><td>Undo last XY point</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>[</kbd> / <kbd>]</kbd></td><td>Cycle prev/next player in XY mode</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>K</kbd></td><td>Quickly link to last event</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>‚Üê</kbd> / <kbd>‚Üí</kbd></td><td>Navigate prev/next event when editing (works with XY editing)</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>?</kbd></td><td>Open this help</td></tr>
        </table>
        <h5 style="color:var(--accent);margin:8px 0 4px;font-size:10px;">Event Type Hotkeys:</h5>
        <div style="font-size:9px;color:var(--muted);">F=Faceoff, S=Shot, P=Pass, G=Goal, T=Turnover, Z=Zone, N=Penalty, X=Stoppage, O=Possession, V=Save, R=Rebound, D=DeadIce</div>
        <h5 style="color:var(--accent);margin:8px 0 4px;font-size:10px;">Zone / Success:</h5>
        <div style="font-size:9px;color:var(--muted);">Q=Offensive, W=Neutral, E=Defensive | Y=Success, U=Unsuccess</div>
      </div>
      
      <!-- Video Controls -->
      <div>
        <h4 style="color:var(--accent);margin-bottom:8px;font-size:12px;">üé¨ Video Controls</h4>
        <table style="font-size:10px;width:100%;">
          <tr><td style="padding:2px 8px;"><kbd>Space</kbd></td><td>Play/Pause</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>‚Üê</kbd> / <kbd>‚Üí</kbd></td><td>Seek ¬±1 second</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Shift+‚Üê/‚Üí</kbd></td><td>Seek ¬±10 seconds</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>‚Üë</kbd> / <kbd>‚Üì</kbd></td><td>Speed up/down</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>;</kbd> / <kbd>'</kbd></td><td>Frame back/forward</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>+</kbd> / <kbd>-</kbd></td><td>Zoom in/out</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>0</kbd></td><td>Reset zoom</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Ctrl+1-9</kbd></td><td>Switch video source</td></tr>
        </table>
        
        <h4 style="color:var(--accent);margin:12px 0 8px;font-size:12px;">üÜï v23.4 Features</h4>
        <div style="font-size:9px;line-height:1.5;color:var(--muted);">
          <p>‚Ä¢ <strong>Drag to Create</strong> - Drag on rink for pass/shot</p>
          <p>‚Ä¢ <strong>Smart XY Linking</strong> - Puck auto-links to players</p>
          <p>‚Ä¢ <strong>Quick Chains</strong> - Entry, Dump, Shot+, Break, PP</p>
          <p>‚Ä¢ <strong>üìç All Here</strong> - Place all players at puck</p>
          <p>‚Ä¢ <strong>Multi-Video</strong> - Ctrl+1-9 to switch sources</p>
        </div>
        
        <h4 style="color:var(--warn);margin:12px 0 8px;font-size:12px;">üöÄ v23.5 Speed Features</h4>
        <div style="font-size:9px;line-height:1.4;color:var(--muted);display:grid;grid-template-columns:1fr 1fr;gap:4px;">
          <p>‚Ä¢ <strong>üîÑ Mirror</strong> - Auto-flip XY for P2</p>
          <p>‚Ä¢ <strong>üéØ AutoZ</strong> - Zone from click position</p>
          <p>‚Ä¢ <strong>ü•Ö AutoG</strong> - Auto-add goalie on shots</p>
          <p>‚Ä¢ <strong>üî¢ Numpad</strong> - Use numpad for players</p>
          <p>‚Ä¢ <strong>Quick Queue</strong> - Mark now, fill later</p>
          <p>‚Ä¢ <strong>‚è∫ Macros</strong> - Record event sequences</p>
          <p>‚Ä¢ <strong>üìç Shots</strong> - Overlay on rink</p>
          <p>‚Ä¢ <strong>üì∫ Float</strong> - Draggable video</p>
          <p>‚Ä¢ <strong>üîç Gaps</strong> - Find missing events</p>
          <p>‚Ä¢ <strong>‚úÖ Check</strong> - Consistency checker</p>
          <p>‚Ä¢ <strong>EN-H/A</strong> - Empty net toggle</p>
          <p>‚Ä¢ <strong>Ice/Offside</strong> - One-click stoppages</p>
        </div>
        
        <h4 style="color:var(--success);margin:12px 0 8px;font-size:12px;">üÜï v23.9 New Features</h4>
        <div style="font-size:9px;line-height:1.5;color:var(--muted);">
          <p>‚Ä¢ <strong>üîó Event Chain Templates</strong> - Auto-suggest next events (Shot‚ÜíSave, Pass Breakout‚ÜíZone Exit, etc.)</p>
          <p>‚Ä¢ <strong>‚úì Log & Next</strong> - Button in confirm modal to log event and auto-create linked next event</p>
          <p>‚Ä¢ <strong>üîÑ XY Sync</strong> - Puck & event_player_1 XY auto-sync for possession events (Zone Entry/Exit Rush)</p>
          <p>‚Ä¢ <strong>K Hotkey</strong> - Quickly link to last event</p>
          <p>‚Ä¢ <strong>Auto XY Propagation</strong> - XY data automatically carries over to all linked events</p>
          <p>‚Ä¢ <strong>Team Auto-Correction</strong> - Excel import automatically fixes swapped home/away teams</p>
          <p>‚Ä¢ <strong>Video Link Fallback</strong> - Highlight videos auto-use main YouTube link with start time if no specific URL</p>
        </div>
        
        <h4 style="color:var(--success);margin:12px 0 8px;font-size:12px;">üÜï v26.0 New Features</h4>
        <div style="font-size:9px;line-height:1.5;color:var(--muted);">
          <p>‚Ä¢ <strong>üîó Link Removal Tools</strong> - Remove all links or remove links based on conditions (event type, detail, team, etc.)</p>
          <p>‚Ä¢ <strong>üîç Linking Rule Preview</strong> - Preview what events would be impacted before applying linking rules</p>
          <p>‚Ä¢ <strong>üîó Event Chain Statistics</strong> - View and filter by event chain patterns (Shot>Save, Pass>Turnover, etc.)</p>
          <p>‚Ä¢ <strong>‚Ü©Ô∏è Undo for Links</strong> - Undo linked event changes to revert incorrect links</p>
          <p>‚Ä¢ <strong>‚è±Ô∏è PIM Export</strong> - Penalty minutes (PIM) now included in Excel export</p>
          <p>‚Ä¢ <strong>üåê Game Links</strong> - Quick links to Norad Hockey and BenchSight game pages in header</p>
          <p>‚Ä¢ <strong>‚è∏Ô∏è DeadIce in Stoppage Time</strong> - DeadIce events (icing, offside, puck out) are now counted as stoppage time for shifts</p>
          <p>‚Ä¢ <strong>‚è±Ô∏è Updated Penalty Defaults</strong> - Minor penalties default to 3 minutes, Major penalties default to 6 minutes (configurable in Settings)</p>
          <p>‚Ä¢ <strong>üìç Dynamic Zone Labels</strong> - Zone labels (OFF/DEF) update automatically when editing events based on period direction</p>
          <p>‚Ä¢ <strong>üîÑ Y Coordinate Adjustment</strong> - Y coordinates are now correctly inverted when teams switch ends (even periods)</p>
        </div>
      </div>
    </div>
    
    <hr style="margin:12px 0;border-color:var(--border);">
    
    <!-- Quick Guide -->
    <div>
      <h4 style="color:var(--accent);margin-bottom:8px;font-size:12px;">üìã Quick Workflow</h4>
      <div style="font-size:10px;display:grid;grid-template-columns:repeat(4,1fr);gap:8px;">
        <div style="background:var(--panel);padding:8px;border-radius:4px;text-align:center;">
          <div style="font-size:16px;">1Ô∏è‚É£</div>
          <div><strong>Load Video</strong></div>
          <div style="font-size:9px;color:var(--muted);">+ or üìÅ button</div>
        </div>
        <div style="background:var(--panel);padding:8px;border-radius:4px;text-align:center;">
          <div style="font-size:16px;">2Ô∏è‚É£</div>
          <div><strong>Set Markers</strong></div>
          <div style="font-size:9px;color:var(--muted);">P1üèí at puck drop</div>
        </div>
        <div style="background:var(--panel);padding:8px;border-radius:4px;text-align:center;">
          <div style="font-size:16px;">3Ô∏è‚É£</div>
          <div><strong>Track Events</strong></div>
          <div style="font-size:9px;color:var(--muted);">Type ‚Üí XY ‚Üí Enter</div>
        </div>
        <div style="background:var(--panel);padding:8px;border-radius:4px;text-align:center;">
          <div style="font-size:16px;">4Ô∏è‚É£</div>
          <div><strong>Export</strong></div>
          <div style="font-size:9px;color:var(--muted);">Download Excel</div>
        </div>
      </div>
    </div>
    
    <hr style="margin:12px 0;border-color:var(--border);">
    
    <!-- Video Timing -->
    <div>
      <h4 style="color:var(--accent);margin-bottom:8px;font-size:12px;">üé¨ Video & Time Sync</h4>
      <div style="font-size:10px;line-height:1.6;">
        <p><strong>Video Time Calculation:</strong></p>
        <ul style="margin:4px 0 4px 16px;">
          <li><strong>event_running_start</strong> = (period-1) √ó period_seconds + (period_seconds - time_remaining)</li>
          <li><strong>running_video_time</strong> = event_running_start + intermission_offset</li>
          <li>Period seconds = periodLength √ó 60 (default 18 min = 1080 sec for NORAD)</li>
        </ul>
        <p><strong>Stoppages:</strong> Stoppage events are tracked with duration. You do NOT need to cut 
           stoppages from video - the tracker calculates running time including them.</p>
        <p><strong>Shift Stoppage Time:</strong> Each shift automatically calculates total stoppage duration 
           from Stoppage/Clockstop/DeadIce events that occur within the shift time window. Any DeadIce event 
           (icing, offside, puck out of play, etc.) during a shift's start/stop time is counted as stoppage.</p>
      </div>
    </div>
    
    <hr style="margin:12px 0;border-color:var(--border);">
    
    <!-- Highlights -->
    <div>
      <h4 style="color:var(--accent);margin-bottom:8px;font-size:12px;">‚≠ê Highlights & Video Clips</h4>
      <div style="font-size:10px;line-height:1.6;">
        <p><strong>Marking Highlights:</strong></p>
        <ul style="margin:4px 0 4px 16px;">
          <li>Check "‚≠ê Highlight" checkbox when creating/editing events</li>
          <li>Goals are automatically marked as highlights</li>
          <li>Double-click event ‚Üí Edit Highlight field</li>
          <li>If no specific video URL is provided, automatically uses main YouTube link with start time (10 seconds before event)</li>
        </ul>
        <p><strong>ETL Export:</strong></p>
        <ul style="margin:4px 0 4px 16px;">
          <li><code>is_highlight</code> column = 1 for highlights, 0 otherwise</li>
          <li>Use <code>running_video_time</code> to find clip start in video</li>
          <li>Clip duration = event duration or default (10 sec for goals)</li>
        </ul>
        <p><strong>Creating Highlight Reels:</strong></p>
        <ul style="margin:4px 0 4px 16px;">
          <li>Query: <code>SELECT * FROM fact_events WHERE is_highlight = 1 ORDER BY running_video_time</code></li>
          <li>Use video editor to extract clips at running_video_time timestamps</li>
        </ul>
      </div>
    </div>
    
    <hr style="margin:12px 0;border-color:var(--border);">
    
    <!-- v23.9: Linked Events & Templates -->
    <div>
      <h4 style="color:var(--accent);margin-bottom:8px;font-size:12px;">üîó Linked Events & Auto-Suggestions</h4>
      <div style="font-size:10px;line-height:1.6;">
        <p><strong>Linking Events:</strong></p>
        <ul style="margin:4px 0 4px 16px;">
          <li>Select a previous event number in the "Linked Event #" dropdown</li>
          <li>Press <kbd>K</kbd> to quickly link to the last event</li>
          <li>Sequence Mode (üîó button) automatically links consecutive events</li>
          <li>XY data (puck and all players) automatically propagates to all linked events in the chain</li>
        </ul>
        <p><strong>Event Chain Templates:</strong></p>
        <ul style="margin:4px 0 4px 16px;">
          <li>Go to <strong>Settings ‚Üí Manage Event Chain Templates</strong> to create custom templates</li>
          <li>Templates define triggers (event type, detail1, detail2, play_detail) and suggested next events</li>
          <li>After logging an event, if a template matches, a suggestion modal appears</li>
          <li>Use <strong>"‚úì Log & Next"</strong> button (or <kbd>Ctrl+L</kbd> / <kbd>Cmd+L</kbd>) in confirm modal to auto-create next event</li>
          <li>Default templates: Shot On Net‚ÜíSave, Pass Breakout‚ÜíZone Exit, Pass Intercepted‚ÜíTurnover</li>
          <li>Templates can map players (e.g., event_player_1 ‚Üí opp_player_1 for Shot‚ÜíSave)</li>
          <li>Templates can copy XY data, zone, and other properties automatically</li>
        </ul>
        <p><strong>XY Data Sync for Possession Events:</strong></p>
        <ul style="margin:4px 0 4px 16px;">
          <li>For Zone Entry/Exit Rush and Possession events, puck XY and event_player_1 XY sync automatically</li>
          <li>Edit puck XY ‚Üí automatically updates event_player_1 XY (all points)</li>
          <li>Edit event_player_1 XY ‚Üí automatically updates puck XY (all points)</li>
          <li>This bidirectional sync ensures puck and player positions stay aligned for possession plays</li>
        </ul>
      </div>
    </div>
    
    <hr style="margin:12px 0;border-color:var(--border);">
    
    <!-- Event Log -->
    <div>
      <h4 style="color:var(--accent);margin-bottom:8px;font-size:12px;">üìù Event Log Columns</h4>
      <div style="font-size:10px;display:grid;grid-template-columns:repeat(3,1fr);gap:4px;">
        <span><strong>Idx:</strong> Event index (1-based)</span>
        <span><strong>Link:</strong> Linked event index</span>
        <span><strong>Seq/Play:</strong> Sequence/Play index</span>
        <span><strong>Time:</strong> Period + game time</span>
        <span><strong>Type:</strong> Event type</span>
        <span><strong>Detail:</strong> Event detail 1</span>
        <span><strong>Zone:</strong> Off/Neu/Def</span>
        <span><strong>‚úì/‚úó:</strong> Success flag</span>
        <span><strong>Players:</strong> Player numbers</span>
        <span><strong>‚óè:</strong> Has XY data</span>
        <span><strong>‚≠ê:</strong> Highlight</span>
      </div>
      <p style="font-size:9px;color:var(--muted);margin-top:4px;">Double-click any event to quick edit (Type, Detail, Zone, Success, Linked, Highlight, Time)</p>
    </div>
    
    <div class="modal-actions" style="display:flex;justify-content:space-between;align-items:center;">
      <a href="TRACKER_USER_GUIDE_v23.9.md" download style="font-size:10px;color:var(--accent);">üì• Download Full User Guide (Markdown)</a>
      <button class="btn-primary" onclick="closeHelp()">Close</button>
    </div>
  </div>
</div>

<!-- Player Picker Modal -->
<div class="overlay" id="playerPickerModal">
  <div class="modal" style="min-width:400px;">
    <h3>üë§ Select Player</h3>
    <div class="form-row">
      <div class="form-group">
        <label>Team</label>
        <select id="pickerTeam" onchange="renderPlayerPicker()">
          <option value="home">Home</option>
          <option value="away">Away</option>
        </select>
      </div>
      <div class="form-group">
        <label>Role</label>
        <select id="pickerRole">
          <option value="event_team_player">Event Team</option>
          <option value="opp_team_player">Opposing Team</option>
        </select>
      </div>
    </div>
    <div id="playerPickerList" style="max-height:250px;overflow-y:auto;margin:8px 0;"></div>
    <div class="modal-actions">
      <button onclick="closePlayerPicker()">Cancel</button>
    </div>
  </div>
</div>

<!-- Verification Panel Modal -->
<div class="overlay" id="verifyModal">
  <div class="modal" style="min-width:600px;max-height:90vh;overflow-y:auto;">
    <h3>‚úÖ Verification Panel</h3>
    
    <!-- Tracked Goals (Blue) -->
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:12px;">
      <div style="background:rgba(59,130,246,0.2);border:2px solid var(--home);padding:12px;border-radius:4px;text-align:center;">
        <div style="font-size:24px;font-weight:bold;color:var(--home);" id="verifyHomeGoals">0</div>
        <div style="font-size:10px;color:var(--muted);">Tracked Home Goals</div>
        <div style="font-size:9px;color:var(--accent);margin-top:4px;" id="verifyHomeByPeriod">P1: 0 | P2: 0 | P3: 0</div>
      </div>
      <div style="background:rgba(239,68,68,0.2);border:2px solid var(--away);padding:12px;border-radius:4px;text-align:center;">
        <div style="font-size:24px;font-weight:bold;color:var(--away);" id="verifyAwayGoals">0</div>
        <div style="font-size:10px;color:var(--muted);">Tracked Away Goals</div>
        <div style="font-size:9px;color:var(--accent);margin-top:4px;" id="verifyAwayByPeriod">P1: 0 | P2: 0 | P3: 0</div>
      </div>
    </div>
    
    <!-- Official Score (Purple - Auto from dim_schedule) -->
    <div style="background:rgba(168,85,247,0.15);border:2px solid #a855f7;padding:12px;border-radius:4px;margin-bottom:12px;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <span style="font-size:11px;color:#a855f7;font-weight:bold;">üìä OFFICIAL SCORE (from dim_schedule)</span>
        <a id="noradGameLink" href="#" target="_blank" style="font-size:9px;color:var(--accent);">View on noradhockey.com ‚Üó</a>
      </div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;">
        <div style="text-align:center;">
          <div style="font-size:24px;font-weight:bold;color:#a855f7;" id="officialHomeGoalsDisplay">-</div>
          <div style="font-size:9px;color:var(--muted);" id="officialHomeByPeriod">P1: - | P2: - | P3: -</div>
        </div>
        <div style="text-align:center;">
          <div style="font-size:24px;font-weight:bold;color:#a855f7;" id="officialAwayGoalsDisplay">-</div>
          <div style="font-size:9px;color:var(--muted);" id="officialAwayByPeriod">P1: - | P2: - | P3: -</div>
        </div>
      </div>
      <input type="hidden" id="officialHomeGoals" value="0">
      <input type="hidden" id="officialAwayGoals" value="0">
    </div>
    
    <!-- Verification Result -->
    <div id="verifyResult" style="padding:12px;border-radius:4px;text-align:center;font-weight:bold;font-size:14px;margin-bottom:12px;"></div>
    
    <!-- Warnings -->
    <div id="verifyWarnings" style="display:none;background:rgba(245,158,11,0.2);border:1px solid var(--warn);padding:8px;border-radius:4px;margin-bottom:12px;font-size:10px;">
      <div style="font-weight:bold;color:var(--warn);margin-bottom:4px;">‚ö†Ô∏è WARNINGS</div>
      <div id="verifyWarningsList"></div>
    </div>
    
    <!-- Goal Breakdown -->
    <div style="margin-bottom:12px;">
      <div style="font-size:9px;color:var(--muted);margin-bottom:4px;">GOAL BREAKDOWN (Scorer #, Assist # from play_details or linked Pass events üîó)</div>
      <table style="width:100%;font-size:10px;border-collapse:collapse;">
        <thead><tr style="background:var(--card);">
          <th style="text-align:left;padding:4px;">P</th>
          <th style="text-align:left;padding:4px;">Time</th>
          <th style="text-align:left;padding:4px;">Team</th>
          <th style="text-align:left;padding:4px;">Scorer</th>
          <th style="text-align:left;padding:4px;">Assists</th>
          <th style="text-align:left;padding:4px;">‚úì</th>
        </tr></thead>
        <tbody id="verifyGoalsList"></tbody>
      </table>
    </div>
    
    <!-- Player Assist Counts -->
    <div style="margin-bottom:12px;">
      <div style="font-size:9px;color:var(--muted);margin-bottom:4px;">PLAYER ASSIST COUNTS (Tracked vs Roster)</div>
      <div style="max-height:200px;overflow-y:auto;border:1px solid var(--border);border-radius:4px;">
        <table style="width:100%;font-size:9px;border-collapse:collapse;">
          <thead><tr style="background:var(--card);position:sticky;top:0;">
            <th style="text-align:left;padding:4px;font-size:8px;">#</th>
            <th style="text-align:left;padding:4px;font-size:8px;">Name</th>
            <th style="text-align:left;padding:4px;font-size:8px;">Team</th>
            <th style="text-align:center;padding:4px;font-size:8px;">Tracked</th>
            <th style="text-align:center;padding:4px;font-size:8px;">Roster</th>
            <th style="text-align:center;padding:4px;font-size:8px;">Status</th>
          </tr></thead>
          <tbody id="verifyAssistCountsList"></tbody>
        </table>
      </div>
    </div>
    
    <div class="modal-actions">
      <button onclick="runVerification()" title="Run verification checks on goals and assists">üîÑ Verify</button>
      <button onclick="closeVerifyModal()" title="Close verification panel">Close</button>
    </div>
  </div>
</div>

<!-- Video Timing Modal -->
<div class="overlay" id="videoTimingModal">
  <div class="modal" style="min-width:500px;max-height:80vh;overflow-y:auto;">
    <h3>üé¨ Video Timing Setup</h3>
    <p style="font-size:10px;color:var(--muted);margin-bottom:12px;">Configure video offsets for accurate timestamp calculations</p>
    
    <!-- Basic Settings -->
    <div style="background:var(--card);padding:12px;border-radius:4px;margin-bottom:12px;">
      <h4 style="font-size:11px;color:var(--accent);margin-bottom:8px;">Basic Settings</h4>
      <div class="form-group">
        <label>Video Start Offset (sec)</label>
        <input type="number" id="vtVideoStartOffset" value="0" min="0" placeholder="Skip warmups etc" oninput="updateVideoTimingPreview()">
      </div>
      
      <!-- Game Start Configuration -->
      <div style="margin-top:12px;padding-top:12px;border-top:1px solid var(--border);">
        <label style="font-size:10px;color:var(--accent);display:block;margin-bottom:6px;font-weight:bold;">üé¨ Game Start (for partial recordings)</label>
        <p style="font-size:9px;color:var(--muted);margin-bottom:8px;">If video only records part of the game, specify when recording starts</p>
        <div class="form-row">
          <div class="form-group" style="flex:1;">
            <label style="font-size:9px;">Start Period</label>
            <select id="vtGameStartPeriod" oninput="updateVideoTimingPreview()">
              <option value="1">Period 1</option>
              <option value="2">Period 2</option>
              <option value="3">Period 3</option>
              <option value="OT">OT</option>
            </select>
          </div>
          <div class="form-group" style="flex:1;">
            <label style="font-size:9px;">Start Time (MM:SS)</label>
            <input type="text" id="vtGameStartTime" placeholder="18:00" oninput="autoFormatTime(this); updateVideoTimingPreview();">
          </div>
        </div>
      </div>
      <div style="margin-top:8px;">
        <label style="font-size:10px;color:var(--muted);display:block;margin-bottom:4px;">Period Lengths (minutes) - synced with Settings</label>
        <div style="display:flex;gap:8px;">
          <div class="form-group" style="flex:1;">
            <label style="font-size:9px;">P1</label>
            <input type="number" id="vtPeriodLength1" value="18" min="5" max="25" style="width:100%;" oninput="syncPeriodLengthsFromVT()">
          </div>
          <div class="form-group" style="flex:1;">
            <label style="font-size:9px;">P2</label>
            <input type="number" id="vtPeriodLength2" value="18" min="5" max="25" style="width:100%;" oninput="syncPeriodLengthsFromVT()">
          </div>
          <div class="form-group" style="flex:1;">
            <label style="font-size:9px;">P3</label>
            <input type="number" id="vtPeriodLength3" value="18" min="5" max="25" style="width:100%;" oninput="syncPeriodLengthsFromVT()">
          </div>
          <div class="form-group" style="flex:1;">
            <label style="font-size:9px;">OT</label>
            <input type="number" id="vtPeriodLengthOT" value="5" min="3" max="20" style="width:100%;" oninput="syncPeriodLengthsFromVT()">
          </div>
        </div>
      </div>
      <div class="form-group" style="margin-top:8px;">
        <label>YouTube URL (optional)</label>
        <input type="text" id="vtYoutubeUrl" placeholder="https://youtube.com/watch?v=...">
      </div>
    </div>
    
    <!-- Period Start Offsets -->
    <div style="background:var(--card);padding:12px;border-radius:4px;margin-bottom:12px;">
      <h4 style="font-size:11px;color:var(--accent);margin-bottom:8px;">Period Start Offsets</h4>
      <p style="font-size:9px;color:var(--muted);margin-bottom:8px;">When each period starts in the video. Enter as seconds (e.g., 120) or time (e.g., 19:02)</p>
      <div class="form-row">
        <div class="form-group" style="flex:1;">
          <label style="font-size:9px;">Period 1 Start</label>
          <input type="text" id="vtPeriod1Start" placeholder="0 or 0:00" oninput="updateVideoTimingPreview()">
        </div>
        <div class="form-group" style="flex:1;">
          <label style="font-size:9px;">Period 2 Start</label>
          <input type="text" id="vtPeriod2Start" placeholder="auto or 19:02" oninput="updateVideoTimingPreview()">
        </div>
        <div class="form-group" style="flex:1;">
          <label style="font-size:9px;">Period 3 Start</label>
          <input type="text" id="vtPeriod3Start" placeholder="auto or 38:04" oninput="updateVideoTimingPreview()">
        </div>
        <div class="form-group" style="flex:1;">
          <label style="font-size:9px;">OT Start</label>
          <input type="text" id="vtPeriodOTStart" placeholder="auto or 57:06" oninput="updateVideoTimingPreview()">
        </div>
      </div>
    </div>
    
    <!-- Intermissions -->
    <div style="background:var(--card);padding:12px;border-radius:4px;margin-bottom:12px;">
      <h4 style="font-size:11px;color:var(--accent);margin-bottom:8px;">Intermission Durations</h4>
      <p style="font-size:9px;color:var(--muted);margin-bottom:8px;">Enter actual video time of intermissions (not game clock)</p>
      <div class="form-row">
        <div class="form-group">
          <label>After Period 1 (sec)</label>
          <input type="number" id="vtIntermission1" value="900" min="0" placeholder="900 = 15 min" oninput="updateVideoTimingPreview()">
        </div>
        <div class="form-group">
          <label>After Period 2 (sec)</label>
          <input type="number" id="vtIntermission2" value="900" min="0" placeholder="900 = 15 min" oninput="updateVideoTimingPreview()">
        </div>
        <div class="form-group">
          <label>After Period 3 / OT (sec)</label>
          <input type="number" id="vtIntermission3" value="300" min="0" placeholder="300 = 5 min" oninput="updateVideoTimingPreview()">
        </div>
      </div>
    </div>
    
    <!-- Timeouts/Stoppages -->
    <div style="background:var(--card);padding:12px;border-radius:4px;margin-bottom:12px;">
      <h4 style="font-size:11px;color:var(--accent);margin-bottom:8px;">Timeouts & Extended Stoppages</h4>
      <p style="font-size:9px;color:var(--muted);margin-bottom:8px;">Add stoppages that add extra video time (injuries, TV timeouts, etc)</p>
      <div id="vtTimeoutsList" style="margin-bottom:8px;max-height:150px;overflow-y:auto;"></div>
      <div class="form-row" style="align-items:flex-end;">
        <div class="form-group" style="flex:0.5;">
          <label>Period</label>
          <select id="vtNewTimeoutPeriod" onchange="updateTimeoutVideoTimes()"><option>1</option><option>2</option><option>3</option><option>OT</option></select>
        </div>
        <div class="form-group" style="flex:1;">
          <label style="font-size:9px;">Game Start (MM:SS)</label>
          <input type="text" id="vtNewTimeoutGameStart" placeholder="15:30" oninput="autoFormatTime(this); updateTimeoutFromGameTimes();">
        </div>
        <div class="form-group" style="flex:1;">
          <label style="font-size:9px;">Game Stop (MM:SS)</label>
          <input type="text" id="vtNewTimeoutGameStop" placeholder="14:20" oninput="autoFormatTime(this); updateTimeoutFromGameTimes();">
        </div>
        <div class="form-group" style="flex:1;">
          <label style="font-size:9px;">Video Start (MM:SS)</label>
          <input type="text" id="vtNewTimeoutVideoStart" placeholder="5:30" oninput="autoFormatTime(this); updateTimeoutFromVideoTimes();">
        </div>
        <div class="form-group" style="flex:1;">
          <label style="font-size:9px;">Video Stop (MM:SS)</label>
          <input type="text" id="vtNewTimeoutVideoStop" placeholder="6:30" oninput="autoFormatTime(this); updateTimeoutFromVideoTimes();">
        </div>
        <div class="form-group" style="flex:0.8;">
          <label style="font-size:9px;">Duration (sec)</label>
          <input type="number" id="vtNewTimeoutDuration" value="0" min="0" oninput="updateTimeoutFromDuration();">
        </div>
        <button class="btn-sm btn-success" onclick="addVideoTimeout()" style="margin-bottom:4px;">+ Add</button>
      </div>
      <p style="font-size:8px;color:var(--muted);margin-top:4px;">Enter either game times OR video times OR duration. The others will auto-calculate.</p>
    </div>
    
    <!-- Video Management (v23.6) -->
    <div style="background:var(--card);padding:12px;border-radius:4px;margin-bottom:12px;border-top:2px solid var(--accent);">
      <h4 style="font-size:11px;color:var(--accent);margin-bottom:8px;">üìπ Video Management</h4>
      <p style="font-size:9px;color:var(--muted);margin-bottom:8px;">Store multiple video links for this game</p>
      <div id="videosList" style="margin-bottom:8px;max-height:200px;overflow-y:auto;"></div>
      <div class="form-row" style="align-items:flex-end;">
        <div class="form-group" style="flex:1;">
          <label>Video URL</label>
          <input type="text" id="newVideoUrl" placeholder="https://youtube.com/watch?v=...">
        </div>
        <div class="form-group" style="flex:0.5;">
          <label>Type</label>
          <select id="newVideoType">
            <option value="Full_Ice">Full Ice</option>
            <option value="Broadcast">Broadcast</option>
            <option value="Highlights">Highlights</option>
            <option value="Goalie">Goalie</option>
            <option value="Overhead">Overhead</option>
            <option value="Wide">Wide</option>
            <option value="Tight">Tight</option>
            <option value="Replay">Replay</option>
            <option value="Other">Other</option>
          </select>
        </div>
        <div class="form-group" style="flex:0.5;">
          <label>Category</label>
          <select id="newVideoCategory">
            <option value="">--</option>
            <option value="Goal">Goal</option>
            <option value="Save">Save</option>
            <option value="Hit">Hit</option>
            <option value="Fight">Fight</option>
            <option value="Breakaway">Breakaway</option>
            <option value="Penalty_Shot">Penalty Shot</option>
            <option value="Sequence">Sequence</option>
            <option value="Momentum">Momentum</option>
            <option value="Skill">Skill</option>
            <option value="Other">Other</option>
          </select>
        </div>
        <button class="btn-sm btn-success" onclick="addVideo()" style="margin-bottom:4px;">+ Add</button>
      </div>
      <div class="form-row">
        <div class="form-group" style="flex:1;">
          <label>Title (optional)</label>
          <input type="text" id="newVideoTitle" placeholder="e.g., Period 1 Highlights">
        </div>
        <div class="form-group" style="flex:0.5;">
          <label>Period</label>
          <select id="newVideoPeriod">
            <option value="">All</option>
            <option value="1">Period 1</option>
            <option value="2">Period 2</option>
            <option value="3">Period 3</option>
            <option value="4">OT</option>
          </select>
        </div>
      </div>
      <div class="form-row">
        <div class="form-group" style="flex:1;">
          <label>Start Time (optional)</label>
          <input type="text" id="newVideoStartTime" placeholder="00:00">
        </div>
        <div class="form-group" style="flex:1;">
          <label>End Time (optional)</label>
          <input type="text" id="newVideoEndTime" placeholder="20:00">
        </div>
      </div>
      <div class="form-group">
        <label>Description/Notes (optional)</label>
        <textarea id="newVideoNotes" rows="2" placeholder="Video description or notes"></textarea>
      </div>
    </div>
    
    <!-- Running Time Preview -->
    <div style="background:var(--panel);padding:12px;border-radius:4px;margin-bottom:12px;border:1px solid var(--accent);">
      <h4 style="font-size:11px;color:var(--accent);margin-bottom:8px;">‚è±Ô∏è Running Time Preview (Video Times)</h4>
      <div id="vtPreviewContent" style="font-size:10px;">
        <!-- Will be populated by updateVideoTimingPreview() -->
      </div>
    </div>
    
    <div class="modal-actions">
      <button class="btn-primary" onclick="saveVideoTiming()">üíæ Save</button>
      <button onclick="closeVideoTimingModal()">Cancel</button>
    </div>
  </div>
</div>

<!-- Highlight Videos Modal -->
<div class="overlay" id="highlightVideosModal">
  <div class="modal" style="min-width:600px;max-height:80vh;overflow-y:auto;">
    <h3>‚≠ê Highlight Videos</h3>
    <p style="font-size:10px;color:var(--muted);margin-bottom:12px;">Manage video URLs for highlighted events</p>
    
    <!-- Existing Highlights List -->
    <div style="background:var(--card);padding:12px;border-radius:4px;margin-bottom:12px;">
      <h4 style="font-size:11px;color:var(--accent);margin-bottom:8px;">Current Highlights</h4>
      <div id="highlightVideosList" style="font-size:10px;">
        <!-- Will be populated by renderHighlightVideos() -->
      </div>
    </div>
    
    <!-- Add New Highlight Video -->
    <div style="background:var(--card);padding:12px;border-radius:4px;margin-bottom:12px;">
      <h4 style="font-size:11px;color:var(--accent);margin-bottom:8px;">Add Highlight Video</h4>
      <div class="form-group">
        <label>Select Event</label>
        <select id="newHighlightEventSelect" style="width:100%;">
          <option value="">-- Select an event --</option>
        </select>
      </div>
      <div class="form-group" style="margin-top:8px;">
        <label>Video URL (YouTube)</label>
        <input type="text" id="newHighlightVideoUrl" placeholder="https://youtube.com/watch?v=..." style="width:100%;">
      </div>
      <button class="btn-sm btn-success" onclick="addHighlightVideo()" style="margin-top:8px;">+ Add Highlight Video</button>
    </div>
    
    <div class="modal-actions">
      <button onclick="closeHighlightVideosModal()">Close</button>
    </div>
  </div>
</div>

<!-- Load Existing Game Modal -->
<div class="overlay" id="loadGameModal">
  <div class="modal" style="min-width:500px;">
    <h3>üìÇ Load Existing Game</h3>
    <p style="font-size:10px;color:var(--muted);margin-bottom:12px;">Load tracked events from Supabase for editing</p>
    <div class="form-group" style="margin-bottom:8px;">
      <label>Select Game</label>
      <select id="loadGameSelect" style="width:100%;" onchange="previewLoadGame()"></select>
    </div>
    <div id="loadGamePreview" style="background:var(--card);padding:8px;border-radius:4px;font-size:10px;margin-bottom:8px;">
      <div>Events: <span id="loadPreviewEvents">--</span></div>
      <div>Shifts: <span id="loadPreviewShifts">--</span></div>
    </div>
    <div class="modal-actions">
      <button class="btn-primary" onclick="confirmLoadGame()">Load Game</button>
      <button onclick="closeLoadGameModal()">Cancel</button>
    </div>
  </div>
</div>
<div class="overlay" id="editModal">
  <div class="modal" style="min-width:650px;max-height:90vh;overflow-y:auto;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
      <button class="btn-sm" onclick="navEditEvent(-1)" title="Previous Event (‚Üê Arrow Left)">‚óÄ Prev <kbd style="font-size:8px;padding:1px 3px;">‚Üê</kbd></button>
      <h3 style="margin:0;">‚úèÔ∏è Event #<span id="editEvtIdx"></span> <span id="editHighlightBadge" style="color:gold;"></span></h3>
      <button class="btn-sm" onclick="navEditEvent(1)" title="Next Event (‚Üí Arrow Right)">Next ‚ñ∂ <kbd style="font-size:8px;padding:1px 3px;">‚Üí</kbd></button>
    </div>
    <div class="form-row">
      <div class="form-group"><label>Event Type</label><select id="editType" onchange="onEditTypeChange()"></select></div>
      <div class="form-group"><label>Team</label><select id="editTeam" onchange="onEditTeamChange()"><option value="home">Home</option><option value="away">Away</option></select></div>
    </div>
    <div class="form-row">
      <div class="form-group"><label>Detail 1</label><select id="editD1" onchange="onEditD1Change()"></select></div>
      <div class="form-group"><label>Detail 2</label><select id="editD2"></select></div>
    </div>
    <div class="form-row tri">
      <div class="form-group"><label>Zone <button class="btn-sm" onclick="autoEditZone()" title="Auto from XY">‚ö°</button></label><select id="editZone"><option value="">--</option><option value="o">O</option><option value="d">D</option><option value="n">N</option></select></div>
      <div class="form-group"><label>Success <button class="btn-sm" onclick="autoEditSuccess()" title="Auto from detail">‚ö°</button></label><select id="editSuccess"><option value="">--</option><option value="s">S</option><option value="u">U</option></select></div>
      <div class="form-group"><label>Strength <button class="btn-sm" onclick="autoEditStrength()" title="Auto from shift">‚ö°</button></label><select id="editStrength"><option value="5v5">5v5</option><option value="5v4">5v4</option><option value="4v5">4v5</option><option value="4v4">4v4</option><option value="3v3">3v3</option><option value="ENG">ENG</option></select></div>
    </div>
    <div class="form-row">
      <div class="form-group"><label>Start Time</label><input type="text" id="editStartTime" oninput="autoFormatTime(this)"></div>
      <div class="form-group"><label>End Time</label><input type="text" id="editEndTime" oninput="autoFormatTime(this)"></div>
    </div>
    <div class="form-row">
      <div class="form-group">
        <label style="display:flex;align-items:center;gap:4px;">
          <input type="checkbox" id="editHighlight" onchange="toggleEditHighlightFields()"> ‚≠ê Highlight (for video)
        </label>
      </div>
      <div class="form-group">
        <label>Linked Event #</label>
        <input type="number" id="editLinkedIdx" style="width:60px;" placeholder="--" title="Enter event # to link to">
      </div>
      <!-- v23.8: Assist to Goal link (for Pass events or events with assist markers) -->
      <div class="form-group" id="editAssistToGoalSection" style="display:none;">
        <label style="font-size:9px;">Assist to Goal #</label>
        <div style="display:flex;gap:4px;align-items:center;">
          <input type="number" id="editAssistToGoalIdx" style="width:60px;" placeholder="--" title="Enter goal event # this assists">
          <button class="btn-sm" onclick="openLinkAssistToGoalModal()" style="font-size:8px;padding:2px 6px;" title="Browse and select a goal to link this assist to">Browse</button>
        </div>
      </div>
    </div>
    <!-- Video URL for highlights (v23.7) -->
    <div id="editHighlightVideoUrlRow" style="display:none;margin-bottom:8px;">
      <div class="form-group">
        <label style="font-size:8px;color:var(--muted);">YouTube URL for this highlight:</label>
        <input type="text" id="editVideoUrl" placeholder="https://youtube.com/watch?v=..." style="width:100%;font-size:9px;">
      </div>
    </div>
    <div class="form-row" style="background:var(--panel);padding:4px 8px;border-radius:4px;margin-bottom:8px;">
      <!-- v23.8: Made event_id, sequence_key, and play_key editable -->
      <div class="form-group" style="margin-bottom:0;">
        <label style="font-size:8px;color:var(--muted);">Event ID</label>
        <input type="text" id="editEventId" style="width:100%;font-size:9px;font-family:monospace;padding:2px 4px;" placeholder="--" title="Event ID (editable)">
      </div>
      <div class="form-group" style="margin-bottom:0;">
        <label style="font-size:8px;color:var(--muted);">Event Index</label>
        <span id="editEventIndex" style="font-size:10px;color:var(--accent);">--</span>
      </div>
      <div class="form-group" style="margin-bottom:0;">
        <label style="font-size:8px;color:var(--muted);">Sequence Key</label>
        <input type="text" id="editSeqKey" style="width:100%;font-size:9px;padding:2px 4px;" placeholder="--" title="Sequence Key / Sequence ID (editable)">
      </div>
      <div class="form-group" style="margin-bottom:0;">
        <label style="font-size:8px;color:var(--muted);">Play Key</label>
        <input type="text" id="editPlayKey" style="width:100%;font-size:9px;padding:2px 4px;" placeholder="--" title="Play Key / Play ID (editable)">
      </div>
      <div class="form-group" style="margin-bottom:0;">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div>
            <label style="font-size:8px;color:var(--muted);">Linked Chain</label>
            <span id="editLinkedChain" style="font-size:9px;color:var(--warn);display:block;">--</span>
          </div>
          <button id="editUnlinkButton" class="btn-sm btn-danger" onclick="unlinkCurrentEvent();event.stopPropagation();" style="font-size:8px;padding:2px 6px;display:none;" title="Remove this event from its linked chain">üîó Unlink</button>
        </div>
      </div>
    </div>
    <div class="section-title" style="margin-top:8px;">
      <span>Players</span>
      <div style="display:flex;gap:4px;">
        <button class="btn-sm" onclick="clearEditPlayers('event_team')" title="Clear all event team players" style="font-size:8px;padding:2px 4px;">Clear Event</button>
        <button class="btn-sm" onclick="clearEditPlayers('opp_team')" title="Clear all opponent team players" style="font-size:8px;padding:2px 4px;">Clear Opp</button>
        <button class="btn-sm" onclick="addPlayerToEdit()">+ Add</button>
      </div>
    </div>
    <div id="editPlayersContainer" style="max-height:200px;overflow-y:auto;"></div>
    <div class="section-title" style="margin-top:8px;"><span>Puck XY</span></div>
    <div id="editPuckXY" style="display:flex;flex-wrap:wrap;gap:4px;"></div>
    <div class="section-title" style="margin-top:8px;"><span>Edit XY on Rink</span></div>
    <svg id="editRinkSvg" viewBox="0 0 200 85" width="100%" style="cursor:crosshair;background:var(--card);border-radius:4px;max-height:150px;" onclick="handleEditRinkClick(event)">
      <!-- Ice surface -->
      <rect x="0" y="0" width="200" height="85" fill="#f0f9ff" rx="14" ry="14" stroke="#1e293b" stroke-width="0.5"/>
      
      <!-- Blue lines -->
      <line x1="75" y1="0" x2="75" y2="85" stroke="#1d4ed8" stroke-width="1.5"/>
      <line x1="125" y1="0" x2="125" y2="85" stroke="#1d4ed8" stroke-width="1.5"/>
      
      <!-- Red center line (dashed) -->
      <line x1="100" y1="0" x2="100" y2="85" stroke="#dc2626" stroke-width="0.8" stroke-dasharray="3,2"/>
      
      <!-- Goal lines -->
      <line x1="11" y1="0" x2="11" y2="85" stroke="#dc2626" stroke-width="0.5"/>
      <line x1="189" y1="0" x2="189" y2="85" stroke="#dc2626" stroke-width="0.5"/>
      
      <!-- Center circle -->
      <circle cx="100" cy="42.5" r="15" fill="none" stroke="#1d4ed8" stroke-width="0.5"/>
      <circle cx="100" cy="42.5" r="1" fill="#1d4ed8"/>
      
      <!-- Offensive zone faceoff circles (left) -->
      <circle cx="31" cy="22" r="15" fill="none" stroke="#dc2626" stroke-width="0.4"/>
      <circle cx="31" cy="22" r="1" fill="#dc2626"/>
      <circle cx="31" cy="63" r="15" fill="none" stroke="#dc2626" stroke-width="0.4"/>
      <circle cx="31" cy="63" r="1" fill="#dc2626"/>
      
      <!-- Offensive zone faceoff circles (right) -->
      <circle cx="169" cy="22" r="15" fill="none" stroke="#dc2626" stroke-width="0.4"/>
      <circle cx="169" cy="22" r="1" fill="#dc2626"/>
      <circle cx="169" cy="63" r="15" fill="none" stroke="#dc2626" stroke-width="0.4"/>
      <circle cx="169" cy="63" r="1" fill="#dc2626"/>
      
      <!-- Neutral zone dots -->
      <circle cx="80" cy="22" r="0.8" fill="#dc2626"/>
      <circle cx="80" cy="63" r="0.8" fill="#dc2626"/>
      <circle cx="120" cy="22" r="0.8" fill="#dc2626"/>
      <circle cx="120" cy="63" r="0.8" fill="#dc2626"/>
      
      <!-- Zone labels (v24.0: Update based on event period) -->
      <text x="43" y="81" font-size="3" fill="#64748b" text-anchor="middle" id="editLeftZoneLbl">--</text>
      <text x="100" y="81" font-size="3" fill="#64748b" text-anchor="middle">NEUTRAL</text>
      <text x="157" y="81" font-size="3" fill="#64748b" text-anchor="middle" id="editRightZoneLbl">--</text>
      
      <!-- Creases (simplified) -->
      <path d="M 11 38.5 L 15 38.5 A 4 4 0 0 1 15 46.5 L 11 46.5" fill="rgba(59,130,246,0.15)" stroke="#3b82f6" stroke-width="0.4"/>
      <path d="M 189 38.5 L 185 38.5 A 4 4 0 0 0 185 46.5 L 189 46.5" fill="rgba(59,130,246,0.15)" stroke="#3b82f6" stroke-width="0.4"/>
      
      <!-- Goals -->
      <rect x="7" y="39" width="4" height="7" fill="#222" stroke="#fff" stroke-width="0.3"/>
      <rect x="189" y="39" width="4" height="7" fill="#222" stroke="#fff" stroke-width="0.3"/>
      
      <!-- High danger zone (slot area) -->
      <path d="M 11 30 L 45 30 L 45 55 L 11 55 Z" fill="rgba(239,68,68,0.08)" stroke="none"/>
      <path d="M 189 30 L 155 30 L 155 55 L 189 55 Z" fill="rgba(239,68,68,0.08)" stroke="none"/>
      
      <!-- Zone labels (v24.0: Update based on event period) -->
      <text x="43" y="82" font-size="3" fill="#64748b" text-anchor="middle" id="editLeftZoneLbl">--</text>
      <text x="100" y="82" font-size="3" fill="#64748b" text-anchor="middle">NEUTRAL</text>
      <text x="157" y="82" font-size="3" fill="#64748b" text-anchor="middle" id="editRightZoneLbl">--</text>
      
      <g id="editRinkMarkers"></g>
    </svg>
    <div id="editXYControls" style="font-size:9px;color:var(--muted);margin-top:4px;">
      Editing: <select id="editXYTarget" onchange="renderEditRinkMarkers()" style="font-size:9px;"></select>
      <button class="btn-sm" onclick="addEditXYPoint()" title="Add XY point (click on rink)">+ Add Point</button>
    </div>
    <!-- Assists Management for Goals (v23.8) -->
    <div id="editAssistsSection" style="display:none;margin-top:8px;">
      <div class="section-title">
        <span>Assists</span>
        <button class="btn-sm" onclick="openAddAssistModal()" style="font-size:9px;" title="Add a new assist by linking a Pass event to this goal">+ Add Assist</button>
      </div>
      <div id="editAssistsList" style="max-height:150px;overflow-y:auto;background:var(--card);padding:6px;border-radius:4px;margin-top:6px;">
        <!-- Assists will be rendered here -->
      </div>
    </div>
    <!-- Net Location for Shots/Goals -->
    <div id="editNetSection" style="display:none;margin-top:8px;">
      <div class="section-title"><span>Net Location (Shot/Goal)</span></div>
      <div style="display:flex;gap:16px;align-items:center;">
        <svg id="editNetSvg" viewBox="0 0 72 48" width="160" style="cursor:crosshair;background:#1f2937;border-radius:4px;" onclick="handleEditNetClick(event)">
          <rect x="1" y="1" width="70" height="46" fill="#111" stroke="#fff" stroke-width="1"/>
          <line x1="1" y1="1" x2="71" y2="47" stroke="#444" stroke-width="0.5"/>
          <line x1="71" y1="1" x2="1" y2="47" stroke="#444" stroke-width="0.5"/>
          <line x1="36" y1="1" x2="36" y2="47" stroke="#444" stroke-width="0.5"/>
          <line x1="1" y1="24" x2="71" y2="24" stroke="#444" stroke-width="0.5"/>
          <text x="12" y="12" font-size="5" fill="#666">Top L</text>
          <text x="50" y="12" font-size="5" fill="#666">Top R</text>
          <text x="12" y="42" font-size="5" fill="#666">Low L</text>
          <text x="50" y="42" font-size="5" fill="#666">Low R</text>
          <text x="26" y="26" font-size="5" fill="#666">5-Hole</text>
          <g id="editNetMarker"></g>
        </svg>
        <div style="font-size:10px;">
          <div style="color:var(--muted);margin-bottom:4px;">Click to set location</div>
          <div>Current: <span id="editNetLocation" style="color:var(--accent);">--</span></div>
          <button class="btn-sm" onclick="clearEditNetXY()" style="margin-top:4px;" title="Clear net location">Clear</button>
        </div>
      </div>
    </div>
    <!-- v20.7: Insert/Delete actions -->
    <div style="display:flex;gap:4px;margin-top:8px;padding-top:8px;border-top:1px solid var(--border);">
      <button class="btn-sm" onclick="insertEventBefore()" title="Insert new event before this one" style="flex:1;background:var(--accent2);">‚ûï Insert Before</button>
      <button class="btn-sm" onclick="insertEventAfter()" title="Insert new event after this one" style="flex:1;background:var(--accent2);">‚ûï Insert After</button>
      <button class="btn-sm" onclick="duplicateEvent()" title="Duplicate this event" style="flex:1;">üìã Duplicate</button>
    </div>
    <!-- v23.9: Insert Linked Event actions -->
    <div style="display:flex;gap:4px;margin-top:4px;">
      <button class="btn-sm" onclick="insertLinkedEventBefore()" title="Insert new linked event before this one (copies XY data)" style="flex:1;background:var(--accent);color:#fff;">üîó Link Before</button>
      <button class="btn-sm" onclick="insertLinkedEventAfter()" title="Insert new linked event after this one (copies XY data)" style="flex:1;background:var(--accent);color:#fff;">üîó Link After</button>
    </div>
    <div class="modal-actions">
      <button class="btn-danger" onclick="deleteEvent()" title="Delete this event">Delete</button>
      <button class="btn-primary" onclick="saveEditEvent()" title="Save changes to event">Save</button>
      <button onclick="closeEditModal()" title="Cancel editing">Cancel</button>
    </div>
  </div>
</div>

<!-- Net Location Modal -->
<div class="overlay" id="netModal">
  <div class="modal" style="min-width:200px;">
    <h3>ü•Ö Net Location</h3>
    <p style="font-size:9px;color:var(--muted);margin-bottom:8px;">Click where puck entered net</p>
    <svg id="netSvg" viewBox="0 0 72 48" width="200" style="cursor:crosshair;background:#222;border-radius:4px;" onclick="handleNetClick(event)">
      <!-- Net frame -->
      <rect x="1" y="1" width="70" height="46" fill="none" stroke="#fff" stroke-width="1"/>
      <!-- Net mesh -->
      <line x1="1" y1="1" x2="71" y2="47" stroke="#666" stroke-width="0.3"/>
      <line x1="71" y1="1" x2="1" y2="47" stroke="#666" stroke-width="0.3"/>
      <line x1="36" y1="1" x2="36" y2="47" stroke="#666" stroke-width="0.3"/>
      <line x1="1" y1="24" x2="71" y2="24" stroke="#666" stroke-width="0.3"/>
      <!-- Zones -->
      <text x="18" y="14" font-size="6" fill="#888">Top L</text>
      <text x="46" y="14" font-size="6" fill="#888">Top R</text>
      <text x="18" y="38" font-size="6" fill="#888">Low L</text>
      <text x="46" y="38" font-size="6" fill="#888">Low R</text>
      <text x="28" y="26" font-size="6" fill="#888">5-Hole</text>
      <!-- Marker layer -->
      <g id="netMarker"></g>
    </svg>
    <div class="modal-actions">
      <button onclick="clearNetXY()">Clear</button>
      <button class="btn-primary" onclick="closeNetModal()">Done</button>
    </div>
  </div>
</div>

<!-- Edit Shift Modal -->
<div class="overlay" id="editShiftModal">
  <div class="modal" style="min-width:500px;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
      <button class="btn-sm" onclick="navEditShift(-1)" title="Previous Shift (‚Üê)">‚óÄ Prev</button>
      <h3 style="margin:0;">‚úèÔ∏è Shift #<span id="editShiftIdx"></span></h3>
      <button class="btn-sm" onclick="navEditShift(1)" title="Next Shift (‚Üí)">Next ‚ñ∂</button>
    </div>
    <div class="form-row">
      <div class="form-group"><label>Period</label><select id="editShiftPeriod"><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="OT">OT</option></select></div>
      <div class="form-group"><label>Strength</label><input type="text" id="editShiftStrength" readonly></div>
    </div>
    <div class="form-row">
      <div class="form-group"><label>Start Time</label><input type="text" id="editShiftStartTime"></div>
      <div class="form-group"><label>End Time</label><input type="text" id="editShiftEndTime"></div>
    </div>
    <div class="form-row">
      <div class="form-group"><label>Start Type</label><select id="editShiftStartType"></select></div>
      <div class="form-group"><label>Stop Type</label><select id="editShiftStopType"></select></div>
    </div>
    <div class="section-title" style="margin-top:8px;"><span>Players on Ice</span></div>
    <div id="editShiftPlayersContainer" style="background:var(--card);padding:8px;border-radius:4px;"></div>
    <!-- v20.6: Insert/Delete actions -->
    <div style="display:flex;gap:4px;margin-top:8px;padding-top:8px;border-top:1px solid var(--border);">
      <button class="btn-sm" onclick="insertShiftBefore()" title="Insert new shift before this one" style="flex:1;background:var(--accent2);">‚ûï Insert Before</button>
      <button class="btn-sm" onclick="insertShiftAfter()" title="Insert new shift after this one" style="flex:1;background:var(--accent2);">‚ûï Insert After</button>
      <button class="btn-sm" onclick="duplicateShift()" title="Duplicate this shift" style="flex:1;">üìã Duplicate</button>
    </div>
    <div class="modal-actions">
      <button class="btn-danger" onclick="deleteShift()">Delete</button>
      <button class="btn-primary" onclick="saveEditShift()">Save</button>
      <button onclick="closeEditShiftModal()">Cancel</button>
    </div>
  </div>
</div>

<!-- XY Edit Modal -->
<div class="overlay" id="xyEditModal">
  <div class="modal" style="min-width:400px;">
    <h3>üìç Edit XY Position</h3>
    <p style="font-size:9px;color:var(--muted);margin-bottom:8px;">Click on rink to set position</p>
    <svg id="xyEditSvg" viewBox="0 0 200 85" width="350" style="cursor:crosshair;background:var(--card);border-radius:4px;" onclick="handleXYEditClick(event)">
      <rect x="0" y="0" width="200" height="85" fill="#f8fafc" rx="14" ry="14" stroke="#1e293b" stroke-width="1"/>
      <line x1="75" y1="0" x2="75" y2="85" stroke="#1d4ed8" stroke-width="1.5"/>
      <line x1="125" y1="0" x2="125" y2="85" stroke="#1d4ed8" stroke-width="1.5"/>
      <line x1="100" y1="0" x2="100" y2="85" stroke="#dc2626" stroke-width="1" stroke-dasharray="3,2"/>
      <line x1="11" y1="0" x2="11" y2="85" stroke="#dc2626" stroke-width="0.8"/>
      <line x1="189" y1="0" x2="189" y2="85" stroke="#dc2626" stroke-width="0.8"/>
      <circle cx="100" cy="42.5" r="15" fill="none" stroke="#1d4ed8" stroke-width="0.8"/>
      <circle cx="31" cy="22" r="15" fill="none" stroke="#dc2626" stroke-width="0.5"/>
      <circle cx="31" cy="63" r="15" fill="none" stroke="#dc2626" stroke-width="0.5"/>
      <circle cx="169" cy="22" r="15" fill="none" stroke="#dc2626" stroke-width="0.5"/>
      <circle cx="169" cy="63" r="15" fill="none" stroke="#dc2626" stroke-width="0.5"/>
      <g id="xyEditMarker"></g>
    </svg>
    <div class="modal-actions">
      <button class="btn-primary" onclick="closeXYEditModal()">Done</button>
    </div>
  </div>
</div>

<!-- Generic Dynamic Modal (v23.4) -->
<div class="overlay" id="genericModal" onclick="if(event.target===this)closeModal()">
  <div class="modal" id="genericModalContent" style="min-width:400px;">
    <!-- Content will be inserted dynamically -->
  </div>
</div>

<!-- Event Confirmation Modal (v23.3) -->
<div class="overlay" id="confirmEventModal">
  <div class="modal" style="min-width:450px;max-width:550px;">
    <h3>‚úì Confirm Event</h3>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:12px;">
      <div class="form-group">
        <label>Type</label>
        <select id="confirmType" onchange="onConfirmTypeChange()"></select>
      </div>
      <div class="form-group">
        <label>Team</label>
        <select id="confirmTeam">
          <option value="home">Home</option>
          <option value="away">Away</option>
        </select>
      </div>
      <div class="form-group">
        <label>Detail 1</label>
        <select id="confirmD1" onchange="onConfirmD1Change()"></select>
      </div>
      <div class="form-group">
        <label>Detail 2</label>
        <select id="confirmD2"></select>
      </div>
      <div class="form-group">
        <label>Zone</label>
        <select id="confirmZone">
          <option value="">--</option>
          <option value="o">Offensive</option>
          <option value="d">Defensive</option>
          <option value="n">Neutral</option>
        </select>
      </div>
      <div class="form-group">
        <label>Success</label>
        <select id="confirmSuccess">
          <option value="">--</option>
          <option value="s">Successful</option>
          <option value="u">Unsuccessful</option>
        </select>
      </div>
      <div class="form-group">
        <label>Start Time</label>
        <input type="text" id="confirmStartTime" placeholder="MM:SS" oninput="autoFormatTime(this)">
      </div>
      <div class="form-group">
        <label>End Time</label>
        <input type="text" id="confirmEndTime" placeholder="MM:SS" oninput="autoFormatTime(this)">
      </div>
    </div>
    <div style="display:flex;gap:8px;margin-bottom:8px;">
      <div class="form-group" style="flex:1;">
        <label>Strength</label>
        <select id="confirmStrength">
          <option value="5v5">5v5</option>
          <option value="5v4">5v4</option>
          <option value="4v5">4v5</option>
          <option value="4v4">4v4</option>
          <option value="3v3">3v3</option>
          <option value="ENG">ENG</option>
        </select>
      </div>
      <div class="form-group" style="flex:1;">
        <label>Linked Event #</label>
        <input type="number" id="confirmLinked" placeholder="--" style="width:60px;">
      </div>
      <div class="form-group" style="flex:1;display:flex;align-items:center;padding-top:14px;">
        <label style="display:flex;align-items:center;gap:4px;font-size:9px;">
          <input type="checkbox" id="confirmHighlight" onchange="toggleConfirmHighlightFields()"> ‚≠ê Highlight
        </div>
        <!-- Video URL for highlights (v23.7) -->
        <div id="confirmHighlightVideoUrlRow" style="display:none;margin-top:4px;">
          <div class="form-group">
            <label style="font-size:8px;color:var(--muted);">YouTube URL for this highlight:</label>
            <input type="text" id="confirmVideoUrl" placeholder="https://youtube.com/watch?v=..." style="width:100%;font-size:9px;">
          </div>
        </div>
        </label>
      </div>
    </div>
    <div style="background:var(--panel);padding:6px 8px;border-radius:4px;margin-bottom:8px;">
      <label style="font-size:9px;color:var(--accent);font-weight:bold;margin-bottom:4px;display:block;">üë• Players & Play Details</label>
      <div style="font-size:8px;color:var(--muted);margin-bottom:6px;">Edit play details (PD1, PD2, Success, Pressure) for each player:</div>
      <div id="confirmPlayers" style="font-size:10px;max-height:250px;overflow-y:auto;"></div>
    </div>
    <div class="modal-actions" style="justify-content:space-between;">
      <button onclick="closeConfirmModal()">Cancel</button>
      <div style="display:flex;gap:8px;">
        <button onclick="confirmAndLogWithNext()" style="background:var(--success);color:#fff;" title="Log event and auto-create linked next event (Ctrl+L)">‚úì Log & Next</button>
        <button onclick="confirmAndLogAndAddLinked()" style="background:var(--accent);color:#fff;" title="Log event and create linked event after it">üîó Log & Add Linked</button>
        <button onclick="confirmAndContinue()" style="background:var(--accent);color:#000;">‚úì Log & Continue</button>
        <button onclick="confirmAndLog()" class="btn-primary">‚úì Log Event</button>
      </div>
    </div>
  </div>
</div>

<!-- All Shifts Modal -->
<div class="overlay" id="allShiftsModal">
  <div class="modal" style="min-width:600px;max-width:800px;">
    <h3>üìã All Shifts (<span id="allShiftsCount">0</span>)</h3>
    <div class="table-wrap" style="max-height:400px;overflow-y:auto;">
      <table style="width:100%;font-size:10px;border-collapse:collapse;">
        <thead style="position:sticky;top:0;background:var(--card);">
          <tr><th>#</th><th>Period</th><th>Start</th><th>End</th><th>Start Type</th><th>Stop Type</th><th>Strength</th></tr>
        </thead>
        <tbody id="allShiftsBody"></tbody>
      </table>
    </div>
    <div class="modal-actions">
      <button onclick="document.getElementById('allShiftsModal').classList.remove('show')">Close</button>
    </div>
  </div>
</div>

<!-- All Events Modal -->
<div class="overlay" id="allEventsModal">
  <div class="modal" style="min-width:700px;max-width:900px;">
    <h3>üìã All Events (<span id="allEventsCount">0</span>)</h3>
    <div class="table-wrap" style="max-height:400px;overflow-y:auto;">
      <table style="width:100%;font-size:10px;border-collapse:collapse;">
        <thead style="position:sticky;top:0;background:var(--card);">
          <tr><th>#</th><th>Period</th><th>Time</th><th>Team</th><th>Type</th><th>Detail</th><th>Players</th></tr>
        </thead>
        <tbody id="allEventsBody"></tbody>
      </table>
    </div>
    <div class="modal-actions">
      <button onclick="document.getElementById('allEventsModal').classList.remove('show')">Close</button>
    </div>
  </div>
</div>

<!-- Full Box Score Modal -->
<div class="overlay" id="boxScoreModal">
  <div class="modal" style="min-width:700px;max-width:900px;">
    <h3>üìä Full Box Score</h3>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-bottom:16px;">
      <div style="background:var(--card);padding:12px;border-radius:6px;text-align:center;">
        <div style="font-size:12px;color:var(--muted);" id="boxModalHome">HOME</div>
        <div style="font-size:32px;font-weight:bold;" id="boxModalHomeScore">0</div>
        <div style="font-size:10px;color:var(--muted);">SOG: <span id="boxModalHomeSOG">0</span> | FO: <span id="boxModalHomeFO">0</span></div>
      </div>
      <div style="background:var(--card);padding:12px;border-radius:6px;text-align:center;">
        <div style="font-size:12px;color:var(--muted);" id="boxModalAway">AWAY</div>
        <div style="font-size:32px;font-weight:bold;" id="boxModalAwayScore">0</div>
        <div style="font-size:10px;color:var(--muted);">SOG: <span id="boxModalAwaySOG">0</span> | FO: <span id="boxModalAwayFO">0</span></div>
      </div>
    </div>
    <div class="table-wrap" style="max-height:300px;overflow-y:auto;">
      <table style="width:100%;font-size:11px;border-collapse:collapse;">
        <thead style="position:sticky;top:0;background:var(--card);">
          <tr><th>#</th><th>Player</th><th>Pos</th><th>G</th><th>A</th><th>PTS</th><th>SOG</th><th>FO%</th><th>TOI</th><th>PIM</th></tr>
        </thead>
        <tbody id="boxModalBody"></tbody>
      </table>
    </div>
    <div class="modal-actions">
      <button onclick="document.getElementById('boxScoreModal').classList.remove('show')">Close</button>
    </div>
  </div>
</div>

<!-- Player Detail Modal -->
<div class="overlay" id="playerDetailModal">
  <div class="modal" style="min-width:400px;">
    <h3>üë§ <span id="playerDetailName">Player</span></h3>
    <div style="display:grid;grid-template-columns:repeat(4, 1fr);gap:8px;margin-bottom:16px;">
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:20px;font-weight:bold;" id="pdGoals">0</div>
        <div style="font-size:9px;color:var(--muted);">Goals</div>
      </div>
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:20px;font-weight:bold;" id="pdAssists">0</div>
        <div style="font-size:9px;color:var(--muted);">Assists</div>
      </div>
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:20px;font-weight:bold;" id="pdShots">0</div>
        <div style="font-size:9px;color:var(--muted);">SOG</div>
      </div>
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:20px;font-weight:bold;" id="pdFO">0%</div>
        <div style="font-size:9px;color:var(--muted);">FO%</div>
      </div>
    </div>
    <div style="display:grid;grid-template-columns:repeat(3, 1fr);gap:8px;margin-bottom:16px;">
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:16px;font-weight:bold;" id="pdTOI">--:--</div>
        <div style="font-size:9px;color:var(--muted);">TOI</div>
      </div>
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:16px;font-weight:bold;" id="pdHits">0</div>
        <div style="font-size:9px;color:var(--muted);">Hits</div>
      </div>
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:16px;font-weight:bold;" id="pdBlocks">0</div>
        <div style="font-size:9px;color:var(--muted);">Blocks</div>
      </div>
    </div>
    <div style="font-size:10px;color:var(--muted);margin-bottom:8px;">Recent Events:</div>
    <div id="pdRecentEvents" style="max-height:150px;overflow-y:auto;background:var(--card);border-radius:4px;padding:8px;font-size:9px;"></div>
    <div class="modal-actions">
      <button onclick="document.getElementById('playerDetailModal').classList.remove('show')">Close</button>
    </div>
  </div>
</div>

<!-- Toast -->
<div class="toast" id="toast"></div>

<script>
// ============================================================
// STATE
// ============================================================
const S = {
  sb: null, connected: false,
  saveDirectoryHandle: null, // v23.8: File System Access API directory handle
  defaultDirectoryHandle: null, // Default folder where game folders are created
  gameFolderHandle: null, // Current game's folder handle (created when game is loaded)
  maxBackups: null, // v26.0: Unlimited backups (null = no limit)
  teamValidationIssues: [], // Store team validation warnings for events
  gameId: null, games: [], rosters: { home: [], away: [] },
  homeTeam: 'Home', awayTeam: 'Away', homeColor: '#3b82f6', awayColor: '#ef4444',
  homeLogo: null, awayLogo: null,
  teams: {},  // v15.01: Team data from dim_team
  // Reference data from Supabase
  playDetails1: [],  // dim_play_detail
  playDetails2: [],  // dim_play_detail_2
  eventDetails1: [], // dim_event_detail (v16.06)
  eventDetails2: [], // dim_event_detail_2 (v16.06)
  eventTypesDB: [],  // dim_event_type (v22.1)
  showAllEventTypes: false, // v22.1: Toggle for showing all event types
  playerRoles: [],   // dim_player_role
  period: 1, evtTeam: 'home', 
  // v23.5: Per-period lengths (NORAD default varies)
  periodLengths: { 1: 18, 2: 18, 3: 18, OT: 5 },
  // v23.8: Penalty lengths (configurable)
  penaltyLengths: { minor: 3, major: 6, misconduct: 10 }, // v24.0: Updated defaults (minor 3min, major 6min)
  periodLength: 18, // Legacy - use getPeriodLength() instead
  homeAttacksRightP1: true, // v19: Configurable per game - which end home attacks in P1
  slots: { home: {F1:null,F2:null,F3:null,D1:null,D2:null,G:null,X:null}, away: {F1:null,F2:null,F3:null,D1:null,D2:null,G:null,X:null} },
  selectedSlot: null, events: [], shifts: [], evtIdx: 0, shiftIdx: 0,
  curr: { type: null, players: [], puckXY: [], netXY: null },
  selectedPlayer: null, xyMode: 'puck', xySlot: 1, highlightedXYSeq: null, highlightedXYType: null, highlightedXYPlayerNum: null,
  editingEvtIdx: null, editingShiftIdx: null, lastEndTime: '18:00',
  editingXYType: null, editingXYIdx: null, editingXYPlayerIdx: null, // For XY editing in modal
  selectedGoalIdx: null, // v23.6: Selected goal index for goals_context filter
  highlightVideos: [], // v23.7: Array of highlight video objects { eventIndex, videoUrl, title, description }
  xyHistory: [], // For undo
  copiedXYData: null, // v23.8: Copied XY data for paste
  selectedEventTypeContext: null, // v23.8: Selected event type for context filter
  selectedEventIdxContext: null, // v23.8: Selected event index for context filter
  issueTypeFilter: null, // v23.8: Selected issue type filter
  lastSave: null, saveTimer: null,
  // v26.0: Work timer - tracks active work time with auto-pause
  workTimer: { startTime: null, pausedTime: 0, isPaused: true, lastActivity: null, pauseTimeout: null, pausedAt: null, updateInterval: null },
  linkedEventIdx: null, // For linked plays (e.g., Shot->Save sequences)
  assistToGoalIdx: null, // v23.8: For Pass events that assist a Goal (separate from linked events)
  // v23.9: Event chain templates for auto-suggesting next events
  eventChainTemplates: [], // Array of {id, name, trigger: {type, detail1, detail2, playDetail1, playDetail2}, suggested: {type, detail1, detail2}, playerMapping: {event_player_X: 'suggested_player_Y'}, copyXY: true, copyZone: true, nextEventPlayerMapping: {event_player_X: 'event_player_Y'}, nextEventTeam: 'same'|'opposite'|'home'|'away'}
  pendingEventSuggestion: null, // Currently pending suggestion {template, sourceEvt}
  // v23.9: Custom rules for user-defined logic
  customRules: [], // Array of {id, name, enabled, trigger: {type, detail1, detail2}, actions: [{field: 'zone'|'success'|'detail1'|'detail2', value: 'o'|'d'|'n'|'s'|'u'|string, condition: 'always'|'ifNextIs'|'ifPrevIs'}], crossEventRules: [{ifNextType: 'Turnover', ifNextDetail1: 'Giveaway', setPrevSuccess: 'u'}]}
  // v23.9: XY Edit Mode and Event Click Mode
  xyEditMode: 'modal', // 'modal' | 'sidePanel' | 'direct'
  eventClickMode: 'modal', // 'modal' | 'sidePanel' | 'xyDrawing'
  editingEventInSidePanel: false, // True when event is loaded into side panel for editing
  rinkZoom: 1.0, // Zoom level for rink (1.0 = normal, 2.0 = 2x zoom, etc.)
  rinkPanX: 0, // Pan offset X
  rinkPanY: 0, // Pan offset Y
  rinkZoomLocked: false, // Lock zoom and pan to prevent changes
  // Video timing - variable intermissions and stoppages
  videoTiming: {
    videoStartOffset: 0,        // Seconds to skip at video start (pre-game, warmups)
    periodOffsets: {            // Period start offsets in seconds (can be overridden)
      1: null,                  // null = auto-calculate, number = explicit offset in seconds
      2: null,
      3: null,
      OT: null
    },
    gameStart: {                // For partial recordings - when video recording actually starts
      period: 1,                // Which period the video starts at
      time: '18:00'             // Game clock time when video starts (MM:SS format)
    },
    intermission1: 900,         // Seconds after P1 (default 15 min)
    intermission2: 900,         // Seconds after P2 (default 15 min)
    intermission3: 300,         // Seconds after P3 if OT (default 5 min)
    timeouts: [],               // Array of {period, gameTime, duration} objects
    youtubeUrl: ''              // Optional YouTube link for this game (legacy)
  },
  // v23.6: Video management - multiple videos per game
  videos: [],                   // Array of {id, url, type, video_id, title, description, start_time, end_time, period, notes}
  // v15.01: Video player state
  videoPlayer: {
    sources: [],                // Array of {id, name, type:'youtube'|'file', url, hotkey}
    currentSourceIdx: 0,
    isPlaying: false,
    currentTime: 0,
    speed: 1,
    autoSync: true,             // Auto-populate start/end times from video
    ytPlayer: null,             // YouTube IFrame API player instance
    gameMarkers: {              // Video timestamps for game events (in seconds)
      P1Start: null, P1End: null,
      P2Start: null, P2End: null,
      P3Start: null, P3End: null,
      OTStart: null, OTEnd: null,
      stoppages: []             // Array of {startTime, endTime, type, note}
    }
  }
};

// ============================================================
// v23.5: PERIOD LENGTH HELPERS
// ============================================================

/**
 * Get the length of a specific period in minutes
 * @param {number|string} period - Period number (1, 2, 3) or 'OT'
 * @returns {number} Period length in minutes
 */
function getPeriodLength(period) {
  const p = String(period).toUpperCase();
  if (p === 'OT' || p === '4') {
    return S.periodLengths?.OT || 5;
  }
  const num = parseInt(period) || 1;
  return S.periodLengths?.[num] || S.periodLength || 18;
}

/**
 * Get the length of a specific period in seconds
 */
function getPeriodLengthSeconds(period) {
  return getPeriodLength(period) * 60;
}

/**
 * Update periodLengths from UI inputs
 */
function updatePeriodLengthsFromUI() {
  S.periodLengths = {
    1: parseInt(document.getElementById('periodLength1')?.value) || 18,
    2: parseInt(document.getElementById('periodLength2')?.value) || 18,
    3: parseInt(document.getElementById('periodLength3')?.value) || 18,
    OT: parseInt(document.getElementById('periodLengthOT')?.value) || 5
  };
  // Keep legacy field in sync with P1 for compatibility
  S.periodLength = S.periodLengths[1];
  document.getElementById('periodLength').value = S.periodLength;
  
  // Update the period length indicator for current period
  updatePeriodLengthIndicator();
  
  // Update clock if it shows full period time
  const clock = document.getElementById('clock')?.value;
  if (clock) {
    const oldLen = parseInt(clock.split(':')[0]);
    if (oldLen >= 15 && oldLen <= 25) {
      // Looks like start of period - update to new length
      const currentLen = getPeriodLength(S.period);
      document.getElementById('clock').value = `${currentLen}:00`;
    }
  }
  
  toast('Period lengths updated', 'info');
}

/**
 * v23.8: Update penalty lengths from UI inputs
 */
function updatePenaltyLengthsFromUI() {
  S.penaltyLengths = {
    minor: parseInt(document.getElementById('penaltyLengthMinor')?.value) || 3, // v24.0: Default 3 min
    major: parseInt(document.getElementById('penaltyLengthMajor')?.value) || 6, // v24.0: Default 6 min
    misconduct: parseInt(document.getElementById('penaltyLengthMisconduct')?.value) || 10
  };
}

/**
 * Update the period length indicator in header
 */
function updatePeriodLengthIndicator() {
  const indicator = document.getElementById('periodLengthIndicator');
  if (indicator) {
    const currentLen = getPeriodLength(S.period);
    const lengths = S.periodLengths || { 1: 18, 2: 18, 3: 18, OT: 5 };
    
    // Show all period lengths if they differ
    const allSame = lengths[1] === lengths[2] && lengths[2] === lengths[3];
    if (allSame) {
      indicator.textContent = `(${currentLen}m)`;
      indicator.title = `All periods: ${lengths[1]}m, OT: ${lengths.OT}m`;
    } else {
      indicator.textContent = `(P${S.period}: ${currentLen}m)`;
      indicator.title = `P1: ${lengths[1]}m, P2: ${lengths[2]}m, P3: ${lengths[3]}m, OT: ${lengths.OT}m`;
    }
  }
}

/**
 * Update UI inputs from periodLengths
 */
function updatePeriodLengthsUI() {
  if (S.periodLengths) {
    document.getElementById('periodLength1').value = S.periodLengths[1] || 18;
    document.getElementById('periodLength2').value = S.periodLengths[2] || 18;
    document.getElementById('periodLength3').value = S.periodLengths[3] || 18;
    document.getElementById('periodLengthOT').value = S.periodLengths.OT || 5;
  }
  
  // v23.8: Load penalty lengths
  if (S.penaltyLengths) {
    document.getElementById('penaltyLengthMinor').value = S.penaltyLengths.minor || 3; // v24.0: Default 3 min
    document.getElementById('penaltyLengthMajor').value = S.penaltyLengths.major || 6; // v24.0: Default 6 min
    document.getElementById('penaltyLengthMisconduct').value = S.penaltyLengths.misconduct || 10;
  } else {
    // Initialize with defaults if not set
    S.penaltyLengths = { minor: 3, major: 6, misconduct: 10 }; // v24.0: Updated defaults
    document.getElementById('penaltyLengthMinor').value = 3;
    document.getElementById('penaltyLengthMajor').value = 6;
    document.getElementById('penaltyLengthMisconduct').value = 10;
  }
  updatePeriodLengthIndicator();
}

/**
 * Get total elapsed time at start of a period (for video sync)
 * Accounts for variable period lengths and intermissions
 */
function getElapsedAtPeriodStart(period) {
  const p = parseInt(period) || 1;
  let elapsed = 0;
  
  for (let i = 1; i < p; i++) {
    elapsed += getPeriodLengthSeconds(i);
    // Add intermission after each period
    if (i === 1) elapsed += (S.videoTiming?.intermission1 || 900);
    if (i === 2) elapsed += (S.videoTiming?.intermission2 || 900);
    if (i === 3) elapsed += (S.videoTiming?.intermission3 || 300);
  }
  
  return elapsed;
}

// ============================================================
// DROPDOWN OPTIONS
// ============================================================
const LISTS = {
  eventTypes: ['Faceoff','Shot','Pass','Goal','Turnover','Zone_Entry_Exit','Penalty','Stoppage','Possession','Save','Rebound','DeadIce','Play','Intermission','Clockstop','Timeout'],
  hotkeys: { Faceoff:'F', Shot:'S', Pass:'P', Goal:'G', Turnover:'T', Zone_Entry_Exit:'Z', Penalty:'N', Stoppage:'X', Possession:'O', Save:'V', Rebound:'R', DeadIce:'D', Play:'Y', Intermission:'I', Clockstop:'C' },
  details: {
    Shot: { d1: ['Shot_OnNetSaved','Shot_Missed','Shot_Blocked','Shot_BlockedSameTeam','Shot_Deflected','Shot_OnNetGoal'], d2: ['Shot-Wrist','Shot-Slap','Shot-Backhand','Shot-Snap','Shot-WrapAround','Shot-Bat','Shot-Poke','Shot-OneTime','Shot-Tip','Shot-Deflection','Shot-Other'] },
    Pass: { d1: ['Pass_Completed','Pass_Missed','Pass_Deflected','Pass_Intercepted'], d2: ['Pass-Stretch','Pass-Rim/Wrap','Pass-Backhand','Pass-Forehand','Pass-Bank','Pass-Dump','Pass-Drop','Pass-OneTouch','Pass-Other'] },
    Goal: { d1: ['Goal_Scored','Goal_Shootout','Goal_PenaltyShot'], d2: ['Goal-Wrist','Goal-Slap','Goal-Backhand','Goal-Tip','Goal-Snap','Goal-WrapAround','Goal-Deflection','Goal-OneTime','Goal-Other'] },
    Faceoff: { d1: ['Faceoff_PeriodStart','Faceoff_GameStart','Faceoff_AfterGoal','Faceoff_AfterPenalty','Faceoff_AfterStoppage'], d2: [] },
    Turnover: { d1: ['Turnover_Giveaway','Turnover_Takeaway'], d2_Giveaway: ['Giveaway-Misplayed','Giveaway-BattleLost','Giveaway-PassIntercepted','Giveaway-Other'], d2_Takeaway: ['Takeaway-BattleWon','Takeaway-PokeCheck','Takeaway-PassIntercepted','Takeaway-Other'] },
    Zone_Entry_Exit: { d1: ['Zone_Entry','Zone_Exit','Zone_Keepin','Zone_EntryFailed','Zone_ExitFailed'], d2_Entry: ['ZoneEntry-Rush','ZoneEntry-Pass','ZoneEntry-DumpIn','ZoneEntry-Chip'], d2_Exit: ['ZoneExit-Rush','ZoneExit-Pass','ZoneExit-Clear','ZoneExit-Chip'] },
    Save: { d1: ['Save_Rebound','Save_Freeze','Save_Played'], d2: ['Save-Glove','Save-Blocker','Save-Pad','Save-Stick','Save-Butterfly','Save-Other'] },
    Stoppage: { d1: ['Stoppage_PeriodEnd','Stoppage_Play','Stoppage_Other','Stoppage_GameEnd'], d2_Play: ['Stoppage-Icing','Stoppage-Offsides','Stoppage-GoalieStoppage','Stoppage-PuckOut','Stoppage-Penalty','Stoppage-Goal'] },
    Penalty: { d1: ['Penalty_Minor','Penalty_Major','Penalty_Misconduct'], d2: ['Penalty-Tripping','Penalty-Hooking','Penalty-Slashing','Penalty-Interference','Penalty-Holding','Penalty-Roughing','Penalty-HighSticking','Penalty-CrossChecking','Penalty-Boarding','Penalty-Other'] },
    Possession: { d1: ['Breakaway','PuckRetrieval','PuckRecovery','Regroup','LoosePuck'], d2: [] },
    Rebound: { d1: ['Rebound_TeamRecovered','Rebound_OppRecovered','Rebound_ShotGenerated'], d2: [] },
    DeadIce: { d1: ['DeadIce_Icing','DeadIce_Offside','DeadIce_PuckOut','DeadIce_NetOff','DeadIce_Other'], d2: [] },
    Play: { d1: ['Play_Offensive','Play_Defensive'], d2_Offensive: ['Play-DriveMiddle','Play-DriveWide','Play-CrashNet','Play-Deke','Play-DumpChase','Play-Forecheck'], d2_Defensive: ['Play-PokeCheck','Play-Backcheck','Play-Contain','Play-BoxOut'] },
    Intermission: { d1: ['Intermission_Period1','Intermission_Period2','Intermission_Period3','Intermission_OT'], d2: [] },
    Clockstop: { d1: ['Clockstop_Injury','Clockstop_Equipment','Clockstop_IceRepair','Clockstop_Other'], d2: [] },
    Timeout: { d1: ['Timeout_Home','Timeout_Away'], d2: [] }
  },
  shiftStart: ['GameStart','PeriodStart','FaceoffAfterGoal','FaceoffAfterPenalty','OtherFaceoff','Stoppage','Intermission','OnTheFly'],
  shiftStop: ['','OnTheFly','PeriodEnd','Period End','GoalScored','Home Goal','Away Goal','Penalty','Stoppage','OtherFaceoff','Intermission','GameEnd','High Stick','Away Icing','Home Icing','Away Offside','Home Offside','Puck Out of Play','Away Goalie Stopped (after Home SOG)','Home Goalie Stopped (after Away SOG)'],
  playOffensive: ['Play-DriveMiddle','Play-DriveWide','Play-CrashNet','Play-Delay','Play-Deke','Play-DumpChase','Play-Forecheck','Play-Other'],
  playDefensive: ['Play-PokeCheck','Play-Backcheck','Play-Contain','Play-BoxOut','Play-Other'],
  // Events where puck XY = event_player_1 XY
  possessionEvents: ['Possession','Zone_Entry_Exit'],
  possessionDetails: ['ZoneEntry-Rush','ZoneExit-Rush','Breakaway','PuckRetrieval','PuckRecovery','Regroup'],
  // Suggested next events based on current event
  nextEventSuggestions: {
    'Faceoff': ['Pass', 'Possession', 'Turnover'],
    'Pass': ['Shot', 'Pass', 'Turnover', 'Zone_Entry_Exit'],
    'Shot': ['Save', 'Goal', 'Rebound'],
    'Save': ['Rebound', 'Pass', 'Stoppage'],
    'Goal': ['Faceoff', 'Stoppage'],
    'Rebound': ['Shot', 'Possession', 'Turnover'],
    'Zone_Entry_Exit': ['Pass', 'Shot', 'Possession'],
    'Turnover': ['Pass', 'Shot', 'Zone_Entry_Exit'],
    'Possession': ['Pass', 'Shot', 'Zone_Entry_Exit'],
    'Penalty': ['Faceoff', 'Stoppage'],
    'Stoppage': ['Faceoff', 'Intermission']
  },
  // Events that can be linked (sequence)
  linkedEvents: {
    'Shot': ['Pass', 'Rebound'], // Shot can link to preceding Pass or following Rebound
    'Goal': ['Shot', 'Pass'], // Goal links to Shot (the goal shot) or Pass (assist)
    'Save': ['Shot'], // Save links to Shot
    'Rebound': ['Shot', 'Save'] // Rebound links to Shot or Save
  },
  // v23.9: Video dim table options (hard-coded from dim_video_type and dim_highlight_category)
  // dim_video_type values
  videoTypes: ['Full_Ice', 'Broadcast', 'Highlights', 'Goalie', 'Overhead', 'Wide', 'Tight', 'Replay', 'Other'],
  // dim_highlight_category values (for highlight categorization)
  highlightCategories: ['Goal', 'Save', 'Hit', 'Fight', 'Breakaway', 'Penalty_Shot', 'Sequence', 'Momentum', 'Skill', 'Other'],
  // Video source/platform options
  videoSources: ['YouTube', 'Vimeo', 'Local', 'Stream', 'Other']
};

// ============================================================
// INIT
// ============================================================
async function init() {
  try {
    console.log('BenchSight v26.0 initializing...');
    
    // v26.0: Update game links on initialization
    updateGameLinks();
    
    // v23.8: Initialize version selector
    initVersionSelector();
    loadSettings();
    loadAutoSettings(); // v23.8: Load auto-detection settings
    loadCustomRules(); // v23.9: Load custom rules
    loadCustomLinkingRules(); // v23.8: Load custom linking rules
    initCollapsibleSections(); // v23.9: Initialize collapsible sections
    setupRinkEventListeners(); // v23.4: Attach rink mouse handlers
    loadVideoSources(); // v23.4: Load saved video sources

    // Initialize connection status
    if (S.connected === undefined) S.connected = false;

    await tryConnect();
    buildUI();
    
    // Update connection status UI after buildUI creates the element
    updateConn(S.connected);
    
    restorePanelWidths(); // v23.8: Restore saved panel widths
    adjustLayoutForScreenSize(); // v23.8: Adjust for screen size
    initSaveFolderUI();  // Initialize save folder UI (after buildUI)
    loadFromStorage();
    setupKeys();
    setupTimeInputs(); // v5: Auto-format time inputs
    
    // v23.8: Load saved directory handle (non-blocking, don't fail if it errors)
    loadDirectoryHandles().catch(e => {
      console.error('Failed to load directory handle:', e);
      // Don't break initialization if this fails
    });
    
    startAutoSave();
    setupActivityTracking(); // v26.0: Setup activity tracking for work timer
    
    // v26.0: Ensure log event button works - attach event listener as backup
    setupLogEventButton();
    
    await loadGames();
    if (S.gameId) {
      await selectGame(S.gameId);
      await ensureGameFolder(); // Create game folder if default folder is set
    }
    updateSaveIndicator();
    updateDefaultFolderDisplay(); // Update default folder display
    updateNextPlaySuggestions();
    updateZoneLabels();
    
    console.log('Ready:', S.events.length, 'events,', S.shifts.length, 'shifts');
    
    // v26.0: Update game links on initialization (after game might be loaded)
    setTimeout(() => {
      updateGameLinks();
    }, 100);
  } catch (e) {
    console.error('Fatal error during initialization:', e);
    alert('Error initializing tracker. Check console for details. Error: ' + e.message);
  }
}

/**
 * v23.4: Attach event listeners to rink SVG
 * v23.6: Added zoom and pan functionality
 */
function setupRinkEventListeners() {
  const svg = document.getElementById('rinkSvg');
  if (!svg) return;
  
  svg.addEventListener('mousedown', handleRinkMouseDown);
  svg.addEventListener('mousemove', (e) => {
    handleRinkMouseMove(e);
    handleRinkHover(e);
  });
  svg.addEventListener('mouseup', handleRinkMouseUp);
  svg.addEventListener('mouseleave', () => {
    hideXYTooltip();
    hideDragPreview();
  });
  
  // v23.6: Add zoom with mouse wheel (scroll at pointer position)
  svg.addEventListener('wheel', (e) => {
    if (S.rinkZoomLocked) {
      e.preventDefault();
      return; // Don't allow zoom when locked
    }
    e.preventDefault();
    const delta = e.deltaY > 0 ? -0.1 : 0.1;
    rinkZoomAtPoint(e.clientX, e.clientY, delta);
  }, { passive: false });
  
  // Initialize zoom state
  if (S.rinkZoom === undefined) S.rinkZoom = 1.0;
  if (S.rinkPanX === undefined) S.rinkPanX = 0;
  if (S.rinkPanY === undefined) S.rinkPanY = 0;
  if (S.rinkZoomLocked === undefined) S.rinkZoomLocked = false;
  updateRinkViewBox();
  updateRinkZoomLockUI(); // Initialize lock button state
}

/**
 * Update rink SVG viewBox based on zoom and pan
 */
function updateRinkViewBox() {
  const svg = document.getElementById('rinkSvg');
  if (!svg) return;
  
  const baseWidth = 200;
  const baseHeight = 85;
  const zoom = S.rinkZoom || 1.0;
  const panX = S.rinkPanX || 0;
  const panY = S.rinkPanY || 0;
  
  // Calculate viewBox: zoom reduces visible area, pan shifts the view
  // At zoom 1.0: viewBox = "0 0 200 85" (full rink)
  // At zoom 2.0: viewBox = "50 21.25 100 42.5" (half size, centered)
  const viewWidth = baseWidth / zoom;
  const viewHeight = baseHeight / zoom;
  
  // Start centered, then apply pan offset
  const centerX = baseWidth / 2;
  const centerY = baseHeight / 2;
  const viewX = centerX - (viewWidth / 2) + panX;
  const viewY = centerY - (viewHeight / 2) + panY;
  
  svg.setAttribute('viewBox', `${viewX} ${viewY} ${viewWidth} ${viewHeight}`);
  
  // Update zoom level display
  const zoomLevelEl = document.getElementById('rinkZoomLevel');
  if (zoomLevelEl) {
    zoomLevelEl.textContent = Math.round(zoom * 100) + '%';
  }
}

/**
 * Zoom in on rink
 */
function rinkZoomIn() {
  if (S.rinkZoomLocked) {
    toast('Zoom is locked. Unlock to change zoom.', 'warning');
    return;
  }
  S.rinkZoom = Math.min((S.rinkZoom || 1.0) * 1.5, 5.0); // Max 5x zoom
  updateRinkViewBox();
  toast(`Zoom: ${Math.round(S.rinkZoom * 100)}%`, 'info');
}

/**
 * Zoom out on rink
 */
function rinkZoomOut() {
  if (S.rinkZoomLocked) {
    toast('Zoom is locked. Unlock to change zoom.', 'warning');
    return;
  }
  S.rinkZoom = Math.max((S.rinkZoom || 1.0) / 1.5, 0.5); // Min 0.5x zoom
  updateRinkViewBox();
  toast(`Zoom: ${Math.round(S.rinkZoom * 100)}%`, 'info');
}

/**
 * Reset zoom and pan
 */
function rinkZoomReset() {
  if (S.rinkZoomLocked) {
    toast('Zoom is locked. Unlock to reset zoom.', 'warning');
    return;
  }
  S.rinkZoom = 1.0;
  S.rinkPanX = 0;
  S.rinkPanY = 0;
  updateRinkViewBox();
  toast('Zoom reset', 'info');
}

/**
 * Toggle zoom lock
 */
function toggleRinkZoomLock() {
  S.rinkZoomLocked = !S.rinkZoomLocked;
  updateRinkZoomLockUI();
  toast(S.rinkZoomLocked ? 'Zoom locked' : 'Zoom unlocked', 'info');
}

/**
 * Update zoom lock UI state
 */
function updateRinkZoomLockUI() {
  const lockBtn = document.getElementById('rinkZoomLockBtn');
  if (lockBtn) {
    lockBtn.textContent = S.rinkZoomLocked ? 'üîì' : 'üîí';
    lockBtn.title = S.rinkZoomLocked ? 'Unlock zoom and pan' : 'Lock zoom and pan';
    lockBtn.style.background = S.rinkZoomLocked ? 'var(--warn)' : 'var(--input)';
  }
  
  // Update button states
  const zoomInBtn = document.getElementById('rinkZoomInBtn');
  const zoomOutBtn = document.getElementById('rinkZoomOutBtn');
  const resetBtn = document.getElementById('rinkZoomResetBtn');
  
  if (zoomInBtn) zoomInBtn.disabled = S.rinkZoomLocked;
  if (zoomOutBtn) zoomOutBtn.disabled = S.rinkZoomLocked;
  if (resetBtn) resetBtn.disabled = S.rinkZoomLocked;
}

/**
 * Zoom at a specific point (for mouse wheel zoom)
 * Keeps the point under the cursor in the same screen position
 */
function rinkZoomAtPoint(clientX, clientY, delta) {
  if (S.rinkZoomLocked) return; // Don't allow zoom when locked
  
  const svg = document.getElementById('rinkSvg');
  if (!svg) return;
  
  const oldZoom = S.rinkZoom || 1.0;
  const newZoom = Math.max(0.5, Math.min(5.0, oldZoom + delta));
  
  if (oldZoom === newZoom) return;
  
  // Get the point in SVG coordinates (in the current viewBox coordinate system)
  const pt = svg.createSVGPoint();
  pt.x = clientX;
  pt.y = clientY;
  const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
  
  // This is the point in the actual SVG coordinate system (0-200, 0-85)
  const targetX = svgPt.x;
  const targetY = svgPt.y;
  
  // Update zoom
  S.rinkZoom = newZoom;
  
  // Calculate new pan to keep targetX, targetY under the cursor
  // The viewBox center should be positioned so that targetX, targetY maps to the same screen position
  const baseWidth = 200;
  const baseHeight = 85;
  const viewWidth = baseWidth / newZoom;
  const viewHeight = baseHeight / newZoom;
  
  // Calculate what the viewBox center should be to keep targetX, targetY at the same screen position
  const rect = svg.getBoundingClientRect();
  const screenX = clientX - rect.left;
  const screenY = clientY - rect.top;
  const screenRatioX = screenX / rect.width;
  const screenRatioY = screenY / rect.height;
  
  // The target point should be at screenRatioX * viewWidth from viewX, screenRatioY * viewHeight from viewY
  const newViewX = targetX - (screenRatioX * viewWidth);
  const newViewY = targetY - (screenRatioY * viewHeight);
  
  // Convert viewBox position to pan offset
  const centerX = baseWidth / 2;
  const centerY = baseHeight / 2;
  S.rinkPanX = newViewX - (centerX - viewWidth / 2);
  S.rinkPanY = newViewY - (centerY - viewHeight / 2);
  
  updateRinkViewBox();
}

function loadSettings() {
  try {
    const s = JSON.parse(localStorage.getItem('bs_settings') || '{}');
    if (s.sbUrl) document.getElementById('sbUrl').value = s.sbUrl;
    if (s.sbKey) document.getElementById('sbKey').value = s.sbKey;
    const settingsEl = document.getElementById('autoSaveInt');
    const headerEl = document.getElementById('autoSaveIntHeader');
    if (s.autoSaveInt) {
      if (settingsEl) settingsEl.value = s.autoSaveInt;
      if (headerEl) headerEl.value = s.autoSaveInt;
    } else {
      // Default to 300 seconds if no setting saved
      const defaultValue = '300';
      if (settingsEl) settingsEl.value = defaultValue;
      if (headerEl) headerEl.value = defaultValue;
    }
    if (s.pressureDist) document.getElementById('pressureDist').value = s.pressureDist;
    if (s.xyHistCnt) document.getElementById('xyHistCnt').value = s.xyHistCnt;
    if (s.periodLength) {
      document.getElementById('periodLength').value = s.periodLength;
      S.periodLength = parseInt(s.periodLength);
    }
    if (s.otLength) document.getElementById('otLength').value = s.otLength;
    
    // v23.9: Load custom rules
    loadCustomRules();
    
    // v23.9: Load event click mode and XY edit mode
    S.eventClickMode = localStorage.getItem('bs_eventClickMode') || 'modal';
    S.xyEditMode = localStorage.getItem('bs_xyEditMode') || 'modal';
    S.xyCarryOverEnabled = localStorage.getItem('bs_xyCarryOverEnabled') !== 'false'; // Default to true
    if (document.getElementById('eventClickMode')) document.getElementById('eventClickMode').value = S.eventClickMode;
    if (document.getElementById('xyEditMode')) document.getElementById('xyEditMode').value = S.xyEditMode;
    if (document.getElementById('xyCarryOverEnabled')) document.getElementById('xyCarryOverEnabled').checked = S.xyCarryOverEnabled;
    
    // v23.8: Load penalty lengths
    S.penaltyLengths = S.penaltyLengths || { minor: 3, major: 6, misconduct: 10 }; // v24.0: Updated defaults
    if (s.penaltyLengthMinor !== undefined) {
      S.penaltyLengths.minor = parseInt(s.penaltyLengthMinor) || 3; // v24.0: Default 3 min
      const minorEl = document.getElementById('penaltyLengthMinor');
      if (minorEl) minorEl.value = S.penaltyLengths.minor;
    }
    if (s.penaltyLengthMajor !== undefined) {
      S.penaltyLengths.major = parseInt(s.penaltyLengthMajor) || 6; // v24.0: Default 6 min
      const majorEl = document.getElementById('penaltyLengthMajor');
      if (majorEl) majorEl.value = S.penaltyLengths.major;
    }
    if (s.penaltyLengthMisconduct !== undefined) {
      S.penaltyLengths.misconduct = parseInt(s.penaltyLengthMisconduct) || 10;
      const misconductEl = document.getElementById('penaltyLengthMisconduct');
      if (misconductEl) misconductEl.value = S.penaltyLengths.misconduct;
    }
  } catch(e) {}
}

function saveSettings() {
  const s = {
    sbUrl: document.getElementById('sbUrl').value,
    sbKey: document.getElementById('sbKey').value,
    autoSaveInt: document.getElementById('autoSaveIntHeader')?.value || document.getElementById('autoSaveInt')?.value || '300',
    pressureDist: document.getElementById('pressureDist').value,
    xyHistCnt: document.getElementById('xyHistCnt').value,
    periodLength: document.getElementById('periodLength').value,
    otLength: document.getElementById('otLength').value,
    // v23.8: Save penalty lengths
    penaltyLengthMinor: document.getElementById('penaltyLengthMinor').value,
    penaltyLengthMajor: document.getElementById('penaltyLengthMajor').value,
    penaltyLengthMisconduct: document.getElementById('penaltyLengthMisconduct').value
  };
  localStorage.setItem('bs_settings', JSON.stringify(s));
  
  // v23.8: Save JSON export preference
  const exportJsonOnSaveEl = document.getElementById('exportJsonOnSave');
  if (exportJsonOnSaveEl) {
    localStorage.setItem('bs_exportJsonOnSave', exportJsonOnSaveEl.checked ? 'true' : 'false');
  }
  S.periodLength = parseInt(s.periodLength) || 18;
  
  // v23.8: Update penalty lengths
  S.penaltyLengths = {
    minor: parseInt(s.penaltyLengthMinor) || 2,
    major: parseInt(s.penaltyLengthMajor) || 5,
    misconduct: parseInt(s.penaltyLengthMisconduct) || 10
  };
  
  // Update clock to match period length
  if (S.period !== 'OT') {
    document.getElementById('clock').value = S.periodLength + ':00';
  }
  
  closeSettings();
  toast('Settings saved', 'success');
  tryConnect();
  startAutoSave();
}

async function tryConnect() {
  // v23.8: Ensure connected is initialized
  if (S.connected === undefined) S.connected = false;
  
  const sbUrlEl = document.getElementById('sbUrl');
  const sbKeyEl = document.getElementById('sbKey');
  if (!sbUrlEl || !sbKeyEl) {
    updateConn(false);
    return;
  }
  
  const url = sbUrlEl.value?.trim();
  const key = sbKeyEl.value?.trim();
  if (!url || !key) { 
    updateConn(false); 
    return; 
  }
  try {
    if (typeof supabase === 'undefined') {
      console.error('Supabase library not loaded');
      updateConn(false);
      return;
    }
    S.sb = supabase.createClient(url, key);
    // Try to query a table that exists
    const { data, error } = await S.sb.from('dim_schedule').select('game_id').limit(1);
    if (error) {
      console.error('Supabase query error:', error);
      // Provide helpful error messages
      if (error.message?.includes('permission denied') || error.code === '42501') {
        toast('RLS is blocking queries. Disable RLS in Supabase SQL Editor.', 'error');
      } else if (error.message?.includes('does not exist') || error.code === '42P01') {
        toast('Tables not found. Run upload.py --schema then upload.py', 'error');
      } else {
        toast('Connection error: ' + (error.message || error.code), 'error');
      }
      throw error;
    }
    S.connected = true;
    updateConn(true);
    
    // Load reference data (play details, player roles)
    await loadReferenceData();
  } catch(e) { 
    console.error('Connection failed:', e);
    S.sb = null; 
    S.connected = false; 
    updateConn(false); 
  }
}

/**
 * Load reference data from Supabase (dim tables)
 */
async function loadReferenceData() {
  if (!S.connected) return;
  
  try {
    // Load dim_play_detail
    // Load dim_play_detail - use play_detail_code column
    const { data: pd1, error: e1 } = await S.sb.from('dim_play_detail')
      .select('play_detail_id,play_detail_code,play_detail_name,play_category')
      .order('play_detail_code');
    
    if (!e1 && pd1) {
      S.playDetails1 = pd1.map(p => ({
        id: p.play_detail_id,
        code: p.play_detail_code || '',
        name: p.play_detail_name,
        category: p.play_category
      }));
      console.log('Loaded', S.playDetails1.length, 'play details 1 from dim_play_detail (using play_detail_code)');
    }
    
    // Load dim_play_detail_2 - use play_detail_code column (not play_detail_2_code)
    const { data: pd2, error: e2 } = await S.sb.from('dim_play_detail_2')
      .select('play_detail_2_id,play_detail_code,play_detail_2_name,play_category')
      .order('play_detail_code');
    
    if (!e2 && pd2) {
      S.playDetails2 = pd2.map(p => ({
        id: p.play_detail_2_id,
        code: p.play_detail_code || '',
        name: p.play_detail_2_name,
        category: p.play_category
      }));
      console.log('Loaded', S.playDetails2.length, 'play details 2 from dim_play_detail_2 (using play_detail_code)');
    }
    
    // v16.06: Load dim_event_detail for event detail 1 dropdown
    const { data: ed1, error: e2a } = await S.sb.from('dim_event_detail')
      .select('event_detail_id,event_detail_code,event_detail_name,event_type')
      .order('event_type,event_detail_name');
    
    if (!e2a && ed1) {
      S.eventDetails1 = ed1.map(e => ({
        id: e.event_detail_id,
        code: e.event_detail_code || '',
        name: e.event_detail_name,
        eventType: e.event_type
      }));
      console.log('Loaded', S.eventDetails1.length, 'event details 1');
    }
    
    // v16.08: Load dim_event_detail_2 for event detail 2 dropdown
    // Note: category is "other" for most entries, so we filter by code prefix
    const { data: ed2, error: e2b } = await S.sb.from('dim_event_detail_2')
      .select('event_detail_2_id,event_detail_2_code,event_detail_2_name,category')
      .order('event_detail_2_code');
    
    if (!e2b && ed2) {
      S.eventDetails2 = ed2.map(e => ({
        id: e.event_detail_2_id,
        code: e.event_detail_2_code,  // e.g., "ZoneEntry_Rush"
        name: e.event_detail_2_name,   // e.g., "ZoneEntry Rush"
        category: e.category
      }));
      console.log('Loaded', S.eventDetails2.length, 'event details 2');
    }
    
    // v22.1: Load dim_event_type for event type buttons
    const { data: et, error: etErr } = await S.sb.from('dim_event_type')
      .select('event_type_id,event_type_code,event_type_name,event_category')
      .order('event_type_code');
    
    if (!etErr && et) {
      S.eventTypesDB = et.map(e => ({
        id: e.event_type_id,
        code: e.event_type_code,
        name: e.event_type_name,
        category: e.event_category
      }));
      console.log('Loaded', S.eventTypesDB.length, 'event types from dim_event_type');
      // Rebuild UI to use dynamic event types
      buildEventTypeButtons();
    }
    
    // Load dim_player_role
    const { data: roles, error: e3 } = await S.sb.from('dim_player_role')
      .select('role_id,role_code,role_name,role_type,sort_order')
      .order('sort_order');
    
    if (!e3 && roles) {
      S.playerRoles = roles.map(r => ({
        id: r.role_id,
        code: r.role_code,
        name: r.role_name,
        type: r.role_type,
        order: r.sort_order
      }));
      console.log('Loaded', S.playerRoles.length, 'player roles');
    }
    
    // v15.01: Load dim_team for colors and logos
    const { data: teams, error: e4 } = await S.sb.from('dim_team')
      .select('team_id,team_name,team_color1,team_color2,team_logo');
    
    if (!e4 && teams) {
      S.teams = {};
      teams.forEach(t => {
        S.teams[t.team_name] = {
          id: t.team_id,
          name: t.team_name,
          color1: t.team_color1 || '#3b82f6',
          color2: t.team_color2 || '#1e40af',
          logo: t.team_logo || null
        };
      });
      console.log('Loaded', Object.keys(S.teams).length, 'teams');
    }
    
  } catch(e) {
    console.error('Error loading reference data:', e);
  }
}

async function testConn() {
  await tryConnect();
  toast(S.connected ? '‚úÖ Connected to Supabase!' : '‚ùå Connection failed', S.connected ? 'success' : 'error');
}

function updateConn(on) {
  const el = document.getElementById('connStatus');
  if (!el) return; // v23.8: Guard if element doesn't exist
  el.textContent = on ? 'ONLINE' : 'OFFLINE';
  el.className = 'conn ' + (on ? 'on' : 'off');
}

function openSettings() {
  try {
  // v23.8: Ensure penalty lengths are initialized before showing modal
  if (!S.penaltyLengths) {
    S.penaltyLengths = { minor: 2, major: 5, misconduct: 10 };
  }
  updatePeriodLengthsUI(); // This will also update penalty lengths UI
  updateSaveFolderDisplay(); // v23.8: Update save folder display
  updateDefaultFolderDisplay(); // Update default folder display
  const modal = document.getElementById('settingsModal');
    if (!modal) {
      console.error('settingsModal not found');
      toast('Settings modal not found', 'error');
      return;
    }
    // Ensure modal is in body (move if needed)
    if (modal.parentElement !== document.body) {
      document.body.appendChild(modal);
    }
    modal.classList.add('show');
    modal.style.display = 'flex';
    modal.style.visibility = 'visible';
    modal.style.opacity = '1';
    modal.style.zIndex = '10000';
    modal.style.position = 'fixed';
    modal.style.top = '0';
    modal.style.left = '0';
    modal.style.right = '0';
    modal.style.bottom = '0';
    modal.style.width = '100%';
    modal.style.height = '100%';
    modal.style.background = 'rgba(0,0,0,0.85)';
    
    // Ensure the modal content div is properly positioned
    const modalContent = modal.querySelector('.modal');
    if (modalContent) {
      modalContent.style.position = 'relative';
      modalContent.style.zIndex = '10001';
    }
    
    // Remove ALL handlers completely
    if (modal._overlayClickHandler) {
      modal.removeEventListener('click', modal._overlayClickHandler);
      modal.removeEventListener('mousedown', modal._overlayClickHandler);
      delete modal._overlayClickHandler;
    }
    modal.onclick = null;
    modal.removeAttribute('onclick');
    
    // Set overlay click handler (only fires when clicking overlay itself, not children)
    modal.setAttribute('onclick', 'if(event.target===this)closeSettings()');
    
    // Use helper function to make ALL buttons work - fixes all modals at once
    ensureModalButtonsWork(modal);
    
    console.log('Settings modal opened');
  } catch (err) {
    console.error('Error opening settings:', err);
    toast('Error opening settings: ' + err.message, 'error');
  }
}

function closeSettings() { 
  console.log('closeSettings() called');
  const modal = document.getElementById('settingsModal');
  if (modal) {
    console.log('Removing show class and forcing display none');
    modal.classList.remove('show');
    // Force all styles to hide - use !important via setProperty
    modal.style.setProperty('display', 'none', 'important');
    modal.style.setProperty('visibility', 'hidden', 'important');
    modal.style.setProperty('opacity', '0', 'important');
    console.log('Modal closed. display:', modal.style.display);
  } else {
    console.error('settingsModal not found!');
  }
}
function openHelp() { 
  try {
  const modal = document.getElementById('helpModal');
    if (!modal) {
      console.error('helpModal not found');
      toast('Help modal not found', 'error');
      return;
    }
    modal.classList.add('show');
    console.log('Help modal opened');
  } catch (err) {
    console.error('Error opening help:', err);
    toast('Error opening help: ' + err.message, 'error');
  }
}
function closeHelp() { 
  const modal = document.getElementById('helpModal');
  if (modal) modal.classList.remove('show');
}

/**
 * Open the full user guide in a new tab
 */
function openUserGuide() {
  // Try to open the guide file
  const guideUrl = 'TRACKER_USER_GUIDE_v23.4.md';
  
  // Create a modal with the guide content if file not accessible
  const html = `
    <h3>üìñ BenchSight Tracker v23.4 User Guide</h3>
    <p style="font-size:11px;color:var(--muted);margin-bottom:12px;">
      The complete user guide covers all features in detail.
    </p>
    
    <div style="max-height:400px;overflow-y:auto;background:var(--panel);padding:12px;border-radius:4px;font-size:10px;line-height:1.6;">
      <h4 style="color:var(--accent);margin-bottom:8px;">üìã Table of Contents</h4>
      <ol style="margin-left:16px;">
        <li><strong>Quick Start</strong> - First time setup, basic workflow</li>
        <li><strong>Interface Overview</strong> - Layout diagram, color coding</li>
        <li><strong>Video Playback</strong> - Loading, controls, multi-source, clock sync</li>
        <li><strong>Event Tracking</strong> - Types, details, players, logging</li>
        <li><strong>XY Positioning</strong> - Modes, smart linking, drag creation</li>
        <li><strong>Shift Tracking</strong> - Recording, line presets</li>
        <li><strong>Workflow Automation</strong> - Chains, templates, auto-features</li>
        <li><strong>Data Management</strong> - Saving, export/import, rosters</li>
        <li><strong>Keyboard Shortcuts</strong> - Complete reference table</li>
        <li><strong>Tips & Best Practices</strong> - Workflows, troubleshooting</li>
      </ol>
      
      <h4 style="color:var(--accent);margin:16px 0 8px;">üé¨ Video Hotkeys (v23.4)</h4>
      <table style="width:100%;border-collapse:collapse;">
        <tr><td style="padding:2px 8px;border-bottom:1px solid var(--border);"><kbd>Space</kbd></td><td>Play/Pause</td></tr>
        <tr><td style="padding:2px 8px;border-bottom:1px solid var(--border);"><kbd>‚Üê</kbd> / <kbd>‚Üí</kbd></td><td>Seek ¬±1s</td></tr>
        <tr><td style="padding:2px 8px;border-bottom:1px solid var(--border);"><kbd>Shift+‚Üê/‚Üí</kbd></td><td>Seek ¬±10s</td></tr>
        <tr><td style="padding:2px 8px;border-bottom:1px solid var(--border);"><kbd>‚Üë</kbd> / <kbd>‚Üì</kbd></td><td>Speed up/down</td></tr>
        <tr><td style="padding:2px 8px;border-bottom:1px solid var(--border);"><kbd>;</kbd> / <kbd>'</kbd></td><td>Frame step</td></tr>
        <tr><td style="padding:2px 8px;border-bottom:1px solid var(--border);"><kbd>+</kbd> / <kbd>-</kbd></td><td>Zoom in/out</td></tr>
        <tr><td style="padding:2px 8px;"><kbd>Ctrl+1-9</kbd></td><td>Switch video source</td></tr>
      </table>
      
      <h4 style="color:var(--accent);margin:16px 0 8px;">‚ö° Quick Workflows</h4>
      <p><strong>Shot:</strong> Drag from shooter toward net ‚Üí Auto-creates shot with XY</p>
      <p><strong>Pass:</strong> Drag from passer to receiver ‚Üí Auto-creates pass with XY</p>
      <p><strong>Hit:</strong> Add players ‚Üí Click puck ‚Üí üìç All Here</p>
      <p><strong>Faceoff:</strong> Click faceoff dot ‚Üí Auto-positions players</p>
    </div>
    
    <div class="modal-actions" style="margin-top:12px;display:flex;justify-content:space-between;">
      <a href="TRACKER_USER_GUIDE_v23.4.md" download class="btn-sm" style="background:var(--accent);color:#000;text-decoration:none;padding:6px 12px;">üì• Download Guide (Markdown)</a>
      <button class="btn-primary" onclick="closeModal()">Close</button>
    </div>
  `;
  
  showModal(html);
}

// ============================================================
// VIDEO TIMING FUNCTIONS
// ============================================================
/**
 * Parse time input - accepts seconds (number) or MM:SS format
 * @param {string} input - Time input (e.g., "120" or "2:00" or "19:02")
 * @returns {number|null} - Seconds, or null if empty/invalid
 */
function parseTimeInput(input) {
  if (!input || input.trim() === '') return null;
  const trimmed = input.trim();
  
  // Check if it's MM:SS format
  if (trimmed.includes(':')) {
    const parts = trimmed.split(':');
    if (parts.length === 2) {
      const minutes = parseInt(parts[0]) || 0;
      const seconds = parseInt(parts[1]) || 0;
      return minutes * 60 + seconds;
    }
  }
  
  // Otherwise, treat as seconds
  const parsed = parseInt(trimmed);
  return isNaN(parsed) ? null : parsed;
}

/**
 * Format seconds as MM:SS or just seconds if < 60
 * @param {number} seconds - Seconds to format
 * @returns {string} - Formatted time
 */
function formatTimeInput(seconds) {
  if (seconds === null || seconds === undefined) return '';
  if (seconds < 60) return String(seconds);
  const minutes = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${minutes}:${String(secs).padStart(2, '0')}`;
}

function openVideoTimingModal() {
  try {
    console.log('Opening video timing modal');
    const modal = document.getElementById('videoTimingModal');
    if (!modal) {
      console.error('videoTimingModal element not found!');
      toast('Video timing modal not found. Please refresh the page.', 'error');
      return;
    }
    
    // Ensure modal is in body (move if needed)
    if (modal.parentElement !== document.body) {
      document.body.appendChild(modal);
    }
    
  // Populate fields from S.videoTiming and S.periodLengths
    const offsetEl = document.getElementById('vtVideoStartOffset');
    if (offsetEl) offsetEl.value = S.videoTiming?.videoStartOffset || 0;
  
  // Populate per-period lengths
    const p1El = document.getElementById('vtPeriodLength1');
    const p2El = document.getElementById('vtPeriodLength2');
    const p3El = document.getElementById('vtPeriodLength3');
    const otEl = document.getElementById('vtPeriodLengthOT');
    if (p1El) p1El.value = S.periodLengths?.[1] || 18;
    if (p2El) p2El.value = S.periodLengths?.[2] || 18;
    if (p3El) p3El.value = S.periodLengths?.[3] || 18;
    if (otEl) otEl.value = S.periodLengths?.OT || 5;
  
  // Populate period start offsets
    const offsets = S.videoTiming?.periodOffsets || {};
    const p1StartEl = document.getElementById('vtPeriod1Start');
    const p2StartEl = document.getElementById('vtPeriod2Start');
    const p3StartEl = document.getElementById('vtPeriod3Start');
    const otStartEl = document.getElementById('vtPeriodOTStart');
    if (p1StartEl) p1StartEl.value = offsets[1] !== null && offsets[1] !== undefined ? formatTimeInput(offsets[1]) : '';
    if (p2StartEl) p2StartEl.value = offsets[2] !== null && offsets[2] !== undefined ? formatTimeInput(offsets[2]) : '';
    if (p3StartEl) p3StartEl.value = offsets[3] !== null && offsets[3] !== undefined ? formatTimeInput(offsets[3]) : '';
    if (otStartEl) otStartEl.value = offsets.OT !== null && offsets.OT !== undefined ? formatTimeInput(offsets.OT) : '';
  
  // Populate game start configuration
    const gameStart = S.videoTiming?.gameStart || { period: 1, time: '18:00' };
    const gameStartPeriodEl = document.getElementById('vtGameStartPeriod');
    const gameStartTimeEl = document.getElementById('vtGameStartTime');
    if (gameStartPeriodEl) gameStartPeriodEl.value = gameStart.period || 1;
    if (gameStartTimeEl) gameStartTimeEl.value = gameStart.time || '18:00';
    
    const int1El = document.getElementById('vtIntermission1');
    const int2El = document.getElementById('vtIntermission2');
    const int3El = document.getElementById('vtIntermission3');
    const urlEl = document.getElementById('vtYoutubeUrl');
    if (int1El) int1El.value = S.videoTiming?.intermission1 || 900;
    if (int2El) int2El.value = S.videoTiming?.intermission2 || 900;
    if (int3El) int3El.value = S.videoTiming?.intermission3 || 300;
    if (urlEl) urlEl.value = S.videoTiming?.youtubeUrl || '';
  
  renderVideoTimeouts();
  renderVideos(); // v23.6: Render video list
  updateVideoTimingPreview();
    
    modal.classList.add('show');
    modal.style.display = 'flex';
    modal.style.visibility = 'visible';
    modal.style.opacity = '1';
    modal.style.zIndex = '10000';
    modal.style.position = 'fixed';
    modal.style.top = '0';
    modal.style.left = '0';
    modal.style.right = '0';
    modal.style.bottom = '0';
    modal.style.width = '100%';
    modal.style.height = '100%';
    modal.style.background = 'rgba(0,0,0,0.85)';
    
    // Ensure the modal content div is properly positioned
    const modalContent = modal.querySelector('.modal');
    if (modalContent) {
      modalContent.style.position = 'relative';
      modalContent.style.zIndex = '10001';
    }
    
    // Remove ALL existing handlers that might interfere
    if (modal._overlayClickHandler) {
      modal.removeEventListener('click', modal._overlayClickHandler);
      modal.removeEventListener('mousedown', modal._overlayClickHandler);
      delete modal._overlayClickHandler;
    }
    modal.onclick = null;
    modal.removeAttribute('onclick');
    
    // Use simple inline onclick pattern - only closes when clicking overlay itself
    modal.setAttribute('onclick', 'if(event.target===this)closeVideoTimingModal()');
    
    // Make ALL buttons work
    ensureModalButtonsWork(modal);
    
    console.log('Video timing modal opened');
  } catch (err) {
    console.error('Error opening video timing modal:', err);
    toast('Error opening video timing: ' + err.message, 'error');
  }
}

function closeVideoTimingModal() {
  console.log('closeVideoTimingModal() called');
  const modal = document.getElementById('videoTimingModal');
  if (modal) {
    modal.classList.remove('show');
    // Force all styles to hide - use !important via setProperty
    modal.style.setProperty('display', 'none', 'important');
    modal.style.setProperty('visibility', 'hidden', 'important');
    modal.style.setProperty('opacity', '0', 'important');
    console.log('Video timing modal closed');
  }
}

/**
 * v23.7: Open highlight videos modal
 */
function openHighlightVideosModal() {
  try {
    console.log('Opening highlight videos modal');
    const modal = document.getElementById('highlightVideosModal');
    if (!modal) {
      console.error('highlightVideosModal element not found!');
      toast('Highlight videos modal not found. Please refresh the page.', 'error');
      return;
    }
    
    // Ensure modal is in body (move if needed)
    if (modal.parentElement !== document.body) {
      document.body.appendChild(modal);
    }
    
    // Initialize highlightVideos array if needed
    if (!S.highlightVideos) S.highlightVideos = [];
    
    // Populate event selector with all events
    const eventSelect = document.getElementById('newHighlightEventSelect');
    if (eventSelect) {
      eventSelect.innerHTML = '<option value="">-- Select an event --</option>';
      S.events.forEach((evt, idx) => {
        const evtType = evt.type || 'Unknown';
        const evtTime = evt.start_time || evt.time || '';
        const evtPeriod = evt.period || '';
        const option = document.createElement('option');
        option.value = idx;
        option.textContent = `Event #${idx + 1} - ${evtPeriod} ${evtTime} - ${evtType}`;
        eventSelect.appendChild(option);
      });
    }
    
    // Render existing highlights
    renderHighlightVideos();
    
    modal.classList.add('show');
    modal.style.display = 'flex';
    modal.style.visibility = 'visible';
    modal.style.opacity = '1';
    modal.style.zIndex = '10000';
    modal.style.position = 'fixed';
    modal.style.top = '0';
    modal.style.left = '0';
    modal.style.right = '0';
    modal.style.bottom = '0';
    modal.style.width = '100%';
    modal.style.height = '100%';
    modal.style.background = 'rgba(0,0,0,0.85)';
    
    // Ensure the modal content div is properly positioned
    const modalContent = modal.querySelector('.modal');
    if (modalContent) {
      modalContent.style.position = 'relative';
      modalContent.style.zIndex = '10001';
    }
    
    // Remove ALL existing handlers that might interfere
    if (modal._overlayClickHandler) {
      modal.removeEventListener('click', modal._overlayClickHandler);
      modal.removeEventListener('mousedown', modal._overlayClickHandler);
      delete modal._overlayClickHandler;
    }
    modal.onclick = null;
    modal.removeAttribute('onclick');
    
    // Use simple inline onclick pattern - only closes when clicking overlay itself
    modal.setAttribute('onclick', 'if(event.target===this)closeHighlightVideosModal()');
    
    // Make ALL buttons work
    ensureModalButtonsWork(modal);
    
    console.log('Highlight videos modal opened');
  } catch (err) {
    console.error('Error opening highlight videos modal:', err);
    toast('Error opening highlight videos: ' + err.message, 'error');
  }
}

/**
 * v23.7: Close highlight videos modal
 */
function closeHighlightVideosModal() {
  console.log('closeHighlightVideosModal() called');
  const modal = document.getElementById('highlightVideosModal');
  if (modal) {
    modal.classList.remove('show');
    modal.style.setProperty('display', 'none', 'important');
    modal.style.setProperty('visibility', 'hidden', 'important');
    modal.style.setProperty('opacity', '0', 'important');
    console.log('Highlight videos modal closed');
  }
}

/**
 * v23.7: Render list of highlight videos
 */
function renderHighlightVideos() {
  const listEl = document.getElementById('highlightVideosList');
  if (!listEl) return;
  
  if (!S.highlightVideos || S.highlightVideos.length === 0) {
    listEl.innerHTML = '<div style="color:var(--muted);font-size:9px;padding:8px;">No highlight videos added yet.</div>';
    return;
  }
  
  listEl.innerHTML = S.highlightVideos.map((hl, idx) => {
    const evt = S.events[hl.eventIndex];
    if (!evt) return '';
    
    const evtType = evt.type || 'Unknown';
    const evtTime = evt.start_time || evt.time || '';
    const evtPeriod = evt.period || '';
    const scorer = evt.players?.find(p => p.role === 'event_player_1');
    const scorerName = scorer ? `#${scorer.num} ${scorer.name || ''}` : '';
    
    return `
      <div style="padding:8px;border:1px solid var(--border);border-radius:4px;margin-bottom:8px;background:var(--bg);">
        <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:4px;">
          <div style="flex:1;">
            <div style="font-weight:bold;color:var(--accent);">Event #${hl.eventIndex + 1} - ${evtPeriod} ${evtTime} - ${evtType}</div>
            ${scorerName ? `<div style="font-size:9px;color:var(--muted);">${scorerName}</div>` : ''}
            ${hl.title ? `<div style="font-size:9px;color:var(--text);margin-top:4px;">${hl.title}</div>` : ''}
          </div>
          <button class="btn-sm" onclick="removeHighlightVideo(${idx})" style="font-size:8px;padding:2px 6px;" title="Remove">‚úï</button>
        </div>
        <div style="margin-top:4px;">
          <label style="font-size:9px;color:var(--muted);">Video URL:</label>
          <input type="text" id="highlightVideoUrl_${idx}" value="${hl.videoUrl || ''}" 
                 onchange="updateHighlightVideoUrl(${idx}, this.value)" 
                 style="width:100%;font-size:9px;padding:4px;margin-top:2px;border:1px solid var(--border);border-radius:3px;background:var(--input);color:var(--text);"
                 placeholder="https://youtube.com/watch?v=...">
        </div>
        ${hl.description ? `<div style="font-size:9px;color:var(--muted);margin-top:4px;">${hl.description}</div>` : ''}
        <button class="btn-sm" onclick="editEvent(${hl.eventIndex})" style="font-size:8px;padding:2px 6px;margin-top:4px;" title="Edit event">‚úèÔ∏è Edit Event</button>
      </div>
    `;
  }).join('');
}

/**
 * v23.7: Add a new highlight video
 */
function addHighlightVideo() {
  const eventSelect = document.getElementById('newHighlightEventSelect');
  const urlInput = document.getElementById('newHighlightVideoUrl');
  
  if (!eventSelect || !urlInput) return;
  
  const eventIndex = parseInt(eventSelect.value);
  const videoUrl = urlInput.value.trim();
  
  if (eventIndex === '' || isNaN(eventIndex)) {
    toast('Please select an event', 'warning');
    return;
  }
  
  if (!videoUrl) {
    toast('Please enter a video URL', 'warning');
    return;
  }
  
  const evt = S.events[eventIndex];
  if (!evt) {
    toast('Invalid event selected', 'error');
    return;
  }
  
  // Check if highlight already exists for this event
  const existing = S.highlightVideos.findIndex(hl => hl.eventIndex === eventIndex);
  if (existing !== -1) {
    // Update existing
    S.highlightVideos[existing].videoUrl = videoUrl;
    toast('Highlight video updated', 'success');
  } else {
    // Add new
    S.highlightVideos.push({
      eventIndex: eventIndex,
      videoUrl: videoUrl,
      title: '',
      description: ''
    });
    toast('Highlight video added', 'success');
  }
  
  // Update event's isHighlight and videoUrl
  evt.isHighlight = true;
  evt.videoUrl = videoUrl;
  
  // Clear form
  eventSelect.value = '';
  urlInput.value = '';
  
  // Re-render list
  renderHighlightVideos();
  
  // Save
  saveGameData();
}

/**
 * v23.7: Remove a highlight video
 */
function removeHighlightVideo(index) {
  if (!S.highlightVideos || index < 0 || index >= S.highlightVideos.length) return;
  
  const hl = S.highlightVideos[index];
  const evt = S.events[hl.eventIndex];
  if (evt) {
    evt.isHighlight = false;
    evt.videoUrl = '';
  }
  
  S.highlightVideos.splice(index, 1);
  renderHighlightVideos();
  saveGameData();
  toast('Highlight video removed', 'info');
}

/**
 * v23.7: Update highlight video URL
 */
function updateHighlightVideoUrl(index, newUrl) {
  if (!S.highlightVideos || index < 0 || index >= S.highlightVideos.length) return;
  
  S.highlightVideos[index].videoUrl = newUrl;
  const hl = S.highlightVideos[index];
  const evt = S.events[hl.eventIndex];
  if (evt) {
    evt.videoUrl = newUrl;
  }
  
  saveGameData();
}

/**
 * Sync period lengths from Video Timing modal to Settings
 */
function syncPeriodLengthsFromVT() {
  S.periodLengths = {
    1: parseInt(document.getElementById('vtPeriodLength1')?.value) || 18,
    2: parseInt(document.getElementById('vtPeriodLength2')?.value) || 18,
    3: parseInt(document.getElementById('vtPeriodLength3')?.value) || 18,
    OT: parseInt(document.getElementById('vtPeriodLengthOT')?.value) || 5
  };
  S.periodLength = S.periodLengths[1];
  
  // Sync to Settings modal inputs
  document.getElementById('periodLength1').value = S.periodLengths[1];
  document.getElementById('periodLength2').value = S.periodLengths[2];
  document.getElementById('periodLength3').value = S.periodLengths[3];
  document.getElementById('periodLengthOT').value = S.periodLengths.OT;
  document.getElementById('periodLength').value = S.periodLength;
  
  updateVideoTimingPreview();
  updatePeriodLengthIndicator();
}

/**
 * Parse time string (MM:SS) to total seconds
 */
function parseTimeToSeconds(timeStr) {
  if (!timeStr) return 0;
  const parts = timeStr.split(':');
  return parseInt(parts[0] || 0) * 60 + parseInt(parts[1] || 0);
}

/**
 * Format seconds to MM:SS
 */
function formatSecondsToTime(seconds) {
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${mins}:${String(secs).padStart(2, '0')}`;
}

/**
 * Update timeout duration from game times
 */
function updateTimeoutFromGameTimes() {
  const gameStart = document.getElementById('vtNewTimeoutGameStart').value;
  const gameStop = document.getElementById('vtNewTimeoutGameStop').value;
  const period = document.getElementById('vtNewTimeoutPeriod').value;
  const durationEl = document.getElementById('vtNewTimeoutDuration');
  
  if (!gameStart || !gameStop) {
    // Try to calculate from video times if available
    updateTimeoutFromVideoTimes();
    return;
  }
  
  // Parse game times (MM:SS format - time remaining on clock)
  const startSec = parseTimeToSeconds(gameStart);
  const stopSec = parseTimeToSeconds(gameStop);
  
  // Duration = start - stop (since clock counts down, higher time = earlier)
  const duration = Math.max(0, startSec - stopSec);
  durationEl.value = duration;
  
  // Calculate video times from game times
  const periodNum = period === 'OT' ? 4 : parseInt(period);
  const videoStart = calculateRunningVideoTime(periodNum, gameStart);
  const videoStop = calculateRunningVideoTime(periodNum, gameStop);
  
  document.getElementById('vtNewTimeoutVideoStart').value = formatSecondsToTime(videoStart);
  document.getElementById('vtNewTimeoutVideoStop').value = formatSecondsToTime(videoStop);
}

/**
 * Update timeout duration from video times
 */
function updateTimeoutFromVideoTimes() {
  const videoStart = document.getElementById('vtNewTimeoutVideoStart').value;
  const videoStop = document.getElementById('vtNewTimeoutVideoStop').value;
  const durationEl = document.getElementById('vtNewTimeoutDuration');
  
  if (!videoStart || !videoStop) {
    durationEl.value = 0;
    return;
  }
  
  // Parse video times (MM:SS format - absolute video time)
  const startSec = parseTimeToSeconds(videoStart);
  const stopSec = parseTimeToSeconds(videoStop);
  
  // Duration = stop - start (video time counts up)
  const duration = Math.max(0, stopSec - startSec);
  durationEl.value = duration;
}

/**
 * Update timeout video times from duration
 */
function updateTimeoutFromDuration() {
  const duration = parseInt(document.getElementById('vtNewTimeoutDuration').value) || 0;
  const videoStart = document.getElementById('vtNewTimeoutVideoStart').value;
  const videoStop = document.getElementById('vtNewTimeoutVideoStop').value;
  
  if (videoStart && !videoStop) {
    // Calculate stop from start + duration
    const startSec = parseTimeToSeconds(videoStart);
    document.getElementById('vtNewTimeoutVideoStop').value = formatSecondsToTime(startSec + duration);
  } else if (videoStop && !videoStart) {
    // Calculate start from stop - duration
    const stopSec = parseTimeToSeconds(videoStop);
    document.getElementById('vtNewTimeoutVideoStart').value = formatSecondsToTime(Math.max(0, stopSec - duration));
  }
}

/**
 * Update video times when period changes
 */
function updateTimeoutVideoTimes() {
  const gameStart = document.getElementById('vtNewTimeoutGameStart').value;
  const gameStop = document.getElementById('vtNewTimeoutGameStop').value;
  const period = document.getElementById('vtNewTimeoutPeriod').value;
  
  if (gameStart && gameStop) {
    // Recalculate video times for new period
    updateTimeoutFromGameTimes();
  }
}

function renderVideoTimeouts() {
  const list = document.getElementById('vtTimeoutsList');
  if (!S.videoTiming.timeouts || S.videoTiming.timeouts.length === 0) {
    list.innerHTML = '<div style="font-size:9px;color:var(--muted);text-align:center;padding:8px;">No timeouts added</div>';
    return;
  }
  
  list.innerHTML = S.videoTiming.timeouts.map((t, i) => {
    // Support both old format (gameTime + duration) and new format (startTime + stopTime)
    const gameStart = t.gameStart || t.startTime || t.gameTime || '--';
    const gameStop = t.gameStop || t.stopTime || (t.gameTime && t.duration ? calculateStopTime(t.gameTime, t.duration) : '--');
    const videoStart = t.videoStart ? formatSecondsToTime(t.videoStart) : '--';
    const videoStop = t.videoStop ? formatSecondsToTime(t.videoStop) : '--';
    const duration = t.duration || 0;
    
    return `
    <div style="display:flex;justify-content:space-between;align-items:center;padding:4px;background:var(--panel);border-radius:2px;margin:2px 0;font-size:9px;">
      <div style="flex:1;">
        <div>P${t.period} Game: ${gameStart} ‚Üí ${gameStop}</div>
        <div style="font-size:8px;color:var(--muted);">Video: ${videoStart} ‚Üí ${videoStop} (${duration}s)</div>
      </div>
      <button class="btn-sm" onclick="removeVideoTimeout(${i})" style="padding:1px 4px;font-size:8px;">‚úï</button>
    </div>
  `;
  }).join('');
}

/**
 * Calculate stop time from start time and duration
 */
function calculateStopTime(startTime, duration) {
  const parseGameTime = (timeStr) => {
    const parts = timeStr.split(':');
    return parseInt(parts[0] || 0) * 60 + parseInt(parts[1] || 0);
  };
  
  const startSec = parseGameTime(startTime);
  const stopSec = startSec - duration; // Clock counts down
  const stopMin = Math.floor(stopSec / 60);
  const stopSecRem = stopSec % 60;
  return `${stopMin}:${String(stopSecRem).padStart(2, '0')}`;
}

/**
 * Calculate duration from start and stop times
 */
function calculateDurationFromTimes(startTime, stopTime) {
  const parseGameTime = (timeStr) => {
    const parts = timeStr.split(':');
    return parseInt(parts[0] || 0) * 60 + parseInt(parts[1] || 0);
  };
  
  const startSec = parseGameTime(startTime);
  const stopSec = parseGameTime(stopTime);
  return Math.max(0, startSec - stopSec);
}

function addVideoTimeout() {
  const period = document.getElementById('vtNewTimeoutPeriod').value;
  const gameStart = document.getElementById('vtNewTimeoutGameStart').value;
  const gameStop = document.getElementById('vtNewTimeoutGameStop').value;
  const videoStart = document.getElementById('vtNewTimeoutVideoStart').value;
  const videoStop = document.getElementById('vtNewTimeoutVideoStop').value;
  const duration = parseInt(document.getElementById('vtNewTimeoutDuration').value) || 0;
  
  // Need at least one set of times or duration
  const hasGameTimes = gameStart && gameStop;
  const hasVideoTimes = videoStart && videoStop;
  
  if (!hasGameTimes && !hasVideoTimes && duration <= 0) {
    toast('Enter game times, video times, or duration', 'error');
    return;
  }
  
  if (!S.videoTiming.timeouts) S.videoTiming.timeouts = [];
  
  // Calculate missing values
  let finalGameStart = gameStart;
  let finalGameStop = gameStop;
  let finalVideoStart = videoStart ? parseTimeToSeconds(videoStart) : null;
  let finalVideoStop = videoStop ? parseTimeToSeconds(videoStop) : null;
  let finalDuration = duration;
  
  // If we have game times, calculate video times
  if (hasGameTimes && (!finalVideoStart || !finalVideoStop)) {
    const periodNum = period === 'OT' ? 4 : parseInt(period);
    finalVideoStart = calculateRunningVideoTime(periodNum, gameStart);
    finalVideoStop = calculateRunningVideoTime(periodNum, gameStop);
    if (!finalDuration) {
      finalDuration = Math.max(0, finalVideoStop - finalVideoStart);
    }
  }
  
  // If we have video times, calculate game times (reverse lookup - approximate)
  if (hasVideoTimes && (!finalGameStart || !finalGameStop)) {
    // For now, we'll store video times and calculate game times when needed
    // This is a simplified approach - full reverse lookup would be more complex
    if (!finalDuration) {
      finalDuration = Math.max(0, finalVideoStop - finalVideoStart);
    }
  }
  
  // If we only have duration, we need at least one time reference
  if (finalDuration > 0 && !hasGameTimes && !hasVideoTimes) {
    toast('Enter at least one time (game or video) when using duration', 'error');
    return;
  }
  
  // Store timeout with all available information
  const timeout = {
    period,
    duration: finalDuration,
    // Game times
    gameStart: finalGameStart || null,
    gameStop: finalGameStop || null,
    // Video times (in seconds)
    videoStart: finalVideoStart,
    videoStop: finalVideoStop,
    // Legacy support
    gameTime: finalGameStart,
    startTime: finalGameStart,
    stopTime: finalGameStop
  };
  
  S.videoTiming.timeouts.push(timeout);
  
  // Sort by period then start time (higher time = earlier in period for game times)
  S.videoTiming.timeouts.sort((a, b) => {
    const aPeriod = a.period === 'OT' ? 4 : parseInt(a.period);
    const bPeriod = b.period === 'OT' ? 4 : parseInt(b.period);
    if (aPeriod !== bPeriod) return aPeriod - bPeriod;
    // Sort by video start time if available, otherwise game time
    const aTime = a.videoStart !== null && a.videoStart !== undefined ? a.videoStart : (a.gameStart || a.gameTime || '');
    const bTime = b.videoStart !== null && b.videoStart !== undefined ? b.videoStart : (b.gameStart || b.gameTime || '');
    if (typeof aTime === 'number' && typeof bTime === 'number') {
      return aTime - bTime;
    }
    return String(bTime).localeCompare(String(aTime)); // Higher time = earlier in period for game times
  });
  
  renderVideoTimeouts();
  updateVideoTimingPreview();
  
  // Clear inputs
  document.getElementById('vtNewTimeoutGameStart').value = '';
  document.getElementById('vtNewTimeoutGameStop').value = '';
  document.getElementById('vtNewTimeoutVideoStart').value = '';
  document.getElementById('vtNewTimeoutVideoStop').value = '';
  document.getElementById('vtNewTimeoutDuration').value = 0;
}

function removeVideoTimeout(idx) {
  S.videoTiming.timeouts.splice(idx, 1);
  renderVideoTimeouts();
  updateVideoTimingPreview();
}

// v23.6: Video management functions
function renderVideos() {
  const list = document.getElementById('videosList');
  if (!list) return;
  
  if (!S.videos || S.videos.length === 0) {
    list.innerHTML = '<div style="font-size:9px;color:var(--muted);text-align:center;padding:8px;">No videos added</div>';
    return;
  }
  
  list.innerHTML = S.videos.map((v, i) => {
    const videoId = v.video_id || extractYouTubeId(v.url) || 'N/A';
    const title = v.title || v.url || 'Untitled';
    const period = v.period ? `P${v.period}` : 'All';
    const timeRange = (v.start_time || v.end_time) ? `${v.start_time || '--'} - ${v.end_time || '--'}` : '';
    const category = v.category ? v.category.replace('_', ' ') : '';
    return `
      <div style="display:flex;justify-content:space-between;align-items:flex-start;padding:6px;background:var(--panel);border-radius:3px;margin:3px 0;font-size:9px;border-left:3px solid var(--accent);">
        <div style="flex:1;">
          <div style="font-weight:600;color:var(--accent);margin-bottom:2px;">${title}</div>
          <div style="color:var(--muted);font-size:8px;">
            <span>${v.type ? v.type.replace('_', ' ') : 'Full Ice'}</span>
            ${category ? `<span style="margin-left:6px;">${category}</span>` : ''}
            ${videoId !== 'N/A' ? `<span style="margin-left:6px;">ID: ${videoId}</span>` : ''}
            ${period !== 'All' ? `<span style="margin-left:6px;">${period}</span>` : ''}
            ${timeRange ? `<span style="margin-left:6px;">${timeRange}</span>` : ''}
          </div>
          ${v.notes ? `<div style="color:var(--muted);font-size:8px;margin-top:2px;font-style:italic;">${v.notes}</div>` : ''}
        </div>
        <button class="btn-sm" onclick="removeVideo(${i})" style="padding:2px 6px;font-size:8px;margin-left:8px;background:var(--danger);">‚úï</button>
      </div>
    `;
  }).join('');
}

function addVideo() {
  const url = document.getElementById('newVideoUrl').value.trim();
  if (!url) {
    toast('Enter a video URL', 'error');
    return;
  }
  
  const type = document.getElementById('newVideoType').value || 'Full_Ice';
  const category = document.getElementById('newVideoCategory').value || undefined;
  // Extract YouTube ID if URL is a YouTube link (regardless of video type)
  const videoId = extractYouTubeId(url) || null;
  const title = document.getElementById('newVideoTitle').value.trim() || undefined;
  const period = document.getElementById('newVideoPeriod').value || undefined;
  const startTime = document.getElementById('newVideoStartTime').value.trim() || undefined;
  const endTime = document.getElementById('newVideoEndTime').value.trim() || undefined;
  const notes = document.getElementById('newVideoNotes').value.trim() || undefined;
  
  if (!S.videos) S.videos = [];
  
  const newVideo = {
    id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
    url: url,
    type: type,
    category: category, // v23.9: Video category from dim table options
    video_id: videoId || undefined,
    title: title,
    description: undefined, // Not used in UI but kept for compatibility
    start_time: startTime,
    end_time: endTime,
    period: period ? parseInt(period) : undefined,
    notes: notes
  };
  
  S.videos.push(newVideo);
  renderVideos();
  autoSave();
  
  // Clear form
  document.getElementById('newVideoUrl').value = '';
  document.getElementById('newVideoTitle').value = '';
  document.getElementById('newVideoPeriod').value = '';
  document.getElementById('newVideoStartTime').value = '';
  document.getElementById('newVideoEndTime').value = '';
  document.getElementById('newVideoNotes').value = '';
  
  toast('Video added', 'success');
}

function removeVideo(idx) {
  if (!S.videos || idx < 0 || idx >= S.videos.length) return;
  S.videos.splice(idx, 1);
  renderVideos();
  autoSave();
  toast('Video removed', 'success');
}

function saveVideoTiming() {
  S.videoTiming.videoStartOffset = parseInt(document.getElementById('vtVideoStartOffset').value) || 0;
  
  // Save per-period lengths
  S.periodLengths = {
    1: parseInt(document.getElementById('vtPeriodLength1').value) || 18,
    2: parseInt(document.getElementById('vtPeriodLength2').value) || 18,
    3: parseInt(document.getElementById('vtPeriodLength3').value) || 18,
    OT: parseInt(document.getElementById('vtPeriodLengthOT').value) || 5
  };
  S.periodLength = S.periodLengths[1];
  
  // Save period start offsets
  if (!S.videoTiming.periodOffsets) S.videoTiming.periodOffsets = {};
  S.videoTiming.periodOffsets[1] = parseTimeInput(document.getElementById('vtPeriod1Start').value);
  S.videoTiming.periodOffsets[2] = parseTimeInput(document.getElementById('vtPeriod2Start').value);
  S.videoTiming.periodOffsets[3] = parseTimeInput(document.getElementById('vtPeriod3Start').value);
  S.videoTiming.periodOffsets.OT = parseTimeInput(document.getElementById('vtPeriodOTStart').value);
  
  // Save game start configuration
  if (!S.videoTiming.gameStart) S.videoTiming.gameStart = {};
  S.videoTiming.gameStart.period = parseInt(document.getElementById('vtGameStartPeriod').value) || 1;
  S.videoTiming.gameStart.time = document.getElementById('vtGameStartTime').value || '18:00';
  
  S.videoTiming.intermission1 = parseInt(document.getElementById('vtIntermission1').value) || 900;
  S.videoTiming.intermission2 = parseInt(document.getElementById('vtIntermission2').value) || 900;
  S.videoTiming.intermission3 = parseInt(document.getElementById('vtIntermission3').value) || 300;
  S.videoTiming.youtubeUrl = document.getElementById('vtYoutubeUrl').value || '';
  
  // Sync to Settings modal
  updatePeriodLengthsUI();
  updatePeriodLengthIndicator();
  
  saveGameData();
  
  // v23.6: Videos are saved automatically when added/removed
  toast('Video timing saved', 'success');
  closeVideoTimingModal();
}

function updateVideoTimingPreview() {
  // Get per-period lengths
  const p1Sec = (parseInt(document.getElementById('vtPeriodLength1')?.value) || 18) * 60;
  const p2Sec = (parseInt(document.getElementById('vtPeriodLength2')?.value) || 18) * 60;
  const p3Sec = (parseInt(document.getElementById('vtPeriodLength3')?.value) || 18) * 60;
  const otSec = (parseInt(document.getElementById('vtPeriodLengthOT')?.value) || 5) * 60;
  
  const int1 = parseInt(document.getElementById('vtIntermission1').value) || 0;
  const int2 = parseInt(document.getElementById('vtIntermission2').value) || 0;
  const int3 = parseInt(document.getElementById('vtIntermission3').value) || 0;
  const offset = parseInt(document.getElementById('vtVideoStartOffset').value) || 0;
  
  // Get period start offsets (if explicitly set)
  const p1Offset = parseTimeInput(document.getElementById('vtPeriod1Start')?.value);
  const p2Offset = parseTimeInput(document.getElementById('vtPeriod2Start')?.value);
  const p3Offset = parseTimeInput(document.getElementById('vtPeriod3Start')?.value);
  const otOffset = parseTimeInput(document.getElementById('vtPeriodOTStart')?.value);
  
  // Calculate timeout durations per period
  const timeouts = S.videoTiming.timeouts || [];
  let p1Timeouts = 0, p2Timeouts = 0, p3Timeouts = 0, otTimeouts = 0;
  
  timeouts.forEach(t => {
    const tPeriod = t.period === 'OT' ? 4 : parseInt(t.period);
    const duration = t.duration || 0;
    
    if (tPeriod === 1) p1Timeouts += duration;
    else if (tPeriod === 2) p2Timeouts += duration;
    else if (tPeriod === 3) p3Timeouts += duration;
    else if (tPeriod === 4) otTimeouts += duration;
  });
  
  // Calculate period starts - explicit offsets ALWAYS override calculated values (including timeouts)
  // When an explicit offset is set, use it directly - don't calculate based on previous periods
  let p1Start = p1Offset !== null ? p1Offset : offset;
  let p1End = p1Start + p1Sec + p1Timeouts; // Add timeouts to period end only
  
  // Period 2: If explicit offset is set, use it directly. Otherwise calculate.
  // When calculating, only use timeouts from Period 1 for Period 2's calculation
  let p2Start;
  if (p2Offset !== null) {
    // Explicit offset - use it directly, ignoring calculated values and previous period timeouts
    p2Start = p2Offset;
  } else {
    // Calculate: p1End already includes p1Timeouts, so we use that
    p2Start = p1End + int1;
  }
  let p2End = p2Start + p2Sec + p2Timeouts; // Add timeouts to period end only
  
  // Period 3: If explicit offset is set, use it directly. Otherwise calculate.
  // When calculating, timeouts from Period 1 and 2 are already accounted for in p2End
  let p3Start;
  if (p3Offset !== null) {
    // Explicit offset - use it directly, ignoring calculated values and previous period timeouts
    p3Start = p3Offset;
  } else {
    // Calculate: p2End already includes p1Timeouts and p2Timeouts
    p3Start = p2End + int2;
  }
  let p3End = p3Start + p3Sec + p3Timeouts; // Add timeouts to period end only
  
  // OT: If explicit offset is set, use it directly. Otherwise calculate.
  let otStart;
  if (otOffset !== null) {
    // Explicit offset - use it directly
    otStart = otOffset;
  } else {
    // Calculate: p3End already includes all previous timeouts
    otStart = p3End + int3;
  }
  let otEnd = otStart + otSec + otTimeouts; // Add timeouts to period end only
  
  const fmt = (s) => `${Math.floor(s/60)}:${String(s%60).padStart(2,'0')}`;
  
  // Build preview HTML with timeouts inline
  const buildPeriodPreview = (periodNum, periodName, periodStart, periodEnd, periodTimeouts) => {
    const periodTimeoutsList = periodTimeouts.filter(t => {
      const tPeriod = t.period === 'OT' ? 4 : parseInt(t.period);
      return tPeriod === periodNum;
    }).sort((a, b) => {
      // Sort by video start time (ascending)
      const aStart = a.videoStart !== null && a.videoStart !== undefined ? a.videoStart : 0;
      const bStart = b.videoStart !== null && b.videoStart !== undefined ? b.videoStart : 0;
      return aStart - bStart;
    });
    
    if (periodTimeoutsList.length === 0) {
      // No timeouts - simple display
      return `
        <div style="display:grid;grid-template-columns:120px 1fr;gap:4px;padding:4px;border-bottom:1px solid var(--border);">
          <span style="font-weight:bold;">${periodName} Start:</span>
          <span>${fmt(periodStart)}</span>
          <span style="font-weight:bold;">${periodName} End:</span>
          <span>${fmt(periodEnd)}</span>
        </div>
      `;
    }
    
    // Has timeouts - show with timeout rows
    let html = `
      <div style="padding:4px;border-bottom:1px solid var(--border);">
        <div style="display:grid;grid-template-columns:120px 1fr;gap:4px;margin-bottom:2px;">
          <span style="font-weight:bold;">${periodName} Start:</span>
          <span>${fmt(periodStart)}</span>
        </div>
    `;
    
    // Show each timeout with its video times
    periodTimeoutsList.forEach((t, idx) => {
      const timeoutStart = t.videoStart !== null && t.videoStart !== undefined ? t.videoStart : (periodStart + (idx * 60));
      const timeoutEnd = t.videoStop !== null && t.videoStop !== undefined ? t.videoStop : (timeoutStart + (t.duration || 0));
      
      html += `
        <div style="display:grid;grid-template-columns:120px 1fr;gap:4px;margin-left:20px;color:var(--warn);font-size:9px;">
          <span>Timeout ${idx + 1} Start:</span>
          <span>${fmt(timeoutStart)}</span>
          <span>Timeout ${idx + 1} End:</span>
          <span>${fmt(timeoutEnd)}</span>
        </div>
      `;
    });
    
    html += `
        <div style="display:grid;grid-template-columns:120px 1fr;gap:4px;margin-top:2px;">
          <span style="font-weight:bold;">${periodName} End:</span>
          <span>${fmt(periodEnd)}</span>
        </div>
      </div>
    `;
    
    return html;
  };
  
  // Build preview content
  // When explicit offsets are set, period starts/ends are already correct (timeouts included in period ends)
  // Don't add timeout adjustments when explicit offsets override calculations
  let previewHTML = '';
  previewHTML += buildPeriodPreview(1, 'Period 1', p1Start, p1End, timeouts);
  previewHTML += buildPeriodPreview(2, 'Period 2', p2Start, p2End, timeouts);
  previewHTML += buildPeriodPreview(3, 'Period 3', p3Start, p3End, timeouts);
  previewHTML += buildPeriodPreview(4, 'OT', otStart, otEnd, timeouts);
  
  document.getElementById('vtPreviewContent').innerHTML = previewHTML;
}

/**
 * Calculate running video time for an event
 * @param {number} period - Period number (1, 2, 3, OT)
 * @param {string} gameTime - Game clock time (e.g., "15:30")
 * @returns {number} - Seconds from video start
 */
/**
 * Calculate adjusted video time for events
 * For events that are NOT faceoff, period start, or game start:
 * - Go back up to 10 seconds (clock counts down, so add seconds to time remaining = earlier in game)
 * - If there's a faceoff within that 10 second window, use that time instead
 * @param {number} period - Event period
 * @param {string} eventTime - Event time in MM:SS format (time remaining on clock)
 * @param {string} eventType - Event type
 * @returns {string} Adjusted time in MM:SS format, or original time if no adjustment needed
 */
function calculateAdjustedVideoTime(period, eventTime, eventType) {
  // Don't adjust faceoffs, period starts, or game starts
  if (eventType === 'Faceoff' || eventType === 'PeriodStart' || eventType === 'GameStart') {
    return eventTime;
  }
  
  if (!eventTime) return eventTime;
  
  // Parse event time to seconds (time remaining on clock)
  // Higher seconds = more time remaining = earlier in period
  const eventSeconds = parseTime(eventTime);
  
  // Maximum adjustment: 10 seconds back (add 10 seconds to time remaining = earlier)
  const maxAdjustment = 10;
  const earliestTime = eventSeconds + maxAdjustment; // Most time remaining = earliest
  
  // Find faceoffs in the same period that occurred before this event (within 10 seconds)
  // Faceoff must have MORE time remaining (higher seconds) = happened earlier
  const samePeriodFaceoffs = S.events
    .filter(e => e.period === period && e.type === 'Faceoff' && e.start_time)
    .map(e => ({ time: e.start_time, seconds: parseTime(e.start_time) }))
    .filter(fo => {
      // Faceoff happened before event: fo.seconds > eventSeconds (more time = earlier)
      // And within 10 seconds: fo.seconds <= earliestTime
      return fo.seconds > eventSeconds && fo.seconds <= earliestTime;
    })
    .sort((a, b) => a.seconds - b.seconds); // Closest to event first (least time difference)
  
  // If we found a faceoff within the window, use that time
  if (samePeriodFaceoffs.length > 0) {
    const faceoffTime = samePeriodFaceoffs[0].time;
    return faceoffTime;
  }
  
  // Otherwise, go back the full 10 seconds (add 10 to time remaining)
  const adjustedSeconds = Math.min(earliestTime, getPeriodLengthSeconds(period));
  const adjustedMin = Math.floor(adjustedSeconds / 60);
  const adjustedSec = adjustedSeconds % 60;
  return `${adjustedMin}:${String(adjustedSec).padStart(2, '0')}`;
}

function calculateRunningVideoTime(period, gameTime) {
  // v23.5: Use per-period lengths
  const currentPeriodSec = getPeriodLengthSeconds(period);
  const int1 = S.videoTiming.intermission1 || 0;
  const int2 = S.videoTiming.intermission2 || 0;
  const int3 = S.videoTiming.intermission3 || 0;
  const offset = S.videoTiming.videoStartOffset || 0;
  
  // Get period offsets (if explicitly set)
  const periodOffsets = S.videoTiming.periodOffsets || {};
  const p1Offset = periodOffsets[1];
  const p2Offset = periodOffsets[2];
  const p3Offset = periodOffsets[3];
  const otOffset = periodOffsets.OT;
  
  // Get game start configuration (for partial recordings)
  const gameStart = S.videoTiming.gameStart || { period: 1, time: '18:00' };
  const gameStartPeriod = gameStart.period === 'OT' ? 4 : parseInt(gameStart.period) || 1;
  const gameStartTime = gameStart.time || '18:00';
  
  // Parse game time (MM:SS) - time remaining in period
  let timeRemaining = 0;
  if (gameTime) {
    const parts = gameTime.split(':');
    timeRemaining = parseInt(parts[0] || 0) * 60 + parseInt(parts[1] || 0);
  }
  
  // Calculate elapsed time in current period
  const elapsedInPeriod = currentPeriodSec - timeRemaining;
  
  // Helper to get period start time in video
  const getPeriodStartInVideo = (p) => {
    const pNum = p === 'OT' ? 4 : parseInt(p);
    
    // If explicit offset is set, use it
    if (pNum === 1 && p1Offset !== null && p1Offset !== undefined) return p1Offset;
    if (pNum === 2 && p2Offset !== null && p2Offset !== undefined) return p2Offset;
    if (pNum === 3 && p3Offset !== null && p3Offset !== undefined) return p3Offset;
    if (p === 'OT' && otOffset !== null && otOffset !== undefined) return otOffset;
    
    // Otherwise, calculate based on previous periods
    if (pNum === 1) return offset;
    if (pNum === 2) {
      const p1Sec = getPeriodLengthSeconds(1);
      return (p1Offset !== null && p1Offset !== undefined ? p1Offset : offset) + p1Sec + int1;
    }
    if (pNum === 3) {
      const p1Sec = getPeriodLengthSeconds(1);
      const p2Sec = getPeriodLengthSeconds(2);
      const p1Start = (p1Offset !== null && p1Offset !== undefined ? p1Offset : offset);
      const p2Start = (p2Offset !== null && p2Offset !== undefined ? p2Offset : (p1Start + p1Sec + int1));
      return p2Start + p2Sec + int2;
    }
    if (p === 'OT') {
      const p1Sec = getPeriodLengthSeconds(1);
      const p2Sec = getPeriodLengthSeconds(2);
      const p3Sec = getPeriodLengthSeconds(3);
      const p1Start = (p1Offset !== null && p1Offset !== undefined ? p1Offset : offset);
      const p2Start = (p2Offset !== null && p2Offset !== undefined ? p2Offset : (p1Start + p1Sec + int1));
      const p3Start = (p3Offset !== null && p3Offset !== undefined ? p3Offset : (p2Start + p2Sec + int2));
      return p3Start + p3Sec + int3;
    }
    return offset;
  };
  
  // Get period start in video
  const periodStartInVideo = getPeriodStartInVideo(period);
  
  // Calculate base running time from period start
  let runningTime = periodStartInVideo + elapsedInPeriod;
  
  // If game start is configured (partial recording), adjust for the offset
  // Example: Video starts at 15:03 of period 2, so period 2 @ 15:03 = video time 0:00
  if (gameStartPeriod > 1 || (gameStartPeriod === 1 && gameStartTime !== '18:00')) {
    // Parse game start time (time remaining when video starts)
    const startParts = gameStartTime.split(':');
    const startTimeRemaining = parseInt(startParts[0] || 0) * 60 + parseInt(startParts[1] || 0);
    const startPeriodSec = getPeriodLengthSeconds(gameStartPeriod);
    const startElapsed = startPeriodSec - startTimeRemaining;
    
    // Calculate where video actually starts in absolute video time
    const videoStartAbsoluteTime = getPeriodStartInVideo(gameStartPeriod) + startElapsed;
    
    // If current event is before video start, return 0 (or handle appropriately)
    if (period < gameStartPeriod || (period === gameStartPeriod && timeRemaining > startTimeRemaining)) {
      // Event is before video recording started
      return 0;
    }
    
    // Adjust: subtract the absolute time where video starts
    runningTime = runningTime - videoStartAbsoluteTime;
    
    // Ensure non-negative
    if (runningTime < 0) runningTime = 0;
  }
  
  // Add timeout durations that occurred before this point
  const timeouts = S.videoTiming.timeouts || [];
  timeouts.forEach(t => {
    const tPeriod = t.period === 'OT' ? 4 : parseInt(t.period);
    const timeoutDuration = t.duration || 0;
    const timeoutVideoStart = t.videoStart;
    const timeoutGameStart = t.gameStart || t.startTime || t.gameTime || '';
    
    if (tPeriod < period) {
      // Timeout in earlier period - always add duration
      runningTime += timeoutDuration;
    } else if (tPeriod === period) {
      // Timeout in same period - check if it happened before current time
      if (timeoutVideoStart !== null && timeoutVideoStart !== undefined) {
        // Use video time if available
        const currentVideoTime = getPeriodStartInVideo(period) + elapsedInPeriod;
        if (timeoutVideoStart < currentVideoTime) {
          runningTime += timeoutDuration;
        }
      } else if (timeoutGameStart) {
        // Fall back to game time comparison
        // Higher gameTime = earlier in period
        if (timeoutGameStart > gameTime) {
          runningTime += timeoutDuration;
        }
      }
    }
  });
  
  return runningTime;
}

// ============================================================
// v23.4: VIDEO PLAYER CONTROLS
// ============================================================

// Video state
let currentVideoSource = null; // 'youtube' or 'local'
let ytPlayer = null; // YouTube player instance
let videoSyncEnabled = true;
let currentVideoZoom = 1;
let videoSources = []; // Multiple video sources with hotkeys

/**
 * Load a video from URL (YouTube or direct file)
 */
function loadVideo(url, name = 'Video') {
  if (!url) {
    toast('Enter a video URL', 'warning');
    return;
  }
  
  const youtubeId = extractYouTubeId(url);
  
  if (youtubeId) {
    loadYouTubeVideo(youtubeId);
    currentVideoSource = 'youtube';
  } else {
    loadLocalVideo(url);
    currentVideoSource = 'local';
  }
  
  // Hide placeholder
  document.getElementById('videoPlaceholder').style.display = 'none';
  
  toast(`Loaded: ${name}`, 'success');
}

/**
 * Extract YouTube video ID from URL
 */
function extractYouTubeId(url) {
  const patterns = [
    /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})/,
    /^([a-zA-Z0-9_-]{11})$/ // Direct ID
  ];

  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) return match[1];
  }
  return null;
}

/**
 * Build YouTube URL with start time parameter
 * @param {string} baseUrl - Base YouTube URL (full URL or just video ID)
 * @param {number} startTimeSeconds - Start time in seconds
 * @returns {string} - YouTube URL with t parameter
 */
function buildYouTubeUrlWithTime(baseUrl, startTimeSeconds) {
  if (!baseUrl) return '';
  
  const videoId = extractYouTubeId(baseUrl) || baseUrl;
  if (!videoId) return baseUrl;
  
  // Use youtu.be format (shorter) with time parameter
  // Format: https://youtu.be/VIDEO_ID?t=123
  const startTime = Math.max(0, Math.floor(startTimeSeconds)); // Ensure non-negative integer
  return `https://youtu.be/${videoId}?t=${startTime}`;
}

/**
 * Load YouTube video using IFrame API
 */
function loadYouTubeVideo(videoId) {
  const container = document.getElementById('youtubePlayer');
  container.style.display = 'block';
  document.getElementById('localVideoPlayer').style.display = 'none';
  
  // Load YouTube API if not already loaded
  if (!window.YT) {
    const tag = document.createElement('script');
    tag.src = 'https://www.youtube.com/iframe_api';
    document.head.appendChild(tag);
    
    window.onYouTubeIframeAPIReady = () => {
      createYouTubePlayer(videoId);
    };
  } else {
    createYouTubePlayer(videoId);
  }
}

/**
 * Create YouTube player instance
 */
function createYouTubePlayer(videoId) {
  // Destroy existing player if any
  if (ytPlayer && ytPlayer.destroy) {
    ytPlayer.destroy();
  }
  
  const container = document.getElementById('youtubePlayer');
  container.innerHTML = '<div id="ytPlayerFrame"></div>';
  
  ytPlayer = new YT.Player('ytPlayerFrame', {
    height: '100%',
    width: '100%',
    videoId: videoId,
    playerVars: {
      'playsinline': 1,
      'enablejsapi': 1,
      'modestbranding': 1,
      'rel': 0
    },
    events: {
      'onReady': onYouTubePlayerReady,
      'onStateChange': onYouTubePlayerStateChange
    }
  });
}

function onYouTubePlayerReady(event) {
  console.log('YouTube player ready');
  startVideoTimeUpdate();
}

function onYouTubePlayerStateChange(event) {
  const playBtn = document.getElementById('videoPlayBtn');
  if (event.data === YT.PlayerState.PLAYING) {
    playBtn.textContent = '‚è∏';
  } else {
    playBtn.textContent = '‚ñ∂';
  }
}

/**
 * Load local/direct video file
 */
function loadLocalVideo(url) {
  const video = document.getElementById('localVideoPlayer');
  video.style.display = 'block';
  document.getElementById('youtubePlayer').style.display = 'none';
  
  video.src = url;
  video.load();
  
  video.onloadedmetadata = () => {
    console.log('Local video loaded, duration:', video.duration);
    startVideoTimeUpdate();
  };
  
  video.onplay = () => document.getElementById('videoPlayBtn').textContent = '‚è∏';
  video.onpause = () => document.getElementById('videoPlayBtn').textContent = '‚ñ∂';
}

/**
 * Load video from file input
 */
function loadVideoFromFile(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  const url = URL.createObjectURL(file);
  loadLocalVideo(url);
  toast(`Loaded: ${file.name}`, 'success');
}

/**
 * Play/Pause video
 */
function videoPlayPause() {
  if (currentVideoSource === 'youtube' && ytPlayer) {
    const state = ytPlayer.getPlayerState();
    if (state === YT.PlayerState.PLAYING) {
      ytPlayer.pauseVideo();
    } else {
      ytPlayer.playVideo();
    }
  } else if (currentVideoSource === 'local') {
    const video = document.getElementById('localVideoPlayer');
    if (video.paused) {
      video.play();
    } else {
      video.pause();
    }
  }
}

/**
 * Seek video by delta seconds
 */
function videoSeek(deltaSec) {
  if (currentVideoSource === 'youtube' && ytPlayer) {
    const current = ytPlayer.getCurrentTime();
    ytPlayer.seekTo(current + deltaSec, true);
  } else if (currentVideoSource === 'local') {
    const video = document.getElementById('localVideoPlayer');
    video.currentTime = Math.max(0, video.currentTime + deltaSec);
  }
}

/**
 * Seek to specific time in seconds
 */
function videoSeekTo(timeSec) {
  if (currentVideoSource === 'youtube' && ytPlayer) {
    ytPlayer.seekTo(timeSec, true);
  } else if (currentVideoSource === 'local') {
    const video = document.getElementById('localVideoPlayer');
    video.currentTime = timeSec;
  }
}

/**
 * Frame step (approximate - 1/30 sec)
 */
function videoFrameStep(frames) {
  const frameDuration = 1 / 30; // Assume 30fps
  videoSeek(frames * frameDuration);
}

/**
 * Set video playback speed
 */
function setVideoSpeed(speed) {
  if (currentVideoSource === 'youtube' && ytPlayer) {
    ytPlayer.setPlaybackRate(speed);
  } else if (currentVideoSource === 'local') {
    const video = document.getElementById('localVideoPlayer');
    video.playbackRate = speed;
  }
  
  // Update UI
  document.querySelectorAll('.speed-btn').forEach(btn => {
    btn.classList.toggle('active', parseFloat(btn.dataset.speed) === speed);
  });
  
  toast(`Speed: ${speed}x`, 'info');
}

/**
 * Get current video playback speed
 */
function getVideoSpeed() {
  if (currentVideoSource === 'youtube' && ytPlayer && ytPlayer.getPlaybackRate) {
    return ytPlayer.getPlaybackRate();
  } else if (currentVideoSource === 'local') {
    return document.getElementById('localVideoPlayer').playbackRate;
  }
  return 1;
}

/**
 * Toggle video section visibility
 */
function toggleVideoSection() {
  const section = document.getElementById('videoSection');
  const toggleBar = document.getElementById('videoToggleBar');
  
  if (section.style.display === 'none') {
    section.style.display = 'block';
    toggleBar.style.display = 'none';
  } else {
    section.style.display = 'none';
    toggleBar.style.display = 'flex';
  }
}

/**
 * Show video section
 */
function showVideoSection() {
  document.getElementById('videoSection').style.display = 'block';
  document.getElementById('videoToggleBar').style.display = 'none';
}

/**
 * Get current video time in seconds
 */
function getVideoCurrentTime() {
  if (currentVideoSource === 'youtube' && ytPlayer && ytPlayer.getCurrentTime) {
    return ytPlayer.getCurrentTime();
  } else if (currentVideoSource === 'local') {
    return document.getElementById('localVideoPlayer').currentTime;
  }
  return 0;
}

/**
 * Get video duration
 */
function getVideoDuration() {
  if (currentVideoSource === 'youtube' && ytPlayer && ytPlayer.getDuration) {
    return ytPlayer.getDuration();
  } else if (currentVideoSource === 'local') {
    return document.getElementById('localVideoPlayer').duration || 0;
  }
  return 0;
}

/**
 * Update video time display continuously
 */
function startVideoTimeUpdate() {
  setInterval(() => {
    const currentTime = getVideoCurrentTime();
    const duration = getVideoDuration();
    
    // Format time
    const formatTime = (sec) => {
      const h = Math.floor(sec / 3600);
      const m = Math.floor((sec % 3600) / 60);
      const s = Math.floor(sec % 60);
      return h > 0 
        ? `${h}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`
        : `${m}:${String(s).padStart(2,'0')}`;
    };
    
    // Update displays
    const videoTimeEl = document.getElementById('videoTime');
    if (videoTimeEl) {
      videoTimeEl.textContent = `${formatTime(currentTime)} / ${formatTime(duration)}`;
    }
    
    const miniTimeEl = document.getElementById('videoMiniTime');
    if (miniTimeEl) {
      miniTimeEl.textContent = formatTime(currentTime);
    }
    
    // Calculate and display game clock time
    if (videoSyncEnabled) {
      const gameTime = calculateGameTimeFromVideo(currentTime);
      const gameTimeEl = document.getElementById('gameTimeFromVideo');
      if (gameTimeEl && gameTime) {
        gameTimeEl.textContent = `P${gameTime.period} ${gameTime.clock}`;
      }
    }
  }, 250);
}

/**
 * Calculate game clock from video time
 */
function calculateGameTimeFromVideo(videoSec) {
  const offset = S.videoTiming?.videoStartOffset || 0;
  const int1 = S.videoTiming?.intermission1 || 900;
  const int2 = S.videoTiming?.intermission2 || 900;
  const int3 = S.videoTiming?.intermission3 || 300;
  
  // Use game markers if set
  const markers = S.videoPlayer?.gameMarkers || {};
  
  // v23.5: Get per-period lengths
  const p1Sec = getPeriodLengthSeconds(1);
  const p2Sec = getPeriodLengthSeconds(2);
  const p3Sec = getPeriodLengthSeconds(3);
  const otSec = getPeriodLengthSeconds('OT');
  
  // Determine which period we're in
  let period = 1;
  let periodSec = p1Sec;
  let periodStartVideo = markers.P1Start || offset;
  let periodEndVideo = markers.P1End || (offset + p1Sec);
  
  if (markers.P2Start && videoSec >= markers.P2Start) {
    period = 2;
    periodSec = p2Sec;
    periodStartVideo = markers.P2Start;
    periodEndVideo = markers.P2End || (markers.P2Start + p2Sec);
  }
  if (markers.P3Start && videoSec >= markers.P3Start) {
    period = 3;
    periodSec = p3Sec;
    periodStartVideo = markers.P3Start;
    periodEndVideo = markers.P3End || (markers.P3Start + p3Sec);
  }
  if (markers.OTStart && videoSec >= markers.OTStart) {
    period = 4;
    periodSec = otSec;
    periodStartVideo = markers.OTStart;
    periodEndVideo = markers.OTEnd || (markers.OTStart + otSec);
  }
  
  // Calculate time elapsed in current period
  const elapsedInPeriod = videoSec - periodStartVideo;
  const timeRemaining = Math.max(0, periodSec - elapsedInPeriod);
  
  const min = Math.floor(timeRemaining / 60);
  const sec = Math.floor(timeRemaining % 60);
  
  return {
    period: period === 4 ? 'OT' : period,
    clock: `${min}:${String(sec).padStart(2, '0')}`,
    elapsed: elapsedInPeriod
  };
}

/**
 * Capture start time from video to event/shift
 */
function captureStartTime() {
  const videoTime = getVideoCurrentTime();
  const gameTime = calculateGameTimeFromVideo(videoTime);
  
  if (gameTime) {
    document.getElementById('evtStartTime').value = gameTime.clock;
    
    // Also set period if different
    if (gameTime.period && gameTime.period !== S.period) {
      toast(`Note: Video is in P${gameTime.period}, tracker in P${S.period}`, 'warning');
    }
    
    toast(`Start: ${gameTime.clock} (P${gameTime.period})`, 'success');
  }
}

/**
 * Capture end time from video to event/shift
 */
function captureEndTime() {
  const videoTime = getVideoCurrentTime();
  const gameTime = calculateGameTimeFromVideo(videoTime);
  
  if (gameTime) {
    document.getElementById('evtEndTime').value = gameTime.clock;
    toast(`End: ${gameTime.clock} (P${gameTime.period})`, 'success');
  }
}

/**
 * Toggle video auto-sync
 */
function toggleVideoAutoSync() {
  videoSyncEnabled = document.getElementById('videoAutoSync').checked;
}

/**
 * Set game marker from current video position
 */
function setGameMarker(markerName) {
  const videoTime = getVideoCurrentTime();
  
  if (!S.videoPlayer) S.videoPlayer = { sources: [], gameMarkers: {} };
  if (!S.videoPlayer.gameMarkers) S.videoPlayer.gameMarkers = {};
  
  S.videoPlayer.gameMarkers[markerName] = videoTime;
  
  updateMarkerStatus();
  saveGameData();
  
  const formattedTime = formatVideoTime(videoTime);
  toast(`Marker set: ${markerName} @ ${formattedTime}`, 'success');
}

function formatVideoTime(sec) {
  const m = Math.floor(sec / 60);
  const s = Math.floor(sec % 60);
  return `${m}:${String(s).padStart(2, '0')}`;
}

/**
 * Update marker status display
 */
function updateMarkerStatus() {
  const markers = S.videoPlayer?.gameMarkers || {};
  const count = Object.keys(markers).length;
  
  const statusEl = document.getElementById('markerStatus');
  if (statusEl) {
    if (count === 0) {
      statusEl.textContent = 'No markers set';
    } else {
      const markerList = Object.entries(markers)
        .map(([k, v]) => `${k}:${formatVideoTime(v)}`)
        .join(' | ');
      statusEl.textContent = markerList;
    }
  }
}

/**
 * Jump to a specific game marker
 */
function jumpToMarker(markerName) {
  const time = S.videoPlayer?.gameMarkers?.[markerName];
  if (time !== undefined) {
    videoSeekTo(time);
    toast(`Jumped to ${markerName}`, 'info');
  }
}

/**
 * Add stoppage marker at current position
 */
function addStoppageMarker() {
  const videoTime = getVideoCurrentTime();
  const gameTime = calculateGameTimeFromVideo(videoTime);
  
  const name = prompt('Stoppage name (e.g., "Timeout", "Injury"):', 'Stoppage');
  if (!name) return;
  
  if (!S.videoTiming.timeouts) S.videoTiming.timeouts = [];
  
  S.videoTiming.timeouts.push({
    period: gameTime?.period || S.period,
    gameTime: gameTime?.clock || '10:00',
    duration: 60, // Default 1 minute
    name: name,
    videoTime: videoTime
  });
  
  saveGameData();
  toast(`Added stoppage: ${name}`, 'success');
}

// ============================================================
// v23.4: VIDEO ZOOM
// ============================================================

/**
 * Set video zoom level
 */
function setVideoZoom(zoom) {
  currentVideoZoom = zoom;
  
  const container = document.getElementById('videoPlayerContainer');
  const videoEl = currentVideoSource === 'youtube' 
    ? document.getElementById('youtubePlayer')
    : document.getElementById('localVideoPlayer');
  
  if (videoEl) {
    videoEl.style.transform = `scale(${zoom})`;
    videoEl.style.transformOrigin = 'center center';
  }
  
  toast(`Zoom: ${Math.round(zoom * 100)}%`, 'info');
}

/**
 * Zoom in
 */
function videoZoomIn() {
  setVideoZoom(Math.min(currentVideoZoom + 0.25, 3));
}

/**
 * Zoom out
 */
function videoZoomOut() {
  setVideoZoom(Math.max(currentVideoZoom - 0.25, 0.5));
}

/**
 * Reset zoom
 */
function videoZoomReset() {
  setVideoZoom(1);
}

// ============================================================
// v23.4: VIDEO SOURCE SWITCHING
// ============================================================

/**
 * Add a video source with hotkey
 */
function addVideoSource(name, url, hotkey) {
  const source = { 
    id: Date.now(), 
    name, 
    url, 
    hotkey,
    type: extractYouTubeId(url) ? 'youtube' : 'local'
  };
  videoSources.push(source);
  
  updateVideoSourcesUI();
  saveVideoSources();
  toast(`Added source: ${name} (${hotkey})`, 'success');
  
  return source;
}

/**
 * Switch to video source by hotkey
 */
function switchVideoByHotkey(key) {
  const source = videoSources.find(s => s.hotkey === key);
  if (source) {
    loadVideo(source.url, source.name);
    setActiveVideoSource(source.id);
    toast(`Switched to: ${source.name} (Ctrl+${key})`, 'info');
  }
}

/**
 * Switch video source from dropdown
 */
function switchVideoSource() {
  const select = document.getElementById('videoSourceSelect');
  const sourceId = select.value;
  
  if (!sourceId) return;
  
  const source = videoSources.find(s => s.id == sourceId);
  if (source) {
    loadVideo(source.url, source.name);
    setActiveVideoSource(source.id);
  }
}

/**
 * Set active video source indicator
 */
function setActiveVideoSource(sourceId) {
  // Update dropdown
  const select = document.getElementById('videoSourceSelect');
  if (select) select.value = sourceId;
  
  // Store active source
  S.activeVideoSourceId = sourceId;
}

/**
 * Update video sources dropdown
 */
function updateVideoSourcesUI() {
  const select = document.getElementById('videoSourceSelect');
  if (!select) return;
  
  select.innerHTML = '<option value="">-- Sources --</option>' +
    videoSources.map(s => 
      `<option value="${s.id}">${s.name} (${s.hotkey || '-'})</option>`
    ).join('');
  
  // Also update hotkey bar
  renderVideoHotkeyBar();
}

/**
 * Render video hotkey bar showing quick-switch buttons
 */
function renderVideoHotkeyBar() {
  const bar = document.getElementById('videoHotkeyBar');
  if (!bar) return;
  
  if (videoSources.length === 0) {
    bar.innerHTML = '<span style="font-size:8px;color:var(--muted);">No sources</span>';
    return;
  }
  
  bar.innerHTML = videoSources.map(s => {
    const isActive = S.activeVideoSourceId === s.id;
    const bg = isActive ? 'var(--accent)' : 'var(--panel)';
    const color = isActive ? '#000' : 'var(--text)';
    return `<button class="btn-sm" onclick="switchVideoByHotkey('${s.hotkey}')" 
      title="${s.name} (Ctrl+${s.hotkey})" 
      style="min-width:20px;padding:2px 4px;font-size:9px;font-weight:bold;background:${bg};color:${color};">
      ${s.hotkey}
    </button>`;
  }).join('');
}

/**
 * Show video sources manager modal
 */
function showVideoSourcesManager() {
  const sourcesHtml = videoSources.length === 0 
    ? '<p style="color:var(--muted);font-size:11px;text-align:center;">No video sources added yet</p>'
    : `<table style="width:100%;font-size:11px;border-collapse:collapse;">
        <thead><tr style="background:var(--panel);"><th>Key</th><th>Name</th><th>Type</th><th></th></tr></thead>
        <tbody>
          ${videoSources.map(s => `
            <tr>
              <td style="padding:4px;text-align:center;"><kbd>${s.hotkey || '-'}</kbd></td>
              <td style="padding:4px;">${s.name}</td>
              <td style="padding:4px;">${s.type || 'local'}</td>
              <td style="padding:4px;">
                <button class="btn-sm btn-danger" onclick="removeVideoSource(${s.id})" style="padding:1px 4px;font-size:8px;">‚úï</button>
              </td>
            </tr>
          `).join('')}
        </tbody>
      </table>`;
  
  const html = `
    <h3>üé¨ Video Sources</h3>
    <p style="font-size:10px;color:var(--muted);margin-bottom:10px;">
      Press Ctrl+hotkey (Ctrl+1 to Ctrl+9) to instantly switch between video feeds
    </p>
    <div style="max-height:200px;overflow-y:auto;margin-bottom:15px;">
      ${sourcesHtml}
    </div>
    <div style="border-top:1px solid var(--border);padding-top:10px;">
      <button class="btn-sm btn-primary" onclick="closeModal();showAddVideoModal();" style="width:100%;">+ Add New Source</button>
    </div>
    <div style="margin-top:10px;text-align:right;">
      <button class="btn-sm" onclick="closeModal()">Close</button>
    </div>
  `;
  
  showModal(html);
}

/**
 * Remove a video source
 */
function removeVideoSource(id) {
  videoSources = videoSources.filter(s => s.id !== id);
  updateVideoSourcesUI();
  saveVideoSources();
  toast('Video source removed', 'info');
  
  // Refresh modal if open
  if (document.getElementById('genericModal').classList.contains('show')) {
    showVideoSourcesManager();
  }
}

/**
 * Show add video modal
 */
function showAddVideoModal() {
  const html = `
    <h3>üé¨ Add Video Source</h3>
    <div class="form-group" style="margin-bottom:8px;">
      <label>Video Name</label>
      <input type="text" id="addVideoName" placeholder="e.g., Main Camera, Overhead" style="width:100%;">
    </div>
    <div class="form-group" style="margin-bottom:8px;">
      <label>URL or YouTube Link</label>
      <input type="text" id="addVideoUrl" placeholder="https://youtube.com/watch?v=... or video file URL" style="width:100%;">
    </div>
    <div style="margin-bottom:8px;">
      <label style="font-size:10px;">Or load local file:</label>
      <input type="file" id="addVideoFile" accept="video/*" onchange="handleVideoFileSelect(event)" style="font-size:10px;">
    </div>
    <div class="form-group" style="margin-bottom:8px;">
      <label>Hotkey (1-9)</label>
      <input type="text" id="addVideoHotkey" placeholder="e.g., 1" maxlength="1" style="width:50px;">
    </div>
    <div class="modal-actions">
      <button class="btn-primary" onclick="confirmAddVideo()">Add Video</button>
      <button onclick="closeModal()">Cancel</button>
    </div>
  `;
  
  showModal(html);
}

function handleVideoFileSelect(event) {
  const file = event.target.files[0];
  if (file) {
    document.getElementById('addVideoUrl').value = URL.createObjectURL(file);
    if (!document.getElementById('addVideoName').value) {
      document.getElementById('addVideoName').value = file.name;
    }
  }
}

function confirmAddVideo() {
  const name = document.getElementById('addVideoName').value || 'Video';
  const url = document.getElementById('addVideoUrl').value;
  const hotkey = document.getElementById('addVideoHotkey').value;
  
  if (!url) {
    toast('Enter a video URL or select a file', 'warning');
    return;
  }
  
  // Add to sources list
  const sourceId = Date.now();
  const source = { 
    id: sourceId, 
    name, 
    url, 
    hotkey: hotkey || null,
    type: extractYouTubeId(url) ? 'youtube' : 'local'
  };
  videoSources.push(source);
  
  // Load the video
  loadVideo(url, name);
  setActiveVideoSource(sourceId);
  
  // Update UI
  updateVideoSourcesUI();
  saveVideoSources();
  
  closeModal();
  showVideoSection();
  
  toast(`Added: ${name}${hotkey ? ` (Ctrl+${hotkey} to switch)` : ''}`, 'success');
}

/**
 * Save video sources to localStorage
 */
function saveVideoSources() {
  localStorage.setItem('benchsight_videoSources', JSON.stringify(videoSources));
}

/**
 * Load video sources from localStorage
 */
function loadVideoSources() {
  try {
    const saved = localStorage.getItem('benchsight_videoSources');
    if (saved) {
      videoSources = JSON.parse(saved);
      updateVideoSourcesUI();
    }
  } catch (e) {
    console.error('Error loading video sources:', e);
  }
}

// ============================================================
// v23.4: VIDEO SCRUB BAR
// ============================================================

/**
 * Render video scrub bar with event markers
 */
function renderVideoScrubBar() {
  const container = document.getElementById('videoScrubBar');
  if (!container) return;
  
  const duration = getVideoDuration();
  if (!duration) return;
  
  // Get events and convert to video times
  const eventMarkers = S.events.map(evt => {
    const videoTime = calculateRunningVideoTime(
      evt.period === 'OT' ? 4 : parseInt(evt.period) || 1,
      evt.start_time
    );
    return {
      time: videoTime,
      type: evt.type,
      idx: evt.idx
    };
  }).filter(m => m.time <= duration);
  
  // Render scrub bar with markers
  container.innerHTML = `
    <div style="position:relative;height:20px;background:var(--panel);border-radius:3px;cursor:pointer;" onclick="handleScrubClick(event)">
      <div id="scrubProgress" style="position:absolute;height:100%;background:var(--accent);opacity:0.3;border-radius:3px;width:0%;"></div>
      ${eventMarkers.map(m => {
        const pct = (m.time / duration) * 100;
        const color = m.type === 'Goal' ? '#22c55e' : m.type === 'Shot' ? '#ef4444' : '#3b82f6';
        return `<div style="position:absolute;left:${pct}%;width:3px;height:100%;background:${color};" title="${m.type} #${m.idx}"></div>`;
      }).join('')}
    </div>
  `;
}

function handleScrubClick(event) {
  const rect = event.currentTarget.getBoundingClientRect();
  const pct = (event.clientX - rect.left) / rect.width;
  const duration = getVideoDuration();
  videoSeekTo(pct * duration);
}

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  // v23.9: XY tracking hotkeys
  if (e.key === 'p' || e.key === 'P') {
    if (e.ctrlKey || e.metaKey) {
      e.preventDefault();
      setXYMode('puck');
      toast('Switched to Puck XY mode', 'info');
      return;
    }
  }
  if (e.key === 'y' || e.key === 'Y') {
    if (e.ctrlKey || e.metaKey) {
      e.preventDefault();
      setXYMode('player');
      toast('Switched to Player XY mode', 'info');
      return;
    }
  }
  // Number keys 1-9 to select player by number for XY tracking
  if ((e.key >= '1' && e.key <= '9') && (e.ctrlKey || e.metaKey) && S.xyMode === 'player') {
    e.preventDefault();
    const num = parseInt(e.key);
    const player = S.curr.players.find(p => p.num == num);
    if (player) {
      selectXYPlayer(num);
    } else {
      toast(`Player #${num} not found`, 'error');
    }
    return;
  }
  
  // Don't trigger if typing in input (unless arrow keys in edit modal)
  const inInput = e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA';
  
  // Arrow keys work in modals for navigation
  if (document.getElementById('editModal').classList.contains('show')) {
    if (e.key === 'ArrowLeft') { navEditEvent(-1); e.preventDefault(); return; }
    if (e.key === 'ArrowRight') { navEditEvent(1); e.preventDefault(); return; }
  }
  if (document.getElementById('editShiftModal').classList.contains('show')) {
    if (e.key === 'ArrowLeft') { navEditShift(-1); e.preventDefault(); return; }
    if (e.key === 'ArrowRight') { navEditShift(1); e.preventDefault(); return; }
  }
  
  if (inInput) return;
  
  switch(e.key) {
    case '?': openHelp(); break;
    case 'Escape': 
      closeSettings(); closeHelp(); 
      document.querySelectorAll('.overlay.show').forEach(m => m.classList.remove('show'));
      break;
    
    // Event type hotkeys
    case 'f': case 'F': setEvtType('Faceoff'); break;
    case 's': case 'S': setEvtType('Shot'); break;
    case 'p': case 'P': setEvtType('Pass'); break;
    case 'g': case 'G': setEvtType('Goal'); break;
    case 't': case 'T': setEvtType('Turnover'); break;
    case 'z': case 'Z': setEvtType('Zone_Entry_Exit'); break;
    case 'n': case 'N': setEvtType('Penalty'); break;
    case 'x': case 'X': setEvtType('Stoppage'); break;
    case 'o': case 'O': setEvtType('Possession'); break;
    case 'v': case 'V': setEvtType('Save'); break;
    case 'r': case 'R': setEvtType('Rebound'); break;
    case 'd': case 'D': setEvtType('DeadIce'); break;
    
    // Quick actions
    case 'h': case 'H': document.getElementById('evtHighlight').checked = !document.getElementById('evtHighlight').checked; break;
    case 'l': case 'L': logEvent(); break;  // Log current event
    case 'Enter': logEvent(); break;  // Also log with Enter
    
    // Team toggle - removed 1/2, now use H/A (v16.06)
    // 1-6 handled in setupKeys() for player selection
    
    // Zone
    case 'q': setZone('o'); break;  // Offensive
    case 'w': setZone('n'); break;  // Neutral
    case 'e': setZone('d'); break;  // Defensive
    
    // Success
    case 'y': case 'Y': document.getElementById('evtSuccess').value = 's'; break;
    case 'u': case 'U': document.getElementById('evtSuccess').value = 'u'; break;
    
    // Period
    case '!': setPeriod(1); break;
    case '@': setPeriod(2); break;
    case '#': setPeriod(3); break;
    case '$': setPeriod('OT'); break;
    
    // Undo XY
    case 'Backspace': undoLastXY(); break;
    
    // Shift actions
    case '[': logShift(); toast('Shift logged', 'success'); break;
    case ']': 
      document.getElementById('shiftStart').value = document.getElementById('clock').value;
      toast('Shift start set', 'info'); 
      break;
    
    // Edit last event
    case 'i': case 'I': 
      if (S.events.length > 0) editEvent(S.events.length - 1);
      break;
    
    // Quick nav
    case ',': if (S.events.length > 0) editEvent(0); break;  // First event
    case '.': if (S.events.length > 0) editEvent(S.events.length - 1); break;  // Last event
    
    // v23.4: Video controls
    case ' ': // Space = play/pause
      e.preventDefault();
      videoPlayPause();
      break;
    case 'ArrowLeft':
      e.preventDefault();
      videoSeek(e.shiftKey ? -10 : -1); // Shift+Left = -10s
      break;
    case 'ArrowRight':
      e.preventDefault();
      videoSeek(e.shiftKey ? 10 : 1); // Shift+Right = +10s
      break;
    case 'ArrowUp':
      e.preventDefault();
      setVideoSpeed(Math.min(2, (getVideoSpeed() || 1) + 0.25));
      break;
    case 'ArrowDown':
      e.preventDefault();
      setVideoSpeed(Math.max(0.25, (getVideoSpeed() || 1) - 0.25));
      break;
    case ';': // Frame back
      videoFrameStep(-1);
      break;
    case "'": // Frame forward
      videoFrameStep(1);
      break;
    case '+': case '=':
      videoZoomIn();
      break;
    case '-': case '_':
      videoZoomOut();
      break;
    case '0':
      videoZoomReset();
      break;
  }
  
  // Video source switching: Ctrl+1-9 (avoids conflict with player 1-6)
  if (!inInput && e.key >= '1' && e.key <= '9' && e.ctrlKey && !e.altKey) {
    e.preventDefault(); // Prevent browser tab switching
    switchVideoByHotkey(e.key);
  }
});

// ============================================================
// v23.5: WORKFLOW IMPROVEMENTS
// ============================================================

// --- 1. QUICK REPLAY (rewind 5s on pause) ---
let quickReplayEnabled = true;
let wasPlayingBeforePause = false;

function videoPlayPauseWithReplay() {
  const isPlaying = currentVideoSource === 'youtube' 
    ? (ytPlayer && ytPlayer.getPlayerState() === YT.PlayerState.PLAYING)
    : (currentVideoSource === 'local' && !document.getElementById('localVideoPlayer').paused);
  
  if (isPlaying && quickReplayEnabled) {
    // Pausing - rewind 5s for context
    videoSeek(-5);
  }
  videoPlayPause();
}

function toggleQuickReplay() {
  quickReplayEnabled = !quickReplayEnabled;
  toast(`Quick replay: ${quickReplayEnabled ? 'ON' : 'OFF'}`, 'info');
}

// --- 2. EVENT SUGGESTIONS ---
const EVENT_SUGGESTIONS = {
  'Goal': ['Faceoff'],
  'Shot': ['Save', 'Rebound', 'Goal'],
  'Save': ['Rebound', 'Possession', 'Pass'],
  'Rebound': ['Shot', 'Goal', 'Possession'],
  'Faceoff': ['Pass', 'Possession', 'Shot'],
  'Pass': ['Shot', 'Pass', 'Possession'],
  'Turnover': ['Possession', 'Shot', 'Pass'],
  'Zone_Entry_Exit': ['Pass', 'Shot', 'Possession'],
  'Possession': ['Pass', 'Shot', 'Zone_Entry_Exit'],
  'Penalty': ['Faceoff'],
  'Stoppage': ['Faceoff']
};

let suggestionsEnabled = true;

function getSuggestedEvents() {
  if (!suggestionsEnabled || S.events.length === 0) return [];
  
  const lastEvent = S.events[S.events.length - 1];
  return EVENT_SUGGESTIONS[lastEvent.type] || [];
}

function renderEventSuggestions() {
  const container = document.getElementById('eventSuggestions');
  if (!container) return;
  
  const suggestions = getSuggestedEvents();
  if (suggestions.length === 0) {
    container.innerHTML = '';
    return;
  }
  
  container.innerHTML = `
    <span style="font-size:8px;color:var(--muted);">Next:</span>
    ${suggestions.map(s => `
      <button class="btn-sm" onclick="setEvtType('${s}')" 
        style="padding:2px 6px;font-size:9px;background:var(--panel);border:1px dashed var(--accent);">
        ${s.replace('_', ' ').substring(0, 6)}
      </button>
    `).join('')}
  `;
}

function toggleSuggestions() {
  suggestionsEnabled = !suggestionsEnabled;
  toast(`Suggestions: ${suggestionsEnabled ? 'ON' : 'OFF'}`, 'info');
  renderEventSuggestions();
}

// --- 3. POSSESSION TRACKER ---
let possessionTeam = null;
let possessionStartTime = null;
let possessionTimers = { home: 0, away: 0 };
let possessionInterval = null;

function setPossession(team) {
  if (possessionTeam === team) {
    // Toggle off
    stopPossessionTimer();
    possessionTeam = null;
    updatePossessionDisplay();
    return;
  }
  
  // Stop current timer if any
  if (possessionTeam) {
    stopPossessionTimer();
  }
  
  // Start new possession
  possessionTeam = team;
  possessionStartTime = Date.now();
  startPossessionTimer();
  updatePossessionDisplay();
}

function startPossessionTimer() {
  if (possessionInterval) clearInterval(possessionInterval);
  possessionInterval = setInterval(() => {
    if (possessionTeam) {
      possessionTimers[possessionTeam] += 0.1;
      updatePossessionDisplay();
    }
  }, 100);
}

function stopPossessionTimer() {
  if (possessionInterval) {
    clearInterval(possessionInterval);
    possessionInterval = null;
  }
}

function resetPossessionTimers() {
  possessionTimers = { home: 0, away: 0 };
  possessionTeam = null;
  stopPossessionTimer();
  updatePossessionDisplay();
}

function updatePossessionDisplay() {
  const display = document.getElementById('possessionDisplay');
  if (!display) return;
  
  const total = possessionTimers.home + possessionTimers.away;
  const homePct = total > 0 ? Math.round((possessionTimers.home / total) * 100) : 50;
  const awayPct = 100 - homePct;
  
  const homeActive = possessionTeam === 'home' ? 'font-weight:bold;' : '';
  const awayActive = possessionTeam === 'away' ? 'font-weight:bold;' : '';
  
  display.innerHTML = `
    <span style="color:var(--home);${homeActive}">${homePct}%</span>
    <div style="flex:1;height:6px;background:var(--away);border-radius:3px;margin:0 4px;overflow:hidden;">
      <div style="width:${homePct}%;height:100%;background:var(--home);"></div>
    </div>
    <span style="color:var(--away);${awayActive}">${awayPct}%</span>
  `;
}

function formatPossessionTime(sec) {
  const m = Math.floor(sec / 60);
  const s = Math.floor(sec % 60);
  return `${m}:${String(s).padStart(2, '0')}`;
}

// --- 4. PENALTY BOX MANAGER ---
let activePenalties = [];

function addPenalty(team, playerNum, minutes, startTime) {
  const penalty = {
    id: Date.now(),
    team,
    playerNum,
    minutes: minutes || 2,
    startTime: startTime || document.getElementById('clock').value,
    startTimestamp: Date.now()
  };
  activePenalties.push(penalty);
  updatePenaltyBox();
  startPenaltyCountdown();
}

function removePenalty(id) {
  activePenalties = activePenalties.filter(p => p.id !== id);
  updatePenaltyBox();
}

function startPenaltyCountdown() {
  // Update every second
  setInterval(updatePenaltyBox, 1000);
}

function updatePenaltyBox() {
  const container = document.getElementById('penaltyBoxDisplay');
  if (!container) return;
  
  if (activePenalties.length === 0) {
    container.innerHTML = '<span style="font-size:9px;color:var(--muted);">No penalties</span>';
    return;
  }
  
  const now = Date.now();
  
  container.innerHTML = activePenalties.map(p => {
    const elapsed = (now - p.startTimestamp) / 1000;
    const remaining = Math.max(0, (p.minutes * 60) - elapsed);
    const remainMin = Math.floor(remaining / 60);
    const remainSec = Math.floor(remaining % 60);
    const color = p.team === 'home' ? 'var(--home)' : 'var(--away)';
    
    // Auto-remove expired penalties
    if (remaining <= 0) {
      setTimeout(() => removePenalty(p.id), 100);
      return '';
    }
    
    return `
      <div style="display:inline-flex;align-items:center;gap:4px;background:${color};color:#fff;padding:2px 6px;border-radius:3px;font-size:9px;">
        <span>#${p.playerNum}</span>
        <span style="font-family:monospace;">${remainMin}:${String(remainSec).padStart(2,'0')}</span>
        <button onclick="removePenalty(${p.id})" style="background:none;border:none;color:#fff;cursor:pointer;font-size:8px;">‚úï</button>
      </div>
    `;
  }).join('');
  
  // Update strength indicator
  updateStrengthFromPenalties();
}

function updateStrengthFromPenalties() {
  const homePens = activePenalties.filter(p => p.team === 'home').length;
  const awayPens = activePenalties.filter(p => p.team === 'away').length;
  
  const homeStr = 5 - Math.min(homePens, 2);
  const awayStr = 5 - Math.min(awayPens, 2);
  
  const strengthEl = document.getElementById('qsStrength');
  if (strengthEl) {
    strengthEl.textContent = `${homeStr}v${awayStr}`;
    strengthEl.className = 'value strength-indicator';
    if (homeStr > awayStr) strengthEl.classList.add('pp');
    else if (awayStr > homeStr) strengthEl.classList.add('pk');
    else strengthEl.classList.add('even');
  }
}

// --- 5. STICKY RECENT PLAYERS ---
let recentPlayers = [];
const MAX_RECENT_PLAYERS = 8;

function addToRecentPlayers(player) {
  if (!player || !player.num) return;
  
  // Remove if already exists
  recentPlayers = recentPlayers.filter(p => 
    !(p.num === player.num && p.team === player.team)
  );
  
  // Add to front
  recentPlayers.unshift({
    num: player.num,
    name: player.name,
    team: player.team
  });
  
  // Limit size
  if (recentPlayers.length > MAX_RECENT_PLAYERS) {
    recentPlayers = recentPlayers.slice(0, MAX_RECENT_PLAYERS);
  }
  
  renderRecentPlayers();
}

function renderRecentPlayers() {
  const container = document.getElementById('recentPlayersBar');
  if (!container) return;
  
  if (recentPlayers.length === 0) {
    container.innerHTML = '<span style="font-size:8px;color:var(--muted);">Recent players appear here</span>';
    return;
  }
  
  container.innerHTML = recentPlayers.map(p => {
    const color = p.team === 'home' ? 'var(--home)' : 'var(--away)';
    return `
      <button class="btn-sm" onclick="quickAddRecentPlayer(${p.num}, '${p.team}')"
        style="padding:2px 6px;font-size:9px;border-left:3px solid ${color};">
        #${p.num}
      </button>
    `;
  }).join('');
}

function quickAddRecentPlayer(num, team) {
  const roster = team === 'home' ? S.homeRoster : S.awayRoster;
  const player = roster.find(p => p.num == num);
  if (player) {
    addEventPlayer({ ...player, team });
    toast(`Added #${num}`, 'success');
  }
}

// --- 6. QUICK NOTES ---
function addQuickNote() {
  const note = prompt('Add note to current event:');
  if (note) {
    S.curr.note = note;
    toast('Note added', 'success');
  }
}

function showEventNotes(idx) {
  const evt = S.events[idx];
  if (evt && evt.note) {
    alert(`Event #${idx + 1} Note:\n${evt.note}`);
  }
}

// --- 7. MULTI-LEVEL UNDO ---
const undoStack = [];
const MAX_UNDO = 20;

function pushUndoState(action) {
  undoStack.push({
    action,
    events: JSON.parse(JSON.stringify(S.events)),
    shifts: JSON.parse(JSON.stringify(S.shifts)),
    timestamp: Date.now()
  });
  
  if (undoStack.length > MAX_UNDO) {
    undoStack.shift();
  }
  
  updateUndoButton();
}

function undo() {
  if (undoStack.length === 0) {
    toast('Nothing to undo', 'warning');
    return;
  }
  
  const state = undoStack.pop();
  S.events = state.events;
  S.shifts = state.shifts;
  
  renderEvents();
  renderShifts();
  updateQuickStats();
  
  toast(`Undone: ${state.action}`, 'info');
  updateUndoButton();
}

function updateUndoButton() {
  const btn = document.getElementById('undoBtn');
  if (btn) {
    btn.disabled = undoStack.length === 0;
    btn.title = undoStack.length > 0 
      ? `Undo: ${undoStack[undoStack.length - 1].action} (${undoStack.length})`
      : 'Nothing to undo';
  }
}

/**
 * v24.0: Update game links in header (Norad and BenchSight)
 */
function updateGameLinks() {
  const noradLink = document.getElementById('noradLink');
  const benchsightGameLink = document.getElementById('benchsightGameLink');
  const gameLinksContainer = document.getElementById('gameLinks');
  
  if (S.gameId) {
    if (noradLink) {
      noradLink.href = `https://noradhockey.com/event/${S.gameId}`;
      noradLink.style.display = 'inline';
    }
    if (benchsightGameLink) {
      benchsightGameLink.href = `https://benchsight.io/norad/games/${S.gameId}`;
      benchsightGameLink.style.display = 'inline';
    }
    if (gameLinksContainer) {
      gameLinksContainer.style.display = 'flex';
    }
  } else {
    if (noradLink) noradLink.style.display = 'none';
    if (benchsightGameLink) benchsightGameLink.style.display = 'none';
    if (gameLinksContainer) gameLinksContainer.style.display = 'none';
  }
}

// --- 8. BATCH EDIT ---
let selectedEventIds = [];
let batchSelectMode = false;

function toggleBatchSelectMode() {
  batchSelectMode = !batchSelectMode;
  selectedEventIds = [];
  
  document.getElementById('batchSelectBtn').classList.toggle('active', batchSelectMode);
  
  if (batchSelectMode) {
    toast('Click events to select. Click again to apply changes.', 'info');
  } else {
    renderEvents();
  }
}

function toggleEventSelection(idx) {
  if (!batchSelectMode) return false;
  
  const eventIdx = selectedEventIds.indexOf(idx);
  if (eventIdx >= 0) {
    selectedEventIds.splice(eventIdx, 1);
  } else {
    selectedEventIds.push(idx);
  }
  
  renderEvents();
  return true; // Prevent normal click behavior
}

function applyBatchEdit() {
  if (selectedEventIds.length === 0) {
    toast('No events selected', 'warning');
    return;
  }
  
  const html = `
    <h3>üìù Batch Edit (${selectedEventIds.length} events)</h3>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
      <div class="form-group">
        <label>Zone</label>
        <select id="batchZone">
          <option value="">-- No change --</option>
          <option value="o">Offensive</option>
          <option value="n">Neutral</option>
          <option value="d">Defensive</option>
        </select>
      </div>
      <div class="form-group">
        <label>Success</label>
        <select id="batchSuccess">
          <option value="">-- No change --</option>
          <option value="s">Success</option>
          <option value="u">Unsuccess</option>
        </select>
      </div>
      <div class="form-group">
        <label>Highlight</label>
        <select id="batchHighlight">
          <option value="">-- No change --</option>
          <option value="true">Yes ‚≠ê</option>
          <option value="false">No</option>
        </select>
      </div>
      <div class="form-group">
        <label>Team</label>
        <select id="batchTeam">
          <option value="">-- No change --</option>
          <option value="home">Home</option>
          <option value="away">Away</option>
        </select>
      </div>
    </div>
    <div class="modal-actions">
      <button class="btn-primary" onclick="confirmBatchEdit()">Apply to ${selectedEventIds.length} Events</button>
      <button onclick="closeModal();toggleBatchSelectMode();">Cancel</button>
    </div>
  `;
  
  showModal(html);
}

function confirmBatchEdit() {
  const zone = document.getElementById('batchZone').value;
  const success = document.getElementById('batchSuccess').value;
  const highlight = document.getElementById('batchHighlight').value;
  const team = document.getElementById('batchTeam').value;
  
  pushUndoState('Batch edit');
  
  selectedEventIds.forEach(idx => {
    const evt = S.events.find(e => e.idx === idx);
    if (evt) {
      if (zone) evt.zone = zone;
      if (success) evt.success = success === 's';
      if (highlight !== '') evt.isHighlight = highlight === 'true';
      if (team) evt.team = team;
    }
  });
  
  closeModal();
  toggleBatchSelectMode();
  renderEvents();
  toast(`Updated ${selectedEventIds.length} events`, 'success');
}

// --- 9. GOAL REVIEW MODE ---
function startGoalReview(idx) {
  const evt = S.events.find(e => e.idx === idx);
  if (!evt || evt.type !== 'Goal') {
    toast('Select a goal event first', 'warning');
    return;
  }
  
  // Find video time for goal
  const videoTime = calculateRunningVideoTime(
    evt.period === 'OT' ? 4 : parseInt(evt.period) || 1,
    evt.start_time
  );
  
  // Seek to 10 seconds before goal
  videoSeekTo(Math.max(0, videoTime - 10));
  setVideoSpeed(0.5);
  
  toast('Goal review: Playing at 0.5x from 10s before', 'info');
  
  // Highlight related events
  highlightGoalSequence(idx);
}

function highlightGoalSequence(goalIdx) {
  // Find events within 30 seconds before goal
  const goal = S.events.find(e => e.idx === goalIdx);
  if (!goal) return;
  
  const goalTime = parseGameTime(goal.start_time);
  const relatedEvents = S.events.filter(e => {
    if (e.period !== goal.period) return false;
    const evtTime = parseGameTime(e.start_time);
    const diff = goalTime - evtTime; // Positive = before goal
    return diff >= 0 && diff <= 30;
  });
  
  // Mark these in UI
  relatedEvents.forEach(e => {
    const row = document.querySelector(`[data-evt-idx="${e.idx}"]`);
    if (row) row.classList.add('goal-sequence');
  });
}

function parseGameTime(timeStr) {
  if (!timeStr) return 0;
  const parts = timeStr.split(':');
  return parseInt(parts[0] || 0) * 60 + parseInt(parts[1] || 0);
}

// --- 10. KEYBOARD-ONLY XY MODE (WASD) ---
let keyboardXYMode = false;
let keyboardXYPosition = { x: 100, y: 42.5 }; // Center of rink

function toggleKeyboardXYMode() {
  keyboardXYMode = !keyboardXYMode;
  
  if (keyboardXYMode) {
    toast('Keyboard XY: WASD to move, Enter to place', 'info');
    showKeyboardCursor();
  } else {
    hideKeyboardCursor();
  }
}

function showKeyboardCursor() {
  let cursor = document.getElementById('keyboardXYCursor');
  if (!cursor) {
    cursor = document.createElement('div');
    cursor.id = 'keyboardXYCursor';
    cursor.style.cssText = `
      position: absolute;
      width: 12px;
      height: 12px;
      border: 2px solid var(--accent);
      border-radius: 50%;
      pointer-events: none;
      z-index: 100;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 8px var(--accent);
    `;
    document.querySelector('.rink-wrap').appendChild(cursor);
  }
  updateKeyboardCursor();
  cursor.style.display = 'block';
}

function hideKeyboardCursor() {
  const cursor = document.getElementById('keyboardXYCursor');
  if (cursor) cursor.style.display = 'none';
}

function updateKeyboardCursor() {
  const cursor = document.getElementById('keyboardXYCursor');
  if (!cursor) return;
  
  const svg = document.getElementById('rinkSvg');
  const rect = svg.getBoundingClientRect();
  
  // Convert SVG coords to screen coords
  const scaleX = rect.width / 200;
  const scaleY = rect.height / 85;
  
  cursor.style.left = `${keyboardXYPosition.x * scaleX}px`;
  cursor.style.top = `${keyboardXYPosition.y * scaleY}px`;
}

function moveKeyboardXY(dx, dy) {
  keyboardXYPosition.x = Math.max(0, Math.min(200, keyboardXYPosition.x + dx));
  keyboardXYPosition.y = Math.max(0, Math.min(85, keyboardXYPosition.y + dy));
  updateKeyboardCursor();
}

function placeKeyboardXY() {
  if (!keyboardXYMode) return;
  
  // Simulate click at current position
  handleXYPlacement(keyboardXYPosition.x, keyboardXYPosition.y);
  toast(`Placed at (${Math.round(keyboardXYPosition.x)}, ${Math.round(keyboardXYPosition.y)})`, 'success');
}

// Add keyboard handlers for WASD
document.addEventListener('keydown', (e) => {
  if (!keyboardXYMode) return;
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') return;
  
  const step = e.shiftKey ? 10 : 3;
  
  switch(e.key.toLowerCase()) {
    case 'w': moveKeyboardXY(0, -step); e.preventDefault(); break;
    case 'a': moveKeyboardXY(-step, 0); e.preventDefault(); break;
    case 's': moveKeyboardXY(0, step); e.preventDefault(); break;
    case 'd': moveKeyboardXY(step, 0); e.preventDefault(); break;
    case 'enter': placeKeyboardXY(); e.preventDefault(); break;
    case 'escape': toggleKeyboardXYMode(); e.preventDefault(); break;
  }
});

// --- 11. EVENT QUEUE (quick log, fill later) ---
let eventQueue = [];

function quickQueueEvent(type) {
  const videoTime = getVideoCurrentTime();
  const gameTime = calculateGameTimeFromVideo(videoTime);
  
  const evt = {
    id: Date.now(),
    type,
    period: gameTime?.period || S.period,
    start_time: gameTime?.clock || document.getElementById('clock').value,
    videoTime,
    team: document.getElementById('evtTeam').value,
    queued: true
  };
  
  eventQueue.push(evt);
  renderEventQueue();
  toast(`Queued: ${type}`, 'info');
}

function renderEventQueue() {
  const container = document.getElementById('eventQueueDisplay');
  if (!container) return;
  
  if (eventQueue.length === 0) {
    container.innerHTML = '';
    return;
  }
  
  container.innerHTML = `
    <div style="font-size:9px;color:var(--warn);margin-bottom:4px;">
      üìã Queue (${eventQueue.length}) - click to complete
    </div>
    ${eventQueue.map((e, i) => `
      <button class="btn-sm" onclick="processQueuedEvent(${i})"
        style="padding:2px 6px;font-size:9px;background:var(--warn);color:#000;margin:1px;">
        ${e.type.substring(0,4)} P${e.period} ${e.start_time}
      </button>
    `).join('')}
  `;
}

function processQueuedEvent(idx) {
  const evt = eventQueue[idx];
  if (!evt) return;
  
  // Load into current event form
  setEvtType(evt.type);
  document.getElementById('evtStartTime').value = evt.start_time;
  document.getElementById('evtTeam').value = evt.team;
  S.period = evt.period;
  document.querySelector('.period-btn.active')?.classList.remove('active');
  document.querySelector(`.period-btn[onclick*="${evt.period}"]`)?.classList.add('active');
  
  // Seek video to that time
  if (evt.videoTime) {
    videoSeekTo(evt.videoTime);
  }
  
  // Remove from queue
  eventQueue.splice(idx, 1);
  renderEventQueue();
  
  toast('Complete the event details and log', 'info');
}

function clearEventQueue() {
  if (eventQueue.length === 0) return;
  if (confirm(`Clear ${eventQueue.length} queued events?`)) {
    eventQueue = [];
    renderEventQueue();
  }
}

// --- 12. LIVE STATS OVERLAY ---
function toggleStatsOverlay() {
  let overlay = document.getElementById('liveStatsOverlay');
  
  if (overlay) {
    overlay.style.display = overlay.style.display === 'none' ? 'block' : 'none';
    return;
  }
  
  // Create overlay
  overlay = document.createElement('div');
  overlay.id = 'liveStatsOverlay';
  overlay.style.cssText = `
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(0,0,0,0.8);
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 10px;
    color: #fff;
    z-index: 50;
    pointer-events: none;
  `;
  
  document.getElementById('videoPlayerContainer').appendChild(overlay);
  updateStatsOverlay();
  
  // Update every second
  setInterval(updateStatsOverlay, 1000);
}

function updateStatsOverlay() {
  const overlay = document.getElementById('liveStatsOverlay');
  if (!overlay || overlay.style.display === 'none') return;
  
  const homeShots = S.events.filter(e => e.type === 'Shot' && e.team === 'home').length;
  const awayShots = S.events.filter(e => e.type === 'Shot' && e.team === 'away').length;
  const homeGoals = S.events.filter(e => e.type === 'Goal' && e.team === 'home').length;
  const awayGoals = S.events.filter(e => e.type === 'Goal' && e.team === 'away').length;
  
  overlay.innerHTML = `
    <div style="display:grid;grid-template-columns:1fr auto 1fr;gap:4px;text-align:center;">
      <span style="color:var(--home);">${S.homeTeam || 'HOME'}</span>
      <span></span>
      <span style="color:var(--away);">${S.awayTeam || 'AWAY'}</span>
      <span style="font-size:16px;font-weight:bold;">${homeGoals}</span>
      <span style="font-size:12px;">SCORE</span>
      <span style="font-size:16px;font-weight:bold;">${awayGoals}</span>
      <span>${homeShots}</span>
      <span style="font-size:8px;">SOG</span>
      <span>${awayShots}</span>
    </div>
  `;
}

// Hook into logEventDirect to track recent players and suggestions
const originalLogEventDirectV26 = typeof logEventDirect === 'function' ? logEventDirect : null;

// --- Initialize new features ---
function initV26Features() {
  renderEventSuggestions();
  renderRecentPlayers();
  renderEventQueue();
  updatePenaltyBox();
  updatePossessionDisplay();
  updateUndoButton();
  
  // Add CSS for goal sequence highlighting
  const style = document.createElement('style');
  style.textContent = `
    .goal-sequence { background: rgba(34, 197, 94, 0.2) !important; }
    .batch-selected { background: rgba(59, 130, 246, 0.3) !important; outline: 2px solid var(--accent); }
  `;
  document.head.appendChild(style);
}

// Call on init
setTimeout(initV26Features, 500);

// ============================================================
// v23.5: SPEED & WORKFLOW FEATURES
// ============================================================

// --- 1. MIRROR MODE (Auto-flip XY for period 2) ---
let mirrorModeEnabled = true;

function toggleMirrorMode() {
  mirrorModeEnabled = !mirrorModeEnabled;
  toast(`Mirror Mode: ${mirrorModeEnabled ? 'ON' : 'OFF'}`, 'info');
  updateMirrorModeIndicator();
}

function updateMirrorModeIndicator() {
  const btn = document.getElementById('mirrorModeBtn');
  if (btn) btn.classList.toggle('active', mirrorModeEnabled);
}

function shouldMirrorXY() {
  if (!mirrorModeEnabled) return false;
  // Mirror in periods 2, 4 (OT if even periods played)
  const period = S.period;
  return period === 2 || period === '2';
}

function applyMirror(x, y) {
  if (shouldMirrorXY()) {
    return { x: 200 - x, y: 85 - y }; // Flip both axes
  }
  return { x, y };
}

// --- 2. AUTO ZONE FROM XY ---
let autoZoneEnabled = true;
let autoPressureEnabled = true;
let autoSuccessEnabled = true;
let autoSideOfPuckEnabled = true;

/**
 * v23.9: Toggle collapsible section
 */
function toggleCollapsible(sectionId) {
  const content = document.getElementById(sectionId);
  const icon = document.getElementById(sectionId + 'Icon');
  if (!content) return;
  
  const isVisible = content.classList.contains('show') || content.style.display !== 'none';
  if (isVisible) {
    content.classList.remove('show');
    content.style.display = 'none';
    if (icon) icon.textContent = '‚ñ∂';
  } else {
    content.classList.add('show');
    // Check if content should be flex (has flex in style attribute or class)
    if (content.style.cssText.includes('display:flex') || content.style.cssText.includes('flex') || content.classList.contains('flex')) {
      content.style.display = 'flex';
    } else {
      content.style.display = 'block';
    }
    if (icon) icon.textContent = '‚ñº';
  }
}

/**
 * v23.9: Initialize collapsible sections - start expanded (visible by default)
 */
function initCollapsibleSections() {
  // Start with sections expanded (shown) - user can collapse if needed
  const sections = ['quickFaceoffRow', 'quickStoppageRow', 'quickPenaltyRow', 'eventTemplatesRow', 'linePresetsBar'];
  sections.forEach(id => {
    const content = document.getElementById(id);
    const icon = document.getElementById(id + 'Icon');
    if (content) {
      // Force add show class and set display with !important
      content.classList.add('show');
      // Set display based on whether it should be flex or block
      if (content.style.cssText.includes('flex') || id === 'quickFaceoffRow' || id === 'quickStoppageRow' || id === 'quickPenaltyRow' || id === 'eventTemplatesRow' || id === 'linePresetsBar') {
        content.style.setProperty('display', 'flex', 'important');
      } else {
        content.style.setProperty('display', 'block', 'important');
      }
      if (icon) icon.textContent = '‚ñº';
    }
  });
}

/**
 * v23.9: Get players from shift at a specific time
 */
function getPlayersFromShiftAtTime(timeStr, period) {
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'getPlayersFromShiftAtTime:5204',message:'Function entry',data:{timeStr,period,shiftsCount:S.shifts?.length||0,allShifts:S.shifts?.map(s=>({idx:s.idx,period:s.period,start:s.start_time,end:s.end_time||'ACTIVE'}))||[]},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
  // #endregion
  if (!timeStr || !period) {
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'getPlayersFromShiftAtTime:5206',message:'Early return - missing params',data:{timeStr,period},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
    // #endregion
    return null;
  }
  
  const parseTime = (t) => {
    if (!t) return 0;
    const [min, sec] = String(t).split(':').map(Number);
    return (min || 0) * 60 + (sec || 0);
  };
  const evtSec = parseTime(timeStr);
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'getPlayersFromShiftAtTime:5210',message:'Parsed event time',data:{timeStr,evtSec,period},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
  // #endregion
  
  // v23.9: Normalize period for comparison (handle string vs number mismatch)
  const normalizePeriod = (p) => {
    if (p === 'OT' || p === 4) return 'OT';
    return String(parseInt(p) || 1);
  };
  const normalizedPeriod = normalizePeriod(period);
  
  const shift = S.shifts.find(s => {
    // #region agent log
    const shiftIdx = S.shifts.indexOf(s);
    const shiftPeriodNorm = normalizePeriod(s.period);
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'getPlayersFromShiftAtTime:5215',message:'Evaluating shift',data:{shiftIdx,shiftPeriod:s.period,shiftPeriodNorm,eventPeriod:period,normalizedPeriod,periodMatch:shiftPeriodNorm===normalizedPeriod,shiftStartTime:s.start_time,shiftEndTime:s.end_time||'ACTIVE',hasStartTime:!!s.start_time},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
    // #endregion
    
    // v23.9: Compare normalized periods
    if (normalizePeriod(s.period) !== normalizedPeriod) return false;
    if (!s.start_time) return false;
    
    // v23.9: Handle shifts with empty end_time (active shifts)
    let timeMatch = false;
    if (!s.end_time || s.end_time.trim() === '') {
      // Active shift - check if event time is >= start time (clock counts down)
      const startSec = parseTime(s.start_time);
      timeMatch = evtSec <= startSec; // Event time is at or after shift start (lower number = later in period)
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'getPlayersFromShiftAtTime:5225',message:'Active shift time check',data:{shiftIdx,evtSec,startSec,evtLessEqualStart:evtSec<=startSec,timeMatch},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
      // #endregion
    } else {
      timeMatch = isTimeBetween(timeStr, s.start_time, s.end_time);
      // #region agent log
      const startSec = parseTime(s.start_time);
      const endSec = parseTime(s.end_time);
      fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'getPlayersFromShiftAtTime:5230',message:'Completed shift time check',data:{shiftIdx,evtSec,startSec,endSec,evtLessEqualStart:evtSec<=startSec,evtGreaterEqualEnd:evtSec>=endSec,timeMatch},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
      // #endregion
    }
    
    return timeMatch;
  });
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'getPlayersFromShiftAtTime:5235',message:'After finding shift',data:{shiftFound:!!shift,shiftPeriod:shift?.period,shiftStartTime:shift?.start_time,shiftEndTime:shift?.end_time,shiftHomeKeys:shift?.home?Object.keys(shift.home):[],shiftAwayKeys:shift?.away?Object.keys(shift.away):[]},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
  // #endregion
  if (!shift) return null;
  
  // Return players from this shift
  const players = [];
  ['F1','F2','F3','D1','D2','G','X'].forEach(pos => {
    if (shift.home?.[pos]?.num) {
      players.push({
        num: shift.home[pos].num,
        name: shift.home[pos].name || '',
        team: 'home',
        role: `event_team_player_${players.filter(p => p.team === 'home').length + 1}`,
        xy: [],
        playD1: '', playD2: '', playSuccess: '', pressure: '', sideOfPuck: ''
      });
    }
    if (shift.away?.[pos]?.num) {
      players.push({
        num: shift.away[pos].num,
        name: shift.away[pos].name || '',
        team: 'away',
        role: `opp_team_player_${players.filter(p => p.team === 'away').length + 1}`,
        xy: [],
        playD1: '', playD2: '', playSuccess: '', pressure: '', sideOfPuck: ''
      });
    }
  });
  
  return { shift, players };
}

/**
 * v23.9: When start time changes, get players from shift at that time
 */
function onStartTimeChange() {
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onStartTimeChange:5246',message:'Function entry',data:{timeStr:document.getElementById('evtStartTime')?.value,period:S.period,shiftsCount:S.shifts?.length||0,rostersHome:S.rosters?.home?.length||0,rostersAway:S.rosters?.away?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
  // #endregion
  const timeStr = document.getElementById('evtStartTime').value;
  const period = S.period;
  
  // v23.9: Auto-populate end time based on start time
  const endTimeEl = document.getElementById('evtEndTime');
  if (endTimeEl && timeStr) {
    // Only auto-populate if end time is currently empty or just has a minute (like "19:")
    const currentEndTime = endTimeEl.value.trim();
    const isEmptyOrPartial = !currentEndTime || currentEndTime.match(/^\d+:$/);
    
    if (isEmptyOrPartial && timeStr.includes(':')) {
      const [startMin, startSec] = timeStr.split(':');
      const startMinNum = parseInt(startMin) || 0;
      const startSecNum = parseInt(startSec) || 0;
      
      if (startSecNum === 0) {
        // If start is :00, end should be previous minute (e.g., 19:00 ‚Üí 18:)
        const endMin = Math.max(0, startMinNum - 1);
        endTimeEl.value = endMin + ':';
      } else {
        // If start has seconds, end should be same minute (e.g., 19:45 ‚Üí 19:)
        endTimeEl.value = startMin + ':';
      }
    }
  }
  
  if (!timeStr || timeStr.length < 4) {
    // Time not valid yet, but don't clear slots - user might still be typing
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onStartTimeChange:5250',message:'Early return - time too short',data:{timeStr,timeStrLength:timeStr?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
    // #endregion
    return;
  }
  
  // v23.9: Validate time format (MM:SS, seconds must be 0-59)
  if (timeStr.includes(':')) {
    const [min, sec] = timeStr.split(':');
    const minNum = parseInt(min) || 0;
    const secNum = parseInt(sec) || 0;
    if (secNum > 59 || secNum < 0 || minNum < 0) {
      // Invalid time format - don't process
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onStartTimeChange:5252',message:'Invalid time format',data:{timeStr,minNum,secNum},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
      // #endregion
      return;
    }
  }
  
  const result = getPlayersFromShiftAtTime(timeStr, period);
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onStartTimeChange:5255',message:'After getPlayersFromShiftAtTime',data:{resultFound:!!result,shiftFound:!!result?.shift,playersCount:result?.players?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
  // #endregion
  if (result && result.shift) {
    const shift = result.shift;
    
    // Populate slots from shift with correct positions
    // Clear existing slots first
    S.slots.home = { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null };
    S.slots.away = { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null };
    
    // Populate home team slots from shift (preserve positions)
    if (shift.home) {
      ['F1', 'F2', 'F3', 'D1', 'D2', 'G', 'X'].forEach(pos => {
        const p = shift.home[pos];
        if (p?.num) {
          // Find player in roster to get full details
          const rosterPlayer = S.rosters?.home?.find(rp => String(rp.num) === String(p.num));
          if (rosterPlayer) {
            S.slots.home[pos] = {
              num: rosterPlayer.num,
              name: rosterPlayer.name,
              pos: rosterPlayer.pos || pos
            };
          } else {
            // Fallback to shift data
            S.slots.home[pos] = {
              num: p.num,
              name: p.name || `#${p.num}`,
              pos: pos
            };
          }
        }
      });
    }
    
    // Populate away team slots from shift (preserve positions)
    if (shift.away) {
      ['F1', 'F2', 'F3', 'D1', 'D2', 'G', 'X'].forEach(pos => {
        const p = shift.away[pos];
        if (p?.num) {
          // Find player in roster to get full details
          const rosterPlayer = S.rosters?.away?.find(rp => String(rp.num) === String(p.num));
          if (rosterPlayer) {
            S.slots.away[pos] = {
              num: rosterPlayer.num,
              name: rosterPlayer.name,
              pos: rosterPlayer.pos || pos
            };
          } else {
            // Fallback to shift data
            S.slots.away[pos] = {
              num: p.num,
              name: p.name || `#${p.num}`,
              pos: pos
            };
          }
        }
      });
    }
    
    // Count how many players were populated
    const homeCount = Object.values(S.slots.home).filter(Boolean).length;
    const awayCount = Object.values(S.slots.away).filter(Boolean).length;
    
    // #region agent log
    const slotsHomeDetails = Object.entries(S.slots.home).filter(([k,v])=>v).map(([k,v])=>({pos:k,num:v.num,name:v.name}));
    const slotsAwayDetails = Object.entries(S.slots.away).filter(([k,v])=>v).map(([k,v])=>({pos:k,num:v.num,name:v.name}));
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onStartTimeChange:5329',message:'After populating slots',data:{homeCount,awayCount,evtTeam:S.evtTeam,slotsHomeDetails,slotsAwayDetails,rostersHomeCount:S.rosters?.home?.length||0,rostersAwayCount:S.rosters?.away?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
    // #endregion
    if (homeCount > 0 || awayCount > 0) {
      renderQuickAdd();
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onStartTimeChange:5336',message:'After renderQuickAdd call',data:{homeCount,awayCount},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
      // #endregion
      toast(`Players from shift at ${timeStr} available (${homeCount + awayCount} players)`, 'success');
    } else {
      toast(`No shift found at ${timeStr} in period ${period}`, 'warning');
    }
  } else {
    // No shift found at this time
    console.log('No shift found at time:', timeStr, 'period:', period);
    toast(`No shift found at ${timeStr} in period ${period}`, 'warning');
  }
}

function toggleAutoZone() {
  autoZoneEnabled = !autoZoneEnabled;
  toast(`Auto Zone: ${autoZoneEnabled ? 'ON' : 'OFF'}`, 'info');
  saveAutoSettings();
}

function toggleAutoPressure() {
  autoPressureEnabled = !autoPressureEnabled;
  toast(`Auto Pressure: ${autoPressureEnabled ? 'ON' : 'OFF'}`, 'info');
  saveAutoSettings();
  if (autoPressureEnabled) autoDetectAllPressure();
}

function toggleAutoSuccess() {
  autoSuccessEnabled = !autoSuccessEnabled;
  toast(`Auto Success: ${autoSuccessEnabled ? 'ON' : 'OFF'}`, 'info');
  saveAutoSettings();
  if (autoSuccessEnabled) autoDetectAllSuccess();
}

function toggleAutoSideOfPuck() {
  autoSideOfPuckEnabled = !autoSideOfPuckEnabled;
  toast(`Auto Side of Puck: ${autoSideOfPuckEnabled ? 'ON' : 'OFF'}`, 'info');
  saveAutoSettings();
  if (autoSideOfPuckEnabled) autoDetectAllSideOfPuck();
}

function saveAutoSettings() {
  localStorage.setItem('benchsight_autoZone', autoZoneEnabled);
  localStorage.setItem('benchsight_autoPressure', autoPressureEnabled);
  localStorage.setItem('benchsight_autoSuccess', autoSuccessEnabled);
  localStorage.setItem('benchsight_autoSideOfPuck', autoSideOfPuckEnabled);
}

function loadAutoSettings() {
  const savedZone = localStorage.getItem('benchsight_autoZone');
  const savedPressure = localStorage.getItem('benchsight_autoPressure');
  const savedSuccess = localStorage.getItem('benchsight_autoSuccess');
  const savedSide = localStorage.getItem('benchsight_autoSideOfPuck');
  
  if (savedZone !== null) autoZoneEnabled = savedZone === 'true';
  if (savedPressure !== null) autoPressureEnabled = savedPressure === 'true';
  if (savedSuccess !== null) autoSuccessEnabled = savedSuccess === 'true';
  if (savedSide !== null) autoSideOfPuckEnabled = savedSide === 'true';
}

/**
 * Get zone from X coordinate for a specific team and period
 * @param {number} x - X coordinate (0-200)
 * @param {string} team - 'home' or 'away'
 * @param {number} period - Period number (1, 2, 3, etc.)
 * @returns {string} 'o' (offensive), 'd' (defensive), or 'n' (neutral)
 */
function getZoneFromX(x, team, period) {
  if (x == null || x === undefined || x === '') return null;
  
  // Rink is 200 units wide
  // Determine which end the team attacks in this period
  const isOddPeriod = period === 1 || period === 3 || period === 'OT' || period === 'OT1' || period === 'OT2' || period === 'OT3';
  const homeAttacksRightP1 = S.homeAttacksRightP1 !== false; // Default to true if not set
  
  // In odd periods, home attacks the same direction as P1
  // In even periods, home attacks the opposite direction (teams switch ends)
  const homeAttacksRight = isOddPeriod ? homeAttacksRightP1 : !homeAttacksRightP1;
  
  // Determine if the specified team attacks right in this period
  const teamAttacksRight = (team === 'home') ? homeAttacksRight : !homeAttacksRight;
  
  if (teamAttacksRight) {
    // Team attacks right: Offensive = right side (x > 140), Defensive = left (x < 60)
    if (x > 140) return 'o';
    if (x < 60) return 'd';
    return 'n';
  } else {
    // Team attacks left: Offensive = left side (x < 60), Defensive = right (x > 140)
    if (x < 60) return 'o';
    if (x > 140) return 'd';
    return 'n';
  }
}

function getZoneFromXY(x) {
  // Rink is 200 units wide
  // Use event team and current period to determine zone
  const period = S.period || 1;
  const eventTeam = S.evtTeam || 'home';
  
  // Use the same logic as getZoneFromX for consistency
  return getZoneFromX(x, eventTeam, period);
}

function autoSetZoneFromXY(x) {
  if (!autoZoneEnabled) return;
  if (typeof getZoneFromXY !== 'function') return;
  const zone = getZoneFromXY(x);
  if (zone) {
    if (typeof setZone === 'function') setZone(zone);
    // Also update zone display
    if (typeof updateZoneDisplay === 'function') updateZoneDisplay();
  }
}

// --- 3. GOALIE AUTO-ADD ---
let goalieAutoAddEnabled = true;

function toggleGoalieAutoAdd() {
  goalieAutoAddEnabled = !goalieAutoAddEnabled;
  toast(`Goalie Auto-Add: ${goalieAutoAddEnabled ? 'ON' : 'OFF'}`, 'info');
}

function autoAddGoalie() {
  if (!goalieAutoAddEnabled) return;
  
  const evtTypeEl = document.getElementById('evtType');
  if (!evtTypeEl) return;
  const evtType = evtTypeEl.value;
  if (!['Shot', 'Goal', 'Save', 'Rebound'].includes(evtType)) return;
  
  // Find opposing goalie
  const oppTeam = S.evtTeam === 'home' ? 'away' : 'home';
  const roster = S.rosters?.[oppTeam] || [];
  const goalie = roster.find(p => p.pos === 'G' || p.position === 'G' || p.position === 'Goalie');
  
  if (goalie) {
    // Check if already added
    const alreadyAdded = S.curr.players?.some(p => p.num == goalie.num && p.team === oppTeam);
    if (!alreadyAdded) {
      addEventPlayer({ ...goalie, team: oppTeam, role: 'opp_team_player_1' });
    }
  }
}

// --- 4. QUICK STRENGTH BUTTONS ---
function setStrength(strength) {
  document.getElementById('evtStrength').value = strength;
  
  // Update button states
  document.querySelectorAll('.strength-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.strength === strength);
  });
  
  toast(`Strength: ${strength}`, 'info');
}

// --- 5. ENHANCED FACEOFF PRESETS ---
function setupFaceoffWithPlayers(dotName, homeCenter, awayCenter) {
  // Set faceoff type
  setEvtType('Faceoff');
  
  // Position at dot
  if (typeof positionAtFaceoffDot === 'function') {
    const dot = FACEOFF_DOTS?.find(d => d.name === dotName);
    if (dot) {
      handleFaceoffDotClick(dot);
    }
  }
  
  // Add centers if provided
  if (homeCenter) {
    const homePlayer = S.homeRoster.find(p => p.num == homeCenter);
    if (homePlayer) addEventPlayer({ ...homePlayer, team: 'home' });
  }
  if (awayCenter) {
    const awayPlayer = S.awayRoster.find(p => p.num == awayCenter);
    if (awayPlayer) addEventPlayer({ ...awayPlayer, team: 'away', role: 'opp_team_player_1' });
  }
}

// --- 6. GAP FINDER ---
function findEventGaps() {
  const events = S.events || [];
  if (events.length < 2) {
    toast('Need at least 2 events to find gaps', 'warning');
    return;
  }
  
  const gaps = [];
  const minGapSeconds = 60; // Report gaps > 1 minute
  
  for (let i = 1; i < events.length; i++) {
    const prev = events[i - 1];
    const curr = events[i];
    
    if (prev.period !== curr.period) continue;
    
    const prevTime = parseGameTime(prev.start_time);
    const currTime = parseGameTime(curr.start_time);
    const gapSec = prevTime - currTime; // Clock counts down
    
    if (gapSec > minGapSeconds) {
      gaps.push({
        period: curr.period,
        from: curr.start_time,
        to: prev.start_time,
        duration: gapSec,
        afterEvent: i - 1
      });
    }
  }
  
  if (gaps.length === 0) {
    toast('No significant gaps found!', 'success');
    return;
  }
  
  // Show gaps
  const html = `
    <h3>üîç Event Gaps Found (>${minGapSeconds}s)</h3>
    <div style="max-height:300px;overflow-y:auto;">
      <table style="width:100%;font-size:10px;border-collapse:collapse;">
        <thead>
          <tr style="background:var(--panel);">
            <th style="padding:4px;">Period</th>
            <th style="padding:4px;">From</th>
            <th style="padding:4px;">To</th>
            <th style="padding:4px;">Gap</th>
            <th style="padding:4px;">Action</th>
          </tr>
        </thead>
        <tbody>
          ${gaps.map(g => `
            <tr>
              <td style="padding:4px;text-align:center;">P${g.period}</td>
              <td style="padding:4px;text-align:center;">${g.from}</td>
              <td style="padding:4px;text-align:center;">${g.to}</td>
              <td style="padding:4px;text-align:center;color:var(--warn);">${Math.floor(g.duration / 60)}:${String(g.duration % 60).padStart(2, '0')}</td>
              <td style="padding:4px;text-align:center;">
                <button class="btn-sm" onclick="jumpToGap(${g.period}, '${g.from}')" style="font-size:8px;">Go</button>
              </td>
            </tr>
          `).join('')}
        </tbody>
      </table>
    </div>
    <div style="margin-top:10px;font-size:9px;color:var(--muted);">
      Found ${gaps.length} gap(s). Click "Go" to seek video to that time.
    </div>
    <div class="modal-actions">
      <button onclick="closeModal()">Close</button>
    </div>
  `;
  
  showModal(html);
}

function jumpToGap(period, time) {
  const videoTime = calculateRunningVideoTime(period, time);
  videoSeekTo(videoTime);
  closeModal();
  toast(`Jumped to P${period} ${time}`, 'info');
}

// --- 7. DUPLICATE DETECTION ---
let duplicateCheckEnabled = true;

function checkForDuplicate() {
  if (!duplicateCheckEnabled || S.events.length === 0) return null;
  
  const curr = S.curr;
  const type = document.getElementById('evtType').value;
  const time = document.getElementById('evtStartTime').value;
  const team = document.getElementById('evtTeam').value;
  
  if (!type || !time) return null;
  
  // Look for similar event in last 10 events
  const recent = S.events.slice(-10);
  
  for (const evt of recent) {
    if (evt.type !== type) continue;
    if (evt.team !== team) continue;
    if (evt.period !== S.period) continue;
    
    // Check if time is within 5 seconds
    const evtTimeSec = parseGameTime(evt.start_time);
    const currTimeSec = parseGameTime(time);
    
    if (Math.abs(evtTimeSec - currTimeSec) <= 5) {
      return evt;
    }
  }
  
  return null;
}

function warnIfDuplicate() {
  const dup = checkForDuplicate();
  if (dup) {
    const idx = S.events.indexOf(dup);
    toast(`‚ö†Ô∏è Similar to event #${idx + 1} (${dup.type} @ ${dup.start_time})`, 'warning');
    return true;
  }
  return false;
}

// --- 8. AUTO-LINK SUGGESTIONS ---
function suggestEventLink() {
  const type = S.curr.type || document.getElementById('evtType')?.value;
  if (!type || S.events.length === 0) return;
  
  // Types that should link to previous
  const linkTypes = {
    'Save': ['Shot'],
    'Rebound': ['Shot', 'Save'],
    'Goal': ['Shot', 'Rebound'],
    'Turnover': ['Pass', 'Possession'],
    'Possession': ['Turnover', 'Faceoff', 'Save']
  };
  
  const shouldLinkTo = linkTypes[type];
  if (!shouldLinkTo) return;
  
  // Find last event of matching type
  for (let i = S.events.length - 1; i >= Math.max(0, S.events.length - 5); i--) {
    const evt = S.events[i];
    if (shouldLinkTo.includes(evt.type) && evt.period === S.period) {
      // Suggest link
      const linkEl = document.getElementById('evtLinked');
      if (linkEl && !linkEl.value) {
        linkEl.value = i + 1;
        toast(`Auto-linked to #${i + 1} (${evt.type})`, 'info');
      }
      return;
    }
  }
}

// --- 9. SHIFT LENGTH ALERT ---
let shiftAlertThreshold = 45; // seconds
let shiftCriticalThreshold = 60;
let shiftAlertInterval = null;

function startShiftAlerts() {
  if (shiftAlertInterval) clearInterval(shiftAlertInterval);
  
  shiftAlertInterval = setInterval(() => {
    checkShiftLengths();
  }, 5000);
}

function checkShiftLengths() {
  // Find active shifts (started but not ended)
  const currentTime = document.getElementById('clock').value;
  const currentTimeSec = parseGameTime(currentTime);
  
  S.shifts?.forEach((shift, idx) => {
    if (shift.end_time) return; // Already ended
    if (shift.period !== S.period) return;
    
    const startSec = parseGameTime(shift.start_time);
    const duration = startSec - currentTimeSec;
    
    if (duration >= shiftCriticalThreshold) {
      // Critical - highlight in red
      highlightShift(idx, 'critical');
    } else if (duration >= shiftAlertThreshold) {
      // Warning - highlight in yellow
      highlightShift(idx, 'warning');
    }
  });
}

function highlightShift(idx, level) {
  const row = document.querySelector(`[data-shift-idx="${idx}"]`);
  if (row) {
    row.classList.remove('shift-warning', 'shift-critical');
    row.classList.add(`shift-${level}`);
  }
}

// --- 10. NUMPAD MODE ---
let numpadModeEnabled = false;

function toggleNumpadMode() {
  numpadModeEnabled = !numpadModeEnabled;
  toast(`Numpad Mode: ${numpadModeEnabled ? 'ON - Use numpad for players' : 'OFF'}`, 'info');
}

// Numpad handler (separate from main keyboard)
document.addEventListener('keydown', (e) => {
  if (!numpadModeEnabled) return;
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') return;
  
  // Numpad keys
  const numpadMap = {
    'Numpad1': 1, 'Numpad2': 2, 'Numpad3': 3,
    'Numpad4': 4, 'Numpad5': 5, 'Numpad6': 6,
    'Numpad7': 7, 'Numpad8': 8, 'Numpad9': 9,
    'Numpad0': 10
  };
  
  if (numpadMap[e.code]) {
    e.preventDefault();
    const slot = numpadMap[e.code];
    
    if (e.shiftKey) {
      // Opponent player
      selectEventPlayerSlot('opp', Math.min(slot, 6));
    } else {
      // Event player
      selectEventPlayerSlot('evt', Math.min(slot, 6));
    }
  }
  
  // NumpadEnter = log event
  if (e.code === 'NumpadEnter') {
    e.preventDefault();
    logEvent();
  }
  
  // NumpadAdd = highlight
  if (e.code === 'NumpadAdd') {
    e.preventDefault();
    document.getElementById('evtHighlight').checked = true;
  }
});

// --- 11. ICING/OFFSIDE QUICK BUTTONS ---
function quickIcing(team) {
  setEvtType('Stoppage');
  document.getElementById('evtD1').value = 'Stoppage_Icing';
  document.getElementById('evtTeam').value = team;
  toast('Icing - ready to log', 'info');
}

function quickOffside() {
  setEvtType('Stoppage');
  document.getElementById('evtD1').value = 'Stoppage_Offside';
  toast('Offside - ready to log', 'info');
}

// --- 12. EMPTY NET TOGGLE ---
let emptyNetTeam = null;

function toggleEmptyNet(team) {
  if (emptyNetTeam === team) {
    emptyNetTeam = null;
    toast('Empty net cleared', 'info');
  } else {
    emptyNetTeam = team;
    toast(`Empty net: ${team.toUpperCase()}`, 'warn');
  }
  updateEmptyNetIndicator();
}

function updateEmptyNetIndicator() {
  const indicator = document.getElementById('emptyNetIndicator');
  if (indicator) {
    if (emptyNetTeam) {
      indicator.textContent = `EN: ${emptyNetTeam.toUpperCase()}`;
      indicator.style.display = 'inline';
      indicator.style.color = emptyNetTeam === 'home' ? 'var(--home)' : 'var(--away)';
    } else {
      indicator.style.display = 'none';
    }
  }
}

// --- Hook into setEvtType to auto-add goalie and suggest links ---
const originalSetEvtType = typeof setEvtType === 'function' ? setEvtType : null;
if (originalSetEvtType) {
  setEvtType = function(type) {
    originalSetEvtType(type);
    
    // Auto-add goalie
    setTimeout(() => {
      autoAddGoalie();
      suggestEventLink();
    }, 100);
  };
}

// --- Hook into handleXYPlacement to auto-set zone ---
function enhanceXYPlacement(x, y) {
  // Apply mirror
  const mirrored = applyMirror(x, y);
  
  // Auto-set zone
  autoSetZoneFromXY(mirrored.x);
  
  return mirrored;
}

// --- Initialize shift alerts ---
setTimeout(startShiftAlerts, 1000);

// --- Add CSS for shift alerts ---
const shiftAlertStyle = document.createElement('style');
shiftAlertStyle.textContent = `
  .shift-warning { background: rgba(245, 158, 11, 0.3) !important; }
  .shift-critical { background: rgba(239, 68, 68, 0.4) !important; animation: pulse 0.5s infinite; }
  @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
  .mode-btn.active { background: var(--accent) !important; color: #000 !important; }
`;
document.head.appendChild(shiftAlertStyle);

// ============================================================
// v23.5: ADDITIONAL SPEED FEATURES
// ============================================================

// --- 13. SMART DEFAULTS (Learn patterns) ---
let eventPatterns = {};

function learnEventPattern() {
  const type = document.getElementById('evtType').value;
  const d1 = document.getElementById('evtD1').value;
  const d2 = document.getElementById('evtD2').value;
  const zone = document.getElementById('evtZone').value;
  
  if (!type) return;
  
  if (!eventPatterns[type]) {
    eventPatterns[type] = { d1: {}, d2: {}, zone: {} };
  }
  
  // Count occurrences
  if (d1) eventPatterns[type].d1[d1] = (eventPatterns[type].d1[d1] || 0) + 1;
  if (d2) eventPatterns[type].d2[d2] = (eventPatterns[type].d2[d2] || 0) + 1;
  if (zone) eventPatterns[type].zone[zone] = (eventPatterns[type].zone[zone] || 0) + 1;
}

function applySmartDefaults(type) {
  const pattern = eventPatterns[type];
  if (!pattern) return;
  
  // Find most common d1
  const topD1 = Object.entries(pattern.d1).sort((a, b) => b[1] - a[1])[0];
  if (topD1 && topD1[1] >= 3) {
    document.getElementById('evtD1').value = topD1[0];
  }
  
  // Find most common zone
  const topZone = Object.entries(pattern.zone).sort((a, b) => b[1] - a[1])[0];
  if (topZone && topZone[1] >= 3) {
    setZone(topZone[0]);
  }
}

// --- 14. EVENT MACROS ---
let eventMacros = [];
let recordingMacro = false;
let currentMacroEvents = [];

function startRecordingMacro() {
  recordingMacro = true;
  currentMacroEvents = [];
  toast('Recording macro... Log events, then click Stop', 'info');
  updateMacroRecordingUI();
}

function stopRecordingMacro() {
  recordingMacro = false;
  
  if (currentMacroEvents.length === 0) {
    toast('No events recorded', 'warning');
    updateMacroRecordingUI();
    return;
  }
  
  const name = prompt(`Name this macro (${currentMacroEvents.length} events):`);
  if (name) {
    eventMacros.push({
      name,
      events: currentMacroEvents,
      created: new Date().toISOString()
    });
    saveMacros();
    toast(`Macro "${name}" saved`, 'success');
  }
  
  currentMacroEvents = [];
  updateMacroRecordingUI();
}

function recordEventForMacro(evt) {
  if (!recordingMacro) return;
  
  currentMacroEvents.push({
    type: evt.type,
    detail1: evt.detail1 || evt.detail,
    detail2: evt.detail2,
    zone: evt.zone,
    success: evt.success,
    playerCount: (evt.players || []).length
  });
}

function playMacro(macroIdx) {
  const macro = eventMacros[macroIdx];
  if (!macro) return;
  
  toast(`Playing macro: ${macro.name}`, 'info');
  
  macro.events.forEach((evt, i) => {
    setTimeout(() => {
      setEvtType(evt.type);
      if (evt.detail1) document.getElementById('evtD1').value = evt.detail1;
      if (evt.detail2) document.getElementById('evtD2').value = evt.detail2;
      if (evt.zone) setZone(evt.zone);
      
      toast(`Macro step ${i + 1}/${macro.events.length}: ${evt.type}`, 'info');
    }, i * 500);
  });
}

function saveMacros() {
  localStorage.setItem('benchsight_macros', JSON.stringify(eventMacros));
}

function loadMacros() {
  const saved = localStorage.getItem('benchsight_macros');
  if (saved) {
    try {
      eventMacros = JSON.parse(saved);
    } catch (e) {
      eventMacros = [];
    }
  }
}

function updateMacroRecordingUI() {
  const btn = document.getElementById('macroRecordBtn');
  if (btn) {
    btn.textContent = recordingMacro ? '‚èπ Stop' : '‚è∫ Rec';
    btn.style.background = recordingMacro ? 'var(--danger)' : '';
  }
}

function showMacroManager() {
  loadMacros();
  
  const html = `
    <h3>üé¨ Event Macros</h3>
    <div style="margin-bottom:10px;">
      <button class="btn-sm" id="macroRecordBtn" onclick="${recordingMacro ? 'stopRecordingMacro()' : 'startRecordingMacro()'}">
        ${recordingMacro ? '‚èπ Stop Recording' : '‚è∫ Record New'}
      </button>
    </div>
    <div style="max-height:250px;overflow-y:auto;">
      ${eventMacros.length === 0 ? '<p style="color:var(--muted);">No macros saved</p>' : 
        eventMacros.map((m, i) => `
          <div style="display:flex;justify-content:space-between;align-items:center;padding:6px;background:var(--panel);margin:4px 0;border-radius:4px;">
            <span><strong>${m.name}</strong> (${m.events.length} events)</span>
            <div>
              <button class="btn-sm" onclick="playMacro(${i})" style="font-size:9px;">‚ñ∂ Play</button>
              <button class="btn-sm" onclick="deleteMacro(${i})" style="font-size:9px;background:var(--danger);">‚úï</button>
            </div>
          </div>
        `).join('')
      }
    </div>
    <div class="modal-actions">
      <button onclick="closeModal()">Close</button>
    </div>
  `;
  
  showModal(html);
}

function deleteMacro(idx) {
  if (confirm(`Delete macro "${eventMacros[idx].name}"?`)) {
    eventMacros.splice(idx, 1);
    saveMacros();
    showMacroManager();
  }
}

// Load macros on init
setTimeout(loadMacros, 100);

// --- 15. SHOT CHART OVERLAY ---
let shotChartOverlayEnabled = false;

function toggleShotChartOverlay() {
  shotChartOverlayEnabled = !shotChartOverlayEnabled;
  
  if (shotChartOverlayEnabled) {
    renderShotChartOverlay();
    toast('Shot chart overlay ON', 'info');
  } else {
    clearShotChartOverlay();
    toast('Shot chart overlay OFF', 'info');
  }
}

function renderShotChartOverlay() {
  clearShotChartOverlay();
  
  const svg = document.getElementById('rinkSvg');
  if (!svg) return;
  
  // Get all shots and goals with XY
  const shots = (S.events || []).filter(e => 
    ['Shot', 'Goal'].includes(e.type) && e.puckXY && e.puckXY.length > 0
  );
  
  shots.forEach(shot => {
    const xy = shot.puckXY[0];
    const isGoal = shot.type === 'Goal';
    const color = shot.team === 'home' ? 'var(--home)' : 'var(--away)';
    
    const marker = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    marker.setAttribute('cx', xy.x);
    marker.setAttribute('cy', xy.y);
    marker.setAttribute('r', isGoal ? 4 : 3);
    marker.setAttribute('fill', isGoal ? '#22c55e' : color);
    marker.setAttribute('stroke', '#fff');
    marker.setAttribute('stroke-width', '1');
    marker.setAttribute('opacity', '0.7');
    marker.setAttribute('class', 'shot-overlay-marker');
    marker.setAttribute('data-event-idx', S.events.indexOf(shot));
    
    // Tooltip
    marker.setAttribute('title', `${shot.type} #${S.events.indexOf(shot) + 1}`);
    
    svg.appendChild(marker);
  });
}

function clearShotChartOverlay() {
  document.querySelectorAll('.shot-overlay-marker').forEach(el => el.remove());
}

// Update overlay when events change
function refreshShotChartOverlay() {
  if (shotChartOverlayEnabled) {
    renderShotChartOverlay();
  }
}

// --- 16. PROGRESS ESTIMATOR ---
function getProgressEstimate() {
  const events = S.events || [];
  const period = S.period;
  
  // Estimate based on typical event count per period
  const eventsPerPeriod = 50; // Rough estimate
  const totalPeriods = 3;
  
  const periodEvents = events.filter(e => e.period == period).length;
  const completedPeriods = (parseInt(period) || 1) - 1;
  
  const estimatedTotal = eventsPerPeriod * totalPeriods;
  const currentCount = events.length;
  
  // Time-based estimate
  const currentTime = document.getElementById('clock').value;
  const timeParts = currentTime.split(':').map(Number);
  const timeRemaining = timeParts[0] * 60 + timeParts[1];
  const periodLengthSec = getPeriodLengthSeconds(period);
  const timeElapsed = periodLengthSec - timeRemaining;
  const periodProgress = timeElapsed / periodLengthSec;
  
  const overallProgress = (completedPeriods + periodProgress) / totalPeriods;
  
  return {
    events: currentCount,
    estimated: estimatedTotal,
    progress: Math.round(overallProgress * 100),
    periodEvents,
    period
  };
}

function updateProgressBar() {
  const progress = getProgressEstimate();
  const bar = document.getElementById('progressBar');
  if (bar) {
    bar.innerHTML = `
      <div style="display:flex;align-items:center;gap:4px;font-size:9px;">
        <span>${progress.events} events</span>
        <div style="flex:1;height:4px;background:var(--border);border-radius:2px;min-width:60px;">
          <div style="width:${progress.progress}%;height:100%;background:var(--accent);border-radius:2px;"></div>
        </div>
        <span>~${progress.progress}%</span>
      </div>
    `;
  }
}

// --- 17. FLOATING VIDEO ---
let floatingVideoEnabled = false;

function toggleFloatingVideo() {
  floatingVideoEnabled = !floatingVideoEnabled;
  
  const container = document.getElementById('videoSection');
  if (!container) return;
  
  if (floatingVideoEnabled) {
    container.style.cssText = `
      position: fixed !important;
      top: 60px;
      right: 20px;
      width: 400px;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
      border-radius: 8px;
      resize: both;
      overflow: auto;
    `;
    toast('Floating video ON - drag to move', 'info');
    makeVideoDraggable();
  } else {
    container.style.cssText = '';
    toast('Floating video OFF', 'info');
  }
}

function makeVideoDraggable() {
  const container = document.getElementById('videoSection');
  if (!container) return;
  
  let isDragging = false;
  let startX, startY, startLeft, startTop;
  
  const header = container.querySelector('.video-header') || container;
  
  header.style.cursor = 'move';
  
  header.addEventListener('mousedown', (e) => {
    if (e.target.tagName === 'BUTTON' || e.target.tagName === 'SELECT') return;
    isDragging = true;
    startX = e.clientX;
    startY = e.clientY;
    startLeft = container.offsetLeft;
    startTop = container.offsetTop;
  });
  
  document.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    container.style.left = `${startLeft + dx}px`;
    container.style.top = `${startTop + dy}px`;
    container.style.right = 'auto';
  });
  
  document.addEventListener('mouseup', () => {
    isDragging = false;
  });
}

// --- 18. QUICK EVENT BUTTONS (Most common) ---
function addQuickEventButtons() {
  // Count most common event types
  const typeCounts = {};
  (S.events || []).forEach(e => {
    typeCounts[e.type] = (typeCounts[e.type] || 0) + 1;
  });
  
  const topTypes = Object.entries(typeCounts)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5)
    .map(([type]) => type);
  
  return topTypes;
}

// --- 19. PERIOD PROGRESS RING ---
function renderPeriodProgress() {
  const ring = document.getElementById('periodProgressRing');
  if (!ring) return;
  
  const currentTime = document.getElementById('clock').value;
  const timeParts = currentTime.split(':').map(Number);
  const timeRemaining = timeParts[0] * 60 + timeParts[1];
  const periodLengthSec = getPeriodLengthSeconds(S.period);
  const progress = 1 - (timeRemaining / periodLengthSec);
  
  // SVG ring
  const radius = 12;
  const circumference = 2 * Math.PI * radius;
  const offset = circumference * (1 - progress);
  
  ring.innerHTML = `
    <svg width="30" height="30" style="transform:rotate(-90deg);">
      <circle cx="15" cy="15" r="${radius}" fill="none" stroke="var(--border)" stroke-width="3"/>
      <circle cx="15" cy="15" r="${radius}" fill="none" stroke="var(--accent)" stroke-width="3"
        stroke-dasharray="${circumference}" stroke-dashoffset="${offset}"/>
    </svg>
  `;
}

// --- 20. CONSISTENCY CHECKER ---
function runConsistencyCheck() {
  const issues = [];
  
  S.events?.forEach((evt, idx) => {
    // Shot without save/goal following
    if (evt.type === 'Shot') {
      const next = S.events[idx + 1];
      if (next && !['Save', 'Goal', 'Rebound', 'Stoppage'].includes(next.type)) {
        issues.push({
          idx,
          type: 'warning',
          msg: `Shot #${idx + 1} not followed by Save/Goal/Rebound`
        });
      }
    }
    
    // Goal without shot before
    if (evt.type === 'Goal') {
      const prev = S.events[idx - 1];
      if (prev && !['Shot', 'Rebound'].includes(prev.type)) {
        issues.push({
          idx,
          type: 'warning',
          msg: `Goal #${idx + 1} not preceded by Shot/Rebound`
        });
      }
    }
    
    // Penalty without faceoff after
    if (evt.type === 'Penalty') {
      const next = S.events[idx + 1];
      if (next && next.type !== 'Faceoff' && next.type !== 'Stoppage') {
        issues.push({
          idx,
          type: 'info',
          msg: `Penalty #${idx + 1} not followed by Faceoff`
        });
      }
    }
    
    // Event without players
    if (['Shot', 'Pass', 'Goal', 'Faceoff'].includes(evt.type)) {
      if (!evt.players || evt.players.length === 0) {
        issues.push({
          idx,
          type: 'error',
          msg: `${evt.type} #${idx + 1} has no players`
        });
      }
    }
  });
  
  if (issues.length === 0) {
    toast('No consistency issues found!', 'success');
    return;
  }
  
  const html = `
    <h3>‚ö†Ô∏è Consistency Check (${issues.length} issues)</h3>
    <div style="max-height:300px;overflow-y:auto;">
      ${issues.map(i => `
        <div style="padding:6px;margin:4px 0;background:${
          i.type === 'error' ? 'rgba(239,68,68,0.2)' : 
          i.type === 'warning' ? 'rgba(245,158,11,0.2)' : 
          'rgba(59,130,246,0.2)'
        };border-radius:4px;font-size:10px;display:flex;justify-content:space-between;align-items:center;">
          <span>${i.msg}</span>
          <button class="btn-sm" onclick="editEvent(${i.idx});closeModal();" style="font-size:8px;">Fix</button>
        </div>
      `).join('')}
    </div>
    <div class="modal-actions">
      <button onclick="closeModal()">Close</button>
    </div>
  `;
  
  showModal(html);
}

// ============================================================
// v23.5: HOOK UPDATES
// ============================================================

// Update logEventDirect hook to include new features
const hookLogEventDirect = () => {
  // This runs after each event is logged
  learnEventPattern();
  
  if (recordingMacro && S.events.length > 0) {
    recordEventForMacro(S.events[S.events.length - 1]);
  }
  
  refreshShotChartOverlay();
  updateProgressBar();
};

// Add to existing logEventDirect hook chain
const existingLogHook = logEventDirect;
logEventDirect = function() {
  existingLogHook.apply(this, arguments);
  hookLogEventDirect();
};

// ============================================================
// AUTO-SAVE
// ============================================================
function startAutoSave() {
  if (S.saveTimer) clearInterval(S.saveTimer);
  // Check both the header input and the settings modal input
  const headerInput = document.getElementById('autoSaveIntHeader');
  const settingsInput = document.getElementById('autoSaveInt');
  const intervalValue = headerInput?.value || settingsInput?.value || '300';
  const interval = (parseInt(intervalValue) || 300) * 1000;
  S.saveTimer = setInterval(autoSave, interval);
  
  // Sync the values between header and settings
  if (headerInput && settingsInput) {
    const value = headerInput.value || settingsInput.value || '300';
    headerInput.value = value;
    settingsInput.value = value;
  }
}

/**
 * Mark that data has changed - call this whenever events, shifts, or other data is modified
 */
function markDataChanged() {
  S.lastChange = new Date();
}

/**
 * Internal save function that performs the actual save operation
 * @param {boolean} force - If true, always save regardless of change tracking
 */
function performSave(force = false) {
  if (!S.gameId) return false;
  
  // Only check for changes if not forcing a save
  if (!force) {
    // Only save if there have been changes in the last 1 minute (60 seconds)
    if (S.lastChange) {
      const timeSinceChange = (new Date() - S.lastChange) / 1000; // seconds
      if (timeSinceChange > 60) {
        // No changes in the last minute, skip auto-save
        return false;
      }
    } else {
      // No changes tracked yet, skip auto-save
      return false;
    }
  }
  
  const key = `bs_${S.gameId}`;
  const data = { 
    events: S.events, 
    shifts: S.shifts, 
    evtIdx: S.evtIdx, 
    shiftIdx: S.shiftIdx, 
    videoTiming: S.videoTiming,  // Save video timing per game
    videos: S.videos || [],      // v23.6: Video management
    highlightVideos: S.highlightVideos || [], // v23.7: Highlight videos management
    periodLength: S.periodLength, // Legacy
    periodLengths: S.periodLengths, // v23.5: Period-specific lengths
    homeAttacksRightP1: S.homeAttacksRightP1, // v19: Zone orientation per game
    savedAt: new Date().toISOString() 
  };
  localStorage.setItem(key, JSON.stringify(data));
  S.lastSave = new Date();
  updateSaveIndicator('saved');
  setTimeout(() => updateSaveIndicator(), 2000);
  
  // v23.8: File system save disabled - commented out to avoid errors
  // Use game folder if available, otherwise use saveDirectoryHandle
  // const targetDirectory = S.gameFolderHandle || S.saveDirectoryHandle;
  // if (targetDirectory) {
  //   saveToFileSystem(data).catch(e => {
  //     console.error('Failed to save to file system:', e);
  //   });
  //   createBackup(data).catch(e => {
  //     console.error('Failed to create backup:', e);
  //   });
  // }
  
  // v26.0: Always export JSON file on save (auto-backup)
  // Save to game folder if available, otherwise try saveDirectoryHandle
  // Don't block on errors - just log them
  saveJsonBackupToGameFolder(data).catch(e => {
    console.warn('Failed to save JSON backup (non-blocking):', e);
    // Don't fall back to download - just silently fail to avoid interrupting user
  });
  
  return true;
}

function autoSave() {
  performSave(false);
}

// ============================================================
// v26.0: WORK TIMER - tracks active work time with auto-pause
// ============================================================

/**
 * Start or resume the work timer
 */
function startWorkTimer() {
  if (!S.workTimer.startTime) {
    // First time starting - initialize
    S.workTimer.startTime = Date.now();
    S.workTimer.isPaused = false;
  } else if (S.workTimer.isPaused) {
    // Resuming from pause - adjust start time to account for paused duration
    if (S.workTimer.pausedAt) {
      const pauseDuration = Date.now() - S.workTimer.pausedAt;
      S.workTimer.startTime += pauseDuration;
    }
    S.workTimer.isPaused = false;
    S.workTimer.pausedAt = null;
  }
  
  S.workTimer.lastActivity = Date.now();
  
  // Clear any existing pause timeout
  if (S.workTimer.pauseTimeout) {
    clearTimeout(S.workTimer.pauseTimeout);
    S.workTimer.pauseTimeout = null;
  }
  
  // Start the update interval if not already running
  if (!S.workTimer.updateInterval) {
    S.workTimer.updateInterval = setInterval(updateWorkTimerDisplay, 1000);
  }
  
  updateWorkTimerDisplay();
}

/**
 * Pause the work timer
 */
function pauseWorkTimer() {
  if (S.workTimer.isPaused) return;
  
  S.workTimer.isPaused = true;
  S.workTimer.pausedAt = Date.now();
  if (S.workTimer.pauseTimeout) {
    clearTimeout(S.workTimer.pauseTimeout);
  }
  updateWorkTimerDisplay();
}

/**
 * Record user activity - resumes timer if paused and resets auto-pause timeout
 */
function recordActivity() {
  const now = Date.now();
  S.workTimer.lastActivity = now;
  
  // If paused and we have activity, resume
  if (S.workTimer.isPaused && S.workTimer.startTime) {
    startWorkTimer();
    return;
  }
  
  // If not paused, reset the auto-pause timeout (2 minutes = 120000ms)
  if (S.workTimer.pauseTimeout) {
    clearTimeout(S.workTimer.pauseTimeout);
  }
  
  S.workTimer.pauseTimeout = setTimeout(() => {
    pauseWorkTimer();
  }, 120000); // 2 minutes of inactivity
}

/**
 * Update the work timer display
 */
function updateWorkTimerDisplay() {
  const display = document.getElementById('workTimerDisplay');
  if (!display) return;
  
  if (!S.workTimer.startTime) {
    display.textContent = `‚è±Ô∏è 0:00`;
    display.style.opacity = '0.5';
    return;
  }
  
  if (S.workTimer.isPaused) {
    // Show time at moment of pause (pausedAt - startTime, accounting for previous pauses)
    const elapsed = S.workTimer.pausedAt ? 
      Math.floor((S.workTimer.pausedAt - S.workTimer.startTime) / 1000) : 0;
    const minutes = Math.floor(elapsed / 60);
    const seconds = elapsed % 60;
    display.textContent = `‚è∏Ô∏è ${minutes}:${seconds.toString().padStart(2, '0')}`;
    display.style.opacity = '0.5';
    return;
  }
  
  const elapsed = Math.floor((Date.now() - S.workTimer.startTime) / 1000);
  const minutes = Math.floor(elapsed / 60);
  const seconds = elapsed % 60;
  display.textContent = `‚è±Ô∏è ${minutes}:${seconds.toString().padStart(2, '0')}`;
  display.style.opacity = '1';
}

/**
 * Initialize activity tracking listeners
 */
function setupActivityTracking() {
  // Track keyboard activity
  document.addEventListener('keydown', recordActivity);
  document.addEventListener('keypress', recordActivity);
  
  // Track mouse activity
  document.addEventListener('mousedown', recordActivity);
  document.addEventListener('mousemove', () => {
    // Throttle mousemove to avoid too many calls
    if (!S.workTimer.lastMouseMove || Date.now() - S.workTimer.lastMouseMove > 5000) {
      recordActivity();
      S.workTimer.lastMouseMove = Date.now();
    }
  });
  
  // Track clicks
  document.addEventListener('click', recordActivity);
  
  // Track input changes
  document.addEventListener('input', recordActivity);
  document.addEventListener('change', recordActivity);
}

// v26.0: Track if button setup has been completed to prevent retry loops
let logEventButtonSetupComplete = false;

/**
 * v26.0: Setup log event button - SIMPLE direct event listener
 */
function setupLogEventButton() {
  // Don't retry if already set up
  if (logEventButtonSetupComplete) {
    return;
  }
  
  const setupButton = () => {
    if (logEventButtonSetupComplete) return; // Double check
    
    const logBtn = document.querySelector('button.btn-success[onclick*="logEvent"]');
    if (logBtn) {
      // Only set up once - check if already set up
      if (logBtn.dataset.setupDone === 'true') {
        logEventButtonSetupComplete = true;
        return;
      }
      
      console.log('setupLogEventButton: Found button, setting up...');
      
      // Remove onclick completely
      logBtn.removeAttribute('onclick');
      logBtn.onclick = null;
      
      // Direct function reference - no string parsing
      const handler = function(e) {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        console.log('Log Event button clicked - calling window.logEvent');
        console.log('window.logEvent type:', typeof window.logEvent);
        if (typeof window.logEvent === 'function') {
          try {
            console.log('About to call window.logEvent()...');
            window.logEvent();
            console.log('window.logEvent() call completed');
          } catch (err) {
            console.error('Error calling window.logEvent():', err);
            toast('Error: ' + err.message, 'error');
          }
        } else {
          console.error('window.logEvent is not a function!', typeof window.logEvent);
          alert('Error: logEvent function not available. Check console.');
        }
        return false;
      };
      
      logBtn.dataset.setupDone = 'true';
      
      // Add multiple event types to ensure it works
      logBtn.onclick = handler;
      logBtn.onmousedown = handler;
      logBtn.addEventListener('click', handler, true); // Capture phase
      logBtn.addEventListener('click', handler, false); // Bubble phase
      logBtn.addEventListener('mousedown', handler, true);
      
      logBtn.style.cursor = 'pointer';
      logBtn.style.pointerEvents = 'auto';
      
      logEventButtonSetupComplete = true;
      console.log('Log Event button setup complete. window.logEvent type:', typeof window.logEvent);
    } else {
      // Only log if we haven't completed setup yet
      if (!logEventButtonSetupComplete) {
        console.log('Log Event button not found, retrying...');
        setTimeout(setupButton, 100);
      }
    }
  };
  
  // Try immediately
  setupButton();
  
  // Also try after DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setupButton);
  }
  
  // Also try after a delay (but only once)
  if (!logEventButtonSetupComplete) {
    setTimeout(setupButton, 500);
  }
  if (!logEventButtonSetupComplete) {
    setTimeout(setupButton, 2000);
  }
}

/**
 * Reset the work timer (when starting a new game)
 */
function resetWorkTimer() {
  if (S.workTimer.updateInterval) {
    clearInterval(S.workTimer.updateInterval);
    S.workTimer.updateInterval = null;
  }
  if (S.workTimer.pauseTimeout) {
    clearTimeout(S.workTimer.pauseTimeout);
    S.workTimer.pauseTimeout = null;
  }
  S.workTimer = { startTime: null, pausedTime: 0, isPaused: true, lastActivity: null, pauseTimeout: null, pausedAt: null, updateInterval: null };
  updateWorkTimerDisplay();
}

/**
 * v23.8: Prompt user to select a save directory
 */
async function promptForSaveDirectory() {
  // Check if File System Access API is supported
  if (!('showDirectoryPicker' in window)) {
    toast('File System Access API not supported in this browser. Using localStorage only.', 'warning');
    updateSaveFolderDisplay();
    return;
  }
  
  try {
    const handle = await window.showDirectoryPicker({
      mode: 'readwrite',
      startIn: 'documents'
    });
    
    S.saveDirectoryHandle = handle;
    
    // Store directory handle in IndexedDB for persistence
    await storeDirectoryHandle(handle);
    
    updateSaveFolderDisplay();
    toast('Save directory selected. Auto-saves will be saved to this location.', 'success');
  } catch (e) {
    if (e.name !== 'AbortError') {
      console.error('Error selecting directory:', e);
      toast('Failed to select save directory. Using localStorage only.', 'warning');
    }
    // User cancelled - that's okay, we'll use localStorage
    updateSaveFolderDisplay();
  }
}

/**
 * v23.8: Update the save folder display in settings
 */
function updateSaveFolderDisplay() {
  const folderPathEl = document.getElementById('saveFolderPath');
  const folderStatusEl = document.getElementById('saveFolderStatus');
  const quickSaveBtn = document.getElementById('quickSaveBtn');
  
  if (folderPathEl) {
    if (S.saveDirectoryHandle) {
      try {
        // File System Access API doesn't expose the full path for security reasons
        // We can only show the directory name
        folderPathEl.textContent = `Selected: ${S.saveDirectoryHandle.name || 'Folder'} (auto-saves enabled)`;
        folderPathEl.classList.remove('empty');
        folderPathEl.style.color = 'var(--success)';
      } catch (e) {
        folderPathEl.textContent = 'Folder selected (auto-saves enabled)';
        folderPathEl.classList.remove('empty');
        folderPathEl.style.color = 'var(--success)';
      }
    } else {
      folderPathEl.textContent = 'No folder selected - using localStorage only';
      folderPathEl.classList.add('empty');
      folderPathEl.style.color = 'var(--muted)';
    }
  }
  
  if (folderStatusEl) {
    if (S.saveDirectoryHandle) {
      folderStatusEl.textContent = '‚úÖ Auto-saves enabled. Files saved to selected folder, backups in "bkup" subfolder (keeps last 10).';
      folderStatusEl.style.color = 'var(--success)';
    } else {
      folderStatusEl.textContent = 'üí° Select a folder to enable auto-saves and backups (saved to "bkup" folder, keeps last 10)';
      folderStatusEl.style.color = 'var(--muted)';
    }
  }
  
  if (quickSaveBtn) {
    quickSaveBtn.disabled = !S.saveDirectoryHandle;
  }
}

/**
 * v23.8: Clear the selected save folder
 */
function clearSaveFolder() {
  if (!confirm('Clear selected save folder? Auto-saves will use localStorage only.')) return;
  
  S.saveDirectoryHandle = null;
  
  // Remove from IndexedDB
  if ('indexedDB' in window) {
    indexedDB.open('benchsight_save', 1).onsuccess = (e) => {
      const db = e.target.result;
      const transaction = db.transaction(['handles'], 'readwrite');
      transaction.objectStore('handles').delete('saveDirectory');
    };
  }
  
  updateSaveFolderDisplay();
  toast('Save folder cleared. Using localStorage only.', 'info');
}

/**
 * Prompt for default directory where game folders will be created
 */
async function promptForDefaultDirectory() {
  // Check if File System Access API is supported
  if (!('showDirectoryPicker' in window)) {
    toast('File System Access API not supported in this browser.', 'warning');
    updateDefaultFolderDisplay();
    return;
  }
  
  try {
    const handle = await window.showDirectoryPicker({
      mode: 'readwrite',
      startIn: 'documents'
    });
    
    S.defaultDirectoryHandle = handle;
    
    // Store directory handle in IndexedDB for persistence
    await storeDirectoryHandle(handle, 'defaultDirectory');
    
    updateDefaultFolderDisplay();
    toast('Default folder selected. Game folders will be created here when loading games.', 'success');
    
    // If a game is already loaded, create its folder now
    if (S.gameId) {
      await ensureGameFolder();
    }
  } catch (e) {
    if (e.name !== 'AbortError') {
      console.error('Error selecting default directory:', e);
      toast('Failed to select default folder.', 'warning');
    }
    updateDefaultFolderDisplay();
  }
}

/**
 * Clear the default directory
 */
function clearDefaultFolder() {
  if (!confirm('Clear default folder? Game folders will not be created automatically.')) return;
  
  S.defaultDirectoryHandle = null;
  S.gameFolderHandle = null;
  
  // Remove from IndexedDB
  if ('indexedDB' in window) {
    indexedDB.open('benchsight_save', 1).onsuccess = (e) => {
      const db = e.target.result;
      const transaction = db.transaction(['handles'], 'readwrite');
      transaction.objectStore('handles').delete('defaultDirectory');
    };
  }
  
  updateDefaultFolderDisplay();
  toast('Default folder cleared.', 'info');
}

/**
 * Update the default folder display in settings
 */
function updateDefaultFolderDisplay() {
  const folderPathEl = document.getElementById('defaultFolderPath');
  const folderStatusEl = document.getElementById('defaultFolderStatus');
  
  if (folderPathEl) {
    if (S.defaultDirectoryHandle) {
      try {
        folderPathEl.textContent = `Selected: ${S.defaultDirectoryHandle.name || 'Folder'}`;
        folderPathEl.classList.remove('empty');
        folderPathEl.style.color = 'var(--success)';
      } catch (e) {
        folderPathEl.textContent = 'Folder selected';
        folderPathEl.classList.remove('empty');
        folderPathEl.style.color = 'var(--success)';
      }
    } else {
      folderPathEl.textContent = 'No default folder selected';
      folderPathEl.classList.add('empty');
      folderPathEl.style.color = 'var(--muted)';
    }
  }
  
  if (folderStatusEl) {
    if (S.defaultDirectoryHandle) {
      folderStatusEl.textContent = `‚úÖ Default folder set. Game folders (named by game ID) will be created automatically when loading games.`;
      folderStatusEl.style.color = 'var(--success)';
    } else {
      folderStatusEl.textContent = 'üí° Select a default folder. Game folders (named by game ID) will be created automatically when loading games.';
      folderStatusEl.style.color = 'var(--muted)';
    }
  }
}

/**
 * Ensure game folder exists - create it if it doesn't exist
 */
async function ensureGameFolder() {
  if (!S.defaultDirectoryHandle || !S.gameId) {
    S.gameFolderHandle = null;
    return;
  }
  
  // Check if File System Access API is available
  if (typeof window.showDirectoryPicker === 'undefined') {
    console.warn('File System Access API not available (requires HTTPS or localhost)');
    S.gameFolderHandle = null;
    return;
  }
  
  try {
    // Game folder name is just the game ID (e.g., "19038")
    const gameFolderName = String(S.gameId);
    
    // Try to get existing folder, or create it
    try {
      S.gameFolderHandle = await S.defaultDirectoryHandle.getDirectoryHandle(gameFolderName, { create: true });
      console.log(`Game folder ready: ${gameFolderName}`);
    } catch (e) {
      // Handle specific error types
      if (e.name === 'NotAllowedError') {
        console.warn('File System Access not allowed. This may be due to:', e);
        console.warn('  - Page not served over HTTPS (required for File System Access API)');
        console.warn('  - User permission not granted');
        console.warn('  - Browser security restrictions');
        // Don't show toast for this - it's expected in some contexts
        S.gameFolderHandle = null;
      } else if (e.name === 'NotFoundError') {
        console.warn('Default directory no longer accessible. User may have revoked permission.');
        S.gameFolderHandle = null;
        S.defaultDirectoryHandle = null; // Clear invalid handle
      } else {
      console.error('Error creating game folder:', e);
        toast('Failed to create game folder: ' + (e.message || e.name), 'warning');
      S.gameFolderHandle = null;
      }
    }
  } catch (e) {
    console.error('Error ensuring game folder:', e);
    S.gameFolderHandle = null;
    // Don't show error toast - file system access is optional
  }
}

/**
 * v23.8: Store directory handle in IndexedDB
 * @param {FileSystemDirectoryHandle} handle - Directory handle to store
 * @param {string} key - Key to store under ('saveDirectory' or 'defaultDirectory')
 */
async function storeDirectoryHandle(handle, key = 'saveDirectory') {
  try {
    if (!('indexedDB' in window)) return;
    
    const db = await new Promise((resolve, reject) => {
      const request = indexedDB.open('benchsight_save', 1);
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve(request.result);
      request.onupgradeneeded = (e) => {
        const db = e.target.result;
        if (!db.objectStoreNames.contains('handles')) {
          db.createObjectStore('handles');
        }
      };
    });
    
    const transaction = db.transaction(['handles'], 'readwrite');
    await transaction.objectStore('handles').put(handle, key);
  } catch (e) {
    console.error('Failed to store directory handle:', e);
  }
}

/**
 * v23.8: Load directory handles from IndexedDB
 */
async function loadDirectoryHandles() {
  try {
    if (!('indexedDB' in window)) return;
    
    const db = await new Promise((resolve, reject) => {
      const request = indexedDB.open('benchsight_save', 1);
      request.onerror = () => {
        console.error('IndexedDB open error:', request.error);
        resolve(null); // Don't reject, just return null
      };
      request.onsuccess = () => resolve(request.result);
      request.onupgradeneeded = (e) => {
        try {
          const db = e.target.result;
          if (!db.objectStoreNames.contains('handles')) {
            db.createObjectStore('handles');
          }
        } catch (err) {
          console.error('Error creating object store:', err);
        }
      };
    });
    
    if (!db) return;
    
    // Load both save directory and default directory
    const transaction = db.transaction(['handles'], 'readonly');
    
    // Load save directory
    const saveDirRequest = transaction.objectStore('handles').get('saveDirectory');
    await new Promise((resolve) => {
      saveDirRequest.onsuccess = () => {
        try {
          if (saveDirRequest.result) {
            S.saveDirectoryHandle = saveDirRequest.result;
          }
        } catch (e) {
          console.error('Error setting save directory handle:', e);
        }
        resolve();
      };
      saveDirRequest.onerror = () => {
        console.error('Error reading save directory handle:', saveDirRequest.error);
        resolve(); // Don't reject
      };
    });
    
    // Load default directory
    const defaultDirRequest = transaction.objectStore('handles').get('defaultDirectory');
    await new Promise((resolve) => {
      defaultDirRequest.onsuccess = () => {
        try {
          if (defaultDirRequest.result) {
            S.defaultDirectoryHandle = defaultDirRequest.result;
          }
        } catch (e) {
          console.error('Error setting default directory handle:', e);
        }
        resolve();
      };
      defaultDirRequest.onerror = () => {
        console.error('Error reading default directory handle:', defaultDirRequest.error);
        resolve(); // Don't reject
      };
    });
  } catch (e) {
    console.error('Failed to load directory handle:', e);
    // Don't throw - this is non-critical
  }
}

/**
 * v23.8: Save game data to file system
 */
async function saveToFileSystem(data) {
  if (!S.gameId) return;
  
  // Use game folder if available, otherwise use saveDirectoryHandle
  const targetDirectory = S.gameFolderHandle || S.saveDirectoryHandle;
  if (!targetDirectory) return;
  
  try {
    // Create comprehensive game data object
    const gameData = {
      exportDate: new Date().toISOString(),
      version: '23.8',
      gameId: S.gameId,
      
      // Game metadata
      homeTeam: S.homeTeam,
      awayTeam: S.awayTeam,
      homeColor: S.homeColor,
      awayColor: S.awayColor,
      homeLogo: S.homeLogo,
      awayLogo: S.awayLogo,
      
      // Rosters
      rosters: {
        home: S.rosters?.home || [],
        away: S.rosters?.away || []
      },
      
      // Game data
      events: data.events,
      shifts: data.shifts,
      evtIdx: data.evtIdx,
      shiftIdx: data.shiftIdx,
      
      // Video data
      videos: data.videos || [],
      videoTiming: data.videoTiming,
      
      // Game settings
      periodLengths: data.periodLengths || S.periodLengths,
      penaltyLengths: S.penaltyLengths,
      homeAttacksRightP1: data.homeAttacksRightP1,
      
      // Application settings
      settings: JSON.parse(localStorage.getItem('bs_settings') || '{}'),
      
      // Custom presets
      customChainPresets: customChainPresets || [],
      linePresets: S.linePresets || {},
      
      // Current state
      currentPeriod: S.period,
      currentTeam: S.evtTeam,
      slots: S.slots,
      
      savedAt: data.savedAt
    };
    
    const gameName = `${S.homeTeam || 'Home'}_vs_${S.awayTeam || 'Away'}`.replace(/[^a-zA-Z0-9_]/g, '_');
    const fileName = `benchsight_game_${gameName}_${S.gameId}.json`;
    
    // Write main save file to game folder (or saveDirectoryHandle)
    const fileHandle = await targetDirectory.getFileHandle(fileName, { create: true });
    const writable = await fileHandle.createWritable();
    await writable.write(JSON.stringify(gameData, null, 2));
    await writable.close();
  } catch (e) {
    console.error('Error saving to file system:', e);
    throw e;
  }
}

/**
 * v23.8: Create backup in bkup folder
 * Uses game folder's bkup subfolder if available, otherwise saveDirectoryHandle's bkup folder
 */
async function createBackup(data) {
  if (!S.gameId) return;
  
  // Use game folder if available, otherwise use saveDirectoryHandle
  const targetDirectory = S.gameFolderHandle || S.saveDirectoryHandle;
  if (!targetDirectory) return;
  
  try {
    // Get or create bkup folder within the target directory
    let backupDir;
    try {
      backupDir = await targetDirectory.getDirectoryHandle('bkup', { create: true });
    } catch (e) {
      console.error('Failed to create backup directory:', e);
      return;
    }
    
    // Create comprehensive game data (same as saveToFileSystem)
    const gameData = {
      exportDate: new Date().toISOString(),
      version: '23.8',
      gameId: S.gameId,
      homeTeam: S.homeTeam,
      awayTeam: S.awayTeam,
      homeColor: S.homeColor,
      awayColor: S.awayColor,
      homeLogo: S.homeLogo,
      awayLogo: S.awayLogo,
      rosters: {
        home: S.rosters?.home || [],
        away: S.rosters?.away || []
      },
      events: data.events,
      shifts: data.shifts,
      evtIdx: data.evtIdx,
      shiftIdx: data.shiftIdx,
      videos: data.videos || [],
      videoTiming: data.videoTiming,
      periodLengths: data.periodLengths || S.periodLengths,
      penaltyLengths: S.penaltyLengths,
      homeAttacksRightP1: data.homeAttacksRightP1,
      settings: JSON.parse(localStorage.getItem('bs_settings') || '{}'),
      customChainPresets: customChainPresets || [],
      linePresets: S.linePresets || {},
      currentPeriod: S.period,
      currentTeam: S.evtTeam,
      slots: S.slots,
      savedAt: data.savedAt
    };
    
    const gameName = `${S.homeTeam || 'Home'}_vs_${S.awayTeam || 'Away'}`.replace(/[^a-zA-Z0-9_]/g, '_');
    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
    const backupFileName = `benchsight_game_${gameName}_${S.gameId}_${timestamp}.json`;
    
    // Write backup file
    const backupHandle = await backupDir.getFileHandle(backupFileName, { create: true });
    const writable = await backupHandle.createWritable();
    await writable.write(JSON.stringify(gameData, null, 2));
    await writable.close();
    
    // Rotate backups (keep only last N backups)
    await rotateBackups(backupDir, gameName, S.gameId);
  } catch (e) {
    console.error('Error creating backup:', e);
    // Don't throw - backup failure shouldn't break auto-save
  }
}

/**
 * v23.8: Rotate backups to keep only the last N files
 */
async function rotateBackups(backupDir, gameName, gameId) {
  try {
    const prefix = `benchsight_game_${gameName}_${gameId}_`;
    const backups = [];
    
    // List all backup files for this game
    for await (const [name, handle] of backupDir.entries()) {
      if (name.startsWith(prefix) && name.endsWith('.json')) {
        const file = await handle.getFile();
        backups.push({
          name,
          handle,
          date: file.lastModified
        });
      }
    }
    
    // Sort by date (newest first)
    backups.sort((a, b) => b.date - a.date);
    
    // Delete old backups beyond maxBackups
    if (backups.length > S.maxBackups) {
      const toDelete = backups.slice(S.maxBackups);
      for (const backup of toDelete) {
        try {
          await backupDir.removeEntry(backup.name);
        } catch (e) {
          console.error(`Failed to delete old backup ${backup.name}:`, e);
        }
      }
    }
  } catch (e) {
    console.error('Error rotating backups:', e);
  }
}

/**
 * Save JSON data to game folder if available
 */
async function saveJsonToGameFolder(data) {
  if (!S.gameFolderHandle || !S.gameId) {
    return Promise.reject('No game folder available');
  }
  
  try {
    // Get or create json_backups folder - handle errors gracefully
    let jsonBackupDir;
    try {
      // Try to get existing directory first
      try {
        jsonBackupDir = await S.gameFolderHandle.getDirectoryHandle('json_backups');
      } catch (e) {
        // Directory doesn't exist, try to create it
        jsonBackupDir = await S.gameFolderHandle.getDirectoryHandle('json_backups', { create: true });
      }
    } catch (e) {
      // If folder creation fails, log but don't throw - this shouldn't block auto-save
      console.warn('Failed to create/access json_backups directory (non-blocking):', e);
      // Return early without error - auto-save will still work via localStorage
      return Promise.resolve(false);
    }
    
    // Create comprehensive game data
    const gameData = {
      exportDate: new Date().toISOString(),
      version: '23.8',
      gameId: S.gameId,
      homeTeam: S.homeTeam,
      awayTeam: S.awayTeam,
      homeColor: S.homeColor,
      awayColor: S.awayColor,
      homeLogo: S.homeLogo,
      awayLogo: S.awayLogo,
      rosters: {
        home: S.rosters?.home || [],
        away: S.rosters?.away || []
      },
      events: data.events,
      shifts: data.shifts,
      evtIdx: data.evtIdx,
      shiftIdx: data.shiftIdx,
      videos: data.videos || [],
      videoTiming: data.videoTiming,
      periodLengths: data.periodLengths || S.periodLengths,
      penaltyLengths: S.penaltyLengths,
      homeAttacksRightP1: data.homeAttacksRightP1,
      settings: JSON.parse(localStorage.getItem('bs_settings') || '{}'),
      savedAt: data.savedAt
    };
    
    // Save with timestamp
    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
    const fileName = `${S.gameId}_game_data_${timestamp}.json`;
    
    const fileHandle = await jsonBackupDir.getFileHandle(fileName, { create: true });
    const writable = await fileHandle.createWritable();
    
    const jsonString = JSON.stringify(gameData, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json' });
    
    await writable.write(blob);
    await writable.close();
    
    console.log(`JSON saved to game folder: ${fileName}`);
    
    // v26.0: Rotate JSON backups if limit is set (unlimited if maxBackups is null)
    if (S.maxBackups !== null && S.maxBackups !== undefined) {
      await rotateJsonBackups(jsonBackupDir, S.gameId);
    }
    
    return true;
  } catch (e) {
    console.error('Error saving JSON to game folder:', e);
    throw e;
  }
}

/**
 * v25.0: Auto-backup JSON file on every auto-save (unlimited backups)
 * Saves comprehensive game data including events, shifts, rosters, settings, etc.
 */
async function saveJsonBackupToGameFolder(data) {
  // Try game folder first, then saveDirectoryHandle
  const targetDirectory = S.gameFolderHandle || S.saveDirectoryHandle;
  if (!targetDirectory || !S.gameId) {
    return Promise.reject('No backup directory or game ID available');
  }
  
  try {
    // Get or create backups folder
    let backupDir;
    try {
      backupDir = await targetDirectory.getDirectoryHandle('backups', { create: true });
    } catch (e) {
      console.warn('Failed to create/access backups directory (non-blocking):', e);
      return Promise.resolve(false);
    }
    
    // Create comprehensive game data (everything in one JSON file)
    const gameData = {
      exportDate: new Date().toISOString(),
      version: '25.0',
      gameId: S.gameId,
      
      // Game metadata
      homeTeam: S.homeTeam,
      awayTeam: S.awayTeam,
      homeColor: S.homeColor,
      awayColor: S.awayColor,
      homeLogo: S.homeLogo,
      awayLogo: S.awayLogo,
      
      // Rosters
      rosters: {
        home: S.rosters?.home || [],
        away: S.rosters?.away || []
      },
      
      // Core game data
      events: data.events || S.events,
      shifts: data.shifts || S.shifts,
      evtIdx: data.evtIdx || S.evtIdx,
      shiftIdx: data.shiftIdx || S.shiftIdx,
      
      // Video data
      videos: data.videos || S.videos || [],
      videoTiming: data.videoTiming || S.videoTiming,
      highlightVideos: S.highlightVideos || [],
      
      // Game settings
      periodLengths: data.periodLengths || S.periodLengths,
      penaltyLengths: S.penaltyLengths,
      homeAttacksRightP1: data.homeAttacksRightP1 || S.homeAttacksRightP1,
      
      // Settings and configurations
      settings: JSON.parse(localStorage.getItem('bs_settings') || '{}'),
      autoSettings: JSON.parse(localStorage.getItem('bs_autoSettings') || '{}'),
      customRules: S.customRules || [],
      customLinkingRules: S.customLinkingRules || [],
      customChainPresets: customChainPresets || [],
      linePresets: S.linePresets || {},
      eventMacros: JSON.parse(localStorage.getItem('benchsight_macros') || '[]'),
      
      // Current state
      currentPeriod: S.period,
      currentTeam: S.evtTeam,
      slots: S.slots,
      
      // Save metadata
      savedAt: data.savedAt || new Date().toISOString()
    };
    
    // Save with timestamp
    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
    const gameName = `${S.homeTeam || 'Home'}_vs_${S.awayTeam || 'Away'}`.replace(/[^a-zA-Z0-9_]/g, '_');
    const fileName = `${S.gameId}_${gameName}_backup_${timestamp}.json`;
    
    const fileHandle = await backupDir.getFileHandle(fileName, { create: true });
    const writable = await fileHandle.createWritable();
    
    const jsonString = JSON.stringify(gameData, null, 2);
    await writable.write(jsonString);
    await writable.close();
    
    console.log(`JSON backup saved: ${fileName}`);
    
    // v26.0: Unlimited backups - no rotation needed (maxBackups is null)
    
    return true;
  } catch (e) {
    console.error('Error saving JSON backup:', e);
    throw e;
  }
}

/**
 * v26.0: Rotate JSON backups (only if maxBackups limit is set)
 */
async function rotateJsonBackups(jsonBackupDir, gameId) {
  if (S.maxBackups === null || S.maxBackups === undefined) {
    return; // Unlimited backups - no rotation
  }
  
  try {
    const prefix = `${gameId}_game_data_`;
    const backups = [];
    
    // List all JSON backup files for this game
    for await (const [name, handle] of jsonBackupDir.entries()) {
      if (name.startsWith(prefix) && name.endsWith('.json')) {
        const file = await handle.getFile();
        backups.push({
          name,
          handle,
          date: file.lastModified
        });
      }
    }
    
    // Sort by date (newest first)
    backups.sort((a, b) => b.date - a.date);
    
    // Delete old backups beyond maxBackups limit
    if (backups.length > S.maxBackups) {
      const toDelete = backups.slice(S.maxBackups);
      for (const backup of toDelete) {
        try {
          await jsonBackupDir.removeEntry(backup.name);
        } catch (e) {
          console.error(`Failed to delete old JSON backup ${backup.name}:`, e);
        }
      }
      console.log(`Rotated JSON backups: kept ${S.maxBackups}, deleted ${toDelete.length}`);
    }
  } catch (e) {
    console.error('Error rotating JSON backups:', e);
  }
}

async function exportGameDataAsJson() {
  if (!S.gameId) return;
  
  const gameData = {
    exportDate: new Date().toISOString(),
    version: '23.8',
    gameId: S.gameId,
    
    // Game metadata
    homeTeam: S.homeTeam,
    awayTeam: S.awayTeam,
    homeColor: S.homeColor,
    awayColor: S.awayColor,
    homeLogo: S.homeLogo,
    awayLogo: S.awayLogo,
    
    // Rosters
    rosters: {
      home: S.rosters?.home || [],
      away: S.rosters?.away || []
    },
    
    // Game data
    events: S.events,
    shifts: S.shifts,
    evtIdx: S.evtIdx,
    shiftIdx: S.shiftIdx,
    
    // Video data
    videos: S.videos || [],
    videoTiming: S.videoTiming,
    
    // Game settings
    periodLengths: S.periodLengths,
    penaltyLengths: S.penaltyLengths,
    homeAttacksRightP1: S.homeAttacksRightP1,
    
    // Application settings
    settings: JSON.parse(localStorage.getItem('bs_settings') || '{}'),
    
    // Custom presets
    customChainPresets: customChainPresets || [],
    linePresets: S.linePresets || {},
    
    // Current state
    currentPeriod: S.period,
    currentTeam: S.evtTeam,
    slots: S.slots,
    
    savedAt: new Date().toISOString()
  };
  
  const gameName = `${S.homeTeam || 'Home'}_vs_${S.awayTeam || 'Away'}`.replace(/[^a-zA-Z0-9_]/g, '_');
  const fileName = `benchsight_game_${gameName}_${S.gameId}_${new Date().toISOString().slice(0,19).replace(/:/g, '-')}.json`;
  const jsonString = JSON.stringify(gameData, null, 2);
  
  // Try to save to game folder first, otherwise download
  if (S.gameFolderHandle) {
    try {
      const fileHandle = await S.gameFolderHandle.getFileHandle(fileName, { create: true });
      const writable = await fileHandle.createWritable();
      const blob = new Blob([jsonString], { type: 'application/json' });
      await writable.write(blob);
      await writable.close();
      toast(`JSON saved to game folder: ${fileName}`, 'success');
      return;
    } catch (e) {
      console.error('Error saving JSON to game folder:', e);
      // Fall through to download
    }
  }
  
  // Download JSON file (fallback if game folder not available)
  const blob = new Blob([jsonString], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = fileName;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  toast('JSON exported!', 'success');
}

function saveGameData() {
  console.log('saveGameData called');
  try {
    autoSave(); // Trigger save immediately
    toast('Game saved', 'success');
  } catch (e) {
    console.error('Error in saveGameData:', e);
    toast('Save failed: ' + e.message, 'error');
  }
}

function updateSaveIndicator(status) {
  const el = document.getElementById('saveInd');
  if (status === 'saving') { el.textContent = 'Saving...'; el.className = 'save-ind saving'; }
  else if (status === 'saved') { el.textContent = 'Saved ‚úì'; el.className = 'save-ind saved'; }
  else if (S.lastSave) {
    const ago = Math.round((new Date() - S.lastSave) / 1000);
    el.textContent = ago < 60 ? `${ago}s ago` : `${Math.round(ago/60)}m ago`;
    el.className = 'save-ind';
  } else { el.textContent = '--'; el.className = 'save-ind'; }
}

function loadFromStorage() {
  try {
    const last = localStorage.getItem('bs_lastGame');
    if (last) S.gameId = parseInt(last);
    
    // Check for saved game data
    if (S.gameId) {
      const key = `bs_${S.gameId}`;
      const saved = localStorage.getItem(key);
      if (saved) {
        const data = JSON.parse(saved);
        if (data.events?.length || data.shifts?.length) {
          // Show resume prompt
          showResumePrompt(data);
        }
      }
    }
  } catch(e) { console.log('Error loading from storage:', e); }
}

function showResumePrompt(data) {
  const evtCount = data.events?.length || 0;
  const shiftCount = data.shifts?.length || 0;
  const savedAt = data.savedAt ? new Date(data.savedAt).toLocaleString() : 'unknown';
  
  // Create resume modal dynamically
  const modal = document.createElement('div');
  modal.className = 'overlay show';
  modal.id = 'resumeModal';
  modal.onclick = function(e) {
    if (e.target === modal) closeResumeModal();
  };
  modal.innerHTML = `
    <div class="modal" style="min-width:350px;">
      <h3>üìÇ Resume Session?</h3>
      <p style="font-size:12px;color:var(--muted);margin:12px 0;">Found saved data for this game:</p>
      <div style="background:var(--card);padding:12px;border-radius:4px;margin:12px 0;">
        <div style="display:flex;justify-content:space-between;margin:4px 0;"><span>Events:</span><strong>${evtCount}</strong></div>
        <div style="display:flex;justify-content:space-between;margin:4px 0;"><span>Shifts:</span><strong>${shiftCount}</strong></div>
        <div style="display:flex;justify-content:space-between;margin:4px 0;"><span>Saved:</span><strong>${savedAt}</strong></div>
      </div>
      <div class="modal-actions">
        <button class="btn-success" onclick="handleResumeClick()">Resume</button>
        <button class="btn-danger" onclick="handleStartNewClick()">Start New</button>
      </div>
    </div>
  `;
  document.body.appendChild(modal);
}

function resumeSession() {
  const key = `bs_${S.gameId}`;
  const saved = localStorage.getItem(key);
  if (saved) {
    const data = JSON.parse(saved);
    S.events = data.events || [];
    S.shifts = data.shifts || [];
    S.evtIdx = data.evtIdx || S.events.length;
    S.shiftIdx = data.shiftIdx || S.shifts.length;
    S.lastSave = data.savedAt ? new Date(data.savedAt) : null;
    
    // v19: Restore zone orientation
    if (data.homeAttacksRightP1 !== undefined) {
      S.homeAttacksRightP1 = data.homeAttacksRightP1;
    }
    if (data.periodLength) {
      S.periodLength = data.periodLength;
    }
    // v23.5: Load period-specific lengths
    if (data.periodLengths) {
      S.periodLengths = data.periodLengths;
      updatePeriodLengthsUI();
    }
    if (data.videoTiming) {
      S.videoTiming = data.videoTiming;
    }
    // v23.6: Restore videos
    if (data.videos) {
      S.videos = data.videos;
    } else {
      S.videos = [];
    }
    
    // Update zone labels with restored orientation
    updateZoneLabels();
    
    // Update flip button visual
    const btn = document.getElementById('flipZonesBtn');
    if (btn) {
      btn.style.background = S.homeAttacksRightP1 ? '#374151' : '#7c3aed';
    }
    
    toast(`Restored ${S.events.length} events, ${S.shifts.length} shifts`, 'success');
    
    // v23.8: Process all goals to detect and link assists after resuming
    if (S.events && S.events.length > 0) {
      processAllGoalsForAssists();
    }
    
    renderAll();
    updateSaveIndicator();
    updateNextPlaySuggestions();
  }
  // Note: closeResumeModal() is called from button onclick
}

function startNewSession() {
  S.events = [];
  S.shifts = [];
  S.evtIdx = 0;
  S.shiftIdx = 0;
  S.lastSave = null;
  
  // Clear saved data
  if (S.gameId) {
    const key = `bs_${S.gameId}`;
    localStorage.removeItem(key);
  }
  
  toast('Starting new session', 'success');
  renderAll();
  closeResumeModal();
}

function handleResumeClick() {
  try {
    resumeSession();
  } catch(e) {
    console.error('Error in resumeSession:', e);
  }
  closeResumeModal();
}

function handleStartNewClick() {
  try {
    startNewSession();
  } catch(e) {
    console.error('Error in startNewSession:', e);
  }
  closeResumeModal();
}

function closeResumeModal() {
  const modal = document.getElementById('resumeModal');
  if (modal) {
    modal.classList.remove('show');
    setTimeout(() => {
      if (modal && modal.parentNode) {
        modal.remove();
      }
    }, 300); // Remove after fade-out animation
  }
}

function manualSave() {
  if (!S.gameId) { toast('No game loaded', 'error'); return; }
  updateSaveIndicator('saving');
  
  // Force save regardless of change tracking
  const saved = performSave(true);
  
  if (saved) {
    // Show appropriate success message
    const exportJsonOnSave = localStorage.getItem('bs_exportJsonOnSave') === 'true';
    if (S.gameFolderHandle) {
      toast('Game saved to localStorage and game folder!', 'success');
    } else if (exportJsonOnSave) {
      toast('Game saved to localStorage and JSON exported!', 'success');
    } else if (S.saveDirectoryHandle) {
      toast('Game saved to localStorage and file system!', 'success');
    } else {
      toast('Game saved!', 'success');
    }
  } else {
    updateSaveIndicator();
    toast('Save failed', 'error');
  }
}

function clearSavedData() {
  if (!S.gameId) return;
  if (!confirm('Clear all saved data for this game? This cannot be undone.')) return;
  
  const key = `bs_${S.gameId}`;
  localStorage.removeItem(key);
  S.events = [];
  S.shifts = [];
  S.evtIdx = 0;
  S.shiftIdx = 0;
  
  toast('Saved data cleared', 'success');
  renderAll();
}

// ============================================================
// BUILD UI
// ============================================================
function buildUI() {
  console.log('buildUI called');
  // v23.8: Ensure evtTypeGrid exists before building buttons
  const grid = document.getElementById('evtTypeGrid');
  if (!grid) {
    console.error('evtTypeGrid not found in DOM! Retrying...');
    setTimeout(buildUI, 100); // Retry after DOM is ready
    return;
  }
  
  console.log('Building event type buttons...');
  // v22.1: Use dynamic event types from Supabase, with "Show More" toggle
  buildEventTypeButtons();
  
  try {
    const shiftStartEl = document.getElementById('shiftStartType');
    const shiftStopEl = document.getElementById('shiftStopType');
    if (shiftStartEl && typeof LISTS !== 'undefined' && LISTS && LISTS.shiftStart) {
      shiftStartEl.innerHTML = LISTS.shiftStart.map(t => `<option value="${t}">${t}</option>`).join('');
    }
    if (shiftStopEl && typeof LISTS !== 'undefined' && LISTS && LISTS.shiftStop) {
      shiftStopEl.innerHTML = LISTS.shiftStop.map(t => `<option value="${t}">${t}</option>`).join('');
    }
  } catch(e) {
    console.error('Error building shift types:', e);
  }
  
  ['home','away'].forEach(team => {
    document.getElementById(`${team}F`).innerHTML = ['F1','F2','F3'].map(p => `<div class="slot" data-team="${team}" data-pos="${p}" onclick="selectSlot(this)"><span class="num">${p}</span></div>`).join('');
    document.getElementById(`${team}D`).innerHTML = ['D1','D2'].map(p => `<div class="slot" data-team="${team}" data-pos="${p}" onclick="selectSlot(this)"><span class="num">${p}</span></div>`).join('');
    document.getElementById(`${team}G`).innerHTML = ['G','X'].map(p => `<div class="slot" data-team="${team}" data-pos="${p}" onclick="selectSlot(this)"><span class="num">${p}</span></div>`).join('');
  });
  
  // v23.3: Setup drag and drop for shift slots
  setupSlotDragDrop();
  
  // Edit type dropdown - use dynamic types if available
  buildEditTypeDropdown();
  
  renderXYSlots();
}

// v22.1: Build event type buttons dynamically from dim_event_type
function buildEventTypeButtons() {
  try {
    const grid = document.getElementById('evtTypeGrid');
    if (!grid) {
      console.error('evtTypeGrid element not found!');
      // Retry after a short delay
      setTimeout(buildEventTypeButtons, 100);
      return;
    }
    
    // Main types always shown (common event types) - ALWAYS use these as fallback
    const mainTypeCodes = ['Faceoff','Shot','Pass','Goal','Turnover','Zone_Entry_Exit','Stoppage','Penalty','Possession','Save','Rebound','Play'];
    
    // Get types from Supabase or fall back to LISTS.eventTypes
    let allTypes = [];
    try {
      if (S && S.eventTypesDB && Array.isArray(S.eventTypesDB) && S.eventTypesDB.length > 0) {
        allTypes = S.eventTypesDB.map(e => (e && e.code) ? e.code : e).filter(Boolean);
      } else if (typeof LISTS !== 'undefined' && LISTS && LISTS.eventTypes && Array.isArray(LISTS.eventTypes) && LISTS.eventTypes.length > 0) {
        allTypes = LISTS.eventTypes;
      }
    } catch(e) {
      console.warn('Error getting event types:', e);
    }
    
    // Always fallback to mainTypeCodes if we don't have types
    if (allTypes.length === 0) {
      console.log('Using fallback event types');
      allTypes = mainTypeCodes;
    }
    
    // Separate main and extra types
    const mainTypes = allTypes.filter(t => mainTypeCodes.includes(t));
    const extraTypes = allTypes.filter(t => !mainTypeCodes.includes(t));
    
    // ALWAYS render main types - use mainTypeCodes if mainTypes is empty
    const typesToRender = mainTypes.length > 0 ? mainTypes : mainTypeCodes;
    
    // Build main type buttons
    let html = '';
    try {
      html = typesToRender.map(t => {
        const displayName = String(t).replace('_Entry_Exit', '');
        let hotkey = '';
        try {
          if (typeof LISTS !== 'undefined' && LISTS && LISTS.hotkeys && LISTS.hotkeys[t]) {
            hotkey = LISTS.hotkeys[t];
          }
        } catch(e) {}
        const tooltip = `Set event type: ${displayName}${hotkey ? ` (Press ${hotkey})` : ''}`;
        return `<button class="evt-btn" data-type="${t}" onclick="setEvtType('${t}')" title="${tooltip}">${displayName}${hotkey ? `<kbd>${hotkey}</kbd>` : ''}</button>`;
      }).join('');
    } catch(e) {
      console.error('Error building button HTML:', e);
      // Fallback: simple buttons without hotkeys
      html = typesToRender.map(t => {
        const displayName = String(t).replace('_Entry_Exit', '');
        return `<button class="evt-btn" data-type="${t}" onclick="setEvtType('${t}')">${displayName}</button>`;
      }).join('');
    }
    
    // Add "Show More" button if there are extra types
    if (extraTypes.length > 0) {
      const showAll = (S && S.showAllEventTypes) ? S.showAllEventTypes : false;
      html += `<button class="evt-btn" id="showMoreTypesBtn" onclick="toggleMoreEventTypes()" style="background:var(--surface);border:1px dashed var(--muted);" title="Show/hide additional event types">
        ${showAll ? '‚óÄ Less' : 'More ‚ñ∂'}
      </button>`;
      
      // Add extra types (hidden by default)
      html += `<div id="extraEventTypes" style="display:${showAll ? 'contents' : 'none'};">`;
      try {
        html += extraTypes.map(t => {
          let hotkey = '';
          try {
            if (typeof LISTS !== 'undefined' && LISTS && LISTS.hotkeys && LISTS.hotkeys[t]) {
              hotkey = LISTS.hotkeys[t];
            }
          } catch(e) {}
          return `<button class="evt-btn" data-type="${t}" onclick="setEvtType('${t}')">${t}${hotkey ? `<kbd>${hotkey}</kbd>` : ''}</button>`;
        }).join('');
      } catch(e) {
        html += extraTypes.map(t => {
          const tooltip = `Set event type: ${t}`;
          return `<button class="evt-btn" data-type="${t}" onclick="setEvtType('${t}')" title="${tooltip}">${t}</button>`;
        }).join('');
      }
      html += '</div>';
    }
    
    // Set the HTML
    grid.innerHTML = html;
    console.log('Event type buttons rendered:', typesToRender.length, 'main types');
  } catch(e) {
    console.error('Fatal error in buildEventTypeButtons:', e);
    // Last resort: render basic buttons
    const grid = document.getElementById('evtTypeGrid');
    if (grid) {
      const mainTypeCodes = ['Faceoff','Shot','Pass','Goal','Turnover','Zone_Entry_Exit','Stoppage','Penalty','Possession','Save','Rebound','Play'];
      grid.innerHTML = mainTypeCodes.map(t => {
        const displayName = t.replace('_Entry_Exit', '');
        return `<button class="evt-btn" data-type="${t}" onclick="setEvtType('${t}')">${displayName}</button>`;
      }).join('');
    }
  }
}

// v22.1: Toggle showing all event types
function toggleMoreEventTypes() {
  S.showAllEventTypes = !S.showAllEventTypes;
  buildEventTypeButtons();
}

// v22.1: Build edit type dropdown with dynamic types
function buildEditTypeDropdown() {
  const dropdown = document.getElementById('editType');
  
  // Get types from Supabase or fall back to LISTS.eventTypes
  const types = S.eventTypesDB.length > 0 
    ? S.eventTypesDB.map(e => e.code) 
    : LISTS.eventTypes;
  
  dropdown.innerHTML = types.map(t => `<option value="${t}">${t}</option>`).join('');
}

// ============================================================
// GAMES & ROSTERS - SUPABASE CONNECTED
// ============================================================
async function loadGames() {
  console.log('loadGames called, S.connected:', S.connected);
  try {
  if (S.connected) {
    try {
      console.log('Loading ALL games from dim_schedule...');
      
      // Load ALL games from dim_schedule (not just tracked)
      // Paginate through in case there are many games
      let allGames = [];
      let offset = 0;
      const pageSize = 1000;
      let hasMore = true;
      
      while (hasMore && offset < 50000) {
        console.log(`  Fetching page at offset ${offset}...`);
        const { data, error } = await S.sb.from('dim_schedule')
          .select('game_id,date,home_team_name,away_team_name')
          .order('date', {ascending: false})
          .range(offset, offset + pageSize - 1);
        
        if (error) {
          console.error('Error at offset', offset, ':', error);
          toast('Error loading games: ' + (error.message || error.code), 'error');
          break;
        }
        
        console.log(`  Got ${data?.length || 0} games`);
        
        if (!data || data.length === 0) {
          hasMore = false;
        } else {
          allGames = allGames.concat(data);
          console.log(`  Page ${offset/pageSize + 1}: ${data.length} games (total: ${allGames.length})`);
          offset += pageSize;
          if (data.length < pageSize) hasMore = false;
        }
      }
      
      console.log('Total games from schedule:', allGames.length);
      
      // Dedupe by game_id (in case of any duplicates)
      const gameMap = new Map();
      allGames.forEach(g => {
        if (!gameMap.has(g.game_id)) {
          gameMap.set(g.game_id, {
            game_id: g.game_id,
            game_date: g.date?.split('T')[0] || g.date,
            home_team_name: g.home_team_name,
            away_team_name: g.away_team_name,
            home_team_color: '#3b82f6',
            away_team_color: '#ef4444'
          });
        }
      });
      
      S.games = Array.from(gameMap.values()).sort((a, b) => {
        // Sort by date descending, then by game_id descending
        if (a.game_date !== b.game_date) return b.game_date.localeCompare(a.game_date);
        return b.game_id - a.game_id;
      });
      
      console.log('Final games list:', S.games.length, 'games');
      
      toast(`${S.games.length} games loaded`, 'success');
    } catch(e) { 
      console.error('Failed to load games from Supabase:', e);
      toast('Failed to load games: ' + e.message, 'error');
      S.games = []; 
    }
  } else { 
    S.games = []; 
    toast('Connect to Supabase to load games', 'info');
  }
  
  renderGameSelect(S.games);
  if (S.gameId) document.getElementById('gameSelect').value = S.gameId;
  } catch(e) {
    console.error('Error in loadGames:', e);
    toast('Error loading games: ' + e.message, 'error');
    S.games = [];
    renderGameSelect(S.games);
  }
}

function renderGameSelect(games) {
  const sel = document.getElementById('gameSelect');
  sel.innerHTML = '<option value="">-- Select Game (' + games.length + ') --</option>' + games.slice(0, 100).map(g => 
    `<option value="${g.game_id}">${g.game_id}: ${g.home_team_name} vs ${g.away_team_name} (${g.game_date})</option>`
  ).join('');
}

function filterGames(query) {
  if (!query) {
    renderGameSelect(S.games);
    return;
  }
  const q = query.toLowerCase();
  const filtered = S.games.filter(g => 
    g.game_id.toString().includes(q) ||
    g.home_team_name?.toLowerCase().includes(q) ||
    g.away_team_name?.toLowerCase().includes(q) ||
    g.game_date?.includes(q)
  );
  renderGameSelect(filtered);
}

async function selectGame(gid) {
  if (!gid) return;
  S.gameId = parseInt(gid);
  localStorage.setItem('bs_lastGame', gid);
  
  // v24.0: Update game links in header
  updateGameLinks();
  
  // Create/get game folder if default folder is set
  await ensureGameFolder();
  
  const g = S.games.find(x => x.game_id == gid);
  if (!g) { toast('Game not found', 'error'); return; }
  
  S.homeTeam = g.home_team_name; S.awayTeam = g.away_team_name;
  
  // v15.01: Use cached team data if available, otherwise load from Supabase
  const homeTeamData = S.teams[g.home_team_name];
  const awayTeamData = S.teams[g.away_team_name];
  
  if (homeTeamData && awayTeamData) {
    S.homeColor = homeTeamData.color1 || '#3b82f6';
    S.awayColor = awayTeamData.color1 || '#ef4444';
    S.homeLogo = homeTeamData.logo || null;
    S.awayLogo = awayTeamData.logo || null;
  } else if (S.connected) {
    try {
      const { data: teamData } = await S.sb.from('dim_team')
        .select('team_name,team_color1,team_logo')
        .in('team_name', [g.home_team_name, g.away_team_name]);
      
      if (teamData?.length) {
        const homeTeam = teamData.find(t => t.team_name === g.home_team_name);
        const awayTeam = teamData.find(t => t.team_name === g.away_team_name);
        S.homeColor = homeTeam?.team_color1 || '#3b82f6';
        S.awayColor = awayTeam?.team_color1 || '#ef4444';
        S.homeLogo = homeTeam?.team_logo || null;
        S.awayLogo = awayTeam?.team_logo || null;
      }
    } catch(e) { console.log('Failed to load team colors:', e); }
  }
  console.log('Team colors:', S.homeColor, S.awayColor);
  
  // Update UI with team names (not just Home/Away)
  document.getElementById('homeLbl').textContent = S.homeTeam;
  document.getElementById('awayLbl').textContent = S.awayTeam;
  document.getElementById('evtHomeLbl').textContent = S.homeTeam;
  document.getElementById('evtAwayLbl').textContent = S.awayTeam;
  document.getElementById('homeDot').style.background = S.homeColor;
  document.getElementById('awayDot').style.background = S.awayColor;
  document.documentElement.style.setProperty('--home', S.homeColor);
  document.documentElement.style.setProperty('--away', S.awayColor);
  
  // v24.0: Update game links in header
  updateGameLinks();
  
  // Update filter dropdown with team names
  const filterTeamSel = document.getElementById('filterEvtTeam');
  if (filterTeamSel) {
    filterTeamSel.innerHTML = `<option value="">All</option><option value="home">${S.homeTeam}</option><option value="away">${S.awayTeam}</option>`;
  }
  
  // v15.01: Update team logos if elements exist
  const homeLogoEl = document.getElementById('homeLogoImg');
  const awayLogoEl = document.getElementById('awayLogoImg');
  if (homeLogoEl) homeLogoEl.src = S.homeLogo || '';
  if (awayLogoEl) awayLogoEl.src = S.awayLogo || '';
  
  // Update zone labels on rink (based on current period)
  updateZoneLabels();
  
  await loadRosters(gid);
  loadGameData(gid);
  
  // v23.9: Load event chain templates
  loadEventChainTemplates();
  
  // v26.0: Reset and start work timer when loading a new game
  resetWorkTimer();
  startWorkTimer();
  
  renderAll();
  toast(`Loaded: ${S.homeTeam} vs ${S.awayTeam}`, 'success');
}

async function loadRosters(gid) {
  if (!S.connected) { 
    generateDemoRosters(); 
    toast('Demo rosters loaded (not connected)', 'info');
    return;
  }
  
  try {
    // Query fact_gameroster for this game
    // Note: player_rating not in table, will be null
    const { data, error } = await S.sb.from('fact_gameroster')
      .select('player_id,player_game_number,player_full_name,player_position,team_venue')
      .eq('game_id', gid)
      .order('player_game_number');
    
    if (error) {
      console.error('Roster query error:', error);
      throw error;
    }
    
    console.log('Raw roster data for game', gid, ':', data?.length, 'players');
    
    if (!data || data.length === 0) {
      // Try alternate column names
      console.log('No data with standard columns, trying alternate...');
      const { data: altData, error: altErr } = await S.sb.from('fact_gameroster')
        .select('*')
        .eq('game_id', gid)
        .limit(50);
      
      if (altErr) throw altErr;
      
      if (altData?.length > 0) {
        console.log('Alt data columns:', Object.keys(altData[0]));
        
        // Try to map alternate column names
        const homeMap = new Map();
        const awayMap = new Map();
        
        altData.forEach(p => {
          const venue = p.team_venue || p.venue || p.team || '';
          const isHome = venue.toLowerCase().includes('home');
          const map = isHome ? homeMap : awayMap;
          const playerId = p.player_id || p.id || '';
          
          if (!map.has(playerId)) {
            map.set(playerId, {
              id: playerId,
              num: String(p.player_game_number || p.jersey_number || p.number || '?'),
              name: p.player_full_name || p.full_name || p.name || 'Unknown',
              pos: normalizePosition(p.player_position || p.position),
              rating: p.player_rating || p.rating || null
            });
          }
        });
        
        S.rosters = {
          home: Array.from(homeMap.values()).sort((a,b) => parseInt(a.num) - parseInt(b.num)),
          away: Array.from(awayMap.values()).sort((a,b) => parseInt(a.num) - parseInt(b.num))
        };
      } else {
        console.log('No roster data found for game', gid);
        generateDemoRosters();
        toast('No roster data - using demo', 'warning');
        return;
      }
    } else {
      // Standard processing - v15: Case-insensitive team_venue check
      const homeMap = new Map();
      const awayMap = new Map();
      
      data.forEach(p => {
        const venue = (p.team_venue || '').toLowerCase();
        const map = venue === 'home' ? homeMap : awayMap;
        if (!map.has(p.player_id)) {
          map.set(p.player_id, { 
            id: p.player_id, 
            num: String(p.player_game_number), 
            name: p.player_full_name, 
            pos: normalizePosition(p.player_position),
            rating: null  // Not in fact_gameroster
          });
        }
      });
      
      S.rosters = { 
        home: Array.from(homeMap.values()).sort((a,b) => parseInt(a.num) - parseInt(b.num)),
        away: Array.from(awayMap.values()).sort((a,b) => parseInt(a.num) - parseInt(b.num))
      };
    }
    
    console.log('Final rosters:', S.rosters.home.length, 'home,', S.rosters.away.length, 'away');
    
    if (S.rosters.home.length === 0 && S.rosters.away.length === 0) {
      toast('No players found for this game', 'warning');
      generateDemoRosters();
    } else {
      toast(`Loaded ${S.rosters.home.length + S.rosters.away.length} players`, 'success');
    }
  } catch(e) { 
    console.error('Failed to load rosters:', e);
    toast('Roster load failed: ' + e.message, 'error');
    generateDemoRosters(); 
  }
}

function generateDemoRosters() {
  S.rosters = {
    home: Array.from({length:12}, (_,i) => ({id:'H'+(i+1), num:String(i+1), name:'Home'+i, pos:i<6?'F':i<10?'D':'G'})),
    away: Array.from({length:12}, (_,i) => ({id:'A'+(i+1), num:String(i+11), name:'Away'+i, pos:i<6?'F':i<10?'D':'G'}))
  };
}

/**
 * Normalize position string to F/D/G format
 * @param {string} pos - Raw position string from database
 * @returns {string} - Normalized position (F, D, or G)
 */
function normalizePosition(pos) {
  if (!pos) return 'F';
  const p = String(pos).toLowerCase().trim();
  if (p === 'g' || p === 'goal' || p === 'goalie' || p === 'goalkeeper' || p === 'goaltender') return 'G';
  if (p === 'd' || p === 'def' || p === 'defense' || p === 'defenseman' || p === 'defenceman') return 'D';
  return 'F'; // Forward by default
}

function loadGameData(gid) {
  try {
    const saved = localStorage.getItem(`bs_${gid}`);
    if (saved) {
      const d = JSON.parse(saved);
      S.events = d.events || []; 
      S.shifts = d.shifts || [];
      S.evtIdx = d.evtIdx || S.events.length; 
      S.shiftIdx = d.shiftIdx || S.shifts.length;
      
      // Restore video timing if saved
      if (d.videoTiming) {
        S.videoTiming = { ...S.videoTiming, ...d.videoTiming };
      }
      // v23.6: Restore videos if saved
      if (d.videos) {
        S.videos = d.videos;
      } else {
        S.videos = [];
      }
      // v23.7: Restore highlight videos if saved
      if (d.highlightVideos) {
        S.highlightVideos = d.highlightVideos;
      } else {
        S.highlightVideos = [];
      }
      if (d.periodLength) {
        S.periodLength = d.periodLength;
      }
    } else {
      S.events = []; S.shifts = []; S.evtIdx = 0; S.shiftIdx = 0;
      // Reset video timing to defaults for new game
      S.videoTiming = {
        videoStartOffset: 0,
        intermission1: 900,
        intermission2: 900,
        timeouts: [],
        youtubeUrl: ''
      };
      S.videos = []; // v23.6: Initialize videos array
      S.highlightVideos = []; // v23.7: Initialize highlight videos array
    }
    
    // v23.8: Process all goals to detect and link assists after loading
    if (S.events && S.events.length > 0) {
      processAllGoalsForAssists();
    }
  } catch(e) { 
    S.events = []; S.shifts = []; S.evtIdx = 0; S.shiftIdx = 0; 
  }
}

// ============================================================
// ZONE AUTO-CALCULATION (switches by period)
// ============================================================
function calculateZone() {
  // Get event_player_1's last XY position
  const evtP1 = S.curr.players.find(p => p.role === 'event_team_player_1');
  if (!evtP1?.xy?.length) return '';
  
  const lastXY = evtP1.xy[evtP1.xy.length - 1];
  if (!lastXY) return '';
  
  // NHL Rink: 200 wide
  // Blue lines at x=75 and x=125 (correct NHL dimensions)
  // 0-75 = left zone, 75-125 = neutral, 125-200 = right zone
  // Use S.homeAttacksRightP1 to determine initial orientation
  // Odd periods (1, 3, OT): Use P1 setting
  // Even periods (2): Flip from P1 setting
  const x = lastXY.x;
  const isOddPeriod = S.period === 1 || S.period === 3 || S.period === 'OT';
  
  // Determine which end is offensive for each team based on configurable setting
  const homeOffensiveRight = isOddPeriod ? S.homeAttacksRightP1 : !S.homeAttacksRightP1;
  
  if (S.evtTeam === 'home') {
    if (homeOffensiveRight) {
      if (x > 125) return 'o';      // Home offensive (right in odd periods)
      else if (x < 75) return 'd';  // Home defensive (left in odd periods)
      else return 'n';
    } else {
      if (x < 75) return 'o';       // Home offensive (left in even periods)
      else if (x > 125) return 'd'; // Home defensive (right in even periods)
      else return 'n';
    }
  } else {
    // Away team is opposite
    if (homeOffensiveRight) {
      if (x < 75) return 'o';       // Away offensive (left in odd periods)
      else if (x > 125) return 'd'; // Away defensive (right in odd periods)
      else return 'n';
    } else {
      if (x > 125) return 'o';      // Away offensive (right in even periods)
      else if (x < 75) return 'd';  // Away defensive (left in even periods)
      else return 'n';
    }
  }
}

function updateZoneLabels(periodOverride) {
  // v24.0: Update zone labels on rink based on period and configurable setting
  // If periodOverride is provided (e.g., when editing an event), use that instead of S.period
  // If editing an event, use the editing period if available
  let period = periodOverride;
  if (period === undefined) {
    // Check if we're editing an event and use its period
    if (S.editingPeriod !== null && S.editingPeriod !== undefined) {
      period = S.editingPeriod;
    } else {
      period = S.period;
    }
  }
  const isOddPeriod = period === 1 || period === 3 || period === 'OT' || period === 4;
  const homeOffensiveRight = isOddPeriod ? S.homeAttacksRightP1 : !S.homeAttacksRightP1;
  const homeShort = (S.homeTeam || 'HOME').toUpperCase().slice(0,6);
  const awayShort = (S.awayTeam || 'AWAY').toUpperCase().slice(0,6);
  
  // v24.0: Update both main rink and edit rink zone labels
  const leftLbl = document.getElementById('leftZoneLbl');
  const rightLbl = document.getElementById('rightZoneLbl');
  const editLeftLbl = document.getElementById('editLeftZoneLbl');
  const editRightLbl = document.getElementById('editRightZoneLbl');
  
  if (homeOffensiveRight) {
    // Home attacks right
    if (leftLbl) leftLbl.textContent = awayShort + ' OFF';
    if (rightLbl) rightLbl.textContent = homeShort + ' OFF';
    if (editLeftLbl) editLeftLbl.textContent = awayShort + ' OFF';
    if (editRightLbl) editRightLbl.textContent = homeShort + ' OFF';
  } else {
    // Home attacks left
    if (leftLbl) leftLbl.textContent = homeShort + ' OFF';
    if (rightLbl) rightLbl.textContent = awayShort + ' OFF';
    if (editLeftLbl) editLeftLbl.textContent = homeShort + ' OFF';
    if (editRightLbl) editRightLbl.textContent = awayShort + ' OFF';
  }
}

/**
 * v16: Update team logos in UI
 */
function updateTeamLogos() {
  // Update existing logo img elements
  const homeLogoImg = document.getElementById('homeLogoImg');
  const awayLogoImg = document.getElementById('awayLogoImg');
  
  if (homeLogoImg) {
    if (S.homeLogo) {
      homeLogoImg.src = S.homeLogo;
      homeLogoImg.alt = S.homeTeam;
      homeLogoImg.style.display = 'inline';
    } else {
      homeLogoImg.style.display = 'none';
    }
  }
  
  if (awayLogoImg) {
    if (S.awayLogo) {
      awayLogoImg.src = S.awayLogo;
      awayLogoImg.alt = S.awayTeam;
      awayLogoImg.style.display = 'inline';
    } else {
      awayLogoImg.style.display = 'none';
    }
  }
  
  // Update team dots with team colors
  const homeDot = document.getElementById('homeDot');
  const awayDot = document.getElementById('awayDot');
  if (homeDot) homeDot.style.backgroundColor = S.homeColor || '#3b82f6';
  if (awayDot) awayDot.style.backgroundColor = S.awayColor || '#ef4444';
}

function updateZoneDisplay() {
  const zone = document.getElementById('evtZone')?.value || calculateZone();
  const el = document.getElementById('zoneDisplay');
  if (!el) return; // Element doesn't exist (e.g., in edit modal or side panel)
  if (zone) {
    const labels = { o: 'OFFENSIVE', d: 'DEFENSIVE', n: 'NEUTRAL' };
    el.innerHTML = `<span class="zone-ind ${zone}">${labels[zone]}</span>`;
  } else { el.innerHTML = ''; }
}

// ============================================================
// SUCCESS AUTO-DERIVATION
// ============================================================
function deriveSuccess() {
  const type = S.curr.type;
  const d1 = document.getElementById('evtD1').value;
  
  // Auto-derive based on event type and detail
  if (type === 'Shot') {
    if (d1.includes('OnNet') || d1.includes('Goal')) return 's';
    if (d1.includes('Missed') || d1.includes('Blocked')) return 'u';
  }
  if (type === 'Pass') {
    if (d1.includes('Completed')) return 's';
    if (d1.includes('Missed') || d1.includes('Intercepted')) return 'u';
  }
  if (type === 'Zone_Entry_Exit') {
    if (d1.includes('Failed')) return 'u';
    if (d1.includes('Entry') || d1.includes('Exit') || d1.includes('Keepin')) return 's';
  }
  if (type === 'Turnover') {
    if (d1.includes('Takeaway')) return 's';
    if (d1.includes('Giveaway')) return 'u';
  }
  if (type === 'Goal') return 's';
  if (type === 'Save') return 's';
  
  return '';
}

/**
 * v16.06: Auto-derive play success for all players based on event success
 * Event team player 1 gets the event success
 * Opposing players get inverse if applicable
 */
function derivePlayerSuccess() {
  const evtSuccess = document.getElementById('evtSuccess').value;
  if (!evtSuccess) return;
  
  S.curr.players.forEach(p => {
    if (p.role === 'event_player_1') {
      // Primary player gets event success
      p.playSuccess = evtSuccess;
    } else if (p.role?.startsWith('event')) {
      // Secondary event players - often also successful if event was
      p.playSuccess = evtSuccess;
    } else if (p.role?.startsWith('opp')) {
      // Opponent players - inverse success for turnovers
      const type = S.curr.type;
      if (type === 'Turnover') {
        p.playSuccess = evtSuccess === 's' ? 'u' : 's';
      }
    }
  });
  
  renderQuickAdd();
  toast('Play success auto-derived from event success', 'info');
}

/**
 * v23.8: Auto-detect success for all players
 */
function autoDetectAllSuccess() {
  if (!autoSuccessEnabled) return;
  const evtSuccess = document.getElementById('evtSuccess').value || deriveSuccess();
  if (!evtSuccess) return;
  
  S.curr.players.forEach(p => {
    if (p.role === 'event_player_1' || p.role === 'event_team_player_1') {
      p.playSuccess = evtSuccess;
    } else if (p.role?.startsWith('event')) {
      p.playSuccess = evtSuccess;
    } else if (p.role?.startsWith('opp')) {
      const type = S.curr.type;
      if (type === 'Turnover') {
        p.playSuccess = evtSuccess === 's' ? 'u' : 's';
      }
    }
  });
  
  // Update quick add display if function exists
  if (typeof renderQuickAdd === 'function') renderQuickAdd();
}

/**
 * v16.06: Auto-calc pressure for selected player
 */
function autoCalcPressure() {
  detectPressure();
  if (S.selectedPlayer) {
    const pressureSel = document.getElementById('pdPressure');
    if (pressureSel && S.selectedPlayer.pressure) {
      pressureSel.value = S.selectedPlayer.pressure;
      toast(`Pressure set to #${S.selectedPlayer.pressure}`, 'info');
    } else {
      toast('No opponent within pressure distance', 'warning');
    }
  }
}

// ============================================================
// PRESSURE AUTO-DETECTION
// ============================================================
function detectPressure() {
  const pressureDist = parseInt(document.getElementById('pressureDist').value) || 10;
  const pixelsPerFoot = 1; // Adjust based on rink scale (200px = 200ft)
  const threshold = pressureDist * pixelsPerFoot;
  
  // For each event player, check distance to opposing players
  const evtPlayers = S.curr.players.filter(p => p.role?.startsWith('event'));
  const oppPlayers = S.curr.players.filter(p => p.role?.startsWith('opp'));
  
  evtPlayers.forEach(ep => {
    if (!ep.xy?.length) return;
    const epPos = ep.xy[ep.xy.length - 1];
    
    let closestOpp = null;
    let closestDist = Infinity;
    
    oppPlayers.forEach(op => {
      if (!op.xy?.length) return;
      const opPos = op.xy[op.xy.length - 1];
      
      const dist = Math.sqrt(Math.pow(epPos.x - opPos.x, 2) + Math.pow(epPos.y - opPos.y, 2));
      if (dist <= threshold && dist < closestDist) {
        closestDist = dist;
        closestOpp = op;
      }
    });
    
    // v16.06: Auto-set pressure if closest opponent is within threshold
    if (closestOpp) {
      ep.pressure = closestOpp.num;
    }
  });
  
  // Update pressure dropdown if a player is selected
  if (S.selectedPlayer && S.selectedPlayer.role?.startsWith('event')) {
    const pressureSel = document.getElementById('pdPressure');
    if (pressureSel && S.selectedPlayer.pressure) {
      pressureSel.value = S.selectedPlayer.pressure;
    }
  }
}

/**
 * v23.8: Auto-detect pressure for all event players
 */
function autoDetectAllPressure() {
  if (!autoPressureEnabled) return;
  detectPressure();
  if (typeof renderQuickAdd === 'function') renderQuickAdd();
}

// ============================================================
// RENDER FUNCTIONS
// ============================================================
function renderAll() {
  renderSlots(); 
  renderRosters(); 
  renderQuickAdd(); 
  renderEvents(); 
  renderMarkers(); 
  updateScores(); 
  updateZoneDisplay(); 
  renderShiftLog(); 
  updateBoxScore();
  updateNextPlaySuggestions();
  updateZoneLabels();
}

function renderShiftLog() {
  const body = document.getElementById('shiftLogBody');
  if (!body) return;
  
  // v6: Filter by period
  let filteredShifts = S.shifts;
  if (S.shiftLogFilter && S.shiftLogFilter !== 'all') {
    if (S.shiftLogFilter === 'issues') {
      // v23.8: Filter shifts with issues
      filteredShifts = S.shifts.filter(s => {
        // Check for missing start/end time
        if (!s.start_time || !s.end_time) return true;
        
        // Check for invalid time range (start > end)
        const parseTime = (t) => {
          if (!t) return null;
          const parts = String(t).split(':');
          if (parts.length !== 2) return null;
          const min = parseInt(parts[0]);
          const sec = parseInt(parts[1]);
          if (isNaN(min) || isNaN(sec)) return null;
          return min * 60 + sec;
        };
        const startSec = parseTime(s.start_time);
        const endSec = parseTime(s.end_time);
        // Clock counts DOWN (18:00 -> 0:00), so end time should be <= start time
        // Invalid if end > start (e.g., 18:00 start, 18:01 end)
        if (startSec !== null && endSec !== null && endSec > startSec) return true;
        
        // Check for missing players
        const homeCount = ['F1','F2','F3','D1','D2','X'].filter(p => s.home?.[p]?.num).length;
        const awayCount = ['F1','F2','F3','D1','D2','X'].filter(p => s.away?.[p]?.num).length;
        if (homeCount === 0 && awayCount === 0) return true;
        
        return false;
      });
    } else {
      filteredShifts = S.shifts.filter(s => String(s.period) === S.shiftLogFilter);
    }
  }
  
  // v23.8: Filter by player search (number or name)
  if (S.shiftLogPlayerFilter) {
    const search = S.shiftLogPlayerFilter.toLowerCase();
    filteredShifts = filteredShifts.filter(shift => {
      // Check home team players
      const homeMatch = shift.home && Object.values(shift.home).some(p => {
        if (!p || !p.num) return false;
        const numMatch = String(p.num).toLowerCase().includes(search);
        const nameMatch = (p.name || '').toLowerCase().includes(search);
        return numMatch || nameMatch;
      });
      
      // Check away team players
      const awayMatch = shift.away && Object.values(shift.away).some(p => {
        if (!p || !p.num) return false;
        const numMatch = String(p.num).toLowerCase().includes(search);
        const nameMatch = (p.name || '').toLowerCase().includes(search);
        return numMatch || nameMatch;
      });
      
      return homeMatch || awayMatch;
    });
  }
  
  // v23.9: Show all shifts (scrollable) in ASCENDING order (oldest to newest)
  // Changed from slice(-50) to show all shifts, starting from the first ones
  const displayShifts = filteredShifts; // Show all filtered shifts
  const startIdx = 0;
  
  body.innerHTML = displayShifts.map((s, i) => {
    const actualIdx = S.shifts.indexOf(s); // Get actual index in full array
    const stoppageTime = s.stoppageTime || 0;
    const stoppageDisplay = stoppageTime > 0 ? `<span style="color:var(--warn);font-size:7px;">${stoppageTime}s</span>` : '';
    
    // Count players
    const homeCount = ['F1','F2','F3','D1','D2','X'].filter(p => s.home?.[p]?.num).length;
    const awayCount = ['F1','F2','F3','D1','D2','X'].filter(p => s.away?.[p]?.num).length;
    const strength = s.strength || `${homeCount}v${awayCount}`;
    
    // Click to edit shift
    return `<div class="log-item" style="grid-template-columns: 20px 20px 32px 32px 35px 40px 20px;font-size:8px;cursor:pointer;" onclick="editShift(${actualIdx})" title="Shift #${actualIdx+1} | ${strength} | Stoppage: ${stoppageTime}s | Click to edit">
      <span>${actualIdx + 1}</span>
      <span>P${s.period}</span>
      <span>${s.start_time}</span>
      <span>${s.end_time}</span>
      <span style="color:var(--accent);">${strength}</span>
      <span style="overflow:hidden;text-overflow:ellipsis;font-size:7px;">${s.stop_type || ''}</span>
      ${stoppageDisplay}
    </div>`;
  }).join('') || '<div style="color:var(--muted);font-size:8px;padding:4px;">No shifts</div>';
}

/**
 * v23.8: Handle shift click - populate players if adding event, edit if Ctrl+click or already editing
 */
function handleShiftClick(idx, event) {
  // Ctrl+click or Cmd+click = edit shift
  if (event.ctrlKey || event.metaKey || S.editingEvtIdx !== null) {
    editShift(idx);
    return;
  }
  
  // Regular click = populate players from shift (when adding new event)
  populatePlayersFromShift(idx);
}

/**
 * v23.8: Populate current event players from a shift
 */
function populatePlayersFromShift(shiftIdx) {
  const shift = S.shifts[shiftIdx];
  if (!shift) {
    toast('Shift not found', 'error');
    return;
  }
  
  // Clear current players (user will select which ones to add)
  S.curr.players = [];
  
  // Populate slots from shift (this makes players available in quick add buttons)
  // Clear existing slots first
  S.slots.home = { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null };
  S.slots.away = { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null };
  
  // Populate home team slots from shift
  if (shift.home) {
    ['F1', 'F2', 'F3', 'D1', 'D2', 'G', 'X'].forEach(pos => {
      const p = shift.home[pos];
      if (p?.num) {
        // Find player in roster to get full details
        const rosterPlayer = S.rosters?.home?.find(rp => String(rp.num) === String(p.num));
        if (rosterPlayer) {
          S.slots.home[pos] = {
            num: rosterPlayer.num,
            name: rosterPlayer.name,
            pos: rosterPlayer.pos || pos
          };
        } else {
          // Fallback to shift data
          S.slots.home[pos] = {
            num: p.num,
            name: p.name || `#${p.num}`,
            pos: pos
          };
        }
      }
    });
  }
  
  // Populate away team slots from shift
  if (shift.away) {
    ['F1', 'F2', 'F3', 'D1', 'D2', 'G', 'X'].forEach(pos => {
      const p = shift.away[pos];
      if (p?.num) {
        // Find player in roster to get full details
        const rosterPlayer = S.rosters?.away?.find(rp => String(rp.num) === String(p.num));
        if (rosterPlayer) {
          S.slots.away[pos] = {
            num: rosterPlayer.num,
            name: rosterPlayer.name,
            pos: rosterPlayer.pos || pos
          };
        } else {
          // Fallback to shift data
          S.slots.away[pos] = {
            num: p.num,
            name: p.name || `#${p.num}`,
            pos: pos
          };
        }
      }
    });
  }
  
  // Set event team based on shift (default to home, or use current team)
  if (shift.team) {
    S.evtTeam = shift.team;
    const teamSel = document.getElementById('evtTeam');
    if (teamSel) teamSel.value = shift.team;
    if (typeof updateEvtTeamUI === 'function') updateEvtTeamUI();
  }
  
  // Set period if not already set
  if (shift.period && !S.period) {
    S.period = shift.period;
    document.querySelectorAll('.period-btn').forEach(btn => {
      btn.classList.remove('active');
      if (btn.dataset.p == shift.period) btn.classList.add('active');
    });
  }
  
  // Set strength from shift
  if (shift.strength) {
    const strengthEl = document.getElementById('evtStrength');
    if (strengthEl) strengthEl.value = shift.strength;
  }
  
  // Update slots display and quick add buttons
  if (typeof renderSlots === 'function') renderSlots();
  if (typeof renderQuickAdd === 'function') renderQuickAdd();
  if (typeof renderCurrentPlayers === 'function') renderCurrentPlayers();
  if (typeof onSlotsChanged === 'function') onSlotsChanged(); // Update strength display
  
  // v23.8: Update box score and scores to show stats up to this shift
  const shiftEndTime = shift.end_time || shift.start_time;
  const shiftPeriod = shift.period;
  
  // Helper function to parse time string to seconds
  const parseTimeToSeconds = (timeStr) => {
    if (!timeStr) return 0;
    const parts = String(timeStr).split(':');
    if (parts.length !== 2) return 0;
    const min = parseInt(parts[0]) || 0;
    const sec = parseInt(parts[1]) || 0;
    return min * 60 + sec;
  };
  
  // Helper function to compare times (handles period differences)
  const isEventBeforeShift = (evt) => {
    if (!evt.start_time && !evt.time) return false;
    
    const evtPeriod = evt.period;
    const evtTime = evt.start_time || evt.time;
    
    // If event is in an earlier period, include it
    if (evtPeriod < shiftPeriod) return true;
    
    // If event is in a later period, exclude it
    if (evtPeriod > shiftPeriod) return false;
    
    // Same period - compare times
    const evtSeconds = parseTimeToSeconds(evtTime);
    const shiftSeconds = parseTimeToSeconds(shiftEndTime);
    
    return evtSeconds <= shiftSeconds;
  };
  
  // Find all events that occurred before or at the shift end time
  const eventsBeforeShift = S.events.filter(isEventBeforeShift);
  
  // Find the event with the highest array index (most recent) that meets criteria
  let cutoffEventIdx = null;
  if (eventsBeforeShift.length > 0) {
    // Get the actual array index in S.events for each event
    const eventIndices = eventsBeforeShift.map(e => S.events.indexOf(e)).filter(idx => idx !== -1);
    
    if (eventIndices.length > 0) {
      cutoffEventIdx = Math.max(...eventIndices);
    }
  }
  
  // Update box score and scores with the cutoff (use array index)
  // This shows stats only up to the point in time when this shift ended
  updateBoxScore(cutoffEventIdx);
  updateScores(cutoffEventIdx);
  
  const homeCount = Object.values(S.slots.home).filter(Boolean).length;
  const awayCount = Object.values(S.slots.away).filter(Boolean).length;
  toast(`Loaded ${homeCount + awayCount} players from shift #${shiftIdx + 1} - click to add to event`, 'success');
}

function editShift(idx) {
  try {
    console.log('Opening edit shift modal for shift', idx);
    
  if (idx === null || idx === undefined || idx < 0 || idx >= S.shifts.length) {
      console.error('Invalid shift index:', idx);
    toast('Invalid shift index', 'error');
    return;
  }
  
  S.editingShiftIdx = idx;
  const shift = S.shifts[idx];
  if (!shift) {
      console.error('Shift not found at index', idx);
    toast('Shift not found', 'error');
    return;
  }
  
  // Populate dropdowns first
  const startTypeEl = document.getElementById('editShiftStartType');
  const stopTypeEl = document.getElementById('editShiftStopType');
  
  if (startTypeEl) {
    startTypeEl.innerHTML = LISTS.shiftStart.map(t => 
      `<option value="${t}" ${shift.start_type === t ? 'selected' : ''}>${t}</option>`
    ).join('');
  }
  
  if (stopTypeEl) {
    stopTypeEl.innerHTML = LISTS.shiftStop.map(t => 
      `<option value="${t}" ${shift.stop_type === t ? 'selected' : ''}>${t}</option>`
    ).join('');
  }
  
  // Populate edit shift modal
  const idxEl = document.getElementById('editShiftIdx');
  if (idxEl) idxEl.textContent = idx + 1;
  
  const periodEl = document.getElementById('editShiftPeriod');
  if (periodEl) periodEl.value = shift.period;
  
  const startTimeEl = document.getElementById('editShiftStartTime');
  if (startTimeEl) startTimeEl.value = shift.start_time || '';
  
  const endTimeEl = document.getElementById('editShiftEndTime');
  if (endTimeEl) endTimeEl.value = shift.end_time || '';
  
  const strengthEl = document.getElementById('editShiftStrength');
  if (strengthEl) strengthEl.value = shift.strength || '5v5';
  
  // Render players
  renderEditShiftPlayers(shift);
  
  const modal = document.getElementById('editShiftModal');
    if (!modal) {
      console.error('editShiftModal element not found!');
      toast('Edit shift modal not found. Please refresh the page.', 'error');
      return;
    }
    
    // Ensure modal is in body (move if needed)
    if (modal.parentElement !== document.body) {
      document.body.appendChild(modal);
    }
    
    // Temporarily disable transition for instant visibility
    const originalTransition = modal.style.transition;
    modal.style.transition = 'none';
    modal.classList.add('show');
    modal.style.display = 'flex';
    modal.style.visibility = 'visible';
    modal.style.opacity = '1';
    modal.style.zIndex = '10000';
    modal.style.position = 'fixed';
    modal.style.top = '0';
    modal.style.left = '0';
    modal.style.right = '0';
    modal.style.bottom = '0';
    modal.style.width = '100%';
    modal.style.height = '100%';
    modal.style.background = 'rgba(0,0,0,0.85)';
    
    // Ensure the modal content div is properly positioned
    const modalContent = modal.querySelector('.modal');
    if (modalContent) {
      modalContent.style.position = 'relative';
      modalContent.style.zIndex = '10001';
    }
    
    // Remove ALL existing handlers that might interfere
    if (modal._overlayClickHandler) {
      modal.removeEventListener('click', modal._overlayClickHandler);
      modal.removeEventListener('mousedown', modal._overlayClickHandler);
      delete modal._overlayClickHandler;
    }
    modal.onclick = null; // Clear any existing onclick
    
    // Use simple inline onclick pattern like genericModal - proven to work
    // This doesn't interfere with buttons because it only runs if e.target === modal
    modal.onclick = null;
    modal.removeAttribute('onclick');
    
    // Set overlay click handler (only fires when clicking overlay itself, not children)
    modal.setAttribute('onclick', 'if(event.target===this)closeEditShiftModal()');
    
    // Make ALL buttons work
    ensureModalButtonsWork(modal);
    
    console.log('Edit shift modal opened, z-index:', modal.style.zIndex, 'display:', modal.style.display, 'visibility:', modal.style.visibility);
    
    // Re-enable transition after a brief delay
    setTimeout(() => {
      modal.style.transition = originalTransition || '';
    }, 50);
    
    // Force visibility immediately with multiple checks
    requestAnimationFrame(() => {
      const computedStyle = window.getComputedStyle(modal);
      console.log('Shift modal computed display:', computedStyle.display, 'visibility:', computedStyle.visibility, 'opacity:', computedStyle.opacity, 'z-index:', computedStyle.zIndex);
      if (computedStyle.display === 'none' || computedStyle.visibility === 'hidden' || computedStyle.opacity === '0') {
        console.error('Shift modal still not visible, forcing display again');
        modal.style.transition = 'none';
        modal.style.display = 'flex';
        modal.style.visibility = 'visible';
        modal.style.opacity = '1';
        modal.style.zIndex = '10000';
        modal.style.background = 'rgba(0,0,0,0.85)';
        // Also check parent elements
        let parent = modal.parentElement;
        while (parent && parent !== document.body) {
          const parentStyle = window.getComputedStyle(parent);
          if (parentStyle.display === 'none' || parentStyle.visibility === 'hidden') {
            console.error('Parent element is hiding shift modal:', parent);
            parent.style.display = 'block';
            parent.style.visibility = 'visible';
          }
          parent = parent.parentElement;
        }
        setTimeout(() => {
          modal.style.transition = originalTransition || '';
        }, 50);
      }
    });
  } catch (err) {
    console.error('Error opening edit shift modal:', err);
    toast('Error opening edit shift: ' + err.message, 'error');
  }
}

function deriveShiftStartType(idx) {
  // Auto-derive start type from previous event/shift
  if (idx === 0) return 'GameStart';
  
  const prevShift = S.shifts[idx - 1];
  if (prevShift?.stop_type === 'GoalScored') return 'FaceoffAfterGoal';
  if (prevShift?.stop_type === 'Penalty') return 'FaceoffAfterPenalty';
  if (prevShift?.stop_type === 'PeriodEnd') return 'PeriodStart';
  if (prevShift?.stop_type === 'Intermission') return 'PeriodStart';
  
  // Check last event
  const lastEvt = S.events.filter(e => e.period === S.period).slice(-1)[0];
  if (lastEvt?.type === 'Goal') return 'FaceoffAfterGoal';
  if (lastEvt?.type === 'Penalty') return 'FaceoffAfterPenalty';
  if (lastEvt?.type === 'Stoppage') return 'Stoppage';
  
  return 'OnTheFly';
}

function deriveShiftStopType() {
  // Auto-derive stop type from last event in shift
  const lastEvt = S.events.filter(e => e.period === S.period).slice(-1)[0];
  if (!lastEvt) return 'OnTheFly';
  
  if (lastEvt.type === 'Goal' && lastEvt.detail1 === 'Goal_Scored') return 'GoalScored';
  if (lastEvt.type === 'Penalty') return 'Penalty';
  if (lastEvt.type === 'Stoppage') return 'Stoppage';
  if (lastEvt.type === 'Intermission') return 'Intermission';
  
  return 'OnTheFly';
}

function saveEditShift() {
  if (S.editingShiftIdx === null) return;
  const shift = S.shifts[S.editingShiftIdx];
  const currentIdx = S.editingShiftIdx;
  
  // Get old values before updating
  const oldStartTime = shift.start_time;
  const oldEndTime = shift.end_time;
  
  // Get new values from form
  const newStartTime = document.getElementById('editShiftStartTime').value;
  const newEndTime = document.getElementById('editShiftEndTime').value;
  
  // Update shift
  shift.period = parseInt(document.getElementById('editShiftPeriod').value);
  shift.start_time = newStartTime;
  shift.end_time = newEndTime;
  shift.start_type = document.getElementById('editShiftStartType').value;
  shift.stop_type = document.getElementById('editShiftStopType').value;
  
  // v23.9: Sync adjacent shifts when times change
  // If end time changed, update next shift's start time
  if (oldEndTime !== newEndTime && newEndTime) {
    const nextShift = currentIdx < S.shifts.length - 1 ? S.shifts[currentIdx + 1] : null;
    if (nextShift && nextShift.period === shift.period) {
      // Only sync if they're in the same period
      nextShift.start_time = newEndTime;
      toast(`Updated shift #${currentIdx + 2} start time to ${newEndTime}`, 'info');
    }
  }
  
  // If start time changed, update previous shift's end time
  if (oldStartTime !== newStartTime && newStartTime) {
    const prevShift = currentIdx > 0 ? S.shifts[currentIdx - 1] : null;
    if (prevShift && prevShift.period === shift.period) {
      // Only sync if they're in the same period
      prevShift.end_time = newStartTime;
      toast(`Updated shift #${currentIdx} end time to ${newStartTime}`, 'info');
    }
  }
  
  markDataChanged();
  closeEditShiftModal();
  renderShiftLog();
  autoSave();
  toast('Shift updated', 'success');
}

/**
 * v23.9: Sync adjacent shift times after add/delete/insert operations
 * @param {number} shiftIdx - Index of the shift that was modified
 */
function syncAdjacentShiftTimes(shiftIdx) {
  if (shiftIdx < 0 || shiftIdx >= S.shifts.length) return;
  
  const shift = S.shifts[shiftIdx];
  if (!shift) return;
  
  // Helper to parse time string (MM:SS) to seconds (clock counts down)
  const parseTime = (timeStr) => {
    if (!timeStr) return null;
    const [min, sec] = timeStr.split(':').map(Number);
    return (min || 0) * 60 + (sec || 0);
  };
  
  // Sync with next shift (if same period)
  const nextShift = shiftIdx < S.shifts.length - 1 ? S.shifts[shiftIdx + 1] : null;
  if (nextShift && nextShift.period === shift.period && shift.end_time) {
    const currentEndSec = parseTime(shift.end_time);
    const nextStartSec = parseTime(nextShift.start_time);
    
    if (currentEndSec !== null && nextStartSec !== null) {
      const timeDiff = Math.abs(currentEndSec - nextStartSec);
      if (timeDiff <= 2) {
        // Within 2 seconds - sync the next shift's start time
        nextShift.start_time = shift.end_time;
        toast(`Updated shift #${shiftIdx + 2} start time to ${shift.end_time}`, 'info');
      }
    }
  }
  
  // Sync with previous shift (if same period)
  const prevShift = shiftIdx > 0 ? S.shifts[shiftIdx - 1] : null;
  if (prevShift && prevShift.period === shift.period && shift.start_time) {
    const currentStartSec = parseTime(shift.start_time);
    const prevEndSec = parseTime(prevShift.end_time);
    
    if (currentStartSec !== null && prevEndSec !== null) {
      const timeDiff = Math.abs(prevEndSec - currentStartSec);
      if (timeDiff <= 2) {
        // Within 2 seconds - sync the previous shift's end time
        prevShift.end_time = shift.start_time;
        toast(`Updated shift #${shiftIdx} end time to ${shift.start_time}`, 'info');
      }
    }
  }
}

function deleteShift() {
  if (S.editingShiftIdx === null) return;
  if (!confirm('Delete this shift?')) return;
  
  const deletedIdx = S.editingShiftIdx;
  const deletedShift = S.shifts[deletedIdx];
  
  // Before deletion, sync the previous and next shifts if they're in the same period
  const prevShift = deletedIdx > 0 ? S.shifts[deletedIdx - 1] : null;
  const nextShift = deletedIdx < S.shifts.length - 1 ? S.shifts[deletedIdx + 1] : null;
  
  // If previous and next are in same period, sync their times
  if (prevShift && nextShift && prevShift.period === nextShift.period && prevShift.period === deletedShift.period) {
    // Previous shift's end should match next shift's start
    if (prevShift.end_time !== nextShift.start_time) {
      prevShift.end_time = nextShift.start_time;
      toast(`Updated shift #${deletedIdx} end time to ${nextShift.start_time}`, 'info');
    }
  }
  
  S.shifts.splice(deletedIdx, 1);
  markDataChanged();
  closeEditShiftModal();
  renderShiftLog();
  autoSave();
  toast('Shift deleted', 'success');
}

/**
 * v20.6: Insert a new shift BEFORE the current one
 */
function insertShiftBefore() {
  if (S.editingShiftIdx === null) return;
  
  const currentShift = S.shifts[S.editingShiftIdx];
  const prevShift = S.editingShiftIdx > 0 ? S.shifts[S.editingShiftIdx - 1] : null;
  
  // Create new shift with interpolated times
  const newShift = {
    period: currentShift.period,
    start_time: prevShift ? prevShift.end_time : currentShift.start_time,
    end_time: currentShift.start_time,
    start_type: prevShift ? deriveShiftStartType(S.editingShiftIdx) : 'OnTheFly',
    stop_type: 'OnTheFly',
    strength: '5v5',
    home: { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null },
    away: { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null }
  };
  
  // Insert at position
  S.shifts.splice(S.editingShiftIdx, 0, newShift);
  markDataChanged();
  
  // Update current index to point to newly inserted shift
  const newIdx = S.editingShiftIdx;
  S.editingShiftIdx = null; // Clear to allow re-edit
  
  // v23.9: Sync adjacent shift times after insertion
  syncAdjacentShiftTimes(newIdx);
  
  closeEditShiftModal();
  renderShiftLog();
  autoSave();
  toast(`Inserted shift #${newIdx + 1}`, 'success');
  
  // Open the new shift for editing
  setTimeout(() => editShift(newIdx), 100);
}

/**
 * v20.6: Insert a new shift AFTER the current one
 */
function insertShiftAfter() {
  if (S.editingShiftIdx === null) return;
  
  const currentShift = S.shifts[S.editingShiftIdx];
  const nextShift = S.editingShiftIdx < S.shifts.length - 1 ? S.shifts[S.editingShiftIdx + 1] : null;
  
  // Create new shift with interpolated times
  const newShift = {
    period: currentShift.period,
    start_time: currentShift.end_time,
    end_time: nextShift ? nextShift.start_time : currentShift.end_time,
    start_type: deriveShiftStartType(S.editingShiftIdx + 1),
    stop_type: 'OnTheFly',
    strength: '5v5',
    home: { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null },
    away: { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null }
  };
  
  // Insert after current position
  const insertIdx = S.editingShiftIdx + 1;
  S.shifts.splice(insertIdx, 0, newShift);
  markDataChanged();
  
  S.editingShiftIdx = null; // Clear to allow re-edit
  
  // v23.9: Sync adjacent shift times after insertion
  syncAdjacentShiftTimes(insertIdx);
  
  closeEditShiftModal();
  renderShiftLog();
  autoSave();
  toast(`Inserted shift #${insertIdx + 1}`, 'success');
  
  // Open the new shift for editing
  setTimeout(() => editShift(insertIdx), 100);
}

/**
 * v20.6: Duplicate the current shift
 */
function duplicateShift() {
  if (S.editingShiftIdx === null) return;
  
  const currentShift = S.shifts[S.editingShiftIdx];
  
  // Deep clone the shift
  const newShift = JSON.parse(JSON.stringify(currentShift));
  
  // Insert after current position
  const insertIdx = S.editingShiftIdx + 1;
  S.shifts.splice(insertIdx, 0, newShift);
  markDataChanged();
  
  S.editingShiftIdx = null;
  
  // v23.9: Sync adjacent shift times after duplication
  syncAdjacentShiftTimes(insertIdx);
  
  closeEditShiftModal();
  renderShiftLog();
  autoSave();
  toast(`Duplicated shift ‚Üí #${insertIdx + 1}`, 'success');
  
  // Open the new shift for editing
  setTimeout(() => editShift(insertIdx), 100);
}

/**
 * v20.6: Add a new shift at the end of the list
 */
function addNewShift() {
  const lastShift = S.shifts.length > 0 ? S.shifts[S.shifts.length - 1] : null;
  
  // Create new shift
  const newShift = {
    period: lastShift ? lastShift.period : S.period || 1,
    start_time: lastShift ? lastShift.end_time : '20:00',
    end_time: '',
    start_type: lastShift ? deriveShiftStartType(S.shifts.length) : 'GameStart',
    stop_type: '',
    strength: '5v5',
    home: { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null },
    away: { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null }
  };
  
  // Add to end
  S.shifts.push(newShift);
  markDataChanged();
  const newIdx = S.shifts.length - 1;
  
  // v23.9: Sync adjacent shift times after adding (if there's a previous shift in same period)
  if (lastShift && lastShift.period === newShift.period && lastShift.end_time && newShift.start_time) {
    // Helper to parse time string (MM:SS) to seconds
    const parseTime = (timeStr) => {
      if (!timeStr) return null;
      const [min, sec] = timeStr.split(':').map(Number);
      return (min || 0) * 60 + (sec || 0);
    };
    
    const lastEndSec = parseTime(lastShift.end_time);
    const newStartSec = parseTime(newShift.start_time);
    
    if (lastEndSec !== null && newStartSec !== null) {
      const timeDiff = Math.abs(lastEndSec - newStartSec);
      if (timeDiff <= 2) {
        // Within 2 seconds - sync the new shift's start time
        newShift.start_time = lastShift.end_time;
      }
    }
  }
  
  renderShiftLog();
  autoSave();
  toast(`Added shift #${newIdx + 1}`, 'success');
  
  // Open the new shift for editing
  setTimeout(() => editShift(newIdx), 100);
}

function closeEditShiftModal() {
  console.log('closeEditShiftModal() called');
  const modal = document.getElementById('editShiftModal');
  if (modal) {
    console.log('Removing show class and forcing display none');
    modal.classList.remove('show');
    // Force all styles to hide - use !important via setProperty
    modal.style.setProperty('display', 'none', 'important');
    modal.style.setProperty('visibility', 'hidden', 'important');
    modal.style.setProperty('opacity', '0', 'important');
    console.log('Shift modal closed. display:', modal.style.display);
  } else {
    console.error('editShiftModal not found!');
  }
  S.editingShiftIdx = null;
}

function showAllShifts() {
  try {
  // Show all shifts modal
  const body = document.getElementById('allShiftsBody');
    if (!body) {
      console.error('allShiftsBody element not found!');
      toast('Shifts modal body not found. Please refresh the page.', 'error');
      return;
    }
  body.innerHTML = S.shifts.map((s, i) => `
    <tr onclick="editShift(${i})" style="cursor:pointer;">
      <td>${i + 1}</td>
      <td>P${s.period}</td>
      <td>${s.start_time}</td>
      <td>${s.end_time}</td>
      <td>${s.start_type}</td>
      <td>${s.stop_type}</td>
      <td>${s.strength || '-'}</td>
    </tr>
  `).join('') || '<tr><td colspan="7">No shifts</td></tr>';
  
    const modal = document.getElementById('allShiftsModal');
    if (!modal) {
      console.error('allShiftsModal element not found!');
      toast('Shifts modal not found. Please refresh the page.', 'error');
      return;
    }
    // Ensure modal is in body (move if needed)
    if (modal.parentElement !== document.body) {
      document.body.appendChild(modal);
    }
    
    // Temporarily disable transition for instant visibility
    const originalTransition = modal.style.transition;
    modal.style.transition = 'none';
    modal.classList.add('show');
    modal.style.display = 'flex';
    modal.style.visibility = 'visible';
    modal.style.opacity = '1';
    modal.style.zIndex = '10000';
    modal.style.position = 'fixed';
    modal.style.top = '0';
    modal.style.left = '0';
    modal.style.right = '0';
    modal.style.bottom = '0';
    modal.style.width = '100%';
    modal.style.height = '100%';
    modal.style.background = 'rgba(0,0,0,0.85)';
    
    // Ensure the modal content div is properly positioned
    const modalContent = modal.querySelector('.modal');
    if (modalContent) {
      modalContent.style.position = 'relative';
      modalContent.style.zIndex = '10001';
    }
    
    // Remove ALL existing handlers that might interfere
    if (modal._overlayClickHandler) {
      modal.removeEventListener('click', modal._overlayClickHandler);
      modal.removeEventListener('mousedown', modal._overlayClickHandler);
      delete modal._overlayClickHandler;
    }
    modal.onclick = null; // Clear any existing onclick
    
    // Use simple inline onclick pattern like genericModal - proven to work
    // This doesn't interfere with buttons because it only runs if e.target === modal
    modal.onclick = function(e) {
      if (e.target === this) {
        closeSettings();
      }
    };
    
    console.log('All shifts modal opened, z-index:', modal.style.zIndex, 'display:', modal.style.display, 'visibility:', modal.style.visibility);
    
    // Re-enable transition after a brief delay
    setTimeout(() => {
      modal.style.transition = originalTransition || '';
    }, 50);
  } catch (err) {
    console.error('Error showing all shifts:', err);
    toast('Error showing shifts: ' + err.message, 'error');
  }
}

function showAllEvents() {
  try {
  // Show all events modal
  const body = document.getElementById('allEventsBody');
    if (!body) {
      console.error('allEventsBody element not found!');
      toast('Events modal body not found. Please refresh the page.', 'error');
      return;
    }
  body.innerHTML = S.events.map((e, i) => `
    <tr onclick="editEvent(${i})" style="cursor:pointer;">
      <td>${i + 1}</td>
      <td>P${e.period}</td>
      <td>${e.start_time || e.time}</td>
      <td>${e.team === 'home' ? S.homeTeam : S.awayTeam}</td>
      <td>${e.type}</td>
      <td>${e.detail1 || ''}</td>
      <td>${e.players?.map(p => p.num).join(',') || ''}</td>
    </tr>
  `).join('') || '<tr><td colspan="7">No events</td></tr>';
  
    const modal = document.getElementById('allEventsModal');
    if (!modal) {
      console.error('allEventsModal element not found!');
      toast('Events modal not found. Please refresh the page.', 'error');
      return;
    }
    // Ensure modal is in body (move if needed)
    if (modal.parentElement !== document.body) {
      document.body.appendChild(modal);
    }
    
    // Temporarily disable transition for instant visibility
    const originalTransition = modal.style.transition;
    modal.style.transition = 'none';
    modal.classList.add('show');
    modal.style.display = 'flex';
    modal.style.visibility = 'visible';
    modal.style.opacity = '1';
    modal.style.zIndex = '10000';
    modal.style.position = 'fixed';
    modal.style.top = '0';
    modal.style.left = '0';
    modal.style.right = '0';
    modal.style.bottom = '0';
    modal.style.width = '100%';
    modal.style.height = '100%';
    modal.style.background = 'rgba(0,0,0,0.85)';
    
    // Ensure the modal content div is properly positioned
    const modalContent = modal.querySelector('.modal');
    if (modalContent) {
      modalContent.style.position = 'relative';
      modalContent.style.zIndex = '10001';
    }
    
    // Remove ALL existing handlers that might interfere
    if (modal._overlayClickHandler) {
      modal.removeEventListener('click', modal._overlayClickHandler);
      modal.removeEventListener('mousedown', modal._overlayClickHandler);
      delete modal._overlayClickHandler;
    }
    modal.onclick = null; // Clear any existing onclick
    
    // Use simple inline onclick pattern like genericModal - proven to work
    // This doesn't interfere with buttons because it only runs if e.target === modal
    modal.onclick = function(e) {
      if (e.target === this) {
        closeSettings();
      }
    };
    
    console.log('All events modal opened, z-index:', modal.style.zIndex, 'display:', modal.style.display, 'visibility:', modal.style.visibility);
    
    // Re-enable transition after a brief delay
    setTimeout(() => {
      modal.style.transition = originalTransition || '';
    }, 50);
  } catch (err) {
    console.error('Error showing all events:', err);
    toast('Error showing events: ' + err.message, 'error');
  }
}

/**
 * v23.8: Update box score with optional cutoff index (for time-based stats when editing)
 * @param {number|null} cutoffIdx - Only count events up to this index (inclusive). If null, count all events.
 */
function updateBoxScore(cutoffIdx = null) {
  // Update team names
  document.getElementById('teamSumHome').textContent = S.homeTeam?.slice(0,8) || 'HOME';
  document.getElementById('teamSumAway').textContent = S.awayTeam?.slice(0,8) || 'AWAY';
  
  // v7: Calculate player stats - ONLY count event_player_1 for most stats
  const playerStats = {};
  
  // Initialize players from rosters with their correct team
  [...(S.rosters?.home || [])].forEach(p => {
    if (p?.num && !playerStats[p.num]) {
      playerStats[p.num] = { 
        num: p.num, name: p.name?.split(' ').pop() || p.name, team: 'home',
        goals: 0, assists: 0, shots: 0, faceoffs: 0, foWins: 0, foLosses: 0, pim: 0, penalties: 0
      };
    }
  });
  [...(S.rosters?.away || [])].forEach(p => {
    if (p?.num && !playerStats[p.num]) {
      playerStats[p.num] = { 
        num: p.num, name: p.name?.split(' ').pop() || p.name, team: 'away',
        goals: 0, assists: 0, shots: 0, faceoffs: 0, foWins: 0, foLosses: 0, pim: 0, penalties: 0
      };
    }
  });
  
  // Filter events up to cutoff index
  // cutoffIdx is the maximum event index (inclusive) to count
  const eventsToCount = cutoffIdx !== null && cutoffIdx !== undefined
    ? S.events.filter((e, arrayIdx) => {
        // Get the event's index - try idx property first, fallback to array index
        const eventIdx = (e.idx !== undefined && e.idx !== null) ? e.idx : arrayIdx;
        return eventIdx !== -1 && eventIdx <= cutoffIdx;
      })
    : S.events;
  
  eventsToCount.forEach(evt => {
    // v7: ONLY count event_player_1 for goals, shots
    const player1 = evt.players?.find(p => 
      p.role === 'event_team_player_1' || p.role === 'event_player_1'
    );
    const oppPlayer1 = evt.players?.find(p => 
      p.role === 'opp_team_player_1' || p.role === 'opp_player_1'
    );
    
    // Initialize player1 stats if needed
    if (player1?.num && !playerStats[player1.num]) {
      playerStats[player1.num] = { 
        num: player1.num, name: player1.name?.split(' ').pop() || player1.name, team: evt.team,
        goals: 0, assists: 0, shots: 0, faceoffs: 0, foWins: 0, foLosses: 0, pim: 0, penalties: 0
      };
    }
    
    if (player1?.num) {
      const ps = playerStats[player1.num];
      // Goals - only event_player_1 on Goal events where detail1 = Goal_Scored
      if (evt.type === 'Goal' && (evt.detail1 === 'Goal_Scored' || evt.detail1 === 'Goal_Shootout' || evt.detail1 === 'Goal_PenaltyShot')) ps.goals++;
      // v15.01: SOG - only shots that reached the net (Shot_OnNetSaved, Shot_OnNetGoal) or Goals
      const d1 = (evt.detail1 || '').toLowerCase();
      if (d1.includes('shot_onnetsaved') || d1.includes('shot_onnetgoal') || d1.includes('goal_scored') || d1.includes('goal_shootout') || d1.includes('goal_penaltyshot')) {
        ps.shots++;
      }
      // v7: Faceoffs - event_player_1 gets FO WIN
      if (evt.type === 'Faceoff') { ps.faceoffs++; ps.foWins++; }
      
      // v23.8: Penalties - only event_player_1 (the player who took the penalty)
      if (evt.type === 'Penalty' && player1?.num) {
        ps.penalties++;
        // Extract penalty minutes from detail1 using configurable lengths
        const detail1 = (evt.detail1 || '').toLowerCase();
        const penaltyLengths = S.penaltyLengths || { minor: 2, major: 5, misconduct: 10 };
        if (detail1.includes('major') || detail1.includes('fighting')) {
          ps.pim += penaltyLengths.major || 5;
        } else if (detail1.includes('misconduct') || detail1.includes('game')) {
          ps.pim += penaltyLengths.misconduct || 10;
        } else {
          // Default minor penalty - use configurable length
          ps.pim += penaltyLengths.minor || 2;
        }
      }
    }
    
    // v7: Faceoff LOSS for opp_player_1
    if (evt.type === 'Faceoff' && oppPlayer1?.num) {
      if (!playerStats[oppPlayer1.num]) {
        const oppTeam = evt.team === 'home' ? 'away' : 'home';
        playerStats[oppPlayer1.num] = { 
          num: oppPlayer1.num, name: oppPlayer1.name?.split(' ').pop() || oppPlayer1.name, team: oppTeam,
          goals: 0, assists: 0, shots: 0, faceoffs: 0, foWins: 0, foLosses: 0, pim: 0, penalties: 0
        };
      }
      playerStats[oppPlayer1.num].faceoffs++;
      playerStats[oppPlayer1.num].foLosses++;
    }
    
    // v7: Assists - check for '%assist%' in play_detail_1 or play_detail_2
    evt.players?.forEach(p => {
      if (!p?.num) return;
      const pd1 = (p.playD1 || '').toLowerCase();
      const pd2 = (p.playD2 || '').toLowerCase();
      if (pd1.includes('assist') || pd2.includes('assist')) {
        if (!playerStats[p.num]) {
          playerStats[p.num] = { 
            num: p.num, name: p.name?.split(' ').pop() || p.name, team: evt.team,
            goals: 0, assists: 0, shots: 0, faceoffs: 0, foWins: 0, foLosses: 0, pim: 0, penalties: 0
          };
        }
        playerStats[p.num].assists++;
      }
    });
    
    // v23.8: Also count assists from linked Pass events (assistToGoalIdx)
    // This ensures assists from auto-detected or manually linked Pass events are counted
    if (evt.type === 'Pass' && evt.assistToGoalIdx !== null && evt.assistToGoalIdx !== undefined) {
      // Verify the goal exists and is a valid goal
      const goalEvent = S.events.find(e => e.idx === evt.assistToGoalIdx && e.type === 'Goal' && e.detail1 === 'Goal_Scored');
        if (goalEvent) {
          const passPlayer = evt.players?.find(p => 
            p.role === 'event_team_player_1' || p.role === 'event_player_1'
          );
          if (passPlayer?.num) {
            // Check if already counted for THIS goal via play_detail markers in goal event
            // (to avoid double-counting the same assist)
            const alreadyCountedForThisGoal = (goalEvent.players || []).some(gp => 
              String(gp.num) === String(passPlayer.num) && 
              ((gp.playD1 || '').toLowerCase().includes('assist') || (gp.playD2 || '').toLowerCase().includes('assist'))
            );
            
            // Always count linked Pass events as assists (the link itself is proof of assist)
            // Only skip if we've already counted this player for this specific goal
            if (!alreadyCountedForThisGoal) {
              if (!playerStats[passPlayer.num]) {
                playerStats[passPlayer.num] = { 
                  num: passPlayer.num, name: passPlayer.name?.split(' ').pop() || passPlayer.name, team: evt.team,
                  goals: 0, assists: 0, shots: 0, faceoffs: 0, foWins: 0, foLosses: 0, pim: 0, penalties: 0
                };
              }
              playerStats[passPlayer.num].assists++;
            }
          }
        }
    }
    
    // v23.8: Penalties - only event_player_1 (the player who took the penalty)
    if (evt.type === 'Penalty' && player1?.num) {
      if (!playerStats[player1.num].penalties) {
        playerStats[player1.num].penalties = 0;
        playerStats[player1.num].pim = 0;
      }
      playerStats[player1.num].penalties++;
      // Extract penalty minutes from detail1
      const detail1 = (evt.detail1 || '').toLowerCase();
      if (detail1.includes('major') || detail1.includes('fighting')) {
        playerStats[player1.num].pim += 5;
      } else if (detail1.includes('misconduct') || detail1.includes('game')) {
        playerStats[player1.num].pim += 10;
      } else {
        // Default minor penalty = 2 minutes
        playerStats[player1.num].pim += 2;
      }
    }
  });
  
  // v7: Organize by team, sort by points
  const homePlayers = Object.values(playerStats)
    .filter(p => p.team === 'home' && (p.goals > 0 || p.assists > 0 || p.shots > 0 || p.faceoffs > 0))
    .sort((a, b) => (b.goals + b.assists) - (a.goals + a.assists) || b.goals - a.goals);
  const awayPlayers = Object.values(playerStats)
    .filter(p => p.team === 'away' && (p.goals > 0 || p.assists > 0 || p.shots > 0 || p.faceoffs > 0))
    .sort((a, b) => (b.goals + b.assists) - (a.goals + a.assists) || b.goals - a.goals);
  
  // Render player box score organized by team
  const tbody = document.getElementById('playerBoxBody');
  let html = '';
  
  // Home players section
  if (homePlayers.length > 0) {
    html += `<tr style="background:rgba(59,130,246,0.15);"><td colspan="6" style="font-size:9px;color:var(--home);font-weight:bold;">${S.homeTeam || 'HOME'}</td></tr>`;
    html += homePlayers.slice(0, 5).map(p => {
      const foPct = p.faceoffs > 0 ? `${p.foWins}/${p.faceoffs}` : '-';
      return `<tr onclick="showPlayerDetail('${p.num}')" style="cursor:pointer;">
        <td>${p.num}</td>
        <td style="max-width:50px;overflow:hidden;text-overflow:ellipsis;">${p.name}</td>
        <td style="font-weight:${p.goals>0?'bold':'normal'};">${p.goals}</td>
        <td>${p.assists}</td>
        <td>${p.shots}</td>
        <td style="font-size:9px;">${foPct}</td>
      </tr>`;
    }).join('');
  }
  
  // Away players section
  if (awayPlayers.length > 0) {
    html += `<tr style="background:rgba(239,68,68,0.15);"><td colspan="6" style="font-size:9px;color:var(--away);font-weight:bold;">${S.awayTeam || 'AWAY'}</td></tr>`;
    html += awayPlayers.slice(0, 5).map(p => {
      const foPct = p.faceoffs > 0 ? `${p.foWins}/${p.faceoffs}` : '-';
      return `<tr onclick="showPlayerDetail('${p.num}')" style="cursor:pointer;">
        <td>${p.num}</td>
        <td style="max-width:50px;overflow:hidden;text-overflow:ellipsis;">${p.name}</td>
        <td style="font-weight:${p.goals>0?'bold':'normal'};">${p.goals}</td>
        <td>${p.assists}</td>
        <td>${p.shots}</td>
        <td style="font-size:9px;">${foPct}</td>
      </tr>`;
    }).join('');
  }
  
  tbody.innerHTML = html || '<tr><td colspan="6" style="color:var(--muted);">No stats yet</td></tr>';
  
  // v16: Team SOG totals - only shots that reached the net (Shot_OnNetSaved, Shot_OnNetGoal) or Goals
  // SOG = event_player_1 events where event_detail = "shot_onnetsaved" OR "shot_onnetgoal" OR goal
  const isSOG = (e) => {
    const d1 = (e.detail1 || '').toLowerCase();
    return d1.includes('shot_onnetsaved') || d1.includes('shot_onnetgoal') || 
           d1.includes('goal_scored') || d1.includes('goal_shootout') || d1.includes('goal_penaltyshot');
  };
  const isGoal = (e) => {
    const d1 = (e.detail1 || '').toLowerCase();
    return e.type === 'Goal' && (d1.includes('goal_scored') || d1.includes('goal_shootout') || d1.includes('goal_penaltyshot'));
  };
  const homeGoals = S.events.filter(e => isGoal(e) && e.team === 'home').length;
  const awayGoals = S.events.filter(e => isGoal(e) && e.team === 'away').length;
  const homeShots = S.events.filter(e => isSOG(e) && e.team === 'home').length;
  const awayShots = S.events.filter(e => isSOG(e) && e.team === 'away').length;
  
  document.getElementById('teamSumHomeScore').textContent = homeGoals;
  document.getElementById('teamSumAwayScore').textContent = awayGoals;
  document.getElementById('teamSumHomeSOG').textContent = homeShots;
  document.getElementById('teamSumAwaySOG').textContent = awayShots;
  
  // v16.02: Update center box score (below events)
  const centerBoxHome = document.getElementById('centerBoxHome');
  const centerBoxAway = document.getElementById('centerBoxAway');
  if (centerBoxHome) centerBoxHome.textContent = S.homeTeam?.slice(0,8) || 'HOME';
  if (centerBoxAway) centerBoxAway.textContent = S.awayTeam?.slice(0,8) || 'AWAY';
  const centerBoxHomeScore = document.getElementById('centerBoxHomeScore');
  const centerBoxAwayScore = document.getElementById('centerBoxAwayScore');
  if (centerBoxHomeScore) centerBoxHomeScore.textContent = homeGoals;
  if (centerBoxAwayScore) centerBoxAwayScore.textContent = awayGoals;
  const centerBoxHomeSOG = document.getElementById('centerBoxHomeSOG');
  const centerBoxAwaySOG = document.getElementById('centerBoxAwaySOG');
  if (centerBoxHomeSOG) centerBoxHomeSOG.textContent = homeShots;
  if (centerBoxAwaySOG) centerBoxAwaySOG.textContent = awayShots;
  
  // Also update header score
  document.getElementById('scoreH').textContent = homeGoals;
  document.getElementById('scoreA').textContent = awayGoals;
}

function showPlayerDetail(num) {
  // Calculate player stats
  const playerStats = calculatePlayerStats();
  const ps = playerStats[num];
  if (!ps) { toast('Player not found', 'error'); return; }
  
  document.getElementById('playerDetailName').textContent = `#${ps.num} ${ps.name}`;
  document.getElementById('pdGoals').textContent = ps.goals;
  document.getElementById('pdAssists').textContent = ps.assists;
  document.getElementById('pdShots').textContent = ps.shots;
  document.getElementById('pdFO').textContent = ps.faceoffs ? Math.round(ps.foWins / ps.faceoffs * 100) + '%' : '-';
  document.getElementById('pdTOI').textContent = formatTOI(ps.toi || 0);
  document.getElementById('pdHits').textContent = ps.hits || 0;
  document.getElementById('pdBlocks').textContent = ps.blocks || 0;
  
  // Recent events for this player
  const recentEvts = S.events.filter(e => e.players?.some(p => p.num === num)).slice(-10);
  document.getElementById('pdRecentEvents').innerHTML = recentEvts.map(e => {
    const role = e.players.find(p => p.num === num)?.role || '';
    return `<div style="padding:2px 0;border-bottom:1px solid var(--border);">P${e.period} ${e.start_time || e.time} - ${e.type} (${role.replace('_team_player_','')})</div>`;
  }).join('') || '<div style="color:var(--muted);">No events</div>';
  
  document.getElementById('playerDetailModal').classList.add('show');
}

function showFullBoxScore() {
  const playerStats = calculatePlayerStats();
  
  // v16: Team totals - only count Goal_Scored for goals, proper SOG calculation
  const isGoal = (e) => {
    const d1 = (e.detail1 || '').toLowerCase();
    return e.type === 'Goal' && (d1.includes('goal_scored') || d1.includes('goal_shootout') || d1.includes('goal_penaltyshot'));
  };
  const isSOG = (e) => {
    const d1 = (e.detail1 || '').toLowerCase();
    return d1.includes('shot_onnetsaved') || d1.includes('shot_onnetgoal') || 
           d1.includes('goal_scored') || d1.includes('goal_shootout') || d1.includes('goal_penaltyshot');
  };
  const homeGoals = S.events.filter(e => isGoal(e) && e.team === 'home').length;
  const awayGoals = S.events.filter(e => isGoal(e) && e.team === 'away').length;
  const homeShots = S.events.filter(e => isSOG(e) && e.team === 'home').length;
  const awayShots = S.events.filter(e => isSOG(e) && e.team === 'away').length;
  const homeFO = S.events.filter(e => e.type === 'Faceoff' && e.team === 'home' && (e.success === 's' || e.success === 'Y')).length;
  const awayFO = S.events.filter(e => e.type === 'Faceoff' && e.team === 'away' && (e.success === 's' || e.success === 'Y')).length;
  
  document.getElementById('boxModalHome').textContent = S.homeTeam;
  document.getElementById('boxModalAway').textContent = S.awayTeam;
  document.getElementById('boxModalHomeScore').textContent = homeGoals;
  document.getElementById('boxModalAwayScore').textContent = awayGoals;
  document.getElementById('boxModalHomeSOG').textContent = homeShots;
  document.getElementById('boxModalAwaySOG').textContent = awayShots;
  document.getElementById('boxModalHomeFO').textContent = homeFO;
  document.getElementById('boxModalAwayFO').textContent = awayFO;
  
  // v23.9: Organize player table by team, then by position (F/D/G), then by points
  const allStats = Object.values(playerStats);
  
  // Helper function to group and sort by position
  const groupByPosition = (teamStats) => {
    const byPos = { F: [], D: [], G: [] };
    teamStats.forEach(p => {
      const pos = (p.pos || 'F').toUpperCase();
      if (pos === 'F' || pos === 'FORWARD') byPos.F.push(p);
      else if (pos === 'D' || pos === 'DEFENSE' || pos === 'DEFENSEMAN') byPos.D.push(p);
      else if (pos === 'G' || pos === 'GOALIE' || pos === 'GOALTENDER') byPos.G.push(p);
      else byPos.F.push(p); // Default to forward
    });
    
    // Sort each position group by points
    ['F', 'D', 'G'].forEach(pos => {
      byPos[pos].sort((a, b) => 
        (b.goals + b.assists) - (a.goals + a.assists) || b.goals - a.goals
      );
    });
    
    return byPos;
  };
  
  const homeStats = allStats.filter(p => p.team === 'home');
  const awayStats = allStats.filter(p => p.team === 'away');
  const homeByPos = groupByPosition(homeStats);
  const awayByPos = groupByPosition(awayStats);
  
  // Build table HTML with team headers and position sections
  let tableHtml = '';
  
  // Position labels
  const posLabels = { F: 'Forwards', D: 'Defense', G: 'Goalies' };
  
  // Home team section
  if (homeStats.length > 0) {
    tableHtml += `<tr style="background:var(--home);color:#fff;"><td colspan="10" style="padding:4px 8px;font-weight:bold;">${S.homeTeam || 'HOME'}</td></tr>`;
    
    // Forwards
    if (homeByPos.F.length > 0) {
      tableHtml += `<tr style="background:rgba(202,5,39,0.1);"><td colspan="10" style="padding:2px 8px;font-size:10px;font-weight:bold;color:var(--muted);">${posLabels.F}</td></tr>`;
      tableHtml += homeByPos.F.map(p => {
        const foPct = p.faceoffs ? Math.round(p.foWins / p.faceoffs * 100) : '-';
        return `<tr onclick="showPlayerDetail('${p.num}')" style="cursor:pointer;border-left:3px solid var(--home);">
          <td>${p.num}</td>
          <td>${p.name}</td>
          <td>F</td>
          <td style="font-weight:${p.goals>0?'bold':'normal'};">${p.goals}</td>
          <td>${p.assists}</td>
          <td style="font-weight:bold;">${p.goals + p.assists}</td>
          <td>${p.shots}</td>
          <td>${foPct}${foPct !== '-' ? '%' : ''}</td>
          <td>${formatTOI(p.toi || 0)}</td>
          <td>${p.pim || 0}</td>
        </tr>`;
      }).join('');
    }
    
    // Defense
    if (homeByPos.D.length > 0) {
      tableHtml += `<tr style="background:rgba(202,5,39,0.1);"><td colspan="10" style="padding:2px 8px;font-size:10px;font-weight:bold;color:var(--muted);">${posLabels.D}</td></tr>`;
      tableHtml += homeByPos.D.map(p => {
        const foPct = p.faceoffs ? Math.round(p.foWins / p.faceoffs * 100) : '-';
        return `<tr onclick="showPlayerDetail('${p.num}')" style="cursor:pointer;border-left:3px solid var(--home);">
          <td>${p.num}</td>
          <td>${p.name}</td>
          <td>D</td>
          <td style="font-weight:${p.goals>0?'bold':'normal'};">${p.goals}</td>
          <td>${p.assists}</td>
          <td style="font-weight:bold;">${p.goals + p.assists}</td>
          <td>${p.shots}</td>
          <td>${foPct}${foPct !== '-' ? '%' : ''}</td>
          <td>${formatTOI(p.toi || 0)}</td>
          <td>${p.pim || 0}</td>
        </tr>`;
      }).join('');
    }
    
    // Goalies
    if (homeByPos.G.length > 0) {
      tableHtml += `<tr style="background:rgba(202,5,39,0.1);"><td colspan="10" style="padding:2px 8px;font-size:10px;font-weight:bold;color:var(--muted);">${posLabels.G}</td></tr>`;
      tableHtml += homeByPos.G.map(p => {
        const foPct = p.faceoffs ? Math.round(p.foWins / p.faceoffs * 100) : '-';
        return `<tr onclick="showPlayerDetail('${p.num}')" style="cursor:pointer;border-left:3px solid var(--home);">
          <td>${p.num}</td>
          <td>${p.name}</td>
          <td>G</td>
          <td style="font-weight:${p.goals>0?'bold':'normal'};">${p.goals}</td>
          <td>${p.assists}</td>
          <td style="font-weight:bold;">${p.goals + p.assists}</td>
          <td>${p.shots}</td>
          <td>${foPct}${foPct !== '-' ? '%' : ''}</td>
          <td>${formatTOI(p.toi || 0)}</td>
          <td>${p.pim || 0}</td>
        </tr>`;
      }).join('');
    }
  }
  
  // Away team section
  if (awayStats.length > 0) {
    tableHtml += `<tr style="background:var(--away);color:#fff;"><td colspan="10" style="padding:4px 8px;font-weight:bold;">${S.awayTeam || 'AWAY'}</td></tr>`;
    
    // Forwards
    if (awayByPos.F.length > 0) {
      tableHtml += `<tr style="background:rgba(156,71,228,0.1);"><td colspan="10" style="padding:2px 8px;font-size:10px;font-weight:bold;color:var(--muted);">${posLabels.F}</td></tr>`;
      tableHtml += awayByPos.F.map(p => {
        const foPct = p.faceoffs ? Math.round(p.foWins / p.faceoffs * 100) : '-';
        return `<tr onclick="showPlayerDetail('${p.num}')" style="cursor:pointer;border-left:3px solid var(--away);">
          <td>${p.num}</td>
          <td>${p.name}</td>
          <td>F</td>
          <td style="font-weight:${p.goals>0?'bold':'normal'};">${p.goals}</td>
          <td>${p.assists}</td>
          <td style="font-weight:bold;">${p.goals + p.assists}</td>
          <td>${p.shots}</td>
          <td>${foPct}${foPct !== '-' ? '%' : ''}</td>
          <td>${formatTOI(p.toi || 0)}</td>
          <td>${p.pim || 0}</td>
        </tr>`;
      }).join('');
    }
    
    // Defense
    if (awayByPos.D.length > 0) {
      tableHtml += `<tr style="background:rgba(156,71,228,0.1);"><td colspan="10" style="padding:2px 8px;font-size:10px;font-weight:bold;color:var(--muted);">${posLabels.D}</td></tr>`;
      tableHtml += awayByPos.D.map(p => {
        const foPct = p.faceoffs ? Math.round(p.foWins / p.faceoffs * 100) : '-';
        return `<tr onclick="showPlayerDetail('${p.num}')" style="cursor:pointer;border-left:3px solid var(--away);">
          <td>${p.num}</td>
          <td>${p.name}</td>
          <td>D</td>
          <td style="font-weight:${p.goals>0?'bold':'normal'};">${p.goals}</td>
          <td>${p.assists}</td>
          <td style="font-weight:bold;">${p.goals + p.assists}</td>
          <td>${p.shots}</td>
          <td>${foPct}${foPct !== '-' ? '%' : ''}</td>
          <td>${formatTOI(p.toi || 0)}</td>
          <td>${p.pim || 0}</td>
        </tr>`;
      }).join('');
    }
    
    // Goalies
    if (awayByPos.G.length > 0) {
      tableHtml += `<tr style="background:rgba(156,71,228,0.1);"><td colspan="10" style="padding:2px 8px;font-size:10px;font-weight:bold;color:var(--muted);">${posLabels.G}</td></tr>`;
      tableHtml += awayByPos.G.map(p => {
        const foPct = p.faceoffs ? Math.round(p.foWins / p.faceoffs * 100) : '-';
        return `<tr onclick="showPlayerDetail('${p.num}')" style="cursor:pointer;border-left:3px solid var(--away);">
          <td>${p.num}</td>
          <td>${p.name}</td>
          <td>G</td>
          <td style="font-weight:${p.goals>0?'bold':'normal'};">${p.goals}</td>
          <td>${p.assists}</td>
          <td style="font-weight:bold;">${p.goals + p.assists}</td>
          <td>${p.shots}</td>
          <td>${foPct}${foPct !== '-' ? '%' : ''}</td>
          <td>${formatTOI(p.toi || 0)}</td>
          <td>${p.pim || 0}</td>
        </tr>`;
      }).join('');
    }
  }
  
  document.getElementById('boxModalBody').innerHTML = tableHtml || '<tr><td colspan="10">No stats</td></tr>';
  
  document.getElementById('boxScoreModal').classList.add('show');
}

/**
 * v23.8: Calculate player stats with optional cutoff index (for time-based stats when editing)
 * @param {number|null} cutoffIdx - Only count events up to this index (inclusive). If null, count all events.
 * @param {number|null} shiftCutoffIdx - Only count shifts up to this index (inclusive). If null, count all shifts.
 */
function calculatePlayerStats(cutoffIdx = null, shiftCutoffIdx = null) {
  const stats = {};
  
  // Initialize from rosters
  [...S.rosters.home, ...S.rosters.away].forEach(p => {
    stats[p.num] = {
      num: p.num,
      name: p.name,
      team: S.rosters.home.includes(p) ? 'home' : 'away',
      pos: p.pos || 'F', // Include position for grouping
      goals: 0, assists: 0, shots: 0, faceoffs: 0, foWins: 0, foLosses: 0, hits: 0, blocks: 0, toi: 0, pim: 0, penalties: 0
    };
  });
  
  // Filter events up to cutoff index
  const eventsToCount = cutoffIdx !== null 
    ? S.events.filter(e => e.idx <= cutoffIdx)
    : S.events;
  
  // v6: Calculate from events - only count event_player_1 for most stats
  eventsToCount.forEach(evt => {
      evt.players?.forEach(p => {
      if (!stats[p.num]) {
        // Try to get position from roster
        const rosterPlayer = [...S.rosters.home, ...S.rosters.away].find(rp => String(rp.num) === String(p.num));
        stats[p.num] = { num: p.num, name: p.name, team: evt.team, pos: rosterPlayer?.pos || 'F', goals: 0, assists: 0, shots: 0, faceoffs: 0, foWins: 0, foLosses: 0, hits: 0, blocks: 0, toi: 0, pim: 0, penalties: 0 };
      }
      const ps = stats[p.num];
      
      // Goals - only event_player_1 is the scorer
      if (evt.type === 'Goal' && evt.detail1 === 'Goal_Scored' && p.role === 'event_player_1') {
        ps.goals++;
      }
      
      // v6: Assists - check for '%assist%' in play_detail1 or play_detail2, or linked Pass events
      if (evt.type === 'Goal' && evt.detail1 === 'Goal_Scored') {
        const pd1Lower = (p.playD1 || '').toLowerCase();
        const pd2Lower = (p.playD2 || '').toLowerCase();
        if (pd1Lower.includes('assist') || pd2Lower.includes('assist')) {
          ps.assists++;
        }
      }
      
      // v23.8: Also count assists from linked Pass events (assistToGoalIdx)
      // This captures assists that were auto-detected or manually linked
      if (evt.type === 'Pass' && evt.assistToGoalIdx !== null && evt.assistToGoalIdx !== undefined) {
        // Verify the goal exists and is a valid goal
        const goalEvent = S.events.find(e => e.idx === evt.assistToGoalIdx && e.type === 'Goal' && e.detail1 === 'Goal_Scored');
        if (goalEvent && (p.role === 'event_player_1' || p.role === 'event_team_player_1')) {
          // Check if already counted for THIS goal via play_detail markers in goal event
          // (to avoid double-counting the same assist)
          const alreadyCountedForThisGoal = (goalEvent.players || []).some(gp => 
            String(gp.num) === String(p.num) && 
            ((gp.playD1 || '').toLowerCase().includes('assist') || (gp.playD2 || '').toLowerCase().includes('assist'))
          );
          
          // Always count linked Pass events as assists (the link itself is proof of assist)
          // Only skip if we've already counted this player for this specific goal
          if (!alreadyCountedForThisGoal) {
            ps.assists++;
          }
        }
      }
      
      // Shots - only event_player_1
      if ((evt.type === 'Shot' || evt.type === 'Goal') && p.role === 'event_player_1') {
        ps.shots++;
      }
      
      // v6: Faceoffs - event_player_1 = FO taken for event team
      // FO win = event_player_1 when event success = 's' 
      // FO loss = opp_player_1 on same event (they lost)
      if (evt.type === 'Faceoff') {
        if (p.role === 'event_player_1') {
          ps.faceoffs++;
          if (evt.success === 's' || evt.success === 'Y' || evt.success === true) {
            ps.foWins++;
          } else {
            ps.foLosses++;
          }
        }
        // The opp_player_1 on a faceoff = the opposing center who took the draw
        if (p.role === 'opp_player_1') {
          ps.faceoffs++;
          if (evt.success === 's' || evt.success === 'Y' || evt.success === true) {
            // Event team won, so opp lost
            ps.foLosses++;
          } else {
            // Event team lost, so opp won
            ps.foWins++;
          }
        }
      }
      
      // Hits - only event_player_1
      if (evt.type === 'Hit' && p.role === 'event_player_1') ps.hits++;
      
      // Blocks - opponent blocked the shot
      if (evt.detail1?.includes('Blocked') && p.role?.startsWith('opp')) ps.blocks++;
      
      // v23.8: Penalties - only event_player_1 (the player who took the penalty)
      if (evt.type === 'Penalty' && p.role === 'event_player_1') {
        ps.penalties++;
        // Extract penalty minutes from detail1 using configurable lengths
        const detail1 = (evt.detail1 || '').toLowerCase();
        const penaltyLengths = S.penaltyLengths || { minor: 2, major: 5, misconduct: 10 };
        if (detail1.includes('major') || detail1.includes('fighting')) {
          ps.pim += penaltyLengths.major || 5;
        } else if (detail1.includes('misconduct') || detail1.includes('game')) {
          ps.pim += penaltyLengths.misconduct || 10;
        } else {
          // Default minor penalty - use configurable length
          ps.pim += penaltyLengths.minor || 2;
        }
      }
    });
  });
  
  // Filter shifts up to cutoff index
  const shiftsToCount = shiftCutoffIdx !== null
    ? S.shifts.filter(s => {
        const shiftIdx = S.shifts.indexOf(s);
        return shiftIdx <= shiftCutoffIdx;
      })
    : S.shifts;
  
  // Calculate TOI from shifts
  shiftsToCount.forEach(shift => {
    const duration = parseTime(shift.start_time) - parseTime(shift.end_time);
    if (duration <= 0) return;
    
    ['home', 'away'].forEach(team => {
      ['F1','F2','F3','D1','D2','G','X'].forEach(pos => {
        const p = shift[team]?.[pos];
        if (p?.num && stats[p.num]) {
          stats[p.num].toi += duration;
        }
      });
    });
  });
  
  return stats;
}

function parseTime(timeStr) {
  if (!timeStr) return 0;
  const [min, sec] = timeStr.split(':').map(Number);
  return (min || 0) * 60 + (sec || 0);
}

/**
 * v23.8: Show detailed player stats modal
 */
function showPlayerDetail(playerNum) {
  const stats = calculatePlayerStats();
  const player = stats[playerNum];
  
  if (!player) {
    toast(`Player #${playerNum} not found`, 'error');
    return;
  }
  
  // Get player's full name from roster
  const rosterPlayer = [...S.rosters.home, ...S.rosters.away].find(p => String(p.num) === String(playerNum));
  const fullName = rosterPlayer?.name || player.name || `Player #${playerNum}`;
  const team = player.team === 'home' ? (S.homeTeam || 'HOME') : (S.awayTeam || 'AWAY');
  const teamColor = player.team === 'home' ? 'var(--home)' : 'var(--away)';
  
  // Calculate additional stats
  const points = player.goals + player.assists;
  const foPct = player.faceoffs > 0 ? Math.round((player.foWins / player.faceoffs) * 100) : 0;
  const toiFormatted = formatTOI(player.toi || 0);
  
  // Get all events for this player
  const playerEvents = S.events.filter(e => {
    return e.players?.some(p => String(p.num) === String(playerNum));
  });
  
  // Get goals
  const goals = playerEvents.filter(e => 
    e.type === 'Goal' && 
    e.detail1 === 'Goal_Scored' && 
    e.players?.find(p => String(p.num) === String(playerNum) && p.role === 'event_player_1')
  );
  
  // Get assists (from play_detail and linked Pass events)
  const assists = [];
  const goalEvents = S.events.filter(e => e.type === 'Goal' && e.detail1 === 'Goal_Scored');
  goalEvents.forEach(goal => {
    // Check if player has assist marker in goal event
    const assistInGoal = goal.players?.find(p => 
      String(p.num) === String(playerNum) && 
      ((p.playD1 || '').toLowerCase().includes('assist') || (p.playD2 || '').toLowerCase().includes('assist'))
    );
    if (assistInGoal) {
      assists.push({ goal, type: 'play_detail', period: goal.period, time: goal.start_time });
    }
    
    // Check if player has linked Pass event that assists this goal
    const passEvents = S.events.filter(e => 
      e.type === 'Pass' && 
      e.assistToGoalIdx === goal.idx &&
      e.players?.find(p => String(p.num) === String(playerNum) && (p.role === 'event_player_1' || p.role === 'event_team_player_1'))
    );
    passEvents.forEach(pass => {
      assists.push({ goal, pass, type: 'linked_pass', period: goal.period, time: goal.start_time });
    });
  });
  
  // Get penalties
  const penalties = playerEvents.filter(e => 
    e.type === 'Penalty' && 
    e.players?.find(p => String(p.num) === String(playerNum) && p.role === 'event_player_1')
  );
  
  // Get shifts for this player
  const playerShifts = S.shifts.filter(shift => {
    const team = player.team === 'home' ? shift.home : shift.away;
    return ['F1', 'F2', 'F3', 'D1', 'D2', 'G', 'X'].some(pos => 
      team?.[pos]?.num === String(playerNum)
    );
  });
  
  const html = `
    <div style="background:var(--card);padding:12px;border-radius:6px;margin-bottom:12px;border-left:4px solid ${teamColor};">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <div>
          <h4 style="font-size:16px;color:${teamColor};margin:0;">#${player.num} ${fullName}</h4>
          <div style="font-size:11px;color:var(--muted);">${team}</div>
        </div>
        <div style="text-align:right;">
          <div style="font-size:24px;font-weight:bold;color:${teamColor};">${points}</div>
          <div style="font-size:10px;color:var(--muted);">Points</div>
        </div>
      </div>
    </div>
    
    <!-- Key Stats Grid -->
    <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-bottom:16px;">
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:20px;font-weight:bold;color:var(--accent);">${player.goals || 0}</div>
        <div style="font-size:9px;color:var(--muted);">Goals</div>
      </div>
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:20px;font-weight:bold;color:var(--accent);">${player.assists || 0}</div>
        <div style="font-size:9px;color:var(--muted);">Assists</div>
      </div>
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:20px;font-weight:bold;color:var(--accent);">${toiFormatted}</div>
        <div style="font-size:9px;color:var(--muted);">TOI</div>
      </div>
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:20px;font-weight:bold;color:var(--accent);">${player.pim || 0}</div>
        <div style="font-size:9px;color:var(--muted);">PIM</div>
      </div>
    </div>
    
    <!-- Detailed Stats Table -->
    <div style="margin-bottom:16px;">
      <h4 style="font-size:12px;color:var(--accent);margin-bottom:8px;">üìä Detailed Stats</h4>
      <table style="width:100%;font-size:11px;border-collapse:collapse;">
        <tbody>
          <tr style="border-bottom:1px solid var(--border);">
            <td style="padding:6px;color:var(--muted);">Goals</td>
            <td style="padding:6px;font-weight:bold;text-align:right;">${player.goals || 0}</td>
          </tr>
          <tr style="border-bottom:1px solid var(--border);">
            <td style="padding:6px;color:var(--muted);">Assists</td>
            <td style="padding:6px;font-weight:bold;text-align:right;">${player.assists || 0}</td>
          </tr>
          <tr style="border-bottom:1px solid var(--border);">
            <td style="padding:6px;color:var(--muted);">Points</td>
            <td style="padding:6px;font-weight:bold;text-align:right;">${points}</td>
          </tr>
          <tr style="border-bottom:1px solid var(--border);">
            <td style="padding:6px;color:var(--muted);">Shots on Goal</td>
            <td style="padding:6px;font-weight:bold;text-align:right;">${player.shots || 0}</td>
          </tr>
          <tr style="border-bottom:1px solid var(--border);">
            <td style="padding:6px;color:var(--muted);">Faceoffs</td>
            <td style="padding:6px;font-weight:bold;text-align:right;">${player.faceoffs || 0} (${player.foWins || 0}W-${player.foLosses || 0}L)</td>
          </tr>
          <tr style="border-bottom:1px solid var(--border);">
            <td style="padding:6px;color:var(--muted);">Faceoff %</td>
            <td style="padding:6px;font-weight:bold;text-align:right;">${foPct}%</td>
          </tr>
          <tr style="border-bottom:1px solid var(--border);">
            <td style="padding:6px;color:var(--muted);">Time on Ice</td>
            <td style="padding:6px;font-weight:bold;text-align:right;">${toiFormatted}</td>
          </tr>
          <tr style="border-bottom:1px solid var(--border);">
            <td style="padding:6px;color:var(--muted);">Penalties</td>
            <td style="padding:6px;font-weight:bold;text-align:right;">${player.penalties || 0}</td>
          </tr>
          <tr style="border-bottom:1px solid var(--border);">
            <td style="padding:6px;color:var(--muted);">Penalty Minutes</td>
            <td style="padding:6px;font-weight:bold;text-align:right;">${player.pim || 0}</td>
          </tr>
          <tr style="border-bottom:1px solid var(--border);">
            <td style="padding:6px;color:var(--muted);">Hits</td>
            <td style="padding:6px;font-weight:bold;text-align:right;">${player.hits || 0}</td>
          </tr>
          <tr style="border-bottom:1px solid var(--border);">
            <td style="padding:6px;color:var(--muted);">Blocks</td>
            <td style="padding:6px;font-weight:bold;text-align:right;">${player.blocks || 0}</td>
          </tr>
          <tr>
            <td style="padding:6px;color:var(--muted);">Shifts</td>
            <td style="padding:6px;font-weight:bold;text-align:right;">${playerShifts.length}</td>
          </tr>
        </tbody>
      </table>
    </div>
    
    <!-- Goals List -->
    ${goals.length > 0 ? `
      <div style="margin-bottom:16px;">
        <h4 style="font-size:12px;color:var(--accent);margin-bottom:8px;">‚öΩ Goals (${goals.length})</h4>
        <div style="max-height:150px;overflow-y:auto;background:var(--card);padding:8px;border-radius:4px;">
          ${goals.map(g => {
            const scorer = g.players?.find(p => p.role === 'event_player_1');
            return `<div style="padding:4px;border-bottom:1px solid var(--border);font-size:10px;">
              <strong>P${g.period} @ ${g.start_time}</strong> - ${g.team === 'home' ? (S.homeTeam || 'HOME') : (S.awayTeam || 'AWAY')}
            </div>`;
          }).join('')}
        </div>
      </div>
    ` : ''}
    
    <!-- Assists List -->
    ${assists.length > 0 ? `
      <div style="margin-bottom:16px;">
        <h4 style="font-size:12px;color:var(--accent);margin-bottom:8px;">üéØ Assists (${assists.length})</h4>
        <div style="max-height:150px;overflow-y:auto;background:var(--card);padding:8px;border-radius:4px;">
          ${assists.map(a => {
            const goalScorer = a.goal.players?.find(p => p.role === 'event_player_1');
            return `<div style="padding:4px;border-bottom:1px solid var(--border);font-size:10px;">
              <strong>P${a.period} @ ${a.time}</strong> - Assisted goal by #${goalScorer?.num || '?'} ${goalScorer?.name || ''}
              ${a.type === 'linked_pass' ? ' üîó' : ''}
            </div>`;
          }).join('')}
        </div>
      </div>
    ` : ''}
    
    <!-- Penalties List -->
    ${penalties.length > 0 ? `
      <div style="margin-bottom:16px;">
        <h4 style="font-size:12px;color:var(--accent);margin-bottom:8px;">‚ö†Ô∏è Penalties (${penalties.length})</h4>
        <div style="max-height:150px;overflow-y:auto;background:var(--card);padding:8px;border-radius:4px;">
          ${penalties.map(p => {
            const penaltyType = p.detail1?.replace('Penalty_', '') || 'Penalty';
            return `<div style="padding:4px;border-bottom:1px solid var(--border);font-size:10px;">
              <strong>P${p.period} @ ${p.start_time}</strong> - ${penaltyType}
            </div>`;
          }).join('')}
        </div>
      </div>
    ` : ''}
  `;
  
  document.getElementById('playerDetailTitle').textContent = `üìä #${player.num} ${fullName}`;
  document.getElementById('playerDetailContent').innerHTML = html;
  document.getElementById('playerDetailModal').classList.add('show');
}

/**
 * v23.8: Show all events for a specific player in a modal
 * Used when clicking on player warnings or player names in verification panel
 */
function showPlayerEvents(playerNum, playerName = '') {
  // Get all events where this player appears (as event or opp player)
  const playerEvents = S.events.filter(e => {
    return e.players?.some(p => String(p.num) === String(playerNum));
  });
  
  if (playerEvents.length === 0) {
    toast(`No events found for #${playerNum} ${playerName}`, 'info');
    return;
  }
  
  // Get player info from roster
  const rosterPlayer = [...S.rosters.home, ...S.rosters.away].find(p => String(p.num) === String(playerNum));
  const fullName = rosterPlayer?.name || playerName || `Player #${playerNum}`;
  const team = rosterPlayer ? (S.rosters.home.includes(rosterPlayer) ? 'home' : 'away') : 'unknown';
  const teamColor = team === 'home' ? 'var(--home)' : 'var(--away)';
  
  // Create modal
  const modal = document.createElement('div');
  modal.className = 'overlay show';
  modal.id = 'playerEventsModal';
  modal.onclick = function(e) {
    if (e.target === modal) {
      document.getElementById('playerEventsModal')?.remove();
    }
  };
  
  // Sort events by period and time (most recent first)
  const sortedEvents = [...playerEvents].sort((a, b) => {
    const periodA = (a.period === 'OT' || a.period === 'ot') ? 4 : parseInt(a.period) || 1;
    const periodB = (b.period === 'OT' || b.period === 'ot') ? 4 : parseInt(b.period) || 1;
    if (periodA !== periodB) return periodB - periodA; // Most recent period first
    // Helper to parse time
    const parseTime = (t) => {
      if (!t) return 0;
      const parts = String(t).split(':').map(Number);
      return (parts[0] || 0) * 60 + (parts[1] || 0);
    };
    const timeA = parseTime(a.start_time || a.time || '');
    const timeB = parseTime(b.start_time || b.time || '');
    return timeB - timeA; // Descending time within period (most recent first)
  });
  
  modal.innerHTML = `
    <div class="modal" style="min-width:800px;max-width:1000px;max-height:85vh;overflow-y:auto;">
      <h3 style="color:${teamColor};">üë§ #${playerNum} ${fullName} - All Events (${playerEvents.length})</h3>
      <p style="font-size:10px;color:var(--muted);margin-bottom:12px;">
        Click any event to edit it. Shows all events where this player appears as event or opponent player.
      </p>
      <table style="width:100%;font-size:10px;border-collapse:collapse;">
        <thead>
          <tr style="background:var(--card);border-bottom:2px solid var(--border);">
            <th style="padding:6px;text-align:left;">#</th>
            <th style="padding:6px;text-align:left;">P</th>
            <th style="padding:6px;text-align:left;">Time</th>
            <th style="padding:6px;text-align:left;">Type</th>
            <th style="padding:6px;text-align:left;">Detail</th>
            <th style="padding:6px;text-align:left;">Role</th>
            <th style="padding:6px;text-align:left;">Team</th>
            <th style="padding:6px;text-align:left;">Zone</th>
            <th style="padding:6px;text-align:left;">Players</th>
          </tr>
        </thead>
        <tbody>
          ${sortedEvents.map(evt => {
            const evtIdx = S.events.indexOf(evt);
            const playerInEvent = evt.players?.find(p => String(p.num) === String(playerNum));
            const role = playerInEvent?.role || 'Unknown';
            const roleLabel = role.replace('event_team_player_', 'E').replace('opp_team_player_', 'O').replace('event_player_', 'E').replace('opp_player_', 'O');
            const allPlayers = (evt.players || []).map(p => `#${p.num}`).join(', ') || '-';
            
            return `
              <tr onclick="editEvent(${evtIdx});document.getElementById('playerEventsModal')?.remove();" style="cursor:pointer;border-bottom:1px solid var(--border);" onmouseover="this.style.background='var(--card)'" onmouseout="this.style.background='transparent'">
                <td style="padding:6px;font-weight:600;color:var(--accent);">${evtIdx + 1}</td>
                <td style="padding:6px;">P${evt.period}</td>
                <td style="padding:6px;font-family:monospace;">${evt.start_time || evt.time || '--'}</td>
                <td style="padding:6px;font-weight:600;">${evt.type || '-'}</td>
                <td style="padding:6px;color:var(--muted);">${evt.detail1 || '-'}</td>
                <td style="padding:6px;font-weight:600;color:${teamColor};">${roleLabel}</td>
                <td style="padding:6px;color:${evt.team === 'home' ? 'var(--home)' : 'var(--away)'};">${evt.team === 'home' ? (S.homeTeam || 'HOME') : (S.awayTeam || 'AWAY')}</td>
                <td style="padding:6px;">${evt.zone || '-'}</td>
                <td style="padding:6px;font-size:9px;">${allPlayers}</td>
              </tr>
            `;
          }).join('')}
        </tbody>
      </table>
      <div class="modal-actions" style="margin-top:15px;">
        <button onclick="document.getElementById('playerEventsModal')?.remove()" title="Close modal">Close</button>
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
}

function formatTOI(seconds) {
  if (!seconds) return '--:--';
  const min = Math.floor(seconds / 60);
  const sec = Math.floor(seconds % 60);
  return `${min}:${sec.toString().padStart(2, '0')}`;
}

function updateNextPlaySuggestions() {
  const lastEvt = S.events[S.events.length - 1];
  const suggestions = lastEvt ? (LISTS.nextEventSuggestions[lastEvt.type] || []) : ['Faceoff'];
  
  document.getElementById('nextPlaySuggestions').innerHTML = suggestions.map(t => 
    `<button class="btn-sm" onclick="selectNextEvent('${t}')" style="margin:0 2px;">${t}</button>`
  ).join('');
  
  // Update linked event dropdown
  updateLinkedEventsDropdown();
  
  // v23.3: Highlight suggested event buttons
  highlightSuggestedEvent();
  
  // v23.3: If sequence mode is on, auto-link to last event
  if (sequenceModeActive && lastEvt) {
    // Use the next available linked index (max + 1), not the event index
    const nextLinkedIdx = getNextLinkedEventIdx();
    S.linkedEventIdx = nextLinkedIdx;
    const linkedEl = document.getElementById('linkedEvt');
    if (linkedEl) linkedEl.value = nextLinkedIdx + 1; // Display is 1-based
    document.getElementById('evtStartTime').value = lastEvt.start_time || lastEvt.end_time || '';
  }
}

function selectNextEvent(type) {
  // Get the last event to carry over data
  const lastEvt = S.events[S.events.length - 1];
  
  // Set the event type
  setEvtType(type);
  
    // Carry over all player data if appropriate
    if (lastEvt) {
      // Carry over all players on ice (keep XY positions)
      if (LISTS.linkedEvents[type]?.includes(lastEvt.type)) {
        // #region agent log
        fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'selectNextEvent:linkedEvent',message:'Linked event detected - copying XY',data:{fromType:lastEvt.type,toType:type,lastEvtPlayersCount:lastEvt.players?.length||0,lastEvtPuckXYCount:lastEvt.puckXY?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
        // #endregion
        
        // Auto-link - use the next available linked index (max + 1)
        const nextLinkedIdx = getNextLinkedEventIdx();
        S.linkedEventIdx = nextLinkedIdx;
        document.getElementById('linkedEvtSelect').value = nextLinkedIdx; // Store linked index, not event idx
      
        // Copy players with XY
        S.curr.players = lastEvt.players.map(p => ({
          ...p,
          xy: [...(p.xy || [])] // Clone XY array
        }));
        
        // #region agent log
        fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'selectNextEvent:playersCopied',message:'Players copied with XY',data:{playersCopied:S.curr.players.length,playersWithXY:S.curr.players.filter(p=>p.xy?.length>0).length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
        // #endregion
      
        // Copy puck XY
        if (lastEvt.puckXY?.length) {
          S.curr.puckXY = [...lastEvt.puckXY];
          // #region agent log
          fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'selectNextEvent:puckXYCopied',message:'Puck XY copied',data:{puckXYCount:S.curr.puckXY.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
          // #endregion
        }
      
        // Copy zone and time
        document.getElementById('evtZone').value = lastEvt.zone || '';
        document.getElementById('evtStartTime').value = lastEvt.start_time || lastEvt.end_time || '';
      }
    
    // Special cases for role swaps (Shot‚ÜíSave: shooter becomes opp)
    if (type === 'Save' && lastEvt.type === 'Shot') {
      S.curr.players = lastEvt.players.map(p => ({
        ...p,
        role: p.role?.startsWith('event') ? p.role.replace('event', 'opp') : p.role.replace('opp', 'event'),
        xy: [...(p.xy || [])]
      }));
      // Swap event team
      S.evtTeam = S.evtTeam === 'home' ? 'away' : 'home';
      updateEvtTeamUI();
    }
  }
  
  renderQuickAdd();
  renderMarkers();
  toast(`${type} - data carried over`, 'success');
}

function updateEvtTeamUI() {
  document.querySelectorAll('.team-toggle button').forEach(b => b.classList.remove('active'));
  document.querySelector(`.team-toggle .${S.evtTeam}`).classList.add('active');
}

function updateLinkedEventsDropdown() {
  const sel = document.getElementById('linkedEvtSelect');
  if (!sel) return;
  
  // Show last 10 events for linking
  const recentEvents = S.events.slice(-10).reverse();
  sel.innerHTML = '<option value="">-- None --</option>' + recentEvents.map(e => {
    const time = e.start_time || e.time || '';
    const players = e.players?.map(p => p.num).join(',') || '';
    const linkedInfo = e.linkedEventIdx !== null ? ` [Linked #${e.linkedEventIdx + 1}]` : '';
    return `<option value="${e.idx}">#${e.idx + 1} ${e.type} ${time} [${players}]${linkedInfo}</option>`;
  }).join('');
  
  // Auto-suggest link based on current event type
  if (S.curr.type && recentEvents.length) {
    const lastEvt = recentEvents[0];
    const canLink = LISTS.linkedEvents[S.curr.type];
    if (canLink && canLink.includes(lastEvt.type)) {
      // If last event has a linked index, use it; otherwise create new
      const nextLinkedIdx = lastEvt.linkedEventIdx !== null ? lastEvt.linkedEventIdx : getNextLinkedEventIdx();
      sel.value = lastEvt.idx; // Show event in dropdown
      S.linkedEventIdx = nextLinkedIdx; // But store linked index
      document.getElementById('linkedEvtInfo').textContent = `‚Üê Auto-linked to ${lastEvt.type}`;
      // Apply linked data
      applyLinkedEventData();
    } else {
      document.getElementById('linkedEvtInfo').textContent = '';
    }
  }
}

/**
 * v23.9: Get the maximum linked event index value (not event index)
 */
function getMaxLinkedEventIdx() {
  const maxLinkedIdx = S.events.reduce((max, evt) => {
    if (evt.linkedEventIdx !== null && evt.linkedEventIdx !== undefined) {
      return Math.max(max, evt.linkedEventIdx);
    }
    return max;
  }, -1);
  return maxLinkedIdx;
}

/**
 * v23.9: Calculate next linked event index (max + 1)
 */
function getNextLinkedEventIdx() {
  const maxLinkedIdx = getMaxLinkedEventIdx();
  return maxLinkedIdx + 1;
}

/**
 * v23.9: Propagate linked index change to all events in the chain
 */
function propagateLinkedIndexChange(changedEvtIdx, newLinkedIdx) {
  // Find all events that link to the changed event (they should all get the same linked index)
  const changedEvt = S.events.find(e => e.idx === changedEvtIdx);
  if (!changedEvt) return;
  
  // Get the chain: all events that link to the same source
  const oldLinkedIdx = changedEvt.linkedEventIdx;
  
  // Only propagate if oldLinkedIdx is not null - if null, this event wasn't in a chain
  if (oldLinkedIdx === null || oldLinkedIdx === undefined) {
    // Event wasn't in a chain - just update this one event
    changedEvt.linkedEventIdx = newLinkedIdx;
    return;
  }
  
  // Find all events in the same chain (same linkedEventIdx)
  const chainEvents = S.events.filter(e => e.linkedEventIdx === oldLinkedIdx && e.linkedEventIdx !== null && e.linkedEventIdx !== undefined);
  
  // Update all events in the chain to use the new linked index
  chainEvents.forEach(evt => {
    evt.linkedEventIdx = newLinkedIdx;
  });
  
  renderEvents();
  autoSave();
}

/**
 * v23.9: Reindex linked event indexes after deletion or insertion
 */
function reindexLinkedEventIndexes() {
  // Group events by their linked index chains
  const linkedGroups = new Map();
  
  S.events.forEach(evt => {
    if (evt.linkedEventIdx !== null && evt.linkedEventIdx !== undefined) {
      const key = evt.linkedEventIdx;
      if (!linkedGroups.has(key)) {
        linkedGroups.set(key, []);
      }
      linkedGroups.get(key).push(evt);
    }
  });
  
  // Reindex each group sequentially
  let newLinkedIdx = 0;
  linkedGroups.forEach((events, oldLinkedIdx) => {
    events.forEach(evt => {
      evt.linkedEventIdx = newLinkedIdx;
    });
    newLinkedIdx++;
  });
  
  renderEvents();
  autoSave();
}

/**
 * v23.9: Propagate XY changes to all events with the same linked index
 */
function propagateXYToLinkedEvents(sourceEvtIdx, xyType, playerNum, xyData) {
  const sourceEvt = S.events.find(e => e.idx === sourceEvtIdx);
  if (!sourceEvt || sourceEvt.linkedEventIdx === null || sourceEvt.linkedEventIdx === undefined) {
    return; // No linked events to propagate to
  }
  
  // Find all events with the same linked index
  const linkedEvents = S.events.filter(e => 
    e.linkedEventIdx === sourceEvt.linkedEventIdx && e.idx !== sourceEvtIdx
  );
  
  if (linkedEvents.length === 0) return;
  
  if (xyType === 'puck') {
    // Propagate puck XY to all linked events
    linkedEvents.forEach(evt => {
      evt.puckXY = JSON.parse(JSON.stringify(xyData)); // Deep clone
    });
  } else if (xyType === 'player' && playerNum !== null) {
    // Propagate player XY to all linked events
    linkedEvents.forEach(evt => {
      const targetPlayer = evt.players?.find(p => 
        p.num === playerNum && 
        (p.team || evt.team) === (sourceEvt.players?.find(sp => sp.num === playerNum)?.team || sourceEvt.team)
      );
      if (targetPlayer) {
        targetPlayer.xy = JSON.parse(JSON.stringify(xyData)); // Deep clone
      }
    });
  }
  
  // Re-render to show updated XY
  renderMarkers();
  renderXYSlots();
}

function onLinkedEvtChange() {
  const val = document.getElementById('linkedEvtSelect').value;
  if (val) {
    // Find the selected event
    const selectedEvt = S.events.find(e => e.idx === parseInt(val));
    if (selectedEvt) {
      // If the selected event already has a linked index, use it
      // Otherwise, create a new linked index
      if (selectedEvt.linkedEventIdx !== null && selectedEvt.linkedEventIdx !== undefined) {
        S.linkedEventIdx = selectedEvt.linkedEventIdx;
      } else {
        // Create new linked index for this chain
        const nextLinkedIdx = getNextLinkedEventIdx();
        selectedEvt.linkedEventIdx = nextLinkedIdx;
        S.linkedEventIdx = nextLinkedIdx;
      }
    } else {
      // Event not found, create new linked index
      S.linkedEventIdx = getNextLinkedEventIdx();
    }
  } else {
    S.linkedEventIdx = null;
  }
  if (S.linkedEventIdx !== null) {
    applyLinkedEventData();
  }
}

// ============================================================
// AUTO BUTTONS
// ============================================================
function autoZone() {
  const zone = calculateZone();
  if (zone) {
    document.getElementById('evtZone').value = zone;
    toast(`Zone: ${zone === 'o' ? 'Offensive' : zone === 'd' ? 'Defensive' : 'Neutral'}`, 'success');
  } else {
    toast('Add player XY to auto-detect zone', 'error');
  }
}

function autoSuccess() {
  const success = deriveSuccess();
  if (success) {
    document.getElementById('evtSuccess').value = success;
    toast(`Success: ${success === 's' ? 'Successful' : 'Unsuccessful'}`, 'success');
  } else {
    toast('Select event type and detail first', 'error');
  }
}

/**
 * v16: Auto-calculate side of puck based on zone and player team
 */
function autoSideOfPuck() {
  if (!S.selectedPlayer) {
    toast('Select a player first', 'error');
    return;
  }
  
  const zone = document.getElementById('evtZone').value;
  if (!zone || zone === 'n') {
    toast('Set zone first (must be offensive or defensive, not neutral)', 'error');
    return;
  }
  
  // Determine player's team - use team property if available, otherwise infer from role
  let playerTeam;
  if (S.selectedPlayer.team) {
    playerTeam = S.selectedPlayer.team; // 'home' or 'away'
  } else {
    // Fallback: infer from role
    const role = S.selectedPlayer.role || '';
    if (role.startsWith('event_team') || role.startsWith('event_player')) {
      playerTeam = S.evtTeam;
    } else if (role.startsWith('opp_team') || role.startsWith('opp_player')) {
      playerTeam = S.evtTeam === 'home' ? 'away' : 'home';
    } else {
      toast('Could not determine player team', 'error');
      return;
    }
  }
  
  const eventTeam = S.evtTeam || 'home'; // 'home' or 'away'
  
  // Zone is always from the event team's perspective
  // Side of puck is from the player's team's perspective
  let sideOfPuck;
  if (playerTeam === eventTeam) {
    // Player is on event team - zone is already from their perspective
    // Event team's offensive zone = player's offensive side
    // Event team's defensive zone = player's defensive side
    sideOfPuck = zone === 'o' ? 'Offensive' : 'Defensive';
  } else {
    // Player is on opponent team - zone is from event team's perspective, need to flip
    // Event team's offensive zone = opponent's defensive side
    // Event team's defensive zone = opponent's offensive side
    sideOfPuck = zone === 'o' ? 'Defensive' : 'Offensive';
  }
  
  if (sideOfPuck) {
    document.getElementById('pdSideOfPuck').value = sideOfPuck;
    updatePlayerDetail('sideOfPuck', sideOfPuck);
    toast(`Side of puck: ${sideOfPuck} (player team: ${playerTeam}, event team: ${eventTeam}, zone: ${zone})`, 'success');
  } else {
    toast('Could not determine side', 'error');
  }
}

/**
 * v23.8: Auto-detect side of puck for all players
 */
function autoDetectAllSideOfPuck() {
  if (!autoSideOfPuckEnabled) return;
  const zone = document.getElementById('evtZone').value;
  if (!zone || zone === 'n') return; // Need zone and not neutral
  
  const eventTeam = S.evtTeam || 'home';
  
  S.curr.players.forEach(p => {
    // Determine player's team - use team property if available, otherwise infer from role
    let playerTeam;
    if (p.team) {
      playerTeam = p.team; // 'home' or 'away'
    } else {
      // Fallback: infer from role
      const role = p.role || '';
      if (role.startsWith('event_team') || role.startsWith('event_player')) {
        playerTeam = eventTeam;
      } else if (role.startsWith('opp_team') || role.startsWith('opp_player')) {
        playerTeam = eventTeam === 'home' ? 'away' : 'home';
      } else {
        return; // Skip if can't determine team
      }
    }
    
    // Zone is always from the event team's perspective
    // Side of puck is from the player's team's perspective
    let sideOfPuck;
    if (playerTeam === eventTeam) {
      // Player is on event team - zone is already from their perspective
      sideOfPuck = zone === 'o' ? 'Offensive' : 'Defensive';
    } else {
      // Player is on opponent team - zone is from event team's perspective, need to flip
      sideOfPuck = zone === 'o' ? 'Defensive' : 'Offensive';
    }
    
    if (sideOfPuck) {
      p.sideOfPuck = sideOfPuck;
    }
  });
  
  if (typeof renderQuickAdd === 'function') renderQuickAdd();
}

function autoStrength() {
  const strength = deriveStrength();
  if (strength) {
    document.getElementById('evtStrength').value = strength;
    toast(`Strength: ${strength}`, 'success');
  } else {
    toast('Fill player slots first', 'error');
  }
}

function updatePlayD2() {
  // Update Play Detail 2 dropdown based on Play Detail 1
  if (!S.selectedPlayer) return;
  
  const d1 = document.getElementById('pdPlayD1').value;
  // v15.02: Use S.playDetails2 from dim_play_detail_2 for second dropdown - use code, not name
  // These are independent of the first dropdown selection
  const pd2Opts = S.playDetails2?.length > 0 
    ? S.playDetails2.map(p => p.code || p.name) 
    : [];
  
  // v16.02: Use datalist for searchable dropdown
  document.getElementById('pdPlayD2List').innerHTML = pd2Opts.map(o => `<option value="${o}">`).join('');
}

function deriveStrength() {
  // Count players on ice (excluding empty slots)
  const homeOnIce = Object.values(S.slots.home).filter(Boolean).length;
  const awayOnIce = Object.values(S.slots.away).filter(Boolean).length;
  
  // Check for goalie
  const homeHasGoalie = !!S.slots.home.G;
  const awayHasGoalie = !!S.slots.away.G;
  
  // Calculate skaters
  const homeSkaters = homeOnIce - (homeHasGoalie ? 1 : 0);
  const awaySkaters = awayOnIce - (awayHasGoalie ? 1 : 0);
  
  // Empty net situations
  if (!homeHasGoalie && homeOnIce >= 5) return 'ENA'; // Empty net away (extra attacker for home)
  if (!awayHasGoalie && awayOnIce >= 5) return 'ENH'; // Empty net home
  
  // Standard situations
  if (homeSkaters === 5 && awaySkaters === 5) return '5v5';
  if (homeSkaters === 5 && awaySkaters === 4) return '5v4';
  if (homeSkaters === 4 && awaySkaters === 5) return '4v5';
  if (homeSkaters === 4 && awaySkaters === 4) return '4v4';
  if (homeSkaters === 5 && awaySkaters === 3) return '5v3';
  if (homeSkaters === 3 && awaySkaters === 5) return '3v5';
  if (homeSkaters === 3 && awaySkaters === 3) return '3v3';
  
  return `${homeSkaters}v${awaySkaters}`;
}

function renderSlots() {
  ['home','away'].forEach(team => {
    ['F1','F2','F3','D1','D2','G','X'].forEach(pos => {
      const el = document.querySelector(`.slot[data-team="${team}"][data-pos="${pos}"]`);
      if (!el) return;
      const p = S.slots[team][pos];
      if (p) { 
        el.innerHTML = `<span class="clear-x" onclick="event.stopPropagation();clearSlot('${team}','${pos}')" title="Remove ${p.name}">‚úï</span><span class="num">${p.num}</span><span class="name">${p.name}</span>`; 
        el.classList.add('filled');
        el.draggable = true;
      }
      else { 
        el.innerHTML = `<span class="num">${pos}</span>`; 
        el.classList.remove('filled'); 
        el.draggable = false;
      }
    });
  });
}

// ============================================================
// SLOT DRAG AND DROP
// ============================================================
let draggedSlot = null;

function setupSlotDragDrop() {
  document.querySelectorAll('.slot').forEach(slot => {
    slot.addEventListener('dragstart', handleSlotDragStart);
    slot.addEventListener('dragend', handleSlotDragEnd);
    slot.addEventListener('dragover', handleSlotDragOver);
    slot.addEventListener('dragleave', handleSlotDragLeave);
    slot.addEventListener('drop', handleSlotDrop);
  });
}

function handleSlotDragStart(e) {
  const team = this.dataset.team;
  const pos = this.dataset.pos;
  if (!S.slots[team][pos]) return; // Can't drag empty slot
  
  draggedSlot = { team, pos, player: S.slots[team][pos] };
  this.classList.add('dragging');
  e.dataTransfer.effectAllowed = 'move';
  e.dataTransfer.setData('text/plain', JSON.stringify(draggedSlot));
}

function handleSlotDragEnd(e) {
  this.classList.remove('dragging');
  document.querySelectorAll('.slot').forEach(s => s.classList.remove('drag-over'));
  draggedSlot = null;
}

function handleSlotDragOver(e) {
  e.preventDefault();
  if (!draggedSlot) return;
  e.dataTransfer.dropEffect = 'move';
  this.classList.add('drag-over');
}

function handleSlotDragLeave(e) {
  this.classList.remove('drag-over');
}

function handleSlotDrop(e) {
  e.preventDefault();
  this.classList.remove('drag-over');
  
  if (!draggedSlot) return;
  
  const targetTeam = this.dataset.team;
  const targetPos = this.dataset.pos;
  const sourceTeam = draggedSlot.team;
  const sourcePos = draggedSlot.pos;
  
  // Get what's in the target slot (if anything)
  const targetPlayer = S.slots[targetTeam][targetPos];
  
  // Swap the players
  S.slots[targetTeam][targetPos] = draggedSlot.player;
  S.slots[sourceTeam][sourcePos] = targetPlayer; // Will be null if target was empty
  
  renderSlots();
  renderRosters();
  renderQuickAdd();
  onSlotsChanged();
  
  // Show feedback
  if (sourceTeam !== targetTeam) {
    toast(`Moved #${draggedSlot.player.num} to ${targetTeam.toUpperCase()} ${targetPos}`, 'info');
  }
}

function renderRosters() {
  ['home','away'].forEach(team => {
    const onIce = Object.values(S.slots[team]).filter(Boolean).map(p => p.num);
    const roster = S.rosters[team];
    
    // Group by position
    const groups = { F: [], D: [], G: [] };
    roster.forEach(p => {
      const pos = (p.pos || 'F').toUpperCase();
      if (pos === 'G') groups.G.push(p);
      else if (pos === 'D' || pos === 'LD' || pos === 'RD') groups.D.push(p);
      else groups.F.push(p);
    });
    
    // Render grouped roster
    let html = '';
    ['F', 'D', 'G'].forEach(grp => {
      if (groups[grp].length === 0) return;
      html += `<div class="roster-group"><span class="roster-group-label">${grp === 'F' ? 'Forwards' : grp === 'D' ? 'Defense' : 'Goalie'}</span>`;
      html += groups[grp].map(p => {
        const used = onIce.includes(p.num);
        const lastName = getLastName(p.name);
        const rating = p.rating ? `<span class="rating">${p.rating}</span>` : '';
        return `<button class="roster-btn ${used?'on-ice':''}" onclick="assignPlayer('${team}','${p.num}')"><span class="num">${p.num}</span><span class="name">${lastName}</span>${rating}</button>`;
      }).join('');
      html += '</div>';
    });
    
    document.getElementById(`${team}Roster`).innerHTML = html;
  });
}

function getLastName(fullName) {
  if (!fullName) return '?';
  const parts = fullName.trim().split(' ');
  return parts[parts.length - 1];
}

function renderQuickAdd() {
  // #region agent log
  const slotsHomeValues = Object.values(S.slots?.home||{}).filter(Boolean).map(p=>({num:p.num,name:p.name}));
  const slotsAwayValues = Object.values(S.slots?.away||{}).filter(Boolean).map(p=>({num:p.num,name:p.name}));
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'renderQuickAdd:9557',message:'Function entry',data:{evtTeam:S.evtTeam,slotsHomeCount:Object.values(S.slots?.home||{}).filter(Boolean).length,slotsAwayCount:Object.values(S.slots?.away||{}).filter(Boolean).length,slotsHomeValues,slotsAwayValues,rostersHomeCount:S.rosters?.home?.length||0,rostersAwayCount:S.rosters?.away?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
  // #endregion
  const evtTeam = S.evtTeam;
  const oppTeam = evtTeam === 'home' ? 'away' : 'home';
  const onIce = num => Object.values(S.slots[evtTeam]||{}).some(p => String(p?.num) === String(num));
  const oppOnIce = num => Object.values(S.slots[oppTeam]||{}).some(p => String(p?.num) === String(num));
  const inEvt = num => S.curr.players.some(p => p.num === num);
  
  // #region agent log
  const evtTeamSlotsNums = Object.values(S.slots[evtTeam]||{}).filter(Boolean).map(p=>String(p.num));
  const oppTeamSlotsNums = Object.values(S.slots[oppTeam]||{}).filter(Boolean).map(p=>String(p.num));
  const logDataSetup = {evtTeam,oppTeam,evtTeamSlotsNums,oppTeamSlotsNums,rostersEvtTeamExists:!!S.rosters[evtTeam],rostersOppTeamExists:!!S.rosters[oppTeam]};
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'renderQuickAdd:9563',message:'onIce/oppOnIce setup',data:logDataSetup,timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
  // #endregion
  
  // v23.4: Get recent players for highlighting
  const recentPlayers = getRecentPlayers();
  const isRecent = num => recentPlayers.includes(num);
  
  // Event quick add - players on ice for event team (recent players first)
  // #region agent log
  const evtRosterNums = S.rosters[evtTeam]?.map(p=>String(p.num))||[];
  const logData1 = {evtTeam,rostersEvtTeamLength:S.rosters[evtTeam]?.length||0,evtRosterNums,evtTeamSlotsNums};
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'renderQuickAdd:9571',message:'Before filtering evtOnIcePlayers',data:logData1,timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
  // #endregion
  const evtOnIcePlayers = S.rosters[evtTeam]?.filter(p => onIce(p.num)) || [];
  // #region agent log
  const evtOnIceNums = evtOnIcePlayers.map(p=>String(p.num));
  const matchedPlayersData = evtOnIcePlayers.map(p=>({num:p.num,name:p.name,onIceResult:onIce(p.num)}));
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'renderQuickAdd:9573',message:'After filtering evtOnIcePlayers',data:{evtOnIcePlayersCount:evtOnIcePlayers.length,evtOnIceNums,matchedPlayers:matchedPlayersData},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
  // #endregion
  const evtSorted = [...evtOnIcePlayers].sort((a, b) => {
    const aRecent = isRecent(a.num) ? 0 : 1;
    const bRecent = isRecent(b.num) ? 0 : 1;
    return aRecent - bRecent;
  });
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'renderQuickAdd:9576',message:'Before rendering evtQuickAdd',data:{evtSortedCount:evtSorted.length,evtQuickAddElementExists:!!document.getElementById('evtQuickAdd')},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
  // #endregion
  const evtQuickAddEl = document.getElementById('evtQuickAdd');
  if (evtQuickAddEl) {
    evtQuickAddEl.innerHTML = evtSorted
      .map(p => `<button class="${inEvt(p.num)?'in-evt':''} ${isRecent(p.num)?'recent':''}" onclick="togglePlayer('${p.num}','evt')" title="${p.name}${isRecent(p.num)?' (recent)':''}">${p.num}</button>`).join('');
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'renderQuickAdd:9580',message:'After rendering evtQuickAdd',data:{evtQuickAddInnerHTMLLength:evtQuickAddEl.innerHTML.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
    // #endregion
  }
  
  // Opp quick add (recent players first)
  // #region agent log
  const oppRosterNums = S.rosters[oppTeam]?.map(p=>String(p.num))||[];
  const oppTeamSlotsNumsForCheck = Object.values(S.slots[oppTeam]||{}).filter(Boolean).map(p=>String(p.num));
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'renderQuickAdd:9585',message:'Before filtering oppOnIcePlayers',data:{oppTeam,rostersOppTeamLength:S.rosters[oppTeam]?.length||0,oppRosterNums,oppTeamSlotsNumsForCheck},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
  // #endregion
  const oppOnIcePlayers = S.rosters[oppTeam]?.filter(p => oppOnIce(p.num)) || [];
  // #region agent log
  const oppOnIceNums = oppOnIcePlayers.map(p=>String(p.num));
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'renderQuickAdd:9587',message:'After filtering oppOnIcePlayers',data:{oppOnIcePlayersCount:oppOnIcePlayers.length,oppOnIceNums},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
  // #endregion
  const oppSorted = [...oppOnIcePlayers].sort((a, b) => {
    const aRecent = isRecent(a.num) ? 0 : 1;
    const bRecent = isRecent(b.num) ? 0 : 1;
    return aRecent - bRecent;
  });
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'renderQuickAdd:9589',message:'Before rendering oppQuickAdd',data:{oppSortedCount:oppSorted.length,oppQuickAddElementExists:!!document.getElementById('oppQuickAdd')},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
  // #endregion
  const oppQuickAddEl = document.getElementById('oppQuickAdd');
  if (oppQuickAddEl) {
    oppQuickAddEl.innerHTML = oppSorted
      .map(p => `<button class="${inEvt(p.num)?'in-evt':''} ${isRecent(p.num)?'recent':''}" onclick="togglePlayer('${p.num}','opp')" title="${p.name}${isRecent(p.num)?' (recent)':''}">${p.num}</button>`).join('');
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'renderQuickAdd:9593',message:'After rendering oppQuickAdd',data:{oppQuickAddInnerHTMLLength:oppQuickAddEl.innerHTML.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
    // #endregion
  }
  
  // Event players display
  const evtPs = S.curr.players.filter(p => p.role?.startsWith('event'));
  document.getElementById('evtPlayers').innerHTML = evtPs.map((p, idx) => {
    const sel = S.selectedPlayer?.num === p.num;
    const xyCount = p.xy?.length || 0;
    const suClass = p.playSuccess ? (p.playSuccess === 's' ? 's' : 'u') : '';
    const roleLabel = p.roleNum || '?';
    return `<span class="player-chip evt ${sel?'selected':''}" draggable="true" data-num="${p.num}" data-role="evt" data-idx="${idx}" onclick="selectPlayer('${p.num}')" ondragstart="handlePlayerDragStart(event)" ondragend="handlePlayerDragEnd(event)" ondragover="handlePlayerDragOver(event)" ondrop="handlePlayerDrop(event)"><span class="role-num">E${roleLabel}</span><span class="num">${p.num}</span>${p.name}${xyCount?`<span style="color:var(--accent);font-size:7px;">‚óè${xyCount}</span>`:''}${p.playSuccess?`<span class="su ${suClass}">${p.playSuccess}</span>`:''}<span class="remove" onclick="event.stopPropagation();removePlayer('${p.num}')">‚úï</span></span>`;
  }).join('') || '<span style="color:var(--muted);font-size:8px;">Click players below</span>';
  
  // Opp players display
  const oppPs = S.curr.players.filter(p => p.role?.startsWith('opp'));
  document.getElementById('oppPlayers').innerHTML = oppPs.map((p, idx) => {
    const sel = S.selectedPlayer?.num === p.num;
    const xyCount = p.xy?.length || 0;
    const suClass = p.playSuccess ? (p.playSuccess === 's' ? 's' : 'u') : '';
    const roleLabel = p.roleNum || '?';
    return `<span class="player-chip opp ${sel?'selected':''}" draggable="true" data-num="${p.num}" data-role="opp" data-idx="${idx}" onclick="selectPlayer('${p.num}')" ondragstart="handlePlayerDragStart(event)" ondragend="handlePlayerDragEnd(event)" ondragover="handlePlayerDragOver(event)" ondrop="handlePlayerDrop(event)"><span class="role-num">O${roleLabel}</span><span class="num">${p.num}</span>${p.name}${xyCount?`<span style="color:var(--accent);font-size:7px;">‚óè${xyCount}</span>`:''}${p.playSuccess?`<span class="su ${suClass}">${p.playSuccess}</span>`:''}<span class="remove" onclick="event.stopPropagation();removePlayer('${p.num}')">‚úï</span></span>`;
  }).join('') || '<span style="color:var(--muted);font-size:8px;">Click players below</span>';
  
  // Player selector for XY - v23.4: Always show when players exist, clearer options
  const sel = document.getElementById('xyPlayerSel');
  if (S.curr.players.length > 0) {
    sel.style.display = 'inline-block';
    const puckOption = S.xyMode === 'puck' 
      ? '<option value="" selected>üèí Puck mode</option>'
      : '<option value="">üèí Switch to Puck</option>';
    sel.innerHTML = puckOption + 
      S.curr.players.map(p => {
        const xyCount = p.xy?.length || 0;
        const selected = S.selectedPlayer?.num === p.num;
        return `<option value="${p.num}" ${selected?'selected':''}>#${p.num} ${p.name}${xyCount ? ` (${xyCount}pt)` : ''}</option>`;
      }).join('');
  } else { 
    sel.style.display = 'none'; 
  }
  
  // Player details panel
  const pdEl = document.getElementById('playerDetails');
  if (S.selectedPlayer) {
    pdEl.style.display = 'block';
    document.getElementById('pdPlayerNum').textContent = '#' + S.selectedPlayer.num + ' ' + S.selectedPlayer.name;
    // v15.01: Use S.playDetails1 from dim_play_detail for first dropdown - use code, not name
    const pd1Opts = S.playDetails1?.length > 0 
      ? S.playDetails1.map(p => p.code || p.name) 
      : (document.getElementById('evtZone').value === 'd' ? LISTS.playDefensive : LISTS.playOffensive);
    // v16.02: Use datalist for searchable dropdowns
    document.getElementById('pdPlayD1List').innerHTML = pd1Opts.map(o => `<option value="${o}">`).join('');
    document.getElementById('pdPlayD1').value = S.selectedPlayer.playD1 || '';
    // v15.01: Use S.playDetails2 from dim_play_detail_2 for second dropdown - use code, not name
    const pd2Opts = S.playDetails2?.length > 0 
      ? S.playDetails2.map(p => p.code || p.name) 
      : [];
    document.getElementById('pdPlayD2List').innerHTML = pd2Opts.map(o => `<option value="${o}">`).join('');
    document.getElementById('pdPlayD2').value = S.selectedPlayer.playD2 || '';
    document.getElementById('pdPlaySuccess').value = S.selectedPlayer.playSuccess || '';
    // v16: Side of puck dropdown
    document.getElementById('pdSideOfPuck').value = S.selectedPlayer.sideOfPuck || '';
    
    // Pressure dropdown - opposing players
    const oppTeam = S.evtTeam === 'home' ? 'away' : 'home';
    const oppInEvt = S.curr.players.filter(p => p.role?.startsWith('opp'));
    document.getElementById('pdPressure').innerHTML = '<option value="">--</option>' + oppInEvt.map(p => `<option value="${p.num}" ${S.selectedPlayer.pressure===p.num?'selected':''}>#${p.num}</option>`).join('');
  } else { pdEl.style.display = 'none'; }
}

function renderXYSlots() {
  const el = document.getElementById('xySlots');
  const max = 6;
  let data = S.xyMode === 'puck' ? S.curr.puckXY : (S.selectedPlayer?.xy || []);
  el.innerHTML = Array.from({length: max}, (_, i) => {
    const slotNum = i + 1;
    // Find if this slot has data (by seq number, not array index)
    const has = data.find(p => p && p.seq === slotNum);
    const active = S.xySlot === slotNum;
    const highlighted = (S.highlightedXYSeq === slotNum && 
                        S.highlightedXYType === S.xyMode && 
                        (S.xyMode === 'puck' || S.highlightedXYPlayerNum === S.selectedPlayer?.num));
    // Add delete button for filled slots
    const deleteBtn = has ? `<button class="btn-sm btn-danger" onclick="deleteCurrentXYSlot(${slotNum});event.stopPropagation();" style="position:absolute;top:-4px;right:-4px;padding:0;width:12px;height:12px;font-size:7px;line-height:1;border-radius:50%;z-index:10;background:var(--danger);color:#fff;border:1px solid #fff;" title="Delete slot ${slotNum}">‚úï</button>` : '';
    return `<div style="position:relative;display:inline-block;margin:2px;">
      <button class="xy-slot ${has?'has':''} ${active?'active':''} ${highlighted?'highlighted':''}" 
              onclick="setXYSlot(${slotNum}); highlightXYPoint(${slotNum});" 
              style="${highlighted ? 'box-shadow: 0 0 8px 3px var(--accent); background: var(--accent); color: #fff;' : ''}"
              title="Slot ${slotNum}${has?' (filled)':' (empty)'} - Click to highlight on rink">${slotNum}</button>
      ${deleteBtn}
    </div>`;
  }).join('');
  
  // v23.4: Update slot indicator with carry-over info
  const indicator = document.getElementById('xySlotIndicator');
  if (indicator) {
    const filledCount = data.filter(Boolean).length;
    let indicatorText = filledCount > 0 ? `(${filledCount} pts)` : '‚Üí click rink';
    
    // Show if XY was carried over (check if slot 1 matches previous event's last point)
    if (filledCount > 0 && data.find(p => p && p.seq === 1)) {
      const lastEvt = S.events[S.events.length - 1];
      if (lastEvt) {
        if (S.xyMode === 'puck' && lastEvt.puckXY?.length > 0) {
          const lastPuckXY = lastEvt.puckXY[lastEvt.puckXY.length - 1];
          const firstPuckXY = data.find(p => p && p.seq === 1);
          if (firstPuckXY && Math.abs(firstPuckXY.x - lastPuckXY.x) < 0.1 && Math.abs(firstPuckXY.y - lastPuckXY.y) < 0.1) {
            indicatorText += ' üîÑ';
          }
        } else if (S.xyMode === 'player' && S.selectedPlayer && lastEvt.players) {
          const prevPlayer = lastEvt.players.find(p => p.num === S.selectedPlayer.num);
          if (prevPlayer?.xy?.length > 0) {
            const lastPlayerXY = prevPlayer.xy[prevPlayer.xy.length - 1];
            const firstPlayerXY = data.find(p => p && p.seq === 1);
            if (firstPlayerXY && Math.abs(firstPlayerXY.x - lastPlayerXY.x) < 0.1 && Math.abs(firstPlayerXY.y - lastPlayerXY.y) < 0.1) {
              indicatorText += ' üîÑ';
            }
          }
        }
      }
    }
    
    indicator.textContent = indicatorText;
  }
}

/**
 * v23.9: Highlight a specific XY point on the rink when slot is clicked
 */
function highlightXYPoint(slotNum) {
  S.highlightedXYSeq = slotNum;
  S.highlightedXYType = S.xyMode;
  S.highlightedXYPlayerNum = S.xyMode === 'player' ? S.selectedPlayer?.num : null;
  
  // Re-render markers to show highlight
  renderMarkers();
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'highlightXYPoint',message:'XY point highlighted',data:{slotNum,xyMode:S.xyMode,playerNum:S.selectedPlayer?.num},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
  // #endregion
}

/**
 * v23.9: Delete a specific XY slot from current event
 */
function deleteCurrentXYSlot(slotNum) {
  if (S.xyMode === 'puck') {
    if (!S.curr.puckXY || S.curr.puckXY.length === 0) return;
    const idx = S.curr.puckXY.findIndex(p => p.seq === slotNum);
    if (idx !== -1) {
      S.curr.puckXY.splice(idx, 1);
      // Renumber remaining slots
      S.curr.puckXY.forEach((p, i) => { p.seq = i + 1; });
      renderMarkers();
      renderXYSlots();
      toast('Puck XY slot deleted', 'success');
    }
  } else if (S.selectedPlayer && S.selectedPlayer.xy) {
    const idx = S.selectedPlayer.xy.findIndex(p => p.seq === slotNum);
    if (idx !== -1) {
      S.selectedPlayer.xy.splice(idx, 1);
      // Renumber remaining slots
      S.selectedPlayer.xy.forEach((p, i) => { p.seq = i + 1; });
      renderMarkers();
      renderXYSlots();
      toast(`Player #${S.selectedPlayer.num} XY slot deleted`, 'success');
    }
  }
}

function renderEvents() {
  const body = document.getElementById('evtListBody');
  if (!body) {
    console.error('evtListBody element not found!');
    return;
  }
  
  // v20.4: Populate filter dropdowns with current values
  populateEventFilterDropdowns();
  
  // v16.04: Debug - log event periods
  console.log('renderEvents called');
  console.log('  S.events count:', S.events?.length || 0);
  console.log('  S.eventLogFilter:', S.eventLogFilter);
  
  // v15.02: Period filter
  let filteredEvents = S.events || [];
  const periodFilter = (S.eventLogFilter || 'all').toLowerCase();
  
  // v23.7: Issues filter - show events with data quality issues
  if (periodFilter === 'issues') {
    filteredEvents = filteredEvents.filter(e => {
      const idx = S.events.indexOf(e);
      if (idx === -1) return false;
      
      // v23.8: Apply issue type filter if set
      if (S.issueTypeFilter) {
        if (S.issueTypeFilter === 'time_invalid') {
          if (!e.start_time || !e.end_time) return false;
          const parseTime = (t) => {
            if (!t) return null;
            const parts = String(t).split(':');
            if (parts.length !== 2) return null;
            const min = parseInt(parts[0]);
            const sec = parseInt(parts[1]);
            if (isNaN(min) || isNaN(sec)) return null;
            return min * 60 + sec;
          };
          const startSec = parseTime(e.start_time);
          const endSec = parseTime(e.end_time);
          if (startSec === null || endSec === null || endSec >= startSec) return false;
          return true;
        } else if (S.issueTypeFilter === 'time_missing') {
          if (e.start_time && e.time) return false;
          return true;
        } else if (S.issueTypeFilter === 'data_missing') {
          if (e.type && e.team && (e.start_time || e.time)) return false;
          return true;
        } else if (S.issueTypeFilter === 'team_validation') {
          const hasTeamIssues = S.teamValidationIssues?.some(issue => issue.eventIdx === idx) || false;
          return hasTeamIssues;
        }
      }
      
      // If no specific filter, show all issues
      // Check for team validation issues
      const hasTeamIssues = S.teamValidationIssues?.some(issue => issue.eventIdx === idx) || false;
      if (hasTeamIssues) return true;
      
      // Check for missing required data
      if (!e.type || !e.team || (!e.start_time && !e.time)) return true;
      
      // Check for invalid time range
      if (e.start_time && e.end_time) {
        const parseTime = (t) => {
          if (!t) return null;
          const parts = String(t).split(':');
          if (parts.length !== 2) return null;
          const min = parseInt(parts[0]);
          const sec = parseInt(parts[1]);
          if (isNaN(min) || isNaN(sec)) return null;
          return min * 60 + sec;
        };
        const startSec = parseTime(e.start_time);
        const endSec = parseTime(e.end_time);
        if (startSec !== null && endSec !== null && endSec < startSec) return true;
      }
      
      return false;
    });
  } else if (periodFilter === 'event_type_context') {
    // v23.8: Event type context filter (similar to goals_context)
    const eventType = S.selectedEventTypeContext?.type || null;
    const detail1 = S.selectedEventTypeContext?.detail1 || null;
    
    if (eventType || detail1) {
      // Filter events matching the type/detail1
      const matchingEvents = S.events.filter(e => {
        if (eventType && e.type !== eventType) return false;
        if (detail1 && e.detail1 !== detail1 && e.detail !== detail1) return false;
        return true;
      });
      
      // Show/hide event selector
      const eventTypeSelector = document.getElementById('eventTypeSelector');
      const eventTypeContextContainer = document.getElementById('eventTypeContextContainer');
      if (eventTypeSelector && eventTypeContextContainer && matchingEvents.length > 0) {
        eventTypeContextContainer.style.display = 'block';
        
        // Populate event selector
        if (eventTypeSelector.options.length <= 1) {
          eventTypeSelector.innerHTML = '<option value="">All Events</option>';
          matchingEvents.forEach((evt, idx) => {
            const evtIdx = S.events.indexOf(evt);
            if (evtIdx === -1) return;
            const p1 = (evt.players || []).find(p => p.role === 'event_player_1' || p.role === 'event_team_player_1');
            const p1Name = p1 ? `#${p1.num} ${p1.name || ''}` : '';
            const label = `P${evt.period} ${evt.start_time || ''} - ${evt.type}${p1Name ? ' (' + p1Name + ')' : ''}`;
            eventTypeSelector.innerHTML += `<option value="${evtIdx}">${label}</option>`;
          });
        }
        
        // If a specific event is selected, show only that event with context
        if (S.selectedEventIdxContext !== null && S.selectedEventIdxContext !== undefined) {
          const evtIdx = S.selectedEventIdxContext;
          const evt = S.events[evtIdx];
          if (evt) {
            const eventIndicesToShow = new Set();
            eventIndicesToShow.add(evtIdx);
            
            const before = parseInt(document.getElementById('eventContextBefore')?.value || '10');
            const after = parseInt(document.getElementById('eventContextAfter')?.value || '3');
            
            const startIdx = Math.max(0, evtIdx - before);
            for (let i = startIdx; i < evtIdx; i++) {
              eventIndicesToShow.add(i);
            }
            
            const endIdx = Math.min(S.events.length, evtIdx + 1 + after);
            for (let i = evtIdx + 1; i < endIdx; i++) {
              eventIndicesToShow.add(i);
            }
            
            filteredEvents = Array.from(eventIndicesToShow)
              .sort((a, b) => a - b)
              .map(idx => S.events[idx])
              .filter(Boolean);
          } else {
            filteredEvents = [];
          }
        } else {
          // Show all matching events with their context
          const eventIndicesToShow = new Set();
          const before = parseInt(document.getElementById('eventContextBefore')?.value || '10');
          const after = parseInt(document.getElementById('eventContextAfter')?.value || '3');
          
          matchingEvents.forEach(evt => {
            const evtIdx = S.events.indexOf(evt);
            if (evtIdx === -1) return;
            
            eventIndicesToShow.add(evtIdx);
            
            const startIdx = Math.max(0, evtIdx - before);
            for (let i = startIdx; i < evtIdx; i++) {
              eventIndicesToShow.add(i);
            }
            
            const endIdx = Math.min(S.events.length, evtIdx + 1 + after);
            for (let i = evtIdx + 1; i < endIdx; i++) {
              eventIndicesToShow.add(i);
            }
          });
          
          filteredEvents = Array.from(eventIndicesToShow)
            .sort((a, b) => a - b)
            .map(idx => S.events[idx])
            .filter(Boolean);
        }
      } else {
        filteredEvents = [];
      }
    } else {
      filteredEvents = [];
    }
  } else if (periodFilter === 'xy_highlights') {
    // v23.7: XY/Highlights filter - show events with XY data or highlights
    // v24.0: Check for valid XY items (not just array length - filter out null/invalid items)
    filteredEvents = filteredEvents.filter(e => {
      const hasPuckXY = (e.puckXY || []).some(pt => pt && pt.x !== null && pt.x !== undefined && pt.y !== null && pt.y !== undefined);
      const hasPlayerXY = e.players?.some(p => {
        const playerXY = p.xy || [];
        return playerXY.some(pt => pt && pt.x !== null && pt.x !== undefined && pt.y !== null && pt.y !== undefined);
      });
      const hasXY = hasPuckXY || hasPlayerXY;
      const hasHighlight = e.isHighlight === true || e.videoUrl;
      return hasXY || hasHighlight;
    });
  } else if (periodFilter === 'goals_context') {
    const goals = S.events.filter(e => e.type === 'Goal' && e.detail1 === 'Goal_Scored');
    
    // Show/hide goal selector
    const goalSelectorContainer = document.getElementById('goalSelectorContainer');
    const goalSelector = document.getElementById('goalSelector');
    if (goalSelectorContainer && goalSelector) {
      goalSelectorContainer.style.display = 'block';
      
      // Populate goal selector if empty
      if (goalSelector.options.length <= 1) {
        goalSelector.innerHTML = '<option value="">All Goals</option>';
        goals.forEach((goal, idx) => {
          const goalIdx = S.events.indexOf(goal);
          const scorer = goal.players?.find(p => p.role === 'event_player_1');
          const scorerName = scorer ? `#${scorer.num} ${scorer.name || ''}` : 'Unknown';
          const goalLabel = `Goal #${idx + 1} - P${goal.period} ${goal.start_time || ''} - ${scorerName}`;
          goalSelector.innerHTML += `<option value="${goalIdx}">${goalLabel}</option>`;
        });
      }
      
      // Set selected value if a specific goal is selected
      if (S.selectedGoalIdx !== null && S.selectedGoalIdx !== undefined) {
        goalSelector.value = S.selectedGoalIdx;
      } else {
        goalSelector.value = '';
      }
    }
    
    // If a specific goal is selected, show only that goal with its context
    if (S.selectedGoalIdx !== null && S.selectedGoalIdx !== undefined) {
      const goalIdx = S.selectedGoalIdx;
      const goal = S.events[goalIdx];
      
      if (goal && goal.type === 'Goal' && goal.detail1 === 'Goal_Scored') {
        const eventIndicesToShow = new Set();
        
        // Add the goal itself
        eventIndicesToShow.add(goalIdx);
        
        // Add up to 10 events before the goal
        const startIdx = Math.max(0, goalIdx - 10);
        for (let i = startIdx; i < goalIdx; i++) {
          eventIndicesToShow.add(i);
        }
        
        // Add up to 3 events after the goal
        const endIdx = Math.min(S.events.length, goalIdx + 1 + 3);
        for (let i = goalIdx + 1; i < endIdx; i++) {
          eventIndicesToShow.add(i);
        }
        
        // Convert set to sorted array and get events
        filteredEvents = Array.from(eventIndicesToShow)
          .sort((a, b) => a - b)
          .map(idx => S.events[idx])
          .filter(Boolean);
      } else {
        filteredEvents = [];
      }
    } else {
      // Show all goals with their context
      const eventIndicesToShow = new Set();
      
      goals.forEach(goal => {
        const goalIdx = S.events.indexOf(goal);
        if (goalIdx === -1) return;
        
        // Add the goal itself
        eventIndicesToShow.add(goalIdx);
        
        // Add up to 10 events before the goal
        const startIdx = Math.max(0, goalIdx - 10);
        for (let i = startIdx; i < goalIdx; i++) {
          eventIndicesToShow.add(i);
        }
        
        // Add up to 3 events after the goal
        const endIdx = Math.min(S.events.length, goalIdx + 1 + 3);
        for (let i = goalIdx + 1; i < endIdx; i++) {
          eventIndicesToShow.add(i);
        }
      });
      
      // Convert set to sorted array and get events
      filteredEvents = Array.from(eventIndicesToShow)
        .sort((a, b) => a - b)
        .map(idx => S.events[idx])
        .filter(Boolean);
    }
  } else if (periodFilter === 'chain_pattern' && S.eventChainFilter) {
    // v24.0: Filter by chain pattern
    filteredEvents = filterEventsByChain(S.eventChainFilter);
  } else if (periodFilter && periodFilter !== 'all') {
    // Hide goal selector when not in goals_context mode
    const goalSelectorContainer = document.getElementById('goalSelectorContainer');
    if (goalSelectorContainer) {
      goalSelectorContainer.style.display = 'none';
    }
    S.selectedGoalIdx = null; // Clear selection when switching filters
    filteredEvents = filteredEvents.filter(e => {
      const evtPeriod = String(e.period || '').toLowerCase();
      if (periodFilter === 'ot') {
        return evtPeriod === 'ot' || evtPeriod === '4' || parseInt(evtPeriod) > 3;
      }
      return evtPeriod === periodFilter;
    });
  }
  
  // v20.4: Apply advanced filters
  const f = S.eventFilters || {};
  
  if (f.type) {
    filteredEvents = filteredEvents.filter(e => e.type === f.type);
  }
  if (f.detail1) {
    filteredEvents = filteredEvents.filter(e => (e.detail1 || e.detail) === f.detail1);
  }
  if (f.detail2) {
    filteredEvents = filteredEvents.filter(e => e.detail2 === f.detail2);
  }
  if (f.playDetail1) {
    filteredEvents = filteredEvents.filter(e => {
      const p1 = (e.players || []).find(p => p.role?.startsWith('event') || !p.role?.startsWith('opp'));
      return p1?.playD1 === f.playDetail1;
    });
  }
  if (f.playDetail2) {
    filteredEvents = filteredEvents.filter(e => {
      const p1 = (e.players || []).find(p => p.role?.startsWith('event') || !p.role?.startsWith('opp'));
      return p1?.playD2 === f.playDetail2;
    });
  }
  if (f.team) {
    filteredEvents = filteredEvents.filter(e => e.team === f.team);
  }
  // v23.8: Filter by player search (number or name)
  if (f.playerSearch) {
    const search = f.playerSearch.toLowerCase();
    filteredEvents = filteredEvents.filter(e => {
      // Check if any player in the event matches the search
      return (e.players || []).some(p => {
        const numMatch = String(p.num || '').toLowerCase().includes(search);
        const nameMatch = (p.name || '').toLowerCase().includes(search);
        return numMatch || nameMatch;
      });
    });
  }
  // v23.8: Handle event index filter with "show X before/after" option
  if (f.eventIdx !== null && f.eventIdx !== undefined) {
    const targetIdx = f.eventIdx - 1; // Convert to 0-based index
    const targetEvent = S.events[targetIdx];
    if (targetEvent) {
      const eventsBefore = f.eventsBefore || 0;
      const eventsAfter = f.eventsAfter || 0;
      const startIdx = Math.max(0, targetIdx - eventsBefore);
      const endIdx = Math.min(S.events.length, targetIdx + 1 + eventsAfter); // Include the target event + events after
      filteredEvents = S.events.slice(startIdx, endIdx);
      // Mark the target event for highlighting
      window.highlightEventIdx = targetIdx;
    } else {
      filteredEvents = [];
    }
  }
  if (f.linkedIdx !== null && f.linkedIdx !== undefined) {
    filteredEvents = filteredEvents.filter(e => e.linkedEventIdx !== null && e.linkedEventIdx + 1 === f.linkedIdx);
  }
  if (f.shiftIdx !== null && f.shiftIdx !== undefined) {
    filteredEvents = filteredEvents.filter(e => e.shiftIdx === f.shiftIdx || e.shift_index === f.shiftIdx);
  }
  
  // Debug log
  console.log('  After filters: ' + filteredEvents.length + ' events to display');
  
  body.innerHTML = filteredEvents.map((e) => {
    const i = S.events.indexOf(e); // Get actual index in full array
    
    // v23.7: Mark goals in goals_context filter for visual distinction, and highlight all goals
    const isGoalInContext = periodFilter === 'goals_context' && e.type === 'Goal' && e.detail1 === 'Goal_Scored';
    const isGoal = e.type === 'Goal' && e.detail1 === 'Goal_Scored';
    const goalContextClass = isGoalInContext ? ' goal-context' : '';
    const goalClass = isGoal ? ' event-goal' : '';
    
    // Get event players and opp players
    const evtPlayers = (e.players || []).filter(p => p.role?.startsWith('event') || !p.role?.startsWith('opp'));
    const oppPlayers = (e.players || []).filter(p => p.role?.startsWith('opp'));
    
    const evtPlayerStr = evtPlayers.map(p => p.num).join(',') || '-';
    const oppPlayerStr = oppPlayers.map(p => p.num).join(',') || '-';
    
    // Get primary player info
    const primaryPlayer = evtPlayers[0];
    const primaryPD1 = primaryPlayer?.playD1?.replace('Play-','').replace(/_/g,' ').substring(0,10) || '';
    const primaryPD2 = primaryPlayer?.playD2?.replace('Play-','').replace(/_/g,' ').substring(0,10) || '';
    const primarySuccess = primaryPlayer?.playSuccess || '';
    
    // Other display values
    // v24.0: Check for valid XY items (not just array length - filter out null/invalid items)
    const hasPuckXY = (e.puckXY || []).some(pt => pt && pt.x !== null && pt.x !== undefined && pt.y !== null && pt.y !== undefined);
    const hasPlayerXY = e.players?.some(p => {
      const playerXY = p.xy || [];
      return playerXY.some(pt => pt && pt.x !== null && pt.x !== undefined && pt.y !== null && pt.y !== undefined);
    });
    const hasXY = hasPuckXY || hasPlayerXY;
    const timeDisplay = e.start_time || e.time || '';
    const highlight = e.isHighlight ? '‚≠ê' : '';
      // Display linked index (1-based for display)
      const linked = e.linkedEventIdx !== null && e.linkedEventIdx !== undefined ? e.linkedEventIdx + 1 : '';
    const detail = e.detail1 || e.detail || '';
    const detail2 = e.detail2 || '';
    const zone = e.zone ? e.zone.substring(0,1).toUpperCase() : '';
    const success = e.success === true || e.success === 1 || e.success === 's' || e.success === 'Y' ? '‚úì' : 
                   (e.success === false || e.success === 0 || e.success === 'u' || e.success === 'N' ? '‚úó' : '');
    const team = e.team === 'home' ? 'H' : 'A';
    const shiftIdx = e.shiftIdx || e.shift_index || '';
    
    // v23.7: Calculate running video time and get team name
    const periodNum = e.period === 'OT' ? 4 : parseInt(e.period);
    const runningVideoTime = calculateRunningVideoTime(periodNum, e.start_time || e.time);
    const runningVideoTimeMin = Math.floor(runningVideoTime / 60);
    const runningVideoTimeSec = runningVideoTime % 60;
    const runningVideoTimeDisplay = runningVideoTime > 0 ? `${runningVideoTimeMin}:${String(runningVideoTimeSec).padStart(2, '0')}` : '0:00';
    
    // Get team name
    const teamName = e.team === 'home' ? (S.homeTeam || 'Home') : (S.awayTeam || 'Away');
    const teamNameShort = teamName.length > 12 ? teamName.substring(0, 12) + '...' : teamName;
    
    // Calculate PIM (Penalty In Minutes) for penalty events based on detail1
    let pim = '';
    if (e.type === 'Penalty') {
      const penaltyLengths = S.penaltyLengths || { minor: 2, major: 5, misconduct: 10 };
      const d1 = (e.detail1 || '').toLowerCase();
      // Check for Penalty_Minor, Penalty_Major, Penalty_Misconduct
      if (d1 === 'penalty_minor' || d1.includes('penalty_minor')) {
        pim = penaltyLengths.minor || 2;
      } else if (d1 === 'penalty_major' || d1.includes('penalty_major')) {
        pim = penaltyLengths.major || 5;
      } else if (d1 === 'penalty_misconduct' || d1.includes('penalty_misconduct')) {
        pim = penaltyLengths.misconduct || 10;
      }
      pim = pim ? String(pim) : '';
    }
    
    // v23.7: Collect all issues for this event
    const eventIssues = [];
    
    // Check for team validation issues
    const teamValidationIssues = S.teamValidationIssues?.filter(issue => issue.eventIdx === i) || [];
    teamValidationIssues.forEach(issue => {
      if (issue.issue === 'wrong_team') {
        eventIssues.push({ type: 'player', icon: 'üë§', text: 'Player on wrong team roster' });
      } else if (issue.issue === 'role_team_mismatch') {
        eventIssues.push({ type: 'role', icon: '‚ö†Ô∏è', text: 'Role/team mismatch' });
      }
    });
    
    // Check for missing required data
    if (!e.type) {
      eventIssues.push({ type: 'missing', icon: '‚ùå', text: 'Missing event type' });
    }
    if (!e.team) {
      eventIssues.push({ type: 'missing', icon: '‚ùå', text: 'Missing team' });
    }
    if (!e.start_time && !e.time) {
      eventIssues.push({ type: 'missing', icon: '‚ùå', text: 'Missing start time' });
    }
    
    // Check for invalid time range
    if (e.start_time && e.end_time) {
      const parseTime = (t) => {
        if (!t) return null;
        const parts = String(t).split(':');
        if (parts.length !== 2) return null;
        const min = parseInt(parts[0]);
        const sec = parseInt(parts[1]);
        if (isNaN(min) || isNaN(sec)) return null;
        return min * 60 + sec;
      };
      const startSec = parseTime(e.start_time);
      const endSec = parseTime(e.end_time);
      // Clock counts DOWN (18:00 -> 0:00), so end time should be <= start time
      // Invalid if end > start (e.g., 18:00 start, 18:01 end)
      if (startSec !== null && endSec !== null && endSec > startSec) {
        eventIssues.push({ type: 'time', icon: '‚è∞', text: 'End time after start time (invalid for countdown clock)' });
      }
    }
    
    const hasIssues = eventIssues.length > 0;
    const issueIcons = eventIssues.map(issue => issue.icon).join('');
    const issueTooltips = eventIssues.map(issue => issue.text).join('; ');
    
    // Build title for hover
    const hoverTitle = [
      'Event #' + (i+1),
      'Type: ' + e.type,
      'Detail: ' + detail + (detail2 ? ' / ' + detail2 : ''),
      'Team: ' + e.team,
      'Shift: ' + (shiftIdx || 'none'),
      'Event Players: ' + (evtPlayers.map(p => '#' + p.num + ' ' + p.name).join(', ') || 'none'),
      'Opp Players: ' + (oppPlayers.map(p => '#' + p.num + ' ' + p.name).join(', ') || 'none'),
      primaryPlayer ? 'P1 Play: ' + primaryPD1 + (primaryPD2 ? ' / ' + primaryPD2 : '') + ' ' + primarySuccess : '',
      e.linkedEventIdx != null ? 'Linked to #' + (e.linkedEventIdx + 1) : '',
      hasXY ? 'Has XY: Yes' : '',
      hasIssues ? 'Issues: ' + issueTooltips : '',
      'Click to edit | Ctrl+Click to filter'
    ].filter(Boolean).join('\\n');
    
    // v20.4: Expanded columns - #, Sh, Lnk, Time, T, Type, Detail1, Detail2, Z, S, EvtP, OppP, PD1, PD2, PS, XY, star
    // v23.5: Add batch-selected class and goal review button
    // v23.8: Highlight the target event when showing events before
    // Check if event has team validation warnings
    const hasTeamWarning = S.teamValidationIssues?.some(issue => issue.eventIdx === i) || false;
    const isTargetEvent = window.highlightEventIdx !== undefined && i === window.highlightEventIdx;
    const isBatchSelected = batchSelectMode && selectedEventIds.includes(i);
    const batchClass = isBatchSelected ? ' batch-selected' : '';
    const targetClass = isTargetEvent ? ' event-highlight' : '';
    const warningClass = hasTeamWarning ? ' event-team-warning' : '';
    const warningIcon = hasTeamWarning ? '‚ö†Ô∏è' : '';
    const goalReviewBtn = e.type === 'Goal' ? '<span class="goal-review" onclick="event.stopPropagation();startGoalReview(' + i + ')" title="Review goal sequence">üé¨</span>' : '';
    
    // v23.5: Handle batch select click
    // v23.8: Ctrl+Click to filter to show X events before/after
    // Single click opens edit modal directly
    const clickHandler = batchSelectMode 
      ? 'toggleEventSelection(' + i + ')' 
      : 'editEvent(' + i + ')'; // Direct edit on single click
    const dblClickHandler = S.editingEventInSidePanel 
      ? 'editEvent(' + i + '); closeSidePanelEdit();'
      : 'editEvent(' + i + ')'; // Always use full edit modal, not quick edit
    
    // v23.8: Move buttons (up/down)
    const canMoveUp = i > 0;
    const canMoveDown = i < S.events.length - 1;
    const moveButtons = '<div class="evt-move-btns" onclick="event.stopPropagation();">' +
      '<button onclick="moveEventUp(' + i + ')" ' + (canMoveUp ? '' : 'disabled') + ' title="Move event up">‚ñ≤</button>' +
      '<button onclick="moveEventDown(' + i + ')" ' + (canMoveDown ? '' : 'disabled') + ' title="Move event down">‚ñº</button>' +
      '</div>';
    
    // Calculate adjusted video time display
    const adjustedTimeDisplay = e.adjustedVideoTime && e.adjustedVideoTime !== e.start_time 
      ? 'P' + e.period + ' ' + e.adjustedVideoTime 
      : '';
    const adjustedTimeStyle = adjustedTimeDisplay 
      ? 'color:var(--accent);font-weight:bold;' 
      : 'color:var(--muted);';
    
    // Use data attributes and event delegation for more reliable click handling
    return '<div class="evt-item' + batchClass + targetClass + warningClass + goalContextClass + goalClass + '" data-evt-idx="' + i + '" data-batch-mode="' + (batchSelectMode ? '1' : '0') + '" onclick="handleEventItemClick(event, ' + i + ')" ondblclick="' + dblClickHandler + '" title="' + hoverTitle + (hasTeamWarning ? '\\n‚ö†Ô∏è Has team validation warning - click to edit' : '') + (isGoalInContext ? '\\nüéØ Goal shown with context' : '') + '">' +
      moveButtons +
      '<span class="idx" title="' + (hasIssues ? issueTooltips : '') + '">' + issueIcons + warningIcon + (isGoalInContext ? 'üéØ' : '') + (i+1) + '</span>' +
      '<span class="seq" title="Shift #' + shiftIdx + '">' + shiftIdx + '</span>' +
      '<span class="link" title="Linked Event #' + linked + '">' + linked + '</span>' +
      '<span class="time">P' + e.period + ' ' + timeDisplay + '</span>' +
      '<span class="time" title="Adjusted Video Time" style="' + adjustedTimeStyle + '">' + (adjustedTimeDisplay || '--') + '</span>' +
      '<span class="time" title="Running Video Time: ' + runningVideoTimeDisplay + '" style="color:var(--accent2);font-size:7px;">' + runningVideoTimeDisplay + '</span>' +
      '<span class="team">' + team + '</span>' +
      '<span class="team" title="' + teamName + '" style="font-size:7px;color:var(--muted);">' + teamNameShort + '</span>' +
      '<span class="type">' + e.type + '</span>' +
      '<span class="pim" title="Penalty In Minutes" style="' + (pim ? 'color:var(--danger);font-weight:bold;' : 'color:var(--muted);') + '">' + pim + '</span>' +
      '<span class="detail" title="' + detail + '">' + detail.substring(0,12) + '</span>' +
      '<span class="detail" title="' + detail2 + '">' + detail2.substring(0,12) + '</span>' +
      '<span class="zone">' + zone + '</span>' +
      '<span class="success">' + success + '</span>' +
      '<span class="evtp" title="Event Players: ' + evtPlayers.map(p => p.num + ':' + p.name).join(', ') + '">' + evtPlayerStr + '</span>' +
      '<span class="oppp" title="Opp Players: ' + oppPlayers.map(p => p.num + ':' + p.name).join(', ') + '">' + oppPlayerStr + '</span>' +
      '<span class="pd1" title="' + primaryPD1 + '">' + primaryPD1.substring(0,8) + '</span>' +
      '<span class="pd1" title="' + primaryPD2 + '">' + primaryPD2.substring(0,8) + '</span>' +
      '<span class="psucc">' + primarySuccess + '</span>' +
      '<span class="xy-dot" title="' + (hasXY ? 'Has XY data (puck or players)' : 'No XY data') + '" style="' + (hasXY ? 'color:var(--accent);font-weight:bold;' : 'color:var(--muted);') + '">' + (hasXY?'üìç':'‚óã') + '</span>' +
      '<span class="hl">' + highlight + goalReviewBtn + '</span>' +
      '<button onclick="loadEventToSidePanel(' + i + ');event.stopPropagation();" title="Open in side panel" style="font-size:8px;padding:1px 3px;border:1px solid var(--border);border-radius:2px;background:var(--input);cursor:pointer;">üìù</button>' +
      '<button onclick="editEvent(' + i + ');event.stopPropagation();" title="Open in modal" style="font-size:8px;padding:1px 3px;border:1px solid var(--border);border-radius:2px;background:var(--input);cursor:pointer;">‚úèÔ∏è</button>' +
    '</div>';
  }).join('') || '<div style="color:var(--muted);padding:10px;text-align:center;font-size:10px;">No events to display</div>';
  
  // v23.8: Clear highlight after rendering
  if (window.highlightEventIdx !== undefined) {
    window.highlightEventIdx = undefined;
  }
  
  // Debug log
  console.log('  renderEvents complete. Filtered count:', filteredEvents.length);
  
  // v23.4: Update timeline scrub
  renderTimeline();
}

/**
 * Handle click on event item - more reliable than inline onclick
 */
function handleEventItemClick(event, idx) {
  console.log('handleEventItemClick called for event', idx, 'batchMode:', batchSelectMode);
  
  // Don't propagate if clicking on buttons inside
  if (event.target.closest('.evt-move-btns') || event.target.closest('.goal-review')) {
    return;
  }
  
  // Ctrl+Click (or Cmd+Click on Mac) to filter to show X events before/after
  if (event.ctrlKey || event.metaKey) {
    event.preventDefault();
    event.stopPropagation();
    
    // Get the current filter values for events before/after
    const eventsBefore = parseInt(document.getElementById('filterEventsBefore')?.value || '0') || 0;
    const eventsAfter = parseInt(document.getElementById('filterEventsAfter')?.value || '0') || 0;
    
    // Set the event index filter
    S.eventFilters.eventIdx = idx + 1; // Convert to 1-based for display
    S.eventFilters.eventsBefore = eventsBefore;
    S.eventFilters.eventsAfter = eventsAfter;
    
    // Update the filter input field
    const filterEvtIdxEl = document.getElementById('filterEvtIdx');
    if (filterEvtIdxEl) {
      filterEvtIdxEl.value = idx + 1;
    }
    
    // Apply filters and re-render
    renderEvents();
    
    toast(`Filtered to event #${idx + 1} (${eventsBefore} before, ${eventsAfter} after)`, 'info');
    return;
  }
  
  // Batch select mode
  if (batchSelectMode) {
    toggleEventSelection(idx);
    return;
  }
  
  // Regular click - open edit modal
  console.log('Opening editEvent for', idx);
  editEvent(idx);
}

/**
 * v23.8: Handle event click - Ctrl+Click to filter, regular click to edit
 */
function handleEventClick(event, idx) {
  // Ctrl+Click (or Cmd+Click on Mac) to filter to show X events before/after
  if (event.ctrlKey || event.metaKey) {
    event.preventDefault();
    event.stopPropagation();
    
    // Get the current filter values for events before/after
    const eventsBefore = parseInt(document.getElementById('filterEventsBefore')?.value || '0') || 0;
    const eventsAfter = parseInt(document.getElementById('filterEventsAfter')?.value || '0') || 0;
    
    // Set the event index filter
    S.eventFilters.eventIdx = idx + 1; // Convert to 1-based for display
    S.eventFilters.eventsBefore = eventsBefore;
    S.eventFilters.eventsAfter = eventsAfter;
    
    // Update the filter input field
    const filterEvtIdxEl = document.getElementById('filterEvtIdx');
    if (filterEvtIdxEl) {
      filterEvtIdxEl.value = idx + 1;
    }
    
    // Apply filters and re-render
    renderEvents();
    
    toast(`Filtered to event #${idx + 1} (${eventsBefore} before, ${eventsAfter} after)`, 'info');
  } else {
    // Regular click - use configured mode
    const mode = S.eventClickMode || 'modal';
    
    if (mode === 'xyDrawing') {
      // Enter XY drawing mode for this event
      enterXYDrawingMode(idx);
    } else if (mode === 'sidePanel') {
      // Load event into side panel for editing
      loadEventToSidePanel(idx);
    } else {
      // Default: open edit modal
      editEvent(idx);
    }
  }
}

// Quick inline edit for event
function quickEditEvent(idx) {
  const evt = S.events[idx];
  
  // Build edit options
  const fields = [
    { name: 'Type', key: 'type', value: evt.type },
    { name: 'Detail 1', key: 'detail1', value: evt.detail1 || evt.detail || '' },
    { name: 'Detail 2', key: 'detail2', value: evt.detail2 || '' },
    { name: 'Linked Index', key: 'linkedEventIdx', value: evt.linkedEventIdx || '' },
    { name: 'Zone (Off/Neu/Def)', key: 'zone', value: evt.zone || '' },
    { name: 'Success (Y/N)', key: 'success', value: evt.success === true ? 'Y' : evt.success === false ? 'N' : '' },
    { name: 'Start Time', key: 'start_time', value: evt.start_time || '' },
    { name: 'Highlight (Y/N)', key: 'isHighlight', value: evt.isHighlight ? 'Y' : 'N' },
  ];
  
  const choice = prompt(
    `Quick Edit Event #${idx+1}\nEnter field number to edit:\n` +
    fields.map((f, i) => `${i+1}. ${f.name}: ${f.value}`).join('\n') +
    '\n\n(or 0 to cancel)'
  );
  
  if (!choice || choice === '0') return;
  
  const fieldIdx = parseInt(choice) - 1;
  if (fieldIdx < 0 || fieldIdx >= fields.length) {
    toast('Invalid selection', 'error');
    return;
  }
  
  const field = fields[fieldIdx];
  const newValue = prompt(`${field.name}:`, field.value);
  
  if (newValue !== null) {
    if (field.key === 'linkedEventIdx') {
      const newLinkedIdx = newValue ? parseInt(newValue) : null;
      if (newLinkedIdx !== null) {
        // Propagate the change to all events in the chain
        propagateLinkedIndexChange(evt.idx, newLinkedIdx);
      } else {
        evt.linkedEventIdx = null;
      }
    } else if (field.key === 'success') {
      evt.success = newValue.toUpperCase() === 'Y' ? true : newValue.toUpperCase() === 'N' ? false : null;
    } else if (field.key === 'isHighlight') {
      evt.isHighlight = newValue.toUpperCase() === 'Y';
    } else if (field.key === 'detail1') {
      evt.detail1 = newValue;
      evt.detail = newValue; // Also update legacy field
    } else {
      evt[field.key] = newValue;
    }
    saveGameData();
    renderEvents();
    toast(`Updated ${field.name}`, 'success');
  }
}

/**
 * v23.8: Render net markers for shot location editing
 */
/**
 * v24.0: Render net markers (shot locations)
 */
function renderNetMarkers() {
  const netMarkers = document.getElementById('netMarkers');
  if (!netMarkers) return;
  
  netMarkers.innerHTML = '';
  
  // Get current editing event
  if (S.editingEvtIdx === null || S.editingEvtIdx === undefined) return;
  const evt = S.events[S.editingEvtIdx];
  if (!evt) return;
  
  // Render netXY if present
  if (evt.netXY) {
    // v24.0: Handle both coordinate systems
    // Check if coordinates are in edit net format (0-72, 0-48) or rink net format (center-relative)
    let netX, netY;
    let displayXY = evt.netXY;
    
    // If coordinates are in edit net format (0-72, 0-48), convert to rink net format
    if (evt.netXY.x >= 0 && evt.netXY.x <= 72 && evt.netXY.y >= 0 && evt.netXY.y <= 48) {
      // Edit net format - convert to rink net format
      const rinkNetXY = convertEditNetToRinkNet(evt.netXY);
      displayXY = rinkNetXY;
    }
    
    // Net SVG viewBox is 0 0 100 100, net opening is from x=20-80, y=30-70
    // Center is at (50, 50) = (0, 0) in relative coordinates
    // Convert relative coordinates to SVG coordinates
    netX = 50 + displayXY.x; // x: -30 to +30 maps to 20-80
    netY = 50 - displayXY.y; // y: -20 to +20 maps to 30-70 (inverted)
    
    // Draw marker
    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('cx', netX);
    circle.setAttribute('cy', netY);
    circle.setAttribute('r', '2.5');
    circle.setAttribute('fill', '#ef4444');
    circle.setAttribute('stroke', '#fff');
    circle.setAttribute('stroke-width', '1');
    circle.style.cursor = 'pointer';
    circle.setAttribute('title', `Shot location: (${evt.netXY.x.toFixed(1)}, ${evt.netXY.y.toFixed(1)})`);
    netMarkers.appendChild(circle);
    
    // Draw crosshair lines from center to marker
    const lineX = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    lineX.setAttribute('x1', '50');
    lineX.setAttribute('y1', '50');
    lineX.setAttribute('x2', netX);
    lineX.setAttribute('y2', '50');
    lineX.setAttribute('stroke', '#ef4444');
    lineX.setAttribute('stroke-width', '0.5');
    lineX.setAttribute('opacity', '0.5');
    lineX.setAttribute('stroke-dasharray', '1,1');
    netMarkers.appendChild(lineX);
    
    const lineY = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    lineY.setAttribute('x1', netX);
    lineY.setAttribute('y1', '50');
    lineY.setAttribute('x2', netX);
    lineY.setAttribute('y2', netY);
    lineY.setAttribute('stroke', '#ef4444');
    lineY.setAttribute('stroke-width', '0.5');
    lineY.setAttribute('opacity', '0.5');
    lineY.setAttribute('stroke-dasharray', '1,1');
    netMarkers.appendChild(lineY);
  }
}

/**
 * v24.0: Handle net hover to show coordinates
 */
function handleNetHover(event) {
  const netSvg = document.getElementById('netSvg');
  const tooltip = document.getElementById('netTooltip');
  if (!netSvg || !tooltip) return;
  
  // Get mouse position relative to SVG
  const rect = netSvg.getBoundingClientRect();
  const svgX = ((event.clientX - rect.left) / rect.width) * 100;
  const svgY = ((event.clientY - rect.top) / rect.height) * 100;
  
  // Convert to relative coordinates (center at 50,50 is 0,0)
  // Net opening is from x=20-80, y=30-70
  // Center is at (50, 50)
  const relX = svgX - 50;
  const relY = 50 - svgY; // Invert Y so positive is up
  
  // Only show tooltip if within net opening
  if (svgX >= 20 && svgX <= 80 && svgY >= 30 && svgY <= 70) {
    tooltip.textContent = `(${relX.toFixed(1)}, ${relY.toFixed(1)})`;
    tooltip.style.display = 'block';
    tooltip.style.left = event.clientX - rect.left + 'px';
    tooltip.style.top = (event.clientY - rect.top - 20) + 'px';
    tooltip.style.transform = 'translateX(-50%)';
  } else {
    tooltip.style.display = 'none';
  }
}

/**
 * v24.0: Hide net tooltip
 */
function hideNetTooltip() {
  const tooltip = document.getElementById('netTooltip');
  if (tooltip) tooltip.style.display = 'none';
}

/**
 * v24.0: Handle net click to place shot location
 */
/**
 * v24.0: Convert rink-side net coordinates (center-relative, -30 to +30) to modal edit net coordinates (0-72, 0-48)
 */
function convertRinkNetToEditNet(rinkNetXY) {
  if (!rinkNetXY || rinkNetXY.x == null || rinkNetXY.y == null) return null;
  
  // Rink net: center-relative, x: -30 to +30, y: -20 to +20
  // Edit net: absolute, x: 0-72, y: 0-48
  // Rink net center (50, 50) = (0, 0) in relative = (36, 24) in edit net
  const editX = 36 + (rinkNetXY.x / 30) * 36; // Map -30..+30 to 0..72
  const editY = 24 - (rinkNetXY.y / 20) * 24; // Map -20..+20 to 48..0 (invert)
  
  return { x: Math.max(0, Math.min(72, editX)), y: Math.max(0, Math.min(48, editY)) };
}

/**
 * v24.0: Convert modal edit net coordinates (0-72, 0-48) to rink-side net coordinates (center-relative, -30 to +30)
 */
function convertEditNetToRinkNet(editNetXY) {
  if (!editNetXY || editNetXY.x == null || editNetXY.y == null) return null;
  
  // Edit net: absolute, x: 0-72, y: 0-48
  // Rink net: center-relative, x: -30 to +30, y: -20 to +20
  // Edit net center (36, 24) = rink net center (50, 50) = (0, 0) in relative
  const rinkX = ((editNetXY.x - 36) / 36) * 30; // Map 0..72 to -30..+30
  const rinkY = -((editNetXY.y - 24) / 24) * 20; // Map 48..0 to -20..+20 (invert)
  
  return { x: Math.max(-30, Math.min(30, rinkX)), y: Math.max(-20, Math.min(20, rinkY)) };
}

function handleNetClick(event) {
  event.preventDefault();
  event.stopPropagation();
  
  if (S.editingEvtIdx === null || S.editingEvtIdx === undefined) {
    toast('Please select a Goal or Shot On Net event to edit', 'warning');
    return;
  }
  
  const evt = S.events[S.editingEvtIdx];
  if (!evt) return;
  
  // v24.0: Check if event qualifies for net editing: Goal OR Shot_OnNetSaved OR Shot_OnNetGoal
  const type = evt.type || '';
  const d1 = evt.detail1 || '';
  const d1Lower = (d1 || '').toLowerCase();
  const canEditNet = type === 'Goal' || 
                     d1 === 'Shot_OnNetSaved' ||
                     d1 === 'Shot_OnNetGoal' ||
                     d1Lower === 'shot_onnetsaved' ||
                     d1Lower === 'shot_onnetgoal' ||
                     d1Lower.includes('shot_onnetsaved') ||
                     d1Lower.includes('shot_onnetgoal');
  
  if (!canEditNet) {
    toast('Net editing only available for Goal events or Shot On Net events', 'warning');
    return;
  }
  
  const netSvg = document.getElementById('netSvg');
  if (!netSvg) return;
  
  // Get click position relative to SVG (rink-side net: viewBox 0 0 100 100)
  const rect = netSvg.getBoundingClientRect();
  const svgX = ((event.clientX - rect.left) / rect.width) * 100;
  const svgY = ((event.clientY - rect.top) / rect.height) * 100;
  
  // Net opening is from x=20-80, y=30-70
  // Convert to relative coordinates (center at 50,50 is 0,0)
  const relX = svgX - 50;
  const relY = 50 - svgY; // Invert Y so positive is up
  
  // Only allow clicks within net opening
  if (svgX < 20 || svgX > 80 || svgY < 30 || svgY > 70) {
    toast('Click within the net opening', 'warning');
    return;
  }
  
  // Store relative coordinates (center is 0,0) - rink-side net format
  const rinkNetXY = {
    x: Math.round(relX * 10) / 10,
    y: Math.round(relY * 10) / 10
  };
  
  // Convert to edit net format (0-72, 0-48) for storage
  const editNetXY = convertRinkNetToEditNet(rinkNetXY);
  
  // Store in event (using edit net format for consistency)
  evt.netXY = editNetXY;
  
  // Also update S.curr if editing
  S.curr.netXY = editNetXY;
  
  // Render both nets
  renderNetMarkers();
  renderEditNetMarker(editNetXY);
  document.getElementById('editNetLocation').textContent = getNetLocationName(editNetXY) || '--';
  
  autoSave();
  toast(`Shot location: ${getNetLocationName(editNetXY) || `(${rinkNetXY.x}, ${rinkNetXY.y})`}`, 'success');
}

function renderMarkers() {
  const layer = document.getElementById('markers');
  layer.innerHTML = '';
  const histCnt = parseInt(document.getElementById('xyHistCnt').value) || 5;
  
  // Historical events
  const recent = S.events.slice(-histCnt);
  recent.forEach((evt, ei) => {
    const opacity = 0.2 + (ei / histCnt) * 0.6;
    const extraData = { evtNum: evt.idx, evtType: evt.type };
    if (evt.puckXY?.length) drawPath(evt.puckXY, '#000', '#fff', opacity, layer, null, false, extraData);
    evt.players?.forEach(p => {
      if (p.xy?.length) {
        // v23.8: Use home/away team colors - ensure team is set correctly
        // Fallback: determine team from role if team is missing
        let playerTeam = p.team;
        if (!playerTeam) {
          // Infer team from role or event team
          if (p.role?.startsWith('event')) {
            playerTeam = evt.team || 'home';
          } else if (p.role?.startsWith('opp')) {
            playerTeam = evt.team === 'home' ? 'away' : 'home';
          } else {
            playerTeam = evt.team || 'home';
          }
        }
        const color = playerTeam === 'home' ? S.homeColor : S.awayColor;
        drawPath(p.xy, color, '#fff', opacity, layer, p.num, false, { ...extraData, playerName: p.name, playerNum: p.num });
      }
    });
  });
  
  // Current event
  if (S.curr.puckXY?.length) {
    // Filter out any null/undefined points before drawing
    const validPuckXY = S.curr.puckXY.filter(pt => pt && pt.x !== null && pt.x !== undefined && pt.y !== null && pt.y !== undefined);
    if (validPuckXY.length > 0) {
      drawPath(validPuckXY, '#00d4aa', '#fff', 1, layer, 'üèí', true);
    }
  }
  S.curr.players?.forEach(p => {
    if (p.xy?.length) {
      // v23.9: Filter out any null/undefined points and ensure we only draw this player's path (not connected to other players)
      const validXY = p.xy.filter(pt => pt && pt.x !== null && pt.x !== undefined && pt.y !== null && pt.y !== undefined);
      if (validXY.length > 0) {
        // v23.8: Use home/away team colors - ensure team is set correctly
        // Fallback: determine team from role if team is missing
        let playerTeam = p.team;
        if (!playerTeam) {
          // Infer team from role or event team
          if (p.role?.startsWith('event')) {
            playerTeam = S.evtTeam || 'home';
          } else if (p.role?.startsWith('opp')) {
            playerTeam = S.evtTeam === 'home' ? 'away' : 'home';
          } else {
            playerTeam = S.evtTeam || 'home';
          }
        }
        const color = playerTeam === 'home' ? S.homeColor : S.awayColor;
        const sel = S.selectedPlayer?.num === p.num;
        // v23.9: Draw only this player's path - no connection to other players
        drawPath(validXY, color, sel ? '#fff' : '#000', 1, layer, p.num, true, { playerName: p.name, playerNum: p.num });
      }
    }
  });
}

function drawPath(points, fill, stroke, opacity, layer, label, current, extraData = {}) {
  if (!points?.length) return;
  
  // v23.9: Filter out any invalid points before processing
  const validPoints = points.filter(pt => pt && pt.x !== null && pt.x !== undefined && pt.y !== null && pt.y !== undefined);
  if (validPoints.length === 0) return;
  
  // v16.06: Convert center-relative coords to SVG coords for display
  // Stored: (0,0) = center ice. SVG: (100, 42.5) = center ice
  const toSvg = (pt) => ({
    x: pt.x + 100,
    y: pt.y + 42.5,
    seq: pt.seq,
    origX: pt.x,  // Keep original for tooltip
    origY: pt.y
  });
  
  const sorted = [...validPoints].map(toSvg).sort((a,b) => a.seq - b.seq);
  
  // v23.9: Remove duplicate seq numbers - if we have duplicates, only keep the first one
  // This prevents cross-entity connections when points get mixed up
  const seenSeqs = new Set();
  const deduplicated = sorted.filter(pt => {
    if (seenSeqs.has(pt.seq)) {
      console.warn(`Duplicate seq ${pt.seq} in path for ${label} - removing duplicate`);
      return false;
    }
    seenSeqs.add(pt.seq);
    return true;
  });
  
  // v23.9: Only draw lines between consecutive points in THIS path (no connection to other players/puck)
  for (let i = 0; i < deduplicated.length - 1; i++) {
    // Only draw line if both points are valid and consecutive in sequence
    // CRITICAL: Must be exactly seq+1, no gaps, and both must be valid numbers
    if (deduplicated[i] && deduplicated[i+1] && 
        deduplicated[i+1].seq === deduplicated[i].seq + 1 &&
        typeof deduplicated[i].seq === 'number' && 
        typeof deduplicated[i+1].seq === 'number' &&
        !isNaN(deduplicated[i].seq) && !isNaN(deduplicated[i+1].seq)) {
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', deduplicated[i].x); line.setAttribute('y1', deduplicated[i].y);
      line.setAttribute('x2', deduplicated[i+1].x); line.setAttribute('y2', deduplicated[i+1].y);
      line.setAttribute('stroke', fill); line.setAttribute('stroke-width', current ? 1 : 0.5);
      line.setAttribute('stroke-dasharray', current ? 'none' : '2,1'); line.setAttribute('opacity', opacity * 0.7);
      
      // v23.9: Make lines clickable for current events to insert new points
      if (current) {
        // Create an invisible wider line for easier clicking
        const hitArea = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        hitArea.setAttribute('x1', deduplicated[i].x); hitArea.setAttribute('y1', deduplicated[i].y);
        hitArea.setAttribute('x2', deduplicated[i+1].x); hitArea.setAttribute('y2', deduplicated[i+1].y);
        hitArea.setAttribute('stroke', 'transparent');
        hitArea.setAttribute('stroke-width', 8); // Wide hit area
        hitArea.style.pointerEvents = 'auto';
        hitArea.style.cursor = 'crosshair';
        
        // Store metadata on hit area
        hitArea.dataset.seqStart = deduplicated[i].seq;
        hitArea.dataset.seqEnd = deduplicated[i+1].seq;
        hitArea.dataset.origX1 = deduplicated[i].origX;
        hitArea.dataset.origY1 = deduplicated[i].origY;
        hitArea.dataset.origX2 = deduplicated[i+1].origX;
        hitArea.dataset.origY2 = deduplicated[i+1].origY;
        
        if (label === 'üèí') {
          hitArea.dataset.xyType = 'puck';
        } else if (extraData.playerNum) {
          hitArea.dataset.xyType = 'player';
          hitArea.dataset.playerNum = extraData.playerNum;
        }
        
        // Click handler on hit area
        hitArea.onclick = (e) => {
          e.stopPropagation();
          
          const svg = layer.ownerSVGElement;
          if (!svg) return;
          
          // Get click position in SVG coordinates
          const svgPt = svg.createSVGPoint();
          svgPt.x = e.clientX;
          svgPt.y = e.clientY;
          const clickCoords = svgPt.matrixTransform(svg.getScreenCTM().inverse());
          
          // Convert to center-relative coordinates
          const relX = Math.round((clickCoords.x - 100) * 100) / 100;
          const relY = Math.round((clickCoords.y - 42.5) * 100) / 100;
          
          // Calculate new seq number (insert between seqStart and seqEnd)
          const seqStart = parseInt(hitArea.dataset.seqStart);
          const newSeq = seqStart + 1;
          
          // Insert the new point
          if (hitArea.dataset.xyType === 'puck' && S.curr.puckXY) {
            // Find insertion point and shift subsequent seq numbers
            const insertIdx = S.curr.puckXY.findIndex(p => p.seq > seqStart);
            const newPoint = { x: relX, y: relY, seq: newSeq };
            
            if (insertIdx === -1) {
              // Insert at end
              S.curr.puckXY.push(newPoint);
            } else {
              // Insert before first point with seq > seqStart
              S.curr.puckXY.splice(insertIdx, 0, newPoint);
            }
            
            // Renumber all points with seq >= newSeq
            S.curr.puckXY.forEach(p => {
              if (p.seq >= newSeq && p !== newPoint) {
                p.seq = p.seq + 1;
              }
            });
            
            renderMarkers();
            renderXYSlots();
            toast('New puck XY point added', 'success');
          } else if (hitArea.dataset.xyType === 'player' && hitArea.dataset.playerNum && S.curr.players) {
            const player = S.curr.players.find(p => p.num === parseInt(hitArea.dataset.playerNum));
            if (player && player.xy) {
              // Find insertion point and shift subsequent seq numbers
              const insertIdx = player.xy.findIndex(p => p.seq > seqStart);
              const newPoint = { x: relX, y: relY, seq: newSeq };
              
              if (insertIdx === -1) {
                // Insert at end
                player.xy.push(newPoint);
              } else {
                // Insert before first point with seq > seqStart
                player.xy.splice(insertIdx, 0, newPoint);
              }
              
              // Renumber all points with seq >= newSeq
              player.xy.forEach(p => {
                if (p.seq >= newSeq && p !== newPoint) {
                  p.seq = p.seq + 1;
                }
              });
              
              renderMarkers();
              renderXYSlots();
              toast(`New XY point added for player #${hitArea.dataset.playerNum}`, 'success');
            }
          }
        };
        
        // Add hit area before the visible line so it's on top
        layer.appendChild(hitArea);
        line.style.pointerEvents = 'none'; // Let hit area handle clicks
      } else {
        line.style.pointerEvents = 'none';
      }
      
      layer.appendChild(line);
    }
  }
  
  deduplicated.forEach((pt, i) => {
    const last = i === deduplicated.length - 1;
    // v16.06: Reduced marker size - current last=2.5, current other=1.5, history last=2, history other=1.2
    const r = current ? (last ? 2.5 : 1.5) : (last ? 2 : 1.2);
    
    // v23.9: Check if this point should be highlighted
    const isHighlighted = current && 
      S.highlightedXYSeq === pt.seq &&
      ((label === 'üèí' && S.highlightedXYType === 'puck') ||
       (extraData.playerNum && S.highlightedXYType === 'player' && S.highlightedXYPlayerNum === extraData.playerNum));
    
    const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    c.setAttribute('cx', pt.x); c.setAttribute('cy', pt.y); 
    c.setAttribute('r', isHighlighted ? r * 1.8 : r); // Make highlighted point larger
    c.setAttribute('fill', isHighlighted ? '#ffff00' : fill); // Yellow for highlighted
    c.setAttribute('stroke', isHighlighted ? '#000' : stroke);
    c.setAttribute('stroke-width', isHighlighted ? 1 : (last ? 0.5 : 0.3));
    c.setAttribute('opacity', isHighlighted ? 1 : opacity);
    
    // Add pulsing animation for highlighted point
    if (isHighlighted) {
      c.style.animation = 'pulse 1s ease-in-out infinite';
      c.style.filter = 'drop-shadow(0 0 4px #ffff00)';
    }
    
    // v23.9: Make current event markers draggable, last marker of current players also clickable to select
    if (current) {
      c.style.pointerEvents = 'auto';
      c.style.cursor = 'grab';
      
      // Store drag info in circle element
      c.dataset.draggable = 'true';
      c.dataset.seq = pt.seq;
      if (label === 'üèí') {
        c.dataset.xyType = 'puck';
      } else if (extraData.playerNum) {
        c.dataset.xyType = 'player';
        c.dataset.playerNum = extraData.playerNum;
      }
      
      // Drag handlers - use data attributes to track drag state
      c.onmousedown = (e) => {
        e.stopPropagation();
        c.dataset.dragStart = 'true';
        c.dataset.hasMoved = 'false';
        
        // Prevent text selection during drag
        e.preventDefault();
      };
      
      // Handle drag on SVG (not just circle)
      const svg = layer.ownerSVGElement;
      if (svg) {
        // Only attach listeners once per marker
        if (!c._dragListenersAttached) {
          const handleMouseMove = (e) => {
            if (c.dataset.dragging !== 'true') return;
            
            const svgPt = svg.createSVGPoint();
            svgPt.x = e.clientX;
            svgPt.y = e.clientY;
            const svgCoords = svgPt.matrixTransform(svg.getScreenCTM().inverse());
            
            // Convert SVG coords to center-relative
            const relativeCoords = {
              x: Math.round((svgCoords.x - 100) * 100) / 100,
              y: Math.round((svgCoords.y - 42.5) * 100) / 100
            };
            
            // Update circle position visually
            c.setAttribute('cx', svgCoords.x);
            c.setAttribute('cy', svgCoords.y);
            
            // Update data structure
            const seq = parseInt(c.dataset.seq);
            if (c.dataset.xyType === 'puck' && S.curr.puckXY) {
              const xyPoint = S.curr.puckXY.find(p => p.seq === seq);
              if (xyPoint) {
                xyPoint.x = relativeCoords.x;
                xyPoint.y = relativeCoords.y;
                
                // Propagate to linked events if this is a logged event being edited
                // Note: For current event (S.curr), we'll propagate after logging
              }
            } else if (c.dataset.xyType === 'player' && c.dataset.playerNum && S.curr.players) {
              const player = S.curr.players.find(p => p.num === parseInt(c.dataset.playerNum));
              if (player && player.xy) {
                const xyPoint = player.xy.find(p => p.seq === seq);
                if (xyPoint) {
                  xyPoint.x = relativeCoords.x;
                  xyPoint.y = relativeCoords.y;
                  
                  // Propagate to linked events if this is a logged event being edited
                  // Note: For current event (S.curr), we'll propagate after logging
                }
              }
            }
            
            // Update text label position if it's the last point
            if (last && label) {
              t.setAttribute('x', svgCoords.x);
              t.setAttribute('y', svgCoords.y + 1);
            }
            
            // Update line positions if needed
            if (i > 0) {
              const prevLine = layer.querySelector(`line[data-seq-start="${sorted[i-1].seq}"][data-seq-end="${seq}"]`);
              if (prevLine) {
                prevLine.setAttribute('x2', svgCoords.x);
                prevLine.setAttribute('y2', svgCoords.y);
              }
            }
            if (i < deduplicated.length - 1) {
              const nextLine = layer.querySelector(`line[data-seq-start="${seq}"][data-seq-end="${sorted[i+1].seq}"]`);
              if (nextLine) {
                nextLine.setAttribute('x1', svgCoords.x);
                nextLine.setAttribute('y1', svgCoords.y);
              }
            }
            
            // Re-render XY slots to update display
            renderXYSlots();
          };
          
          const handleMouseUp = (e) => {
            if (c.dataset.dragging === 'true') {
              const hadMoved = c.dataset.hasMoved === 'true';
              c.dataset.dragging = 'false';
              c.dataset.dragStart = 'false';
              c.dataset.hasMoved = 'false';
              c.style.cursor = 'grab';
              document.body.style.cursor = '';
              
              // Propagate XY to linked events if this is a logged event being edited
              if (S.editingEvtIdx !== null && hadMoved) {
                const editedEvt = S.events[S.editingEvtIdx];
                if (editedEvt && editedEvt.linkedEventIdx !== null) {
                  if (c.dataset.xyType === 'puck' && editedEvt.puckXY) {
                    propagateXYToLinkedEvents(editedEvt.idx, 'puck', null, editedEvt.puckXY);
                  } else if (c.dataset.xyType === 'player' && c.dataset.playerNum) {
                    const player = editedEvt.players?.find(p => p.num === parseInt(c.dataset.playerNum));
                    if (player && player.xy) {
                      propagateXYToLinkedEvents(editedEvt.idx, 'player', parseInt(c.dataset.playerNum), player.xy);
                    }
                  }
                }
              }
              
              // Final update - re-render to ensure consistency
              renderMarkers();
              renderXYSlots();
              if (hadMoved) {
                toast('XY position updated', 'success');
              }
            }
          };
          
          // Add listeners to SVG for drag tracking (once per marker)
          svg.addEventListener('mousemove', handleMouseMove);
          svg.addEventListener('mouseup', handleMouseUp);
          svg.addEventListener('mouseleave', handleMouseUp);
          
          c._dragListenersAttached = true;
        }
        
        // Start drag on mousemove (not mousedown) to distinguish from click
        const oneTimeMove = (e) => {
          if (c.dataset.dragStart === 'true' && c.dataset.dragging !== 'true') {
            const moveDistance = Math.abs(e.movementX || 0) + Math.abs(e.movementY || 0);
            if (moveDistance > 2) { // Only start drag if mouse actually moved
              c.dataset.dragging = 'true';
              c.dataset.hasMoved = 'true';
              c.style.cursor = 'grabbing';
              document.body.style.cursor = 'grabbing';
              svg.removeEventListener('mousemove', oneTimeMove);
            }
          }
        };
        
        // Use a one-time mousemove listener to detect drag start
        svg.addEventListener('mousemove', oneTimeMove);
        
        // Clean up one-time listener on mouseup
        const oneTimeUp = () => {
          svg.removeEventListener('mousemove', oneTimeMove);
          svg.removeEventListener('mouseup', oneTimeUp);
          if (c.dataset.dragStart === 'true' && c.dataset.dragging !== 'true') {
            c.dataset.dragStart = 'false';
          }
        };
        svg.addEventListener('mouseup', oneTimeUp);
      }
      
      // Double-click to delete XY point
      let clickTimeout = null;
      let lastClickTime = 0;
      
      c.ondblclick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        // Only delete if not dragging
        if (c.dataset.dragging === 'true') return;
        
        const seq = parseInt(c.dataset.seq);
        if (c.dataset.xyType === 'puck' && S.curr.puckXY) {
          const idx = S.curr.puckXY.findIndex(p => p.seq === seq);
          if (idx !== -1) {
            S.curr.puckXY.splice(idx, 1);
            // Renumber remaining slots
            S.curr.puckXY.forEach((p, i) => { p.seq = i + 1; });
            renderMarkers();
            renderXYSlots();
            toast('Puck XY point deleted', 'success');
          }
        } else if (c.dataset.xyType === 'player' && c.dataset.playerNum && S.curr.players) {
          const player = S.curr.players.find(p => p.num === parseInt(c.dataset.playerNum));
          if (player && player.xy) {
            const idx = player.xy.findIndex(p => p.seq === seq);
            if (idx !== -1) {
              player.xy.splice(idx, 1);
              // Renumber remaining slots
              player.xy.forEach((p, i) => { p.seq = i + 1; });
              renderMarkers();
              renderXYSlots();
              toast(`Player #${c.dataset.playerNum} XY point deleted`, 'success');
            }
          }
        }
        if (clickTimeout) {
          clearTimeout(clickTimeout);
          clickTimeout = null;
        }
      };
      
      // If it's the last marker of a player, also allow click to select
      if (last && extraData.playerNum) {
        c.onclick = (e) => {
          // Don't select if dragging
          if (c.dataset.dragging === 'true') return;
          
          // Handle single click with timeout to distinguish from double-click
          const now = Date.now();
          if (now - lastClickTime < 300) {
            // Double click detected, let ondblclick handle it
            return;
          }
          lastClickTime = now;
          
          if (clickTimeout) {
            clearTimeout(clickTimeout);
          }
          clickTimeout = setTimeout(() => {
            e.stopPropagation();
            selectPlayer(extraData.playerNum);
            toast(`Selected #${extraData.playerNum}`, 'info');
            clickTimeout = null;
          }, 300);
        };
      }
    } else {
      c.style.pointerEvents = 'none';
    }
    
    // Add data attributes for tooltip - use center-relative coords
    c.dataset.x = Math.round(pt.origX * 10) / 10;
    c.dataset.y = Math.round(pt.origY * 10) / 10;
    if (label === 'üèí') {
      c.dataset.type = 'puck';
    } else if (label && !isNaN(parseInt(label))) {
      c.dataset.type = 'player';
      c.dataset.num = label;
      c.dataset.name = extraData.playerName || '';
    } else if (extraData.evtNum) {
      c.dataset.type = 'history';
      c.dataset.evtnum = extraData.evtNum;
      c.dataset.evttype = extraData.evtType || '';
    }
    
    layer.appendChild(c);
    
    if (last && label) {
      const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      t.setAttribute('x', pt.x); t.setAttribute('y', pt.y + 1);
      t.setAttribute('fill', stroke); t.setAttribute('font-size', current ? '3.5' : '3');
      t.setAttribute('font-weight', 'bold'); t.setAttribute('text-anchor', 'middle');
      t.setAttribute('dominant-baseline', 'middle'); t.setAttribute('opacity', opacity);
      t.textContent = label;
      t.style.pointerEvents = 'none'; // Let events pass through to circle
      layer.appendChild(t);
    }
  });
}

/**
 * v23.8: Update scores with optional cutoff index (for time-based stats when viewing shifts/events)
 * @param {number|null} cutoffIdx - Only count events up to this index (inclusive). If null, count all events.
 */
function updateScores(cutoffIdx = null) {
  // Filter events up to cutoff index
  // cutoffIdx is the maximum array index (inclusive) to count
  const eventsToCount = cutoffIdx !== null && cutoffIdx !== undefined
    ? S.events.filter((e, arrayIdx) => arrayIdx <= cutoffIdx)
    : S.events;

  const goals = eventsToCount.filter(e => e.type === 'Goal' && e.detail1?.includes('Scored'));
  document.getElementById('scoreH').textContent = goals.filter(e => e.team === 'home').length;
  document.getElementById('scoreA').textContent = goals.filter(e => e.team === 'away').length;
  updateQuickStats(cutoffIdx); // v5
}

/**
 * v23.8: Update quick stats bar with optional cutoff index
 * @param {number|null} cutoffIdx - Only count events up to this index (inclusive). If null, count all events.
 */
function updateQuickStats(cutoffIdx = null) {
  // Filter events up to cutoff index
  // cutoffIdx is the maximum array index (inclusive) to count
  const eventsToCount = cutoffIdx !== null && cutoffIdx !== undefined
    ? S.events.filter((e, arrayIdx) => arrayIdx <= cutoffIdx)
    : S.events;
  
  // Event & shift counts
  document.getElementById('qsEvents').textContent = eventsToCount.length;
  document.getElementById('qsShifts').textContent = S.shifts.length;
  
  // v16: SOG (shots on goal) - only shots that reached the net or goals
  const isSOG = (e) => {
    const d1 = (e.detail1 || '').toLowerCase();
    return d1.includes('shot_onnetsaved') || d1.includes('shot_onnetgoal') || 
           d1.includes('goal_scored') || d1.includes('goal_shootout') || d1.includes('goal_penaltyshot');
  };
  const homeSOG = eventsToCount.filter(e => isSOG(e) && e.team === 'home').length;
  const awaySOG = eventsToCount.filter(e => isSOG(e) && e.team === 'away').length;
  document.getElementById('qsSOG').textContent = `${homeSOG}-${awaySOG}`;
  
  // Faceoffs
  const faceoffs = eventsToCount.filter(e => e.type === 'Faceoff');
  const homeFO = faceoffs.filter(e => e.team === 'home' && e.success === 's').length;
  const awayFO = faceoffs.filter(e => e.team === 'away' && e.success === 's').length;
  document.getElementById('qsFO').textContent = `${homeFO}-${awayFO}`;
  
  // Penalties
  const penalties = eventsToCount.filter(e => e.type === 'Penalty');
  const homePEN = penalties.filter(e => e.team === 'home').length;
  const awayPEN = penalties.filter(e => e.team === 'away').length;
  document.getElementById('qsPEN').textContent = `${homePEN}-${awayPEN}`;
  
  // Current strength from slots
  const homeCount = ['F1','F2','F3','D1','D2','X'].filter(p => S.slots.home?.[p]?.num).length;
  const awayCount = ['F1','F2','F3','D1','D2','X'].filter(p => S.slots.away?.[p]?.num).length;
  const strength = `${homeCount}v${awayCount}`;
  const strengthEl = document.getElementById('qsStrength');
  strengthEl.textContent = strength;
  strengthEl.className = 'value strength-indicator';
  if (homeCount > awayCount) strengthEl.classList.add('pp');
  else if (homeCount < awayCount) strengthEl.classList.add('pk');
  else strengthEl.classList.add('even');
}

// ============================================================
// SLOTS & ROSTERS
// ============================================================
function selectSlot(el) {
  document.querySelectorAll('.slot').forEach(s => s.classList.remove('selected'));
  el.classList.add('selected');
  S.selectedSlot = { team: el.dataset.team, pos: el.dataset.pos };
}

function assignPlayer(team, num) {
  if (!S.selectedSlot || S.selectedSlot.team !== team) {
    const positions = ['F1','F2','F3','D1','D2','G','X'];
    for (const pos of positions) { if (!S.slots[team][pos]) { S.selectedSlot = { team, pos }; break; } }
  }
  if (!S.selectedSlot) return;
  const p = S.rosters[team].find(x => x.num === num);
  if (!p) return;
  S.slots[team][S.selectedSlot.pos] = p;
  S.selectedSlot = null;
  renderSlots(); renderRosters(); renderQuickAdd();
  onSlotsChanged(); // Update strength
}

function clearSlots(team) {
  Object.keys(S.slots[team]).forEach(pos => S.slots[team][pos] = null);
  renderSlots(); renderRosters(); renderQuickAdd();
  onSlotsChanged(); // Update strength
}

function clearSlot(team, pos) {
  S.slots[team][pos] = null;
  S.selectedSlot = null;
  renderSlots(); renderRosters(); renderQuickAdd();
  onSlotsChanged(); // Update strength
}

// ============================================================
// EVENT ENTRY
// ============================================================
function setEvtTeam(team) {
  const oldTeam = S.evtTeam;
  S.evtTeam = team;
  
  // v23.8: If team changed, clear all players from both event_team and opp_team
  if (oldTeam && oldTeam !== team && S.curr.players && S.curr.players.length > 0) {
    // Clear all players when team is switched
    S.curr.players = [];
    
    // Re-render players
    if (typeof renderCurrentPlayers === 'function') renderCurrentPlayers();
    if (typeof renderQuickAdd === 'function') renderQuickAdd();
    if (typeof renderXYSlots === 'function') renderXYSlots();
    toast('Players cleared - team switched', 'info');
  }
  
  document.querySelectorAll('.team-toggle button.home, .team-toggle button.away').forEach(b => b.classList.remove('active'));
  document.querySelector(`.team-toggle .${team}`).classList.add('active');
  renderQuickAdd();
  updateZoneDisplay();
}

function swapEvtTeam() {
  // Swap the event team
  const newTeam = S.evtTeam === 'home' ? 'away' : 'home';
  
  // Also swap players between event and opp roles
  const evtPlayers = S.curr.players.filter(p => p.role?.startsWith('event'));
  const oppPlayers = S.curr.players.filter(p => p.role?.startsWith('opp'));
  
  // Swap roles - use consistent format event_team_player_N / opp_team_player_N
  evtPlayers.forEach((p, i) => {
    p.role = `opp_team_player_${i + 1}`;
    p.roleNum = i + 1;
  });
  oppPlayers.forEach((p, i) => {
    p.role = `event_team_player_${i + 1}`;
    p.roleNum = i + 1;
  });
  
  // Merge back - new event players first
  S.curr.players = [...oppPlayers, ...evtPlayers];
  
  // Set new team
  setEvtTeam(newTeam);
  renderQuickAdd();
  toast(`Swapped to ${newTeam.toUpperCase()}`, 'info');
}

function setEvtType(type) {
  S.curr.type = type;
  document.querySelectorAll('.evt-btn').forEach(b => b.classList.remove('active'));
  document.querySelector(`.evt-btn[data-type="${type}"]`)?.classList.add('active');

  // v23.8: Auto-populate F1 players for faceoffs
  if (type === 'Faceoff') {
    autoPopulateFaceoffPlayers();
  }

  // v23.3: Auto-link and setup for follow-up events (Shot ‚Üí Save, etc.)
  autoLinkFollowUp(type);

  // v16.06: Use S.eventDetails1 from dim_event_detail if available - use event_detail_code, not name
  let d1Options = [];
  if (S.eventDetails1?.length > 0) {
    // Case-insensitive filtering for event type
    const filtered = S.eventDetails1.filter(e => 
      String(e.eventType || '').toLowerCase() === String(type || '').toLowerCase()
    );
    d1Options = filtered.map(e => e.code || e.name);
    
    // For Penalty type: Validate that Supabase data has proper penalty types
    // If event_detail_name is just "penalty" (generic), it's invalid data
    if (type === 'Penalty') {
      const hasInvalidData = d1Options.length > 0 && 
        d1Options.every(opt => {
          const optLower = opt.toLowerCase();
          // Check if all options are just generic "penalty" without specific types
          return optLower === 'penalty' || 
                 (!optLower.includes('minor') && !optLower.includes('major') && !optLower.includes('misconduct'));
        });
      
      if (hasInvalidData) {
        console.warn('‚ö†Ô∏è Supabase penalty data is invalid - event_detail_name values are generic "penalty" instead of specific types (Penalty_Minor, Penalty_Major, Penalty_Misconduct)');
        console.warn('Falling back to LISTS.details. Please fix dim_event_detail table in Supabase.');
        d1Options = []; // Clear invalid data to trigger fallback
      }
    }
  }
  
  // Fall back to LISTS.details if no Supabase data or invalid/incomplete data
  // For Penalty, we need at least 3 specific types (Minor, Major, Misconduct)
  const needsFallback = d1Options.length === 0 || 
    (type === 'Penalty' && (
      d1Options.length < 3 || 
      !d1Options.some(opt => {
        const optLower = opt.toLowerCase();
        return optLower.includes('minor') || optLower.includes('major') || optLower.includes('misconduct');
      })
    ));
  
  if (needsFallback) {
    const opts = LISTS.details[type] || { d1: [], d2: [] };
    const fallbackOptions = opts.d1 || [];
    if (fallbackOptions.length > 0) {
      d1Options = fallbackOptions;
      if (type === 'Penalty') {
        console.log('Using fallback LISTS.details for Penalty:', fallbackOptions);
      }
    }
  }

  const evtD1El = document.getElementById('evtD1');
  const evtD2El = document.getElementById('evtD2');
  if (evtD1El) {
    evtD1El.innerHTML = '<option value="">--</option>' +
      d1Options.map(o => `<option value="${o}">${o}</option>`).join('');
  }
  if (evtD2El) {
    evtD2El.innerHTML = '<option value="">--</option>';
  }

  // v23.4: Render quick detail buttons
  renderQuickDetails(type, d1Options);

  // Update linked events dropdown based on current type
  updateLinkedEventsDropdown();

  // Apply linked event data if linked
  applyLinkedEventData();

  // Auto-derive zone from position if we have XY
  const zone = calculateZone();
  if (zone) document.getElementById('evtZone').value = zone;

  // Auto-derive strength from slots
  const strength = deriveStrength();
  if (strength) document.getElementById('evtStrength').value = strength;
  
  // v23.3: Auto-populate goalie for Save events
  if (type === 'Save') {
    autoPopulateGoalie();
  }
  
  // v23.8: Auto-detect success when event type changes
  if (autoSuccessEnabled) {
    const success = deriveSuccess();
    if (success) {
      document.getElementById('evtSuccess').value = success;
      autoDetectAllSuccess();
    }
  }
  
  // v23.8: Auto-detect side of puck when zone is set
  autoDetectAllSideOfPuck();
  
  // Check penalty detail dropdowns when type = Penalty
  if (type === 'Penalty') {
    const d1El = document.getElementById('evtD1');
    const d2El = document.getElementById('evtD2');
    console.log('Penalty type selected - Detail 1 options:', d1El ? Array.from(d1El.options).map(o => o.value).filter(v => v) : 'N/A');
    console.log('Penalty type selected - Detail 2 options:', d2El ? Array.from(d2El.options).map(o => o.value).filter(v => v) : 'N/A');
    if (d1El && d1El.options.length <= 1) {
      toast('‚ö†Ô∏è No penalty detail1 options available - check configuration', 'warning');
    }
  }
}

// ============================================================
// v23.4: QUICK DETAIL BUTTONS
// ============================================================

// Most common details by event type for quick buttons
const QUICK_DETAILS = {
  Shot: ['Shot_OnNet', 'Shot_Missed', 'Shot_Blocked', 'Shot_Goal'],
  Goal: ['Goal_Scored', 'Goal_Disallowed'],
  Pass: ['Pass_Completed', 'Pass_Incomplete', 'Pass_Intercepted'],
  Faceoff: ['Faceoff_Won', 'Faceoff_Lost'],
  Turnover: ['Turnover_Giveaway', 'Turnover_Takeaway'],
  Zone_Entry_Exit: ['Zone_Entry', 'Zone_Exit'],
  Save: ['Save_Made', 'Save_Rebound'],
  Possession: ['Possession_Gained', 'Possession_Lost', 'Possession_Cycle'],
  Stoppage: ['Stoppage_Icing', 'Stoppage_Offside', 'Stoppage_GoalieFreeze'],
  Penalty: ['Penalty_Tripping', 'Penalty_Hooking', 'Penalty_Slashing', 'Penalty_Holding']
};

/**
 * Render quick detail buttons for current event type
 */
function renderQuickDetails(type, allOptions) {
  const row = document.getElementById('quickDetailRow');
  if (!row) return;
  
  // Get quick details for this type, or use first 4 from all options
  const quickOptions = QUICK_DETAILS[type] || allOptions.slice(0, 4);
  
  if (quickOptions.length === 0) {
    row.style.display = 'none';
    return;
  }
  
  row.style.display = 'flex';
  row.innerHTML = quickOptions.map(opt => {
    const label = opt.replace(`${type}_`, '').replace(/_/g, ' ');
    const isActive = document.getElementById('evtD1').value === opt;
    return `<button class="btn-sm ${isActive ? 'active' : ''}" onclick="quickSetDetail1('${opt}')" style="font-size:8px;padding:2px 6px;">${label}</button>`;
  }).join('');
}

/**
 * Quick set Detail 1 value
 */
function quickSetDetail1(value) {
  document.getElementById('evtD1').value = value;
  onD1Change();
  
  // Update button states
  document.querySelectorAll('#quickDetailRow button').forEach(btn => {
    btn.classList.remove('active');
  });
  event.target.classList.add('active');
}

/**
 * Set zone via button click
 */
function setZone(zone) {
  document.getElementById('evtZone').value = zone;

  // Update button states
  document.querySelectorAll('.zone-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.zone === zone);
    btn.style.background = btn.dataset.zone === zone ?
      (zone === 'o' ? 'var(--success)' : zone === 'd' ? 'var(--danger)' : 'var(--muted)') : '';
    btn.style.color = btn.dataset.zone === zone ? '#fff' : '';
  });
  
  // v23.8: Auto-detect side of puck when zone changes
  autoDetectAllSideOfPuck();
}

/**
 * Set success via button click
 */
function setSuccess(success) {
  document.getElementById('evtSuccess').value = success;
  
  // Update button states
  document.querySelectorAll('.success-btn').forEach(btn => {
    const isActive = btn.dataset.success === success;
    btn.style.opacity = isActive ? '1' : '0.5';
    btn.style.transform = isActive ? 'scale(1.1)' : 'scale(1)';
  });
  
  // v23.8: Auto-detect success for all players when success is set
  autoDetectAllSuccess();
}

function onD1Change() {
  const type = S.curr.type;
  const d1 = document.getElementById('evtD1').value;
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onD1Change:10491',message:'Function entry',data:{type,d1,eventDetails2Count:S.eventDetails2?.length||0,eventDetails2Exists:!!S.eventDetails2,evtD2ElementExists:!!document.getElementById('evtD2')},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
  // #endregion
  console.log('onD1Change called - type:', type, 'd1:', d1);
  
  // v23.8: Auto-detect success when detail1 changes
  if (autoSuccessEnabled) {
    const success = deriveSuccess();
    if (success) {
      document.getElementById('evtSuccess').value = success;
      autoDetectAllSuccess();
    }
  }
  
  let d2Opts = [];
  
  // If no detail1 selected, clear detail2
  if (!d1 || d1 === '') {
    const evtD2El = document.getElementById('evtD2');
    if (evtD2El) evtD2El.innerHTML = '<option value="">--</option>';
    return;
  }
  
  // Special handling for Penalty - always use LISTS.details
  if (d1.startsWith('Penalty_')) {
    const penaltyOpts = LISTS.details.Penalty || {};
    if (penaltyOpts.d2 && penaltyOpts.d2.length > 0) {
      d2Opts = penaltyOpts.d2;
      console.log('Penalty detail2 options:', d2Opts);
    }
  }
  // v16.08: Use S.eventDetails2 from dim_event_detail_2 - filter by code prefix
  else if (S.eventDetails2?.length > 0) {
    // Determine code prefix based on detail1 value
    let codePrefix = null;
    if (d1.startsWith('Shot_')) codePrefix = 'Shot_';
    else if (d1.startsWith('Pass_')) codePrefix = 'Pass_';
    else if (d1.startsWith('Goal_')) codePrefix = 'Goal_';
    else if (d1.startsWith('Save_')) codePrefix = 'Save_';
    else if (d1.includes('Giveaway')) codePrefix = 'Giveaway_';
    else if (d1.includes('Takeaway')) codePrefix = 'Takeaway_';
    else if (d1.includes('Entry')) codePrefix = 'ZoneEntry_';
    else if (d1.includes('Exit') || d1.includes('Keepin')) codePrefix = 'ZoneExit_';
    else if (d1 === 'Stoppage_Play') codePrefix = 'Stoppage_';
    else if (d1 === 'Play_Offensive') codePrefix = 'PlayOffensive_';
    else if (d1 === 'Play_Defensive') codePrefix = 'PlayDefensive_';
    else if (d1.startsWith('Faceoff_') || (type === 'Faceoff' && (d1.includes('Faceoff') || d1.includes('GameStart')))) codePrefix = 'Faceoff_';
    else if (d1.startsWith('Possession_')) codePrefix = 'Possession_';
    else if (d1.startsWith('Rebound_')) codePrefix = 'Rebound_';
    
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onD1Change:10525',message:'Code prefix determination',data:{d1,codePrefix,eventDetails2Count:S.eventDetails2.length,eventDetails2SampleCodes:S.eventDetails2.slice(0,5).map(e=>({code:e.code,name:e.name}))},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
    // #endregion
    if (codePrefix) {
      d2Opts = S.eventDetails2
        .filter(e => e.code && e.code.startsWith(codePrefix))
        .map(e => e.code || e.name); // Use code, fallback to name
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onD1Change:10542',message:'After Supabase filter',data:{codePrefix,d2OptsCount:d2Opts.length,d2Opts},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
      // #endregion
      console.log('Detail2 filter from Supabase:', codePrefix, '‚Üí', d2Opts.length, 'options', d2Opts);
    } else {
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onD1Change:10547',message:'No code prefix matched',data:{d1},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
      // #endregion
      console.log('No code prefix matched for d1:', d1);
    }
  }
  
  // v23.9: Fall back to LISTS.details - also merge with Supabase for giveaway types to ensure all options
  const opts = LISTS.details[type] || {};
  
  // For giveaway types, always merge fallback options to ensure all types are available
  if ((d1.includes('Giveaway') || d1 === 'Turnover_Giveaway') && opts.d2_Giveaway) {
    const fallbackOpts = opts.d2_Giveaway || [];
    fallbackOpts.forEach(opt => {
      if (!d2Opts.includes(opt)) d2Opts.push(opt);
    });
  }
  
  // If no Supabase results at all, use fallback
  if (d2Opts.length === 0) {
    d2Opts = opts.d2 || [];
    if (d1.includes('Takeaway') && opts.d2_Takeaway) d2Opts = opts.d2_Takeaway;
    else if (d1.includes('Entry') && opts.d2_Entry) d2Opts = opts.d2_Entry;
    else if (d1.includes('Exit') && opts.d2_Exit) d2Opts = opts.d2_Exit;
    else if (d1.includes('Play') && opts.d2_Play) d2Opts = opts.d2_Play;
    else if (d1.includes('Offensive') && opts.d2_Offensive) d2Opts = opts.d2_Offensive;
    else if (d1.includes('Defensive') && opts.d2_Defensive) d2Opts = opts.d2_Defensive;
    else if (d1.includes('Keepin') && opts.d2_Exit) d2Opts = opts.d2_Exit;
    
    if (d2Opts.length > 0) {
      console.log('Using fallback LISTS.details for detail2:', d2Opts.length, 'options', d2Opts);
    } else {
      console.log('No detail2 options found for type:', type, 'd1:', d1);
    }
  }
  
  const d2Html = '<option value="">--</option>' + d2Opts.map(o => `<option value="${o}">${o}</option>`).join('');
  const evtD2El = document.getElementById('evtD2');
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onD1Change:10571',message:'Before setting evtD2 innerHTML',data:{d2OptsCount:d2Opts.length,evtD2ElementExists:!!evtD2El,d2HtmlLength:d2Html.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
  // #endregion
  if (evtD2El) {
    evtD2El.innerHTML = d2Html;
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onD1Change:10572',message:'After setting evtD2 innerHTML',data:{d2OptsCount:d2Opts.length,evtD2OptionsCount:evtD2El.options.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
    // #endregion
  } else {
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onD1Change:10572',message:'evtD2 element not found',data:{d2OptsCount:d2Opts.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
    // #endregion
  }
  console.log('Detail2 dropdown populated with', d2Opts.length, 'options');
  
  // Auto-derive success
  const success = deriveSuccess();
  if (success) document.getElementById('evtSuccess').value = success;
  
  // v23.3: Check if this is a shot on net or goal - prompt for net location
  const needsNetLocation = (type === 'Shot' && (d1.includes('OnNet') || d1.includes('Goal'))) || 
                           type === 'Goal' || 
                           (d1 && d1.includes('Goal_Scored'));
  if (needsNetLocation) {
    setTimeout(() => document.getElementById('netModal').classList.add('show'), 100);
    // v23.3: Auto-add opposing goalie for shots on net
    autoPopulateGoalie();
  }
}

function togglePlayer(num, role) {
  const team = role === 'evt' ? S.evtTeam : (S.evtTeam === 'home' ? 'away' : 'home');
  const p = S.rosters[team]?.find(x => x.num === num);
  
  // v23.3: Guard - can't add player from wrong team
  if (!p) {
    // Check if player is from opposite team
    const otherTeam = team === 'home' ? 'away' : 'home';
    const otherPlayer = S.rosters[otherTeam]?.find(x => x.num === num);
    if (otherPlayer) {
      toast(`#${num} is on ${otherTeam} team - use ${role === 'evt' ? 'Opp' : 'Event'} side`, 'warning');
    }
    return;
  }
  
  // v23.3: Guard - check if adding this player would create mixed teams in event/opp
  const existingEvtPlayers = S.curr.players.filter(x => x.role?.startsWith('event'));
  const existingOppPlayers = S.curr.players.filter(x => x.role?.startsWith('opp'));
  
  if (role === 'evt' && existingEvtPlayers.length > 0) {
    const existingTeam = existingEvtPlayers[0].team;
    if (existingTeam !== team) {
      toast(`Event players must all be from same team (${existingTeam})`, 'error');
      return;
    }
  }
  if (role === 'opp' && existingOppPlayers.length > 0) {
    const existingTeam = existingOppPlayers[0].team;
    if (existingTeam !== team) {
      toast(`Opp players must all be from same team (${existingTeam})`, 'error');
      return;
    }
  }
  
  const existingIdx = S.curr.players.findIndex(x => x.num === num);
  if (existingIdx >= 0) {
    S.curr.players.splice(existingIdx, 1);
    if (S.selectedPlayer?.num === num) S.selectedPlayer = null;
  } else {
    const roleNum = S.curr.players.filter(x => x.role?.startsWith(role === 'evt' ? 'event' : 'opp')).length + 1;
    S.curr.players.push({
      ...p, 
      team: team, // v23.8: Explicitly set team to ensure correct colors
      role: `${role === 'evt' ? 'event' : 'opp'}_team_player_${roleNum}`,
      roleNum, xy: [], playD1: '', playD2: '', playSuccess: '', pressure: '', sideOfPuck: ''
    });
  }
  renumberPlayers();
  
  // v23.8: Auto-detect all settings when players are added
  autoDetectAllPressure();
  autoDetectAllSuccess();
  autoDetectAllSideOfPuck();
  
  renderQuickAdd(); renderMarkers();
}

function removePlayer(num) {
  S.curr.players = S.curr.players.filter(p => p.num !== num);
  if (S.selectedPlayer?.num === num) S.selectedPlayer = null;
  renumberPlayers();
  renderQuickAdd(); renderMarkers();
}

function renumberPlayers() {
  let evtN = 1, oppN = 1;
  S.curr.players.forEach(p => {
    if (p.role?.startsWith('event')) { p.role = `event_team_player_${evtN}`; p.roleNum = evtN++; }
    else { p.role = `opp_team_player_${oppN}`; p.roleNum = oppN++; }
  });
}

// ============================================================
// PLAYER CHIP DRAG AND DROP
// ============================================================
let draggedPlayer = null;

function handlePlayerDragStart(e) {
  const chip = e.target.closest('.player-chip');
  if (!chip) return;
  
  draggedPlayer = {
    num: chip.dataset.num,
    role: chip.dataset.role,
    idx: parseInt(chip.dataset.idx)
  };
  chip.classList.add('dragging');
  e.dataTransfer.effectAllowed = 'move';
  e.dataTransfer.setData('text/plain', JSON.stringify(draggedPlayer));
}

function handlePlayerDragEnd(e) {
  const chip = e.target.closest('.player-chip');
  if (chip) chip.classList.remove('dragging');
  document.querySelectorAll('.player-chip').forEach(c => c.classList.remove('drag-over'));
  document.querySelectorAll('.player-list').forEach(l => l.classList.remove('drag-target'));
  draggedPlayer = null;
}

function handlePlayerDragOver(e) {
  e.preventDefault();
  if (!draggedPlayer) return;
  
  const chip = e.target.closest('.player-chip');
  if (chip && chip.dataset.num !== draggedPlayer.num) {
    chip.classList.add('drag-over');
  }
  
  // Also highlight the player list container for cross-list drops
  const list = e.target.closest('.player-list');
  if (list) list.classList.add('drag-target');
  
  e.dataTransfer.dropEffect = 'move';
}

function handlePlayerDrop(e) {
  e.preventDefault();
  const chip = e.target.closest('.player-chip');
  
  document.querySelectorAll('.player-chip').forEach(c => c.classList.remove('drag-over'));
  document.querySelectorAll('.player-list').forEach(l => l.classList.remove('drag-target'));
  
  if (!draggedPlayer) return;
  
  const sourceNum = draggedPlayer.num;
  const sourceRole = draggedPlayer.role; // 'evt' or 'opp'
  
  // Find the source player
  const sourcePlayer = S.curr.players.find(p => p.num === sourceNum);
  if (!sourcePlayer) return;
  
  // Determine target role from drop location
  let targetRole = sourceRole;
  const list = e.target.closest('.player-list');
  if (list) {
    if (list.id === 'evtPlayers') targetRole = 'evt';
    else if (list.id === 'oppPlayers') targetRole = 'opp';
  }
  
  // If dropping on another chip in the SAME list, swap positions
  if (chip && chip.dataset.num !== sourceNum) {
    const targetNum = chip.dataset.num;
    const targetPlayer = S.curr.players.find(p => p.num === targetNum);
    const targetChipRole = chip.dataset.role;
    
    if (targetPlayer && sourceRole === targetChipRole) {
      // Same list - just swap positions
      const sourceIdx = S.curr.players.indexOf(sourcePlayer);
      const targetIdx = S.curr.players.indexOf(targetPlayer);
      S.curr.players[sourceIdx] = targetPlayer;
      S.curr.players[targetIdx] = sourcePlayer;
      renumberPlayers();
      renderQuickAdd();
      renderMarkers();
      toast('Swapped player positions', 'info');
      return;
    }
  }
  
  // v23.3: If dropping on opposite list (not on a chip), swap ALL players and team
  if (sourceRole !== targetRole) {
    // Swap ALL players: event becomes opp, opp becomes event
    S.curr.players.forEach(p => {
      if (p.role?.startsWith('event')) {
        p.role = p.role.replace('event', 'opp');
      } else if (p.role?.startsWith('opp')) {
        p.role = p.role.replace('opp', 'event');
      }
    });
    
    // Swap event team
    const newTeam = S.evtTeam === 'home' ? 'away' : 'home';
    setEvtTeam(newTeam);
    
    renumberPlayers();
    renderQuickAdd();
    renderMarkers();
    toast(`Swapped Event‚ÜîOpp (${S.homeTeam || 'Home'} is now ${newTeam === 'home' ? 'Event' : 'Opp'})`, 'success');
  }
}

function handleListDragOver(e) {
  e.preventDefault();
  if (!draggedPlayer) return;
  e.currentTarget.classList.add('drag-target');
  e.dataTransfer.dropEffect = 'move';
}

function handleListDragLeave(e) {
  e.currentTarget.classList.remove('drag-target');
}

function handleListDrop(e, targetRole) {
  e.preventDefault();
  e.currentTarget.classList.remove('drag-target');
  
  if (!draggedPlayer) return;
  
  // Check if we dropped directly on a chip (handled by chip handler)
  if (e.target.closest('.player-chip')) return;
  
  const sourceNum = draggedPlayer.num;
  const sourceRole = draggedPlayer.role;
  
  // Find the source player
  const sourcePlayer = S.curr.players.find(p => p.num === sourceNum);
  if (!sourcePlayer) return;
  
  // v23.3: When dragging to opposite list, swap ALL players and the event team
  if (sourceRole !== targetRole) {
    // Swap ALL players: event becomes opp, opp becomes event
    S.curr.players.forEach(p => {
      if (p.role?.startsWith('event')) {
        p.role = p.role.replace('event', 'opp');
      } else if (p.role?.startsWith('opp')) {
        p.role = p.role.replace('opp', 'event');
      }
    });
    
    // Swap event team
    const newTeam = S.evtTeam === 'home' ? 'away' : 'home';
    setEvtTeam(newTeam);
    
    renumberPlayers();
    renderQuickAdd();
    renderMarkers();
    toast(`Swapped Event‚ÜîOpp (now ${S.homeTeam || 'Home'} is ${newTeam === 'home' ? 'Event' : 'Opp'})`, 'success');
  }
}

function selectPlayer(num) {
  S.selectedPlayer = S.curr.players.find(p => p.num === num) || null;
  if (S.selectedPlayer && S.xyMode !== 'player') setXYMode('player');
  // Clear highlighting when selecting a different player
  if (S.highlightedXYPlayerNum !== num) {
    S.highlightedXYSeq = null;
    S.highlightedXYType = null;
    S.highlightedXYPlayerNum = null;
  }
  renderQuickAdd(); renderXYSlots(); renderMarkers();
}

function updatePlayerDetail(field, val) {
  if (!S.selectedPlayer) return;
  S.selectedPlayer[field] = val;
  renderQuickAdd();
}

// ============================================================
// XY HANDLING
// ============================================================
function setXYMode(mode) {
  S.xyMode = mode;
  document.getElementById('puckModeBtn').classList.toggle('active', mode === 'puck');
  document.getElementById('playerModeBtn').classList.toggle('active', mode === 'player');
  document.getElementById('modeInd').textContent = mode === 'puck' ? 'üèí PUCK' : 'üë§ PLAYER';
  document.getElementById('modeInd').className = 'mode-ind ' + mode;
  S.xySlot = 1;
  // Clear highlighting when switching modes
  S.highlightedXYSeq = null;
  S.highlightedXYType = null;
  S.highlightedXYPlayerNum = null;
  renderXYSlots(); renderQuickAdd(); renderMarkers();
}

function setXYSlot(n) {
  S.xySlot = n;
  highlightXYPoint(n); // Highlight the point when slot is selected
  renderXYSlots();
}

function selectXYPlayer(num) {
  if (!num || num === '') {
    // User selected puck option - switch to puck mode
    S.selectedPlayer = null;
    setXYMode('puck');
    S.xySlot = (S.curr.puckXY?.filter(Boolean).length || 0) + 1;
    if (S.xySlot > 6) S.xySlot = 1;
    renderXYSlots(); renderQuickAdd();
    return;
  }
  
  S.selectedPlayer = S.curr.players.find(p => p.num == num) || null;
  
  if (S.selectedPlayer) {
    // Only switch to player mode if we actually found the player
    setXYMode('player');
    // v23.9: Always start at slot 1 when selecting a player for XY editing
    S.xySlot = 1;
    toast(`#${num} selected - click rink to place (slot 1)`, 'info');
  } else {
    S.xySlot = 1;
  }
  
  renderXYSlots(); renderQuickAdd();
}

/**
 * Cycle through players in XY dropdown (next or previous)
 * @param {number} direction - 1 for next, -1 for previous
 */
function cycleXYPlayer(direction) {
  if (S.curr.players.length === 0) return;
  
  const currentIdx = S.selectedPlayer 
    ? S.curr.players.findIndex(p => p.num === S.selectedPlayer.num)
    : -1;
  
  let nextIdx;
  if (currentIdx === -1) {
    // No player selected - start at first or last
    nextIdx = direction > 0 ? 0 : S.curr.players.length - 1;
  } else {
    // Cycle through players
    nextIdx = currentIdx + direction;
    if (nextIdx < 0) nextIdx = S.curr.players.length - 1;
    if (nextIdx >= S.curr.players.length) nextIdx = 0;
  }
  
  const nextPlayer = S.curr.players[nextIdx];
  if (nextPlayer) {
    selectXYPlayer(nextPlayer.num);
  }
}

// ============================================================
// v23.4: DRAG FOR PASSES/SHOTS
// ============================================================
let dragStartXY = null;
let isDragging = false;
let isPanning = false;
let panStartX = 0;
let panStartY = 0;
let panStartPanX = 0;
let panStartPanY = 0;

function handleRinkMouseDown(event) {
  // Don't allow panning if zoom is locked
  if (S.rinkZoomLocked && (event.shiftKey || event.button === 1)) {
    return;
  }
  const svg = document.getElementById('rinkSvg');
  if (!svg) return;
  
  const pt = svg.createSVGPoint();
  pt.x = event.clientX; pt.y = event.clientY;
  const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
  
  // v23.8: Check bounds - only allow clicks within rink area (0-200 x, 0-85 y)
  if (svgPt.x < 0 || svgPt.x > 200 || svgPt.y < 0 || svgPt.y > 85) {
    // Click is outside rink bounds, ignore
    return;
  }
  
  const relX = Math.round((svgPt.x - 100) * 100) / 100;
  const relY = Math.round((svgPt.y - 42.5) * 100) / 100;
  
  // Middle mouse button or Shift+Click for panning
  if (event.button === 1 || (event.button === 0 && event.shiftKey)) {
    event.preventDefault();
    isPanning = true;
    panStartX = event.clientX;
    panStartY = event.clientY;
    panStartPanX = S.rinkPanX || 0;
    panStartPanY = S.rinkPanY || 0;
    svg.classList.add('panning');
    return;
  }
  
  dragStartXY = { x: relX, y: relY, svgX: svgPt.x, svgY: svgPt.y };
  isDragging = false;
}

function handleRinkMouseMove(event) {
  // Handle panning
  if (isPanning && S.rinkZoomLocked) {
    // Stop panning if zoom gets locked during pan
    isPanning = false;
    const svg = document.getElementById('rinkSvg');
    if (svg) svg.classList.remove('panning');
    return;
  }
  if (isPanning) {
    const svg = document.getElementById('rinkSvg');
    if (!svg) return;
    
    const zoom = S.rinkZoom || 1.0;
    const deltaX = (event.clientX - panStartX) / zoom;
    const deltaY = (event.clientY - panStartY) / zoom;
    
    S.rinkPanX = panStartPanX - deltaX;
    S.rinkPanY = panStartPanY - deltaY;
    updateRinkViewBox();
    return;
  }
  
  if (!dragStartXY) return;
  
  const svg = document.getElementById('rinkSvg');
  const pt = svg.createSVGPoint();
  pt.x = event.clientX; pt.y = event.clientY;
  const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
  
  const dist = Math.sqrt(Math.pow(svgPt.x - dragStartXY.svgX, 2) + Math.pow(svgPt.y - dragStartXY.svgY, 2));
  
  // If moved more than 10px, we're dragging
  if (dist > 10) {
    isDragging = true;
    // Show drag preview line
    showDragPreview(dragStartXY, svgPt);
  }
}

function handleRinkMouseUp(event) {
  // Handle panning end
  if (isPanning) {
    isPanning = false;
    const svg = document.getElementById('rinkSvg');
    if (svg) svg.classList.remove('panning');
    return;
  }
  
  if (!dragStartXY) return;
  
  const svg = document.getElementById('rinkSvg');
  if (!svg) return;
  
  const pt = svg.createSVGPoint();
  pt.x = event.clientX; pt.y = event.clientY;
  const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
  
  // v23.8: Check bounds - only allow clicks within rink area (0-200 x, 0-85 y)
  if (svgPt.x < 0 || svgPt.x > 200 || svgPt.y < 0 || svgPt.y > 85) {
    // Click is outside rink bounds, ignore
    dragStartXY = null;
    isDragging = false;
    hideDragPreview();
    return;
  }
  
  const relX = Math.round((svgPt.x - 100) * 100) / 100;
  const relY = Math.round((svgPt.y - 42.5) * 100) / 100;
  
  hideDragPreview();
  
  // v23.9: If in XY drawing mode for an event, save XY directly
  if (S.editingEvtIdx !== null && S.editingEvtIdx !== undefined && !S.editingEventInSidePanel) {
    const evt = S.events[S.editingEvtIdx];
    if (evt) {
      if (isDragging) {
        // For drags, add both start and end points
        const startXY = { x: dragStartXY.x, y: dragStartXY.y, seq: (S.curr.puckXY.length + 1) };
        const endXY = { x: relX, y: relY, seq: (S.curr.puckXY.length + 2) };
        if (S.xyMode === 'puck') {
          S.curr.puckXY.push(startXY, endXY);
          evt.puckXY = [...S.curr.puckXY];
        }
        renderMarkers();
        toast(`XY path added to event #${S.editingEvtIdx + 1}`, 'info');
      } else {
        // Regular click
        const xy = { x: dragStartXY.x, y: dragStartXY.y, seq: (S.curr.puckXY.length + 1) };
        if (S.xyMode === 'puck') {
          S.curr.puckXY.push(xy);
          evt.puckXY = [...S.curr.puckXY];
        } else if (S.selectedPlayer) {
          S.selectedPlayer.xy = S.selectedPlayer.xy || [];
          S.selectedPlayer.xy.push(xy);
          const playerIdx = S.curr.players.findIndex(p => p.num === S.selectedPlayer.num);
          if (playerIdx >= 0) {
            evt.players[playerIdx] = {...S.curr.players[playerIdx], xy: [...S.selectedPlayer.xy]};
          }
        }
        renderMarkers();
        toast(`XY added to event #${S.editingEvtIdx + 1}`, 'info');
      }
      dragStartXY = null;
      isDragging = false;
      return;
    }
  }
  
  if (isDragging) {
    // Handle drag as pass or shot
    handleDragEvent(dragStartXY, { x: relX, y: relY, svgX: svgPt.x, svgY: svgPt.y });
  } else {
    // Regular click - use existing handler
    handleRinkClickInternal(event, dragStartXY.x, dragStartXY.y, dragStartXY.svgX, dragStartXY.svgY);
  }
  
  dragStartXY = null;
  isDragging = false;
}

/**
 * Show drag preview line on rink
 */
function showDragPreview(start, end) {
  let preview = document.getElementById('dragPreviewLine');
  if (!preview) {
    const svg = document.getElementById('rinkSvg');
    preview = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    preview.id = 'dragPreviewLine';
    preview.setAttribute('stroke', '#00d4aa');
    preview.setAttribute('stroke-width', '2');
    preview.setAttribute('stroke-dasharray', '5,5');
    preview.setAttribute('pointer-events', 'none');
    svg.appendChild(preview);
  }
  preview.setAttribute('x1', start.svgX);
  preview.setAttribute('y1', start.svgY);
  preview.setAttribute('x2', end.x);
  preview.setAttribute('y2', end.y);
  preview.style.display = 'block';
}

function hideDragPreview() {
  const preview = document.getElementById('dragPreviewLine');
  if (preview) preview.style.display = 'none';
}

/**
 * Handle drag as pass or shot based on direction and end location
 */
function handleDragEvent(start, end) {
  // Determine if drag ends near net (shot) or not (pass)
  const isTowardNet = end.svgX > 170 || end.svgX < 30; // Near either net
  const zone = getZoneFromClick(start.svgX);
  
  // Set puck XY to start and end points
  S.curr.puckXY = [
    { x: start.x, y: start.y, seq: 1 },
    { x: end.x, y: end.y, seq: 2 }
  ];
  
  if (isTowardNet && zone === 'o') {
    // Shot toward net
    if (!S.curr.type) setEvtType('Shot');
    document.getElementById('evtZone').value = 'o';
    
    // Set net location if we have it
    if (end.svgX > 170) {
      S.curr.netXY = { x: end.x, y: end.y };
    }
    
    // Auto-link: E1 at start (shooter position)
    const e1 = S.curr.players.find(p => p.role === 'event_team_player_1');
    if (e1) e1.xy = [{ x: start.x, y: start.y, seq: 1 }];
    
    toast('Shot created from drag', 'success');
  } else {
    // Pass
    if (!S.curr.type) setEvtType('Pass');
    document.getElementById('evtZone').value = zone || 'n';
    
    // Auto-link: E1 at start (passer), E2 at end (receiver)
    const e1 = S.curr.players.find(p => p.role === 'event_team_player_1');
    const e2 = S.curr.players.find(p => p.role === 'event_team_player_2');
    if (e1) e1.xy = [{ x: start.x, y: start.y, seq: 1 }];
    if (e2) e2.xy = [{ x: end.x, y: end.y, seq: 1 }];
    
    toast('Pass created from drag', 'success');
  }
  
  S.xySlot = 3;
  renderXYSlots(); renderMarkers(); updateZoneDisplay(); renderQuickAdd();
}

// ============================================================
// v23.4: KEYBOARD MODIFIERS FOR XY PLACEMENT
// ============================================================
let xyKeyModifier = null; // null, 1, 2, 3... for which player

document.addEventListener('keydown', (e) => {
  // Number keys 1-6 while on rink = assign to that player slot
  if (e.key >= '1' && e.key <= '6' && !e.ctrlKey && !e.altKey) {
    const activeEl = document.activeElement;
    if (activeEl.tagName !== 'INPUT' && activeEl.tagName !== 'SELECT' && activeEl.tagName !== 'TEXTAREA') {
      xyKeyModifier = parseInt(e.key);
    }
  }
});

document.addEventListener('keyup', (e) => {
  if (e.key >= '1' && e.key <= '6') {
    xyKeyModifier = null;
  }
});

function handleRinkClick(event) {
  const svg = document.getElementById('rinkSvg');
  if (!svg) return;
  
  // Calculate SVG coordinates
  const pt = svg.createSVGPoint();
  pt.x = event.clientX;
  pt.y = event.clientY;
  const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
  
  // v23.8: Check bounds - only allow clicks within rink area (0-200 x, 0-85 y)
  if (svgPt.x < 0 || svgPt.x > 200 || svgPt.y < 0 || svgPt.y > 85) {
    // Click is outside rink bounds, ignore
    return;
  }
  
  // v23.9: If in XY drawing mode for an event, calculate coordinates and save XY directly
  if (S.editingEvtIdx !== null && S.editingEvtIdx !== undefined && !S.editingEventInSidePanel) {
    const evt = S.events[S.editingEvtIdx];
    if (evt) {
      const relX = Math.round((svgPt.x - 100) * 100) / 100;
      const relY = Math.round((svgPt.y - 42.5) * 100) / 100;
      
      const xy = { x: relX, y: relY, seq: (S.curr.puckXY.length + 1) };
      if (S.xyMode === 'puck') {
        S.curr.puckXY.push(xy);
        evt.puckXY = [...S.curr.puckXY];
      } else if (S.selectedPlayer) {
        S.selectedPlayer.xy = S.selectedPlayer.xy || [];
        S.selectedPlayer.xy.push(xy);
        const playerIdx = S.curr.players.findIndex(p => p.num === S.selectedPlayer.num);
        if (playerIdx >= 0) {
          evt.players[playerIdx] = {...S.curr.players[playerIdx], xy: [...S.selectedPlayer.xy]};
        }
      }
      renderMarkers();
      toast(`XY added to event #${S.editingEvtIdx + 1}`, 'info');
      return;
    }
  }
  
  // Normal rink click behavior
  // Delegate to mousedown/up for drag support
  // This is now called internally after drag detection
}

function handleRinkClickInternal(event, relX, relY, svgX, svgY) {
  // v23.8: Check bounds - only allow clicks within rink area (0-200 x, 0-85 y)
  if (svgX < 0 || svgX > 200 || svgY < 0 || svgY > 85) {
    // Click is outside rink bounds, ignore
    return;
  }
  
  const xy = { x: relX, y: relY, seq: S.xySlot };
  
  // v23.4: Keyboard modifier - hold number key to place specific player
  if (xyKeyModifier && S.curr.players.length >= xyKeyModifier) {
    const player = S.curr.players[xyKeyModifier - 1];
    if (player) {
      player.xy = player.xy || [];
      player.xy.push(xy);
      toast(`Placed #${player.num} (key ${xyKeyModifier})`, 'info');
      renderXYSlots(); renderMarkers(); renderQuickAdd();
      return;
    }
  }
  
  // v23.3: Shot chart mode - create shot at click location
  if (shotChartModeActive) {
    if (handleShotChartClick(svgX, svgY, relX, relY)) return;
  }
  
  // v23.3: Batch placement mode
  if (batchPlacementPlayers.length > 0) {
    if (placeBatchPlayers(relX, relY)) return;
  }
  
  // v23.3: Detect faceoff dot clicks - auto-assign E1 and O1 positions
  const faceoffDot = detectFaceoffDot(svgX, svgY);
  if (faceoffDot && S.curr.type === 'Faceoff') {
    handleFaceoffDotClick(faceoffDot, relX, relY);
    return;
  }
  
  // v23.4: One-click event creation - if no type, suggest based on zone
  if (!S.curr.type) {
    const zone = getZoneFromClick(svgX);
    handleZoneClickNoType(zone, relX, relY);
    return;
  }
  
  // v23.3: Auto-set zone from click position (if zone not already set)
  if (!document.getElementById('evtZone').value) {
    const zone = getZoneFromClick(svgX);
    if (zone) {
      document.getElementById('evtZone').value = zone;
      setZone(zone);
    }
  }
  
  // v23.3: Smart first click - if player mode but no players, place puck first
  if (S.xyMode === 'player' && S.curr.players.length === 0) {
    S.curr.puckXY[0] = xy;
    S.xySlot = 2;
    setXYMode('puck');
    renderXYSlots(); renderMarkers(); updateZoneDisplay();
    toast('Placed puck (add players next)', 'info');
    return;
  }
  
  // Store for undo
  S.xyHistory.push({ mode: S.xyMode, player: S.selectedPlayer?.num, slot: S.xySlot, prev: null });
  
  if (S.xyMode === 'puck') {
    if (!S.curr.puckXY) S.curr.puckXY = [];
    S.curr.puckXY[S.xySlot - 1] = xy;
    
    // v23.9: For possession events, sync puck XY to ONLY event_player_1 XY (not other players)
    const d2 = document.getElementById('evtD2');
    const isPossession = S.curr.type === 'Possession' || 
      (S.curr.type === 'Zone_Entry_Exit' && d2 && (d2.value.includes('Rush') || d2.value.includes('Carried')));
    
    if (isPossession) {
      // Only sync to event_team_player_1 (NOT opp_team_player_1 or other roles)
      const evtPlayer1 = S.curr.players.find(p => 
        (p.role === 'event_team_player_1' || p.role === 'event_player_1') && 
        !p.role.startsWith('opp') && 
        p.roleNum === 1
      );
      if (evtPlayer1) {
        if (!evtPlayer1.xy) evtPlayer1.xy = [];
        // Sync all puck XY points to ONLY player1 (ensure arrays are same length)
        while (evtPlayer1.xy.length < S.curr.puckXY.length) {
          evtPlayer1.xy.push(null);
        }
        evtPlayer1.xy[S.xySlot - 1] = {...xy};
        // Remove any trailing nulls
        while (evtPlayer1.xy.length > 0 && evtPlayer1.xy[evtPlayer1.xy.length - 1] === null) {
          evtPlayer1.xy.pop();
        }
      }
      // DO NOT sync puck XY to other players - only event_team_player_1 (NOT opponent players)
    }
    
    // v23.4: Smart XY auto-linking based on event type
    if (typeof smartAutoLinkXY === 'function') {
      smartAutoLinkXY(xy, S.xySlot);
    }
    
    // v23.8: Auto-suggest zone from puck XY if not already set
    const evtZoneEl = document.getElementById('evtZone');
    if (autoZoneEnabled && evtZoneEl && !evtZoneEl.value) {
      autoSetZoneFromXY(relX);
    }
    
    S.xySlot = Math.min(S.xySlot + 1, 10);
  } else if (S.xyMode === 'player') {
    if (!S.selectedPlayer) {
      if (!S.curr.puckXY) S.curr.puckXY = [];
      S.curr.puckXY[S.xySlot - 1] = xy;
      S.xySlot = Math.min(S.xySlot + 1, 10);
      toast('No player selected - placed puck instead', 'info');
      
      // v23.8: Auto-suggest zone from puck XY if not already set
      const evtZoneEl2 = document.getElementById('evtZone');
      if (autoZoneEnabled && evtZoneEl2 && !evtZoneEl2.value) {
        autoSetZoneFromXY(relX);
      }
    } else {
      if (!S.selectedPlayer.xy) S.selectedPlayer.xy = [];
      S.selectedPlayer.xy[S.xySlot - 1] = xy;
      
      // v23.9: If event_player_1 XY is edited, sync to puck XY ONLY for possession events (Possession or Zone_Entry_Exit with Rush/Carried)
      const d2 = document.getElementById('evtD2');
      const isPossession = S.curr.type === 'Possession' || 
        (S.curr.type === 'Zone_Entry_Exit' && d2 && (d2.value.includes('Rush') || d2.value.includes('Carried')));
      // Only match event_team_player_1, NOT opponent players
      const isEvtPlayer1 = (S.selectedPlayer.role === 'event_team_player_1' || 
                            S.selectedPlayer.role === 'event_player_1') && 
                           !S.selectedPlayer.role.startsWith('opp') &&
                           S.selectedPlayer.roleNum === 1;
      
      // ONLY sync if it's event_player_1 AND it's a possession event
      if (isPossession && isEvtPlayer1) {
        if (!S.curr.puckXY) S.curr.puckXY = [];
        // Sync all player1 XY points to puck (ensure arrays are same length)
        while (S.curr.puckXY.length < S.selectedPlayer.xy.length) {
          S.curr.puckXY.push(null);
        }
        S.curr.puckXY[S.xySlot - 1] = {...xy};
        // Remove any trailing nulls
        while (S.curr.puckXY.length > 0 && S.curr.puckXY[S.curr.puckXY.length - 1] === null) {
          S.curr.puckXY.pop();
        }
      }
      // DO NOT sync other players to puck - only event_player_1
      
      S.xySlot = Math.min(S.xySlot + 1, 10);
      
      // v23.8: Auto-suggest zone from player XY if not already set
      const evtZoneEl3 = document.getElementById('evtZone');
      if (autoZoneEnabled && evtZoneEl3 && !evtZoneEl3.value) {
        autoSetZoneFromXY(relX);
      }
    }
  }
  
  renderXYSlots(); renderMarkers(); updateZoneDisplay(); 
  
  // v23.8: Auto-detect all settings when XY is placed
  autoDetectAllPressure();
  autoDetectAllSideOfPuck();
  
  renderQuickAdd();
}

/**
 * v23.4: Smart auto-link XY based on event type
 */
function smartAutoLinkXY(xy, slot) {
  const type = S.curr.type;
  const e1 = S.curr.players.find(p => p.role === 'event_team_player_1');
  const e2 = S.curr.players.find(p => p.role === 'event_team_player_2');
  const o1 = S.curr.players.find(p => p.role === 'opp_team_player_1');
  
  switch(type) {
    case 'Shot':
      // Slot 1 = shooter position (E1)
      if (slot === 1 && e1) {
        e1.xy = e1.xy || [];
        e1.xy[0] = {...xy};
      }
      break;
      
    case 'Pass':
      // Slot 1 = passer (E1), Slot 2 = receiver (E2)
      if (slot === 1 && e1) {
        e1.xy = e1.xy || [];
        e1.xy[0] = {...xy};
      } else if (slot === 2 && e2) {
        e2.xy = e2.xy || [];
        e2.xy[0] = {...xy};
      }
      break;
      
    case 'Hit':
    case 'Battle':
      // Only assign to event_player_1, NOT opponent player
      // Opponent player should be placed separately by user
      if (slot === 1 && e1) {
        e1.xy = e1.xy || [];
        e1.xy[0] = {...xy};
      }
      // DO NOT auto-assign to o1 - user should place opponent player separately
      break;
      
    case 'Possession':
    case 'Turnover':
      // E1 at puck
      if (slot === 1 && e1) {
        e1.xy = e1.xy || [];
        e1.xy[0] = {...xy};
      }
      break;
      
    case 'Zone_Entry_Exit':
      // E1 carries puck
      if (slot === 1 && e1) {
        e1.xy = e1.xy || [];
        e1.xy[0] = {...xy};
      }
      break;
  }
}

/**
 * v23.4: Handle zone click when no event type selected - suggest event
 */
function handleZoneClickNoType(zone, relX, relY) {
  const xy = { x: relX, y: relY, seq: 1 };
  
  // Show zone-based suggestions
  let suggestedType = 'Possession';
  let detail1 = '';
  
  if (zone === 'o') {
    // Offensive zone - likely shot or cycle
    suggestedType = 'Shot';
    detail1 = 'Shot_OnNet';
  } else if (zone === 'd') {
    // Defensive zone - likely possession/breakout
    suggestedType = 'Possession';
    detail1 = 'Possession_Breakout';
  } else {
    // Neutral zone - likely zone entry
    suggestedType = 'Zone_Entry_Exit';
    detail1 = 'Zone_Entry';
  }
  
  // Set it up
  setEvtType(suggestedType);
  setTimeout(() => {
    document.getElementById('evtD1').value = detail1;
    document.getElementById('evtZone').value = zone;
    setZone(zone);
    
    // Place puck
    S.curr.puckXY[0] = xy;
    S.xySlot = 2;
    
    renderXYSlots(); renderMarkers(); updateZoneDisplay(); renderQuickAdd();
    toast(`${zone === 'o' ? 'Offensive' : zone === 'd' ? 'Defensive' : 'Neutral'} zone ‚Üí ${suggestedType}`, 'info');
  }, 50);
}

/**
 * v23.3: Detect if click is on a faceoff dot
 * Returns dot info or null
 */
function detectFaceoffDot(svgX, svgY) {
  // Faceoff dot positions in SVG coordinates (200x85 rink)
  // Center ice: (100, 42.5)
  // Zone circles: approximately at (31, 22), (31, 63), (169, 22), (169, 63)
  // Neutral zone dots: (80, 22), (80, 63), (120, 22), (120, 63)
  
  const dots = [
    { name: 'center', svgX: 100, svgY: 42.5, relX: 0, relY: 0, zone: 'n' },
    { name: 'left_top', svgX: 31, svgY: 22, relX: -69, relY: -20.5, zone: 'left' },
    { name: 'left_bot', svgX: 31, svgY: 63, relX: -69, relY: 20.5, zone: 'left' },
    { name: 'right_top', svgX: 169, svgY: 22, relX: 69, relY: -20.5, zone: 'right' },
    { name: 'right_bot', svgX: 169, svgY: 63, relX: 69, relY: 20.5, zone: 'right' },
    { name: 'neut_left_top', svgX: 80, svgY: 22, relX: -20, relY: -20.5, zone: 'n' },
    { name: 'neut_left_bot', svgX: 80, svgY: 63, relX: -20, relY: 20.5, zone: 'n' },
    { name: 'neut_right_top', svgX: 120, svgY: 22, relX: 20, relY: -20.5, zone: 'n' },
    { name: 'neut_right_bot', svgX: 120, svgY: 63, relX: 20, relY: 20.5, zone: 'n' },
  ];
  
  const RADIUS = 8; // Click tolerance radius
  
  for (const dot of dots) {
    const dist = Math.sqrt(Math.pow(svgX - dot.svgX, 2) + Math.pow(svgY - dot.svgY, 2));
    if (dist <= RADIUS) {
      return dot;
    }
  }
  
  return null;
}

/**
 * v23.3: Handle faceoff dot click - auto-assign positions
 */
function handleFaceoffDotClick(dot, relX, relY) {
  // Set puck position at the dot
  S.curr.puckXY = [{ x: dot.relX, y: dot.relY, seq: 1 }];
  
  // Find E1 and O1
  const e1 = S.curr.players.find(p => p.role === 'event_team_player_1');
  const o1 = S.curr.players.find(p => p.role === 'opp_team_player_1');
  
  // Set E1 and O1 positions at the dot
  if (e1) {
    e1.xy = [{ x: dot.relX, y: dot.relY, seq: 1 }];
  }
  if (o1) {
    o1.xy = [{ x: dot.relX, y: dot.relY, seq: 1 }];
  }
  
  // Set zone based on dot location
  let zone = 'n';
  if (dot.zone === 'left' || dot.zone === 'right') {
    zone = getZoneFromClick(dot.svgX);
  }
  document.getElementById('evtZone').value = zone;
  
  // Update zone display
  const zoneName = zone === 'o' ? 'Offensive' : zone === 'd' ? 'Defensive' : 'Neutral';
  document.getElementById('zoneDisplay').innerHTML = `<span style="background:${zone === 'o' ? 'var(--success)' : zone === 'd' ? 'var(--danger)' : 'var(--muted)'};color:#fff;padding:1px 6px;border-radius:3px;font-size:9px;">${zoneName.toUpperCase()}</span>`;
  
  renderXYSlots();
  renderMarkers();
  
  const playersSet = [e1 ? 'E1' : '', o1 ? 'O1' : ''].filter(Boolean).join(', ');
  toast(`Faceoff at ${dot.name.replace('_', ' ')}: Puck${playersSet ? ' + ' + playersSet : ''} positioned`, 'success');
}

/**
 * v23.3: Get zone from rink X position
 */
function getZoneFromClick(svgX) {
  // svgX is 0-200, blue lines at 75 and 125
  const period = S.period || 1;
  const isOddPeriod = period === 1 || period === 3 || period === 'OT';
  const homeOffensiveRight = isOddPeriod ? S.homeAttacksRightP1 : !S.homeAttacksRightP1;
  
  let rawZone = '';
  if (svgX < 75) rawZone = 'left';
  else if (svgX > 125) rawZone = 'right';
  else rawZone = 'neutral';
  
  if (rawZone === 'neutral') return 'n';
  
  // Convert to offensive/defensive based on event team
  if (S.evtTeam === 'home') {
    if (homeOffensiveRight) {
      return rawZone === 'right' ? 'o' : 'd';
    } else {
      return rawZone === 'left' ? 'o' : 'd';
    }
  } else {
    if (homeOffensiveRight) {
      return rawZone === 'left' ? 'o' : 'd';
    } else {
      return rawZone === 'right' ? 'o' : 'd';
    }
  }
}

function undoLastXY() {
  if (!S.xyHistory.length) return;
  const last = S.xyHistory.pop();
  
  if (last.mode === 'puck') {
    S.curr.puckXY.pop();
    S.xySlot = Math.max(1, S.curr.puckXY.length + 1);
  } else if (last.player) {
    const p = S.curr.players.find(p => p.num === last.player);
    if (p) {
      p.xy.pop();
      S.xySlot = Math.max(1, p.xy.length + 1);
    }
  }
  
  renderXYSlots(); renderMarkers();
  toast('Undo XY', 'success');
}

function clearCurrentXY() {
  if (S.xyMode === 'puck') S.curr.puckXY = [];
  else if (S.selectedPlayer) S.selectedPlayer.xy = [];
  S.xySlot = 1;
  renderXYSlots(); renderMarkers();
}

function clearRink() {
  // v23.8: Clear all XY data from rink
  S.xyHistory = [];
  
  // Clear current event XY
  if (S.curr) {
    if (S.curr.puckXY) S.curr.puckXY = [];
    if (S.curr.players) {
      S.curr.players.forEach(p => {
        if (p.xy) p.xy = [];
      });
    }
  }
  
  // Reset XY slot
  S.xySlot = 1;
  
  // Clear zone if it was auto-set
  const evtZoneEl = document.getElementById('evtZone');
  if (evtZoneEl && evtZoneEl.value) {
    const zoneBtn = document.querySelector(`.zone-btn[data-zone="${evtZoneEl.value}"]`);
    if (zoneBtn) zoneBtn.classList.remove('active');
    evtZoneEl.value = '';
  }
  
  renderXYSlots();
  renderMarkers();
  if (typeof updateZoneDisplay === 'function') updateZoneDisplay();
  toast('Rink cleared', 'success');
}

/**
 * Handle mouse hover over rink for XY tooltips (v5)
 * Shows coordinates on hover, and player info when hovering markers
 */
function handleRinkHover(event) {
  const svg = document.getElementById('rinkSvg');
  const tooltip = document.getElementById('xyTooltip');
  if (!svg || !tooltip) return;
  
  const rect = svg.getBoundingClientRect();
  const pt = svg.createSVGPoint();
  pt.x = event.clientX; pt.y = event.clientY;
  const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
  
  // v16.06: Show center-relative coordinates
  const x = Math.round((svgPt.x - 100) * 10) / 10;
  const y = Math.round((svgPt.y - 42.5) * 10) / 10;
  
  // Check if hovering over a marker
  const target = event.target;
  let tooltipContent = `(${x}, ${y})`;
  
  if (target && target.dataset && target.dataset.type) {
    const type = target.dataset.type;
    const markerX = target.dataset.x || '--';
    const markerY = target.dataset.y || '--';
    
    if (type === 'puck') {
      tooltipContent = `üèí Puck (${markerX}, ${markerY})`;
    } else if (type === 'player') {
      const num = target.dataset.num || '?';
      const name = target.dataset.name || '';
      tooltipContent = `#${num} ${name}\n(${markerX}, ${markerY})`;
    } else if (type === 'history') {
      const evtNum = target.dataset.evtnum || '?';
      const evtType = target.dataset.evttype || '';
      tooltipContent = `Event #${evtNum} - ${evtType}\n(${markerX}, ${markerY})`;
    }
  }
  
  // Position tooltip at cursor
  tooltip.textContent = tooltipContent;
  tooltip.style.display = 'block';
  tooltip.style.left = (event.clientX - rect.left) + 'px';
  tooltip.style.top = (event.clientY - rect.top) + 'px';
}

/**
 * Hide XY tooltip (v5)
 */
function hideXYTooltip() {
  const tooltip = document.getElementById('xyTooltip');
  if (tooltip) tooltip.style.display = 'none';
}

// ============================================================
// NET LOCATION
// ============================================================
// v24.0: Removed duplicate handleNetClick - using the one in main rink area

function clearNetXY() {
  S.curr.netXY = null;
  document.getElementById('netMarker').innerHTML = '';
}

function closeNetModal() {
  document.getElementById('netModal').classList.remove('show');
}

// ============================================================
// LOG EVENT
// ============================================================
// Define logEvent on window immediately to ensure it's always available
window.logEvent = function() {
  console.log('window.logEvent() called');
  console.log('S.curr:', S.curr);
  console.log('S.curr.type:', S.curr?.type);
  
  try {
    if (!S.curr.type) { 
      console.log('No event type selected, showing toast');
      toast('Select event type', 'error'); 
      return; 
    }
    
    console.log('Event type is:', S.curr.type);
    
    // v23.3: Check if user wants to skip confirmation
    const skipConfirm = document.getElementById('skipConfirm')?.checked;
    console.log('skipConfirm checked:', skipConfirm);
    
    if (skipConfirm) {
      console.log('Skipping confirmation, calling logEventDirect');
      if (typeof window.logEventDirect === 'function') {
        window.logEventDirect();
      } else if (typeof logEventDirect === 'function') {
        logEventDirect();
      } else {
        console.error('logEventDirect not available');
      }
      return;
    }
    
    // Show confirmation modal
    console.log('About to show confirmation modal');
    console.log('window.showConfirmModal type:', typeof window.showConfirmModal);
    console.log('showConfirmModal type:', typeof showConfirmModal);
    
    if (typeof window.showConfirmModal === 'function') {
      console.log('Calling window.showConfirmModal()');
      window.showConfirmModal();
      console.log('window.showConfirmModal() completed');
    } else if (typeof showConfirmModal === 'function') {
      console.log('Calling showConfirmModal()');
      showConfirmModal();
      console.log('showConfirmModal() completed');
    } else {
      console.error('showConfirmModal not available');
      toast('Error: showConfirmModal not available', 'error');
    }
  } catch (e) {
    console.error('Error in logEvent:', e);
    console.error('Error stack:', e.stack);
    toast('Error logging event: ' + e.message, 'error');
  }
};

// Also assign to regular function for internal use
function logEvent() {
  return window.logEvent();
}

/**
 * v23.3: Log event directly without confirmation modal
 */
function logEventDirect() {
  // This function calls doLogEvent() which handles XY carry-over
  if (!S.curr.type) { toast('Select event type', 'error'); return; }
  
  // Get values directly from the main form
  const startTime = document.getElementById('evtStartTime').value || document.getElementById('clock').value;
  // v23.9: Treat end time as empty if it's just a minute (e.g., "19:") without seconds
  let endTimeRaw = document.getElementById('evtEndTime').value.trim();
  const endTime = (endTimeRaw && !endTimeRaw.match(/^\d+:$/)) ? endTimeRaw : startTime;
  const zone = document.getElementById('evtZone').value || calculateZone();
  const success = document.getElementById('evtSuccess').value || deriveSuccess();
  const strength = document.getElementById('evtStrength').value || deriveStrength();
  const isHighlight = document.getElementById('isHighlight').checked;
  let videoUrl = isHighlight ? (document.getElementById('evtVideoUrl').value.trim() || '') : '';
  
  // v23.9: If highlight but no videoUrl, use main YouTube link with start time
  if (isHighlight && !videoUrl && S.videoTiming?.youtubeUrl) {
    const runningVideoTime = calculateRunningVideoTime(S.period, startTime);
    const startTimeSeconds = Math.max(0, runningVideoTime - 10); // 10 seconds before event
    videoUrl = buildYouTubeUrlWithTime(S.videoTiming.youtubeUrl, startTimeSeconds);
  }

  // v23.8: Auto-detect all settings before logging
  autoDetectAllPressure();
  autoDetectAllSuccess();
  autoDetectAllSideOfPuck();
  
  // For Possession and Zone_Entry_Exit, copy player XY to puck
  const detail1 = document.getElementById('evtD1').value || '';
  const detail2 = document.getElementById('evtD2').value || '';
  const isPossessionEvent = S.curr.type === 'Possession' || 
    (S.curr.type === 'Zone_Entry_Exit' && (detail2.includes('Rush') || detail1.includes('Entry')));
  
  if (isPossessionEvent && S.curr.puckXY.length === 0) {
    const evtPlayer1 = S.curr.players.find(p => 
      p.role === 'event_team_player_1' || p.role === 'event_player_1' || p.roleNum === 1
    );
    if (evtPlayer1?.xy?.length > 0) {
      S.curr.puckXY = evtPlayer1.xy.map(xy => ({...xy}));
    }
  }
  
  // Build linked event chain
  let linkedEventChain = [];
  if (S.linkedEventIdx !== null) {
    linkedEventChain.push(S.linkedEventIdx);
    const linkedEvt = S.events.find(e => e.idx === S.linkedEventIdx);
    if (linkedEvt?.linkedEventChain?.length) {
      linkedEventChain = [...linkedEvt.linkedEventChain, S.linkedEventIdx];
    }
  }
  
  // v23.9: Ensure detail1 and detail2 are always populated (use type as fallback)
  const finalDetail1 = detail1 || S.curr.type || '';
  const finalDetail2 = detail2 || '';
  
  // Get codes and IDs for export (display uses names)
  const typeInfo = getEventTypeCodeAndId(S.curr.type);
  const detail1Info = getEventDetailCodeAndId(finalDetail1, S.curr.type);
  const detail2Info = getEventDetail2CodeAndId(finalDetail2);
  
  // Calculate adjusted video time (go back up to 10 seconds, or to nearest faceoff)
  const adjustedVideoTime = calculateAdjustedVideoTime(S.period, startTime, S.curr.type);
  
  const evt = {
    idx: S.evtIdx++,
    game_id: S.gameId,
    period: S.period,
    start_time: startTime,
    end_time: endTime,
    team: S.evtTeam,
    type: S.curr.type,  // Display name
    typeCode: typeInfo.code,  // Export code
    typeId: typeInfo.id,  // Export ID
    detail1: finalDetail1,  // Display name
    detail1Code: detail1Info.code,  // Export code
    detail1Id: detail1Info.id,  // Export ID
    detail2: finalDetail2,  // Display name
    detail2Code: detail2Info.code,  // Export code
    detail2Id: detail2Info.id,  // Export ID
    zone,
    success,
    strength,
    linkedEventIdx: S.linkedEventIdx,
    linkedEventChain,
    isHighlight,
    videoUrl: isHighlight ? videoUrl : undefined,  // v23.7: Individual highlight video URL
    adjustedVideoTime: adjustedVideoTime,  // Adjusted time for video playback
    puckXY: [...S.curr.puckXY],
    netXY: S.curr.netXY,
    players: S.curr.players.map(p => ({...p, xy: [...(p.xy || [])]}))
  };
  
  S.events.push(evt);
  markDataChanged();
  
  // v23.4: Auto-sort and reindex events by time
  sortAndReindexEvents();
  
  // v23.8: Auto-detect assists for Goals
  if (evt.type === 'Goal') {
    detectAndLinkAssists(evt);
  }
  
  // v23.8: Determine end time (use start time if no end time)
  const actualEndTime = endTime || startTime;
  S.lastEndTime = actualEndTime;
  
  // v23.9: Use end time as next start time (instead of decrementing by 1 second)
  let nextStartTime = actualEndTime;
  
  // v23.9: Auto-switch teams based on event type
  const shouldSwitchTeam = shouldAutoSwitchTeam(evt.type, finalDetail1, finalDetail2);
  if (shouldSwitchTeam) {
    const newTeam = S.evtTeam === 'home' ? 'away' : 'home';
    setEvtTeam(newTeam);
    toast(`Team switched to ${newTeam === 'home' ? S.homeTeam || 'Home' : S.awayTeam || 'Away'}`, 'info');
  }
  
  // v23.9: Preserve players for next event (carry over)
  const preservedPlayers = S.curr.players.map(p => ({...p, xy: [...(p.xy || [])]}));
  
  S.linkedEventIdx = null;
  
  const highlightIcon = isHighlight ? ' ‚≠ê' : '';
  toast(`Event #${evt.idx + 1}: ${evt.type}${highlightIcon}`, 'success');
  
  clearEvent();
  
  // v23.9: Apply next event player/team mapping rules from templates
  const mappedPlayers = applyNextEventMappingRules(evt);
  
  // Use mapped players if template applied, otherwise use preserved players
  if (mappedPlayers && mappedPlayers.length > 0) {
    S.curr.players = mappedPlayers;
    renumberPlayers();
  } else if (preservedPlayers.length > 0) {
    S.curr.players = preservedPlayers;
  }
  
  // v23.9: Auto-carry over XY from previous event if all players match and no XY set
  carryOverXYFromPreviousEvent(evt);
  
  if (S.curr.players.length > 0) {
    renderQuickAdd();
    renderXYSlots();
  }
  
  document.getElementById('evtStartTime').value = nextStartTime;
  
  renderEvents(); renderMarkers(); updateScores(); updateBoxScore();
  updateNextPlaySuggestions();
  autoSave();
  
  if (document.getElementById('autoEditNext')?.checked) {
    setTimeout(() => editEvent(S.events.length - 1), 100);
  }
}

// Ensure logEventDirect is globally accessible
if (typeof window !== 'undefined') {
  window.logEventDirect = logEventDirect;
}

/**
 * v23.8: Process all goals to detect and link assists
 * Called after loading games from Supabase, Excel, or localStorage
 */
function processAllGoalsForAssists() {
  if (!S.events || S.events.length === 0) return;
  
  // Sort events first to ensure proper ordering
  sortAndReindexEvents();
  
  const goals = S.events.filter(e => e.type === 'Goal');
  if (goals.length === 0) return;
  
  let totalProcessed = 0;
  let totalAutoLinked = 0;
  
  goals.forEach(goal => {
    const result = detectAndLinkAssists(goal, true); // true = silent mode (no prompts)
    if (result) {
      totalProcessed++;
      totalAutoLinked += (result.autoLinked || 0);
    }
  });
  
  if (totalAutoLinked > 0) {
    renderEvents();
    autoSave();
    toast(`Auto-linked ${totalAutoLinked} assist(s) for ${totalProcessed} goal(s)`, 'success');
  } else if (totalProcessed > 0) {
    // Still show message if we processed goals but found no assists to link
    console.log(`Processed ${totalProcessed} goal(s) for assist detection`);
  }
}

/**
 * v23.8: Auto-detect and link assists for Goals
 * Finds recent Pass events and either auto-links them (if already marked as assists)
 * or prompts user to mark them as assists
 * @param {Object} goalEvent - The goal event to process
 * @param {boolean} silent - If true, don't show prompts (for batch processing)
 * @returns {Object|null} - Result object with autoLinked count, or null
 */
function detectAndLinkAssists(goalEvent, silent = false) {
  if (!goalEvent || goalEvent.type !== 'Goal') return { autoLinked: 0, needsManualReview: false };
  
  const parseTime = (t) => {
    if (!t) return 0;
    const [min, sec] = t.split(':').map(Number);
    return (min || 0) * 60 + (sec || 0);
  };
  
  const goalTime = parseTime(goalEvent.start_time);
  const goalPeriod = goalEvent.period;
  const goalTeam = goalEvent.team;
  
  // Find recent Pass events (within 15 seconds before goal, same period, same team)
  // v23.8: Increased window to 15 seconds to capture secondary assists
  // Note: After sortAndReindexEvents(), goalEvent.idx may have changed, so we use object reference
  const goalEventIdx = goalEvent.idx; // Store before filtering
  const recentPasses = S.events
    .filter(e => {
      if (e.type !== 'Pass') return false;
      if (e.period !== goalPeriod) return false;
      if (e.team !== goalTeam) return false;
      if (e === goalEvent) return false; // Don't include the goal itself
      if (e.idx >= goalEventIdx) return false; // Must be before goal (by index)
      if (e.assistToGoalIdx !== null && e.assistToGoalIdx !== undefined) return false; // Already linked to a goal
      
      const passTime = parseTime(e.start_time);
      const timeDiff = goalTime - passTime;
      return timeDiff >= 0 && timeDiff <= 15; // Within 15 seconds (increased from 10 to capture secondary assists)
    })
    .sort((a, b) => parseTime(b.start_time) - parseTime(a.start_time)); // Most recent first
  
  if (recentPasses.length === 0) return { autoLinked: 0, needsManualReview: false };
  
  // Separate passes that already have assist markers vs those that don't
  const passesWithAssist = [];
  const passesWithoutAssist = [];
  
  recentPasses.forEach(pass => {
    const hasAssist = pass.players?.some(p => {
      const pd1 = (p.playD1 || '').toLowerCase();
      const pd2 = (p.playD2 || '').toLowerCase();
      return pd1.includes('assist') || pd2.includes('assist');
    });
    
    if (hasAssist) {
      passesWithAssist.push(pass);
    } else {
      passesWithoutAssist.push(pass);
    }
  });
  
  // Auto-link passes that already have assist markers
  if (passesWithAssist.length > 0) {
    // Re-find goalEvent after sorting (idx may have changed)
    const currentGoalEvent = S.events.find(e => e === goalEvent);
    if (currentGoalEvent) {
      passesWithAssist.forEach(pass => {
        // v23.8: Use assistToGoalIdx instead of linkedEventIdx for assists
        if (pass.assistToGoalIdx === null || pass.assistToGoalIdx === undefined) {
          pass.assistToGoalIdx = currentGoalEvent.idx;
        }
      });
      autoSave();
      toast(`Auto-linked ${passesWithAssist.length} assist(s) to goal`, 'success');
    }
  }
  
  // Show prompt for passes without assist markers (only if not in silent mode)
  if (passesWithoutAssist.length > 0 && !silent) {
    showAssistPromptModal(goalEvent, passesWithoutAssist);
  }
  
  // Return result for batch processing
  return {
    autoLinked: passesWithAssist.length,
    needsManualReview: passesWithoutAssist.length > 0 && !silent
  };
}

/**
 * v23.8: Show modal to mark recent passes as assists
 */
function showAssistPromptModal(goalEvent, passes) {
  // Create modal dynamically
  const modal = document.createElement('div');
  modal.className = 'overlay show';
  modal.id = 'assistPromptModal';
  modal.innerHTML = `
    <div class="modal" style="min-width:400px;max-width:600px;">
      <h3>üéØ Mark Assists for Goal #${goalEvent.idx + 1}</h3>
      <p style="font-size:10px;color:var(--muted);margin-bottom:12px;">
        Found ${passes.length} recent pass(es). Mark as assists?
      </p>
      <div id="assistPassesList" style="max-height:300px;overflow-y:auto;margin-bottom:12px;"></div>
      <div class="modal-actions">
        <button class="btn-primary" onclick="saveAssistSelections()">üíæ Save Assists</button>
        <button onclick="closeAssistPromptModal()">Skip</button>
      </div>
    </div>
  `;
  document.body.appendChild(modal);
  
  // Store in global for access
  window.currentAssistGoal = goalEvent;
  window.currentAssistPasses = passes;
  window.assistSelections = {}; // {passIdx: 'primary'|'secondary'|null}
  
  // Render pass list
  const list = document.getElementById('assistPassesList');
  list.innerHTML = passes.map((pass, i) => {
    const player = pass.players?.find(p => p.role === 'event_team_player_1' || p.role === 'event_player_1');
    const playerName = player ? `#${player.num} ${player.name}` : 'Unknown';
    const passTime = pass.start_time || '';
    
    return `
      <div style="background:var(--card);padding:8px;border-radius:4px;margin-bottom:6px;border-left:3px solid var(--accent);">
        <div style="font-size:10px;font-weight:600;margin-bottom:4px;">${playerName} @ ${passTime}</div>
        <div style="display:flex;gap:8px;align-items:center;">
          <button class="btn-sm ${window.assistSelections[pass.idx] === 'primary' ? 'active' : ''}" 
                  onclick="selectAssistType(${pass.idx}, 'primary')" 
                  style="flex:1;font-size:9px;">A1 (Primary)</button>
          <button class="btn-sm ${window.assistSelections[pass.idx] === 'secondary' ? 'active' : ''}" 
                  onclick="selectAssistType(${pass.idx}, 'secondary')" 
                  style="flex:1;font-size:9px;">A2 (Secondary)</button>
          <button class="btn-sm" onclick="selectAssistType(${pass.idx}, null)" 
                  style="flex:0.5;font-size:9px;background:var(--muted);">Skip</button>
        </div>
      </div>
    `;
  }).join('');
}

function selectAssistType(passIdx, type) {
  if (!window.assistSelections) window.assistSelections = {};
  window.assistSelections[passIdx] = type;
  
  // Update button states
  const buttons = document.querySelectorAll(`[onclick*="selectAssistType(${passIdx}"]`);
  buttons.forEach(btn => {
    if (btn.textContent.includes('A1') && type === 'primary') btn.classList.add('active');
    else if (btn.textContent.includes('A2') && type === 'secondary') btn.classList.add('active');
    else btn.classList.remove('active');
  });
}

function saveAssistSelections() {
  if (!window.currentAssistGoal || !window.currentAssistPasses || !window.assistSelections) return;
  
  // Re-find goalEvent after sorting (idx may have changed)
  const currentGoalEvent = S.events.find(e => e === window.currentAssistGoal);
  if (!currentGoalEvent) {
    toast('Goal event not found', 'error');
    closeAssistPromptModal();
    return;
  }
  
  let linked = 0;
  window.currentAssistPasses.forEach(pass => {
    const assistType = window.assistSelections[pass.idx];
    if (!assistType) return; // Skip if not selected
    
    // Find the pass event in S.events (use object reference)
    const passEvent = S.events.find(e => e === pass);
    if (!passEvent) return;
    
    // v23.8: Link assist to goal using assistToGoalIdx (separate from linkedEventIdx)
    passEvent.assistToGoalIdx = currentGoalEvent.idx;
    
    // Mark assist in play_detail1 for event_player_1
    const player1 = passEvent.players?.find(p => 
      p.role === 'event_team_player_1' || p.role === 'event_player_1'
    );
    if (player1) {
      if (assistType === 'primary') {
        player1.playD1 = 'AssistPrimary';
      } else if (assistType === 'secondary') {
        player1.playD1 = 'AssistSecondary';
      }
    }
    
    linked++;
  });
  
  if (linked > 0) {
    renderEvents();
    autoSave();
    toast(`Marked ${linked} assist(s) and linked to goal`, 'success');
  }
  
  closeAssistPromptModal();
}

function closeAssistPromptModal() {
  const modal = document.getElementById('assistPromptModal');
  if (modal) modal.remove();
  window.currentAssistGoal = null;
  window.currentAssistPasses = null;
  window.assistSelections = null;
}

/**
 * v23.8: Show modal to enter video URLs for imported goals
 */
function showGoalVideoUrlsModal(goals) {
  // Sort goals by period and time
  const sortedGoals = [...goals].sort((a, b) => {
    if (a.period !== b.period) return a.period - b.period;
    return a.start_time.localeCompare(b.start_time);
  });
  
  const scorer = (goal) => {
    const p = goal.players?.find(p => p.role === 'event_player_1');
    return p ? `#${p.num} ${p.name || ''}`.trim() : 'Unknown';
  };
  
  const html = `
    <div class="overlay show" id="goalVideoUrlsModal" style="z-index:10000;">
      <div class="modal" style="max-width:700px;max-height:85vh;overflow-y:auto;">
        <h3>‚≠ê Enter Video URLs for Goals</h3>
        <p style="font-size:10px;color:var(--muted);margin-bottom:12px;">
          ${sortedGoals.length} goal(s) were automatically marked as highlights. Enter YouTube URLs for each goal below.
        </p>
        
        <div style="max-height:60vh;overflow-y:auto;margin-bottom:12px;">
          ${sortedGoals.map((goal, idx) => {
            const goalId = `goalVideo_${goal.idx}`;
            const currentUrl = goal.videoUrl || '';
            return `
              <div style="background:var(--card);padding:10px;border-radius:4px;margin-bottom:8px;border-left:3px solid var(--${goal.team});">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
                  <div>
                    <strong style="font-size:11px;color:var(--${goal.team});">
                      P${goal.period} @ ${goal.start_time} - ${goal.team === 'home' ? (S.homeTeam || 'HOME') : (S.awayTeam || 'AWAY')}
                    </strong>
                    <div style="font-size:9px;color:var(--muted);margin-top:2px;">
                      ${scorer(goal)}
                    </div>
                  </div>
                  <span style="font-size:18px;">‚≠ê</span>
                </div>
                <div class="form-group" style="margin:0;">
                  <label style="font-size:9px;color:var(--muted);">YouTube URL:</label>
                  <input 
                    type="text" 
                    id="${goalId}" 
                    value="${currentUrl}"
                    placeholder="https://youtube.com/watch?v=..." 
                    style="width:100%;font-size:10px;padding:4px;"
                    onkeydown="if(event.key==='Enter') { event.preventDefault(); const next = document.querySelectorAll('#goalVideoUrlsModal input[type=text]')[${idx + 1}]; if(next) next.focus(); else saveGoalVideoUrls(); }"
                  >
                </div>
              </div>
            `;
          }).join('')}
        </div>
        
        <div style="background:rgba(59,130,246,0.1);padding:8px;border-radius:4px;margin-bottom:12px;font-size:9px;color:var(--muted);">
          üí° <strong>Tip:</strong> You can press Enter to move to the next goal. Leave blank to skip.
        </div>
        
        <div class="modal-actions">
          <button class="btn-primary" onclick="saveGoalVideoUrls()">üíæ Save Video URLs</button>
          <button onclick="skipGoalVideoUrls()">Skip</button>
        </div>
      </div>
    </div>
  `;
  
  // Remove existing modal if any
  const existing = document.getElementById('goalVideoUrlsModal');
  if (existing) existing.remove();
  
  // Add to body
  document.body.insertAdjacentHTML('beforeend', html);
  
  // Focus first input
  const firstInput = document.getElementById(`goalVideo_${sortedGoals[0].idx}`);
  if (firstInput) {
    setTimeout(() => firstInput.focus(), 100);
  }
}

function saveGoalVideoUrls() {
  const modal = document.getElementById('goalVideoUrlsModal');
  if (!modal) return;
  
  const inputs = modal.querySelectorAll('input[type="text"]');
  let saved = 0;
  
  inputs.forEach(input => {
    const goalIdx = parseInt(input.id.replace('goalVideo_', ''));
    const videoUrl = input.value.trim();
    
    const goal = S.events.find(e => e.idx === goalIdx);
    if (goal && goal.type === 'Goal') {
      if (videoUrl) {
        goal.videoUrl = videoUrl;
        saved++;
      } else {
        // If URL is cleared, remove it but keep highlight
        goal.videoUrl = undefined;
      }
    }
  });
  
  renderEvents();
  autoSave();
  
  if (saved > 0) {
    toast(`Saved ${saved} video URL(s) for goals`, 'success');
  }
  
  closeGoalVideoUrlsModal();
  
  // Open verification panel after saving
  setTimeout(() => {
    openVerifyModal();
  }, 300);
}

function skipGoalVideoUrls() {
  closeGoalVideoUrlsModal();
  
  // Open verification panel after skipping
  setTimeout(() => {
    openVerifyModal();
  }, 300);
}

function closeGoalVideoUrlsModal() {
  const modal = document.getElementById('goalVideoUrlsModal');
  if (modal) modal.remove();
}

/**
 * v23.3: Show confirmation modal before logging event
 */
function showConfirmModal() {
  console.log('showConfirmModal() called');
  const modal = document.getElementById('confirmEventModal');
  console.log('Modal element:', modal);
  
  if (!modal) {
    console.error('confirmEventModal element not found!');
    toast('Error: Confirmation modal element not found', 'error');
    return;
  }
  
  console.log('Modal found, showing it...');
  
  // Populate type dropdown with all event types
  const types = Object.keys(LISTS.details);
  document.getElementById('confirmType').innerHTML = types.map(t => 
    `<option value="${t}" ${t === S.curr.type ? 'selected' : ''}>${t}</option>`
  ).join('');
  
  // Team dropdown with team names
  const teamSel = document.getElementById('confirmTeam');
  teamSel.innerHTML = `<option value="home">${S.homeTeam || 'Home'}</option><option value="away">${S.awayTeam || 'Away'}</option>`;
  teamSel.value = S.evtTeam;
  
  // Populate D1 dropdown
  onConfirmTypeChange();
  document.getElementById('confirmD1').value = document.getElementById('evtD1').value || '';
  onConfirmD1Change();
  document.getElementById('confirmD2').value = document.getElementById('evtD2').value || '';
  
  // Other fields
  document.getElementById('confirmZone').value = document.getElementById('evtZone').value || calculateZone() || '';
  document.getElementById('confirmSuccess').value = document.getElementById('evtSuccess').value || deriveSuccess() || '';
  document.getElementById('confirmStrength').value = document.getElementById('evtStrength').value || deriveStrength() || '5v5';
  document.getElementById('confirmStartTime').value = document.getElementById('evtStartTime').value || document.getElementById('clock').value;
  document.getElementById('confirmEndTime').value = document.getElementById('evtEndTime').value || document.getElementById('evtStartTime').value || document.getElementById('clock').value;
  document.getElementById('confirmHighlight').checked = document.getElementById('isHighlight').checked;
  document.getElementById('confirmVideoUrl').value = document.getElementById('evtVideoUrl').value || '';
  toggleConfirmHighlightFields();
  // v23.9: Default to next event index (S.events.length + 1) instead of current linkedEventIdx
  // This makes it easier to create new links to the next event
  const nextEventIndex = S.events.length > 0 ? S.events.length + 1 : 1;
  document.getElementById('confirmLinked').value = S.linkedEventIdx !== null ? S.linkedEventIdx + 1 : nextEventIndex;
  
  // v23.9: Show players with editable details
  renderConfirmPlayers();
  
  console.log('About to add "show" class to modal');
  console.log('Modal classes BEFORE:', modal.classList.toString());
  modal.classList.add('show');
  console.log('Modal classes after adding show:', modal.classList.toString());
  
  // Force show the modal with inline styles
  modal.style.display = 'flex';
  modal.style.visibility = 'visible';
  modal.style.opacity = '1';
  modal.style.zIndex = '10000';
  modal.style.position = 'fixed';
  modal.style.top = '0';
  modal.style.left = '0';
  modal.style.right = '0';
  modal.style.bottom = '0';
  modal.style.width = '100%';
  modal.style.height = '100%';
  modal.style.background = 'rgba(0,0,0,0.85)';
  
  console.log('Modal display style:', window.getComputedStyle(modal).display);
  console.log('Modal visibility style:', window.getComputedStyle(modal).visibility);
  console.log('Modal opacity style:', window.getComputedStyle(modal).opacity);
  console.log('Modal z-index style:', window.getComputedStyle(modal).zIndex);
  console.log('Modal position style:', window.getComputedStyle(modal).position);
  
  // Check if modal is in body
  console.log('Modal parent:', modal.parentElement);
  console.log('Modal in body?', document.body.contains(modal));
  
  // Ensure modal is in body
  if (modal.parentElement !== document.body) {
    console.log('Moving modal to body...');
    document.body.appendChild(modal);
  }
  
  // v26.0: Ensure buttons in confirmation modal work - use setTimeout to ensure DOM is ready
  setTimeout(() => {
    try {
      console.log('Setting up confirmation modal buttons...');
      
      // Ensure all functions are on window before setting up buttons
      try {
        if (typeof closeConfirmModal === 'function' && !window.closeConfirmModal) {
          window.closeConfirmModal = closeConfirmModal;
        }
        if (typeof confirmAndLog === 'function' && !window.confirmAndLog) {
          window.confirmAndLog = confirmAndLog;
        }
        if (typeof confirmAndContinue === 'function' && !window.confirmAndContinue) {
          window.confirmAndContinue = confirmAndContinue;
        }
        if (typeof confirmAndLogWithNext === 'function' && !window.confirmAndLogWithNext) {
          window.confirmAndLogWithNext = confirmAndLogWithNext;
        }
        if (typeof confirmAndLogAndAddLinked === 'function' && !window.confirmAndLogAndAddLinked) {
          window.confirmAndLogAndAddLinked = confirmAndLogAndAddLinked;
        }
        
        console.log('Functions on window:', {
          closeConfirmModal: typeof window.closeConfirmModal,
          confirmAndLog: typeof window.confirmAndLog,
          confirmAndContinue: typeof window.confirmAndContinue,
          confirmAndLogWithNext: typeof window.confirmAndLogWithNext,
          confirmAndLogAndAddLinked: typeof window.confirmAndLogAndAddLinked
        });
      } catch (e) {
        console.error('Error assigning functions to window:', e);
      }
      
      // Re-query the modal after moving to body
      const modalAfterMove = document.getElementById('confirmEventModal');
      if (modalAfterMove) {
        ensureModalButtonsWork(modalAfterMove);
      } else {
        console.error('Could not find modal after moving to body!');
      }
    } catch (e) {
      console.error('Error setting up modal buttons:', e);
    }
  }, 10);
}

// Ensure showConfirmModal is globally accessible
if (typeof window !== 'undefined') {
  window.showConfirmModal = showConfirmModal;
}

/**
 * v23.9: Render players in confirmation modal with editable details
 */
function renderConfirmPlayers() {
  const container = document.getElementById('confirmPlayers');
  if (!container) return;
  
  const evtPlayers = S.curr.players.filter(p => p.role?.startsWith('event') || (!p.role?.startsWith('opp') && p.role));
  const oppPlayers = S.curr.players.filter(p => p.role?.startsWith('opp'));
  
  let html = '';
  
  if (evtPlayers.length > 0) {
    html += '<div style="margin-bottom:8px;"><div style="font-size:9px;color:var(--accent);font-weight:bold;margin-bottom:4px;">Event Players:</div>';
    evtPlayers.forEach((p, idx) => {
      const pd1Display = p.playD1 || '--';
      const pd2Display = p.playD2 || '--';
      const successDisplay = p.playSuccess === 's' ? '‚úì' : (p.playSuccess === 'u' ? '‚úó' : '--');
      const pressureDisplay = p.pressure ? `#${p.pressure}` : '--';
      html += `<div style="display:grid;grid-template-columns:50px 1fr 1fr 60px 70px;gap:4px;padding:6px;background:var(--card);border-radius:3px;margin-bottom:3px;align-items:center;border-left:3px solid var(--accent);">
        <span style="font-weight:bold;color:var(--accent);font-size:11px;">#${p.num}</span>
        <select id="confirmPlayerPD1_${idx}" style="font-size:9px;padding:3px;" onchange="updateConfirmPlayerDetail(${idx}, 'playD1', this.value)" title="Play Detail 1">
          <option value="">PD1: ${pd1Display}</option>
          ${(S.playDetails1 || []).map(pd => `<option value="${pd.name}" ${p.playD1 === pd.name ? 'selected' : ''}>${pd.name}</option>`).join('')}
        </select>
        <select id="confirmPlayerPD2_${idx}" style="font-size:9px;padding:3px;" onchange="updateConfirmPlayerDetail(${idx}, 'playD2', this.value)" title="Play Detail 2">
          <option value="">PD2: ${pd2Display}</option>
          ${(S.playDetails2 || []).map(pd => `<option value="${pd.name}" ${p.playD2 === pd.name ? 'selected' : ''}>${pd.name}</option>`).join('')}
        </select>
        <select id="confirmPlayerSuccess_${idx}" style="font-size:9px;padding:3px;" onchange="updateConfirmPlayerDetail(${idx}, 'playSuccess', this.value)" title="Success/Unsuccess">
          <option value="">S/U: ${successDisplay}</option>
          <option value="s" ${p.playSuccess === 's' ? 'selected' : ''}>‚úì Success</option>
          <option value="u" ${p.playSuccess === 'u' ? 'selected' : ''}>‚úó Unsuccess</option>
        </select>
        <select id="confirmPlayerPressure_${idx}" style="font-size:9px;padding:3px;" onchange="updateConfirmPlayerDetail(${idx}, 'pressure', this.value)" title="Pressured By">
          <option value="">Press: ${pressureDisplay}</option>
          ${(S.rosters?.home || []).concat(S.rosters?.away || []).map(r => `<option value="${r.num}" ${p.pressure == r.num ? 'selected' : ''}>#${r.num}</option>`).join('')}
        </select>
      </div>`;
    });
    html += '</div>';
  }
  
  if (oppPlayers.length > 0) {
    html += '<div><div style="font-size:9px;color:var(--danger);font-weight:bold;margin-bottom:4px;">Opp Players:</div>';
    oppPlayers.forEach((p, idx) => {
      const oppIdx = evtPlayers.length + idx;
      const pd1Display = p.playD1 || '--';
      const pd2Display = p.playD2 || '--';
      const successDisplay = p.playSuccess === 's' ? '‚úì' : (p.playSuccess === 'u' ? '‚úó' : '--');
      const pressureDisplay = p.pressure ? `#${p.pressure}` : '--';
      html += `<div style="display:grid;grid-template-columns:50px 1fr 1fr 60px 70px;gap:4px;padding:6px;background:var(--card);border-radius:3px;margin-bottom:3px;align-items:center;border-left:3px solid var(--danger);">
        <span style="font-weight:bold;color:var(--danger);font-size:11px;">#${p.num}</span>
        <select id="confirmPlayerPD1_${oppIdx}" style="font-size:9px;padding:3px;" onchange="updateConfirmPlayerDetail(${oppIdx}, 'playD1', this.value)" title="Play Detail 1">
          <option value="">PD1: ${pd1Display}</option>
          ${(S.playDetails1 || []).map(pd => `<option value="${pd.name}" ${p.playD1 === pd.name ? 'selected' : ''}>${pd.name}</option>`).join('')}
        </select>
        <select id="confirmPlayerPD2_${oppIdx}" style="font-size:9px;padding:3px;" onchange="updateConfirmPlayerDetail(${oppIdx}, 'playD2', this.value)" title="Play Detail 2">
          <option value="">PD2: ${pd2Display}</option>
          ${(S.playDetails2 || []).map(pd => `<option value="${pd.name}" ${p.playD2 === pd.name ? 'selected' : ''}>${pd.name}</option>`).join('')}
        </select>
        <select id="confirmPlayerSuccess_${oppIdx}" style="font-size:9px;padding:3px;" onchange="updateConfirmPlayerDetail(${oppIdx}, 'playSuccess', this.value)" title="Success/Unsuccess">
          <option value="">S/U: ${successDisplay}</option>
          <option value="s" ${p.playSuccess === 's' ? 'selected' : ''}>‚úì Success</option>
          <option value="u" ${p.playSuccess === 'u' ? 'selected' : ''}>‚úó Unsuccess</option>
        </select>
        <select id="confirmPlayerPressure_${oppIdx}" style="font-size:9px;padding:3px;" onchange="updateConfirmPlayerDetail(${oppIdx}, 'pressure', this.value)" title="Pressured By">
          <option value="">Press: ${pressureDisplay}</option>
          ${(S.rosters?.home || []).concat(S.rosters?.away || []).map(r => `<option value="${r.num}" ${p.pressure == r.num ? 'selected' : ''}>#${r.num}</option>`).join('')}
        </select>
      </div>`;
    });
    html += '</div>';
  }
  
  container.innerHTML = html || '<span style="color:var(--muted);">No players</span>';
}

/**
 * v23.9: Update player detail in confirmation modal
 */
function updateConfirmPlayerDetail(playerIdx, field, value) {
  const allPlayers = S.curr.players.filter(p => p.role?.startsWith('event') || (!p.role?.startsWith('opp') && p.role))
    .concat(S.curr.players.filter(p => p.role?.startsWith('opp')));
  
  if (playerIdx >= 0 && playerIdx < allPlayers.length) {
    const player = allPlayers[playerIdx];
    if (field === 'playD1') player.playD1 = value;
    else if (field === 'playD2') player.playD2 = value;
    else if (field === 'playSuccess') player.playSuccess = value;
    else if (field === 'pressure') player.pressure = value;
  }
}

function onConfirmTypeChange() {
  const type = document.getElementById('confirmType').value;
  const d1Options = LISTS.details[type]?.d1 || [];
  document.getElementById('confirmD1').innerHTML = '<option value="">--</option>' + 
    d1Options.map(o => `<option value="${o}">${o}</option>`).join('');
  document.getElementById('confirmD2').innerHTML = '<option value="">--</option>';
}

function onConfirmD1Change() {
  const type = document.getElementById('confirmType').value;
  const d1 = document.getElementById('confirmD1').value;
  
  let d2Opts = [];
  
  // If no detail1 selected, clear detail2
  if (!d1 || d1 === '') {
    document.getElementById('confirmD2').innerHTML = '<option value="">--</option>';
    return;
  }
  
  // Special handling for Penalty - always use LISTS.details
  if (d1.startsWith('Penalty_')) {
    const penaltyOpts = LISTS.details.Penalty || {};
    if (penaltyOpts.d2 && penaltyOpts.d2.length > 0) {
      d2Opts = penaltyOpts.d2;
    }
  }
  // v16.08: Use S.eventDetails2 from dim_event_detail_2 - filter by code prefix
  else if (S.eventDetails2?.length > 0) {
    // Determine code prefix based on detail1 value
    let codePrefix = null;
    if (d1.startsWith('Shot_')) codePrefix = 'Shot_';
    else if (d1.startsWith('Pass_')) codePrefix = 'Pass_';
    else if (d1.startsWith('Goal_')) codePrefix = 'Goal_';
    else if (d1.startsWith('Save_')) codePrefix = 'Save_';
    else if (d1.includes('Giveaway')) codePrefix = 'Giveaway_';
    else if (d1.includes('Takeaway')) codePrefix = 'Takeaway_';
    else if (d1.includes('Entry')) codePrefix = 'ZoneEntry_';
    else if (d1.includes('Exit') || d1.includes('Keepin')) codePrefix = 'ZoneExit_';
    else if (d1 === 'Stoppage_Play') codePrefix = 'Stoppage_';
    else if (d1 === 'Play_Offensive') codePrefix = 'PlayOffensive_';
    else if (d1 === 'Play_Defensive') codePrefix = 'PlayDefensive_';
    else if (d1.startsWith('Faceoff_') || (type === 'Faceoff' && (d1.includes('Faceoff') || d1.includes('GameStart')))) codePrefix = 'Faceoff_';
    else if (d1.startsWith('Possession_')) codePrefix = 'Possession_';
    else if (d1.startsWith('Rebound_')) codePrefix = 'Rebound_';
    
    if (codePrefix) {
      d2Opts = S.eventDetails2
        .filter(e => e.code && e.code.startsWith(codePrefix))
        .map(e => e.code || e.name); // Use code, fallback to name
      console.log('Confirm Detail2 filter from Supabase:', codePrefix, '‚Üí', d2Opts.length, 'options', d2Opts);
    } else {
      console.log('No code prefix matched for d1:', d1);
    }
  }
  
  // Fall back to LISTS.details - also merge with Supabase for giveaway types to ensure all options
  const opts = LISTS.details[type] || {};
  
  // For giveaway types, always merge fallback options to ensure all types are available
  if ((d1.includes('Giveaway') || d1 === 'Turnover_Giveaway') && opts.d2_Giveaway) {
    const fallbackOpts = opts.d2_Giveaway || [];
    fallbackOpts.forEach(opt => {
      if (!d2Opts.includes(opt)) d2Opts.push(opt);
    });
  }
  
  // If no Supabase results at all, use fallback
  if (d2Opts.length === 0) {
    d2Opts = opts.d2 || [];
    if (d1.includes('Takeaway') && opts.d2_Takeaway) d2Opts = opts.d2_Takeaway;
    else if (d1.includes('Entry') && opts.d2_Entry) d2Opts = opts.d2_Entry;
    else if (d1.includes('Exit') && opts.d2_Exit) d2Opts = opts.d2_Exit;
    else if (d1.includes('Play') && opts.d2_Play) d2Opts = opts.d2_Play;
    else if (d1.includes('Offensive') && opts.d2_Offensive) d2Opts = opts.d2_Offensive;
    else if (d1.includes('Defensive') && opts.d2_Defensive) d2Opts = opts.d2_Defensive;
    else if (d1.includes('Keepin') && opts.d2_Exit) d2Opts = opts.d2_Exit;
    
    if (d2Opts.length > 0) {
      console.log('Using fallback LISTS.details for confirm detail2:', d2Opts.length, 'options', d2Opts);
    } else {
      console.log('No detail2 options found for type:', type, 'd1:', d1);
    }
  }
  
  document.getElementById('confirmD2').innerHTML = '<option value="">--</option>' + 
    d2Opts.map(o => `<option value="${o}">${o}</option>`).join('');
}

function closeConfirmModal() {
  console.log('closeConfirmModal() called');
  const modal = document.getElementById('confirmEventModal');
  if (!modal) {
    console.error('confirmEventModal not found in closeConfirmModal');
    return;
  }
  
  console.log('Removing show class and hiding modal');
  modal.classList.remove('show');
  
  // Force hide with inline styles (same approach as closeSettings)
  modal.style.setProperty('display', 'none', 'important');
  modal.style.setProperty('visibility', 'hidden', 'important');
  modal.style.setProperty('opacity', '0', 'important');
  modal.style.setProperty('z-index', '-1', 'important');
  
  console.log('Modal closed. display:', modal.style.display);
}

// Ensure closeConfirmModal is globally accessible
if (typeof window !== 'undefined') {
  window.closeConfirmModal = closeConfirmModal;
}

/**
 * v23.3: Confirm and log the event, then continue tracking
 */
function confirmAndContinue() {
  // Clear linked index before logging - "log & continue" should not create linked events
  document.getElementById('confirmLinked').value = '';
  S.linkedEventIdx = null;
  doLogEvent();
  closeConfirmModal();
}

// Ensure confirmAndContinue is globally accessible
if (typeof window !== 'undefined') {
  window.confirmAndContinue = confirmAndContinue;
}

/**
 * v23.3: Confirm and log the event
 */
function confirmAndLog() {
  doLogEvent();
  closeConfirmModal();
}

// Ensure confirmAndLog is globally accessible
if (typeof window !== 'undefined') {
  window.confirmAndLog = confirmAndLog;
}

/**
 * v23.9: Confirm and log the event, then auto-create next linked event
 */
function confirmAndLogWithNext() {
  // First log the current event
  const eventCountBefore = S.events.length;
  doLogEvent();
  closeConfirmModal();
  
  // Check if event was actually logged
  if (S.events.length === eventCountBefore) {
    console.error('confirmAndLogWithNext: Event was not logged');
    toast('Failed to log event', 'error');
    return;
  }
  
  // Check for templates and auto-create next event
  setTimeout(() => {
    const lastEvt = S.events[S.events.length - 1];
    if (lastEvt) {
      // Carry over the linked index from the just-logged event
      if (lastEvt.linkedEventIdx !== null) {
        S.linkedEventIdx = lastEvt.linkedEventIdx;
        const linkedSel = document.getElementById('linkedEvtSelect');
        if (linkedSel) {
          linkedSel.value = lastEvt.linkedEventIdx;
        }
      }
      
      const created = autoCreateNextLinkedEvent(lastEvt);
      if (!created) {
        // No template matched - just clear the form for next event
        clearEvent();
        // Set next event start time to previous event end time
        if (lastEvt.end_time) {
          document.getElementById('evtStartTime').value = lastEvt.end_time;
        }
        toast('Event logged. Ready for next event.', 'success');
      }
    }
  }, 100);
}

// Ensure confirmAndLogWithNext is globally accessible
if (typeof window !== 'undefined') {
  window.confirmAndLogWithNext = confirmAndLogWithNext;
}

/**
 * v23.9: Log event and create a linked event after it
 * Creates a blank linked event (unlike Log & Next which uses templates)
 */
function confirmAndLogAndAddLinked() {
  // Log the event first
  doLogEvent();
  closeConfirmModal();
  
  // Then create a blank linked event after it
  setTimeout(() => {
    const lastEvt = S.events[S.events.length - 1];
    if (lastEvt) {
      const newEvtIdx = S.events.length; // This will be the index of the new event
      
      // Create new blank event linked to the just-logged event
      // Use the same linked index as the just-logged event
      const linkedIdx = lastEvt.linkedEventIdx !== null ? lastEvt.linkedEventIdx : getNextLinkedEventIdx();
      const newEvt = {
        period: lastEvt.period,
        team: lastEvt.team,
        type: '',
        detail1: '',
        detail2: '',
        zone: lastEvt.zone || '',
        success: '',
        strength: lastEvt.strength || '5v5',
        start_time: lastEvt.start_time,
        end_time: '',
        players: [],
        puckXY: [],
        linkedEventIdx: linkedIdx, // Use linked index, not event idx
        assistToGoalIdx: null,
        isHighlight: false
      };
      
      // Copy XY data from the just-logged event
      if (lastEvt.puckXY?.length) {
        newEvt.puckXY = JSON.parse(JSON.stringify(lastEvt.puckXY));
      }
      if (lastEvt.netXY) {
        newEvt.netXY = JSON.parse(JSON.stringify(lastEvt.netXY));
      }
      if (lastEvt.players?.length) {
        newEvt.players = JSON.parse(JSON.stringify(lastEvt.players));
      }
      
      // Add to events array
      newEvt.idx = S.evtIdx++;
      S.events.push(newEvt);
      markDataChanged();
      
      // Update UI
      renderEvents();
      updateScores();
      updateBoxScore();
      autoSave();
      
      toast(`Created linked event #${newEvtIdx + 1} ‚Üê #${lastEvt.idx + 1}`, 'success');
      
      // Open the new event for editing
      setTimeout(() => editEvent(newEvtIdx), 100);
    }
  }, 100);
}

// Ensure confirmAndLogAndAddLinked is globally accessible
if (typeof window !== 'undefined') {
  window.confirmAndLogAndAddLinked = confirmAndLogAndAddLinked;
}

/**
 * v23.3: Actually log the event (called from confirmation modal)
 */
function doLogEvent() {
  // Get values from confirmation modal
  const type = document.getElementById('confirmType').value;
  const team = document.getElementById('confirmTeam').value;
  const detail1 = document.getElementById('confirmD1').value;
  const detail2 = document.getElementById('confirmD2').value;
  const zone = document.getElementById('confirmZone').value;
  const success = document.getElementById('confirmSuccess').value;
  const strength = document.getElementById('confirmStrength').value;
  const startTime = document.getElementById('confirmStartTime').value;
  const endTime = document.getElementById('confirmEndTime').value || startTime;
  const isHighlight = document.getElementById('confirmHighlight').checked;
  let videoUrl = isHighlight ? (document.getElementById('confirmVideoUrl')?.value.trim() || '') : '';
  
  // v23.9: If highlight but no videoUrl, use main YouTube link with start time
  if (isHighlight && !videoUrl && S.videoTiming?.youtubeUrl) {
    const runningVideoTime = calculateRunningVideoTime(S.period, startTime);
    const startTimeSeconds = Math.max(0, runningVideoTime - 10); // 10 seconds before event
    videoUrl = buildYouTubeUrlWithTime(S.videoTiming.youtubeUrl, startTimeSeconds);
  }
  const linkedInput = document.getElementById('confirmLinked').value;
  const linkedEventIdx = linkedInput ? parseInt(linkedInput) - 1 : null;
  
  // Detect pressure for all event players
  detectPressure();
  
  // v23.3: For Possession and Zone_Entry_Exit (rush/carry), copy ONLY event_player_1's XY to puckXY
  const isPossessionEvent = type === 'Possession' || 
    (type === 'Zone_Entry_Exit' && (detail2.includes('Rush') || detail2.includes('Carried') || detail1.includes('Entry')));
  
  if (isPossessionEvent && S.curr.puckXY.length === 0) {
    const evtPlayer1 = S.curr.players.find(p => 
      p.role === 'event_team_player_1' || p.role === 'event_player_1' || p.roleNum === 1
    );
    if (evtPlayer1?.xy?.length > 0) {
      S.curr.puckXY = evtPlayer1.xy.map(xy => ({...xy}));
      console.log(`Copied #${evtPlayer1.num}'s XY to puckXY for ${type}`);
    }
  }
  
  // Build linked event chain
  let linkedEventChain = [];
  if (linkedEventIdx !== null) {
    linkedEventChain.push(linkedEventIdx);
    const linkedEvt = S.events.find(e => e.idx === linkedEventIdx);
    if (linkedEvt?.linkedEventChain?.length) {
      linkedEventChain = [...linkedEvt.linkedEventChain, linkedEventIdx];
    }
  }
  
  // v23.9: Ensure detail1 and detail2 are always populated (use type as fallback)
  const finalDetail1 = detail1 || type || '';
  const finalDetail2 = detail2 || '';
  
  // Get codes and IDs for export (display uses names)
  const typeInfo = getEventTypeCodeAndId(type);
  const detail1Info = getEventDetailCodeAndId(finalDetail1, type);
  const detail2Info = getEventDetail2CodeAndId(finalDetail2);
  
  // Calculate adjusted video time (go back up to 10 seconds, or to nearest faceoff)
  const adjustedVideoTime = calculateAdjustedVideoTime(S.period, startTime, type);
  
  const evt = {
    idx: S.evtIdx++,
    game_id: S.gameId,
    period: S.period,
    start_time: startTime,
    end_time: endTime,
    team: team,
    type: type,  // Display name
    typeCode: typeInfo.code,  // Export code
    typeId: typeInfo.id,  // Export ID
    detail1: finalDetail1,  // Display name
    detail1Code: detail1Info.code,  // Export code
    detail1Id: detail1Info.id,  // Export ID
    detail2: finalDetail2,  // Display name
    detail2Code: detail2Info.code,  // Export code
    detail2Id: detail2Info.id,  // Export ID
    zone,
    success,
    strength,
    linkedEventIdx: linkedEventIdx,
    linkedEventChain,
    isHighlight,
    videoUrl: isHighlight ? videoUrl : undefined,  // v23.7: Individual highlight video URL
    adjustedVideoTime: adjustedVideoTime,  // Adjusted time for video playback
    puckXY: [...S.curr.puckXY],
    netXY: S.curr.netXY,
    // v23.9: Use players from S.curr which may have been updated in confirmation modal
    players: S.curr.players.map(p => ({...p, xy: [...(p.xy || [])]}))
  };
  
  // v23.9: Apply custom rules before pushing
  applyCustomRules(evt);
  
  S.events.push(evt);
  markDataChanged();
  
  // v23.8: Apply custom linking rules (only if linked index is explicitly set)
  // Don't auto-link events unless user explicitly requested it
  if (linkedEventIdx !== null) {
    applyCustomLinkingRules(evt);
  }
  
  // v23.9: Apply cross-event rules (e.g., if next is giveaway, previous is unsuccessful)
  applyCrossEventRules(S.events.length - 1);
  
  // v23.4: Auto-sort and reindex events by time
  sortAndReindexEvents();
  
  // v23.8: Auto-detect assists for Goals
  if (evt.type === 'Goal') {
    detectAndLinkAssists(evt);
  }
  
  // v23.8: Determine end time (use start time if no end time)
  const actualEndTime = endTime || startTime;
  S.lastEndTime = actualEndTime;
  
  // v23.9: Use end time as next start time (instead of decrementing by 1 second)
  let nextStartTime = actualEndTime;
  
  // v23.9: Auto-switch teams based on event type
  const shouldSwitchTeam = shouldAutoSwitchTeam(evt.type, finalDetail1, finalDetail2);
  if (shouldSwitchTeam) {
    const newTeam = team === 'home' ? 'away' : 'home';
    setEvtTeam(newTeam);
    toast(`Team switched to ${newTeam === 'home' ? S.homeTeam || 'Home' : S.awayTeam || 'Away'}`, 'info');
  }
  
  // Clear linked index - don't auto-create linked events
  S.linkedEventIdx = null;
  const linkedSel = document.getElementById('linkedEvtSelect');
  if (linkedSel) {
    linkedSel.value = '';
  }
  
  const highlightIcon = isHighlight ? ' ‚≠ê' : '';
  toast(`Event #${evt.idx + 1}: ${evt.type}${highlightIcon}`, 'success');
  
  clearEvent();
  
  // v23.9: Apply next event player/team mapping rules from templates
  const mappedPlayers = applyNextEventMappingRules(evt);
  
  // Helper function to get last XY point from logged event for a player
  const getLastXYForPlayer = (playerNum, playerTeam) => {
    const loggedPlayer = evt.players.find(p => 
      p.num === playerNum && 
      (p.team || evt.team) === (playerTeam || evt.team)
    );
    if (loggedPlayer && loggedPlayer.xy && loggedPlayer.xy.length > 0) {
      const lastXY = loggedPlayer.xy[loggedPlayer.xy.length - 1];
      return [{ x: lastXY.x, y: lastXY.y, seq: 1 }];
    }
    return [];
  };
  
  // Check if events are linked - only carry over play details if linked
  const isLinked = evt.linkedEventIdx !== null && evt.linkedEventIdx !== undefined;
  
  // Use mapped players if template applied, otherwise preserve from logged event
  if (mappedPlayers && mappedPlayers.length > 0) {
    // For mapped players, carry over last XY point from logged event
    mappedPlayers.forEach(mappedPlayer => {
      const lastXY = getLastXYForPlayer(mappedPlayer.num, mappedPlayer.team);
      if (lastXY.length > 0) {
        mappedPlayer.xy = lastXY;
      } else {
        mappedPlayer.xy = [];
      }
      // Only carry over play details if events are linked
      if (!isLinked) {
        mappedPlayer.playD1 = '';
        mappedPlayer.playD2 = '';
        mappedPlayer.playSuccess = '';
      }
    });
    S.curr.players = mappedPlayers;
    renumberPlayers();
  } else if (evt.players && evt.players.length > 0) {
    // Preserve players from logged event - only the last XY point for each player
    S.curr.players = evt.players.map(p => {
      const playerCopy = {...p};
      // Only keep the last XY point as the starting point for the next event
      if (p.xy && p.xy.length > 0) {
        const lastXY = p.xy[p.xy.length - 1];
        playerCopy.xy = [{ x: lastXY.x, y: lastXY.y, seq: 1 }];
      } else {
        playerCopy.xy = [];
      }
      // Only carry over play details (playD1, playD2, playSuccess) if events are linked
      if (!isLinked) {
        playerCopy.playD1 = '';
        playerCopy.playD2 = '';
        playerCopy.playSuccess = '';
      }
      return playerCopy;
    });
  } else {
    S.curr.players = [];
  }
  
  // Also carry over puck XY - only the last point from logged event
  if (evt.puckXY && evt.puckXY.length > 0) {
    const lastPuckXY = evt.puckXY[evt.puckXY.length - 1];
    S.curr.puckXY = [{ x: lastPuckXY.x, y: lastPuckXY.y, seq: 1 }];
  } else {
    S.curr.puckXY = [];
  }
  
  if (S.curr.players.length > 0) {
    renderQuickAdd();
    renderXYSlots();
  }
  
  document.getElementById('evtStartTime').value = nextStartTime;
  
  renderEvents(); renderMarkers(); updateScores(); updateBoxScore();
  updateNextPlaySuggestions();
  autoSave();
  
  if (document.getElementById('autoEditNext')?.checked) {
    setTimeout(() => editEvent(S.events.length - 1), 100);
  }
}

/**
 * v23.3: Auto-populate goalie for Shot/Save events
 * For Shot_OnNet: Add opposing goalie as opp_team_player_1
 * For Save: Add event team goalie as event_team_player_1
 */
function autoPopulateGoalie() {
  const type = S.curr.type;
  const d1 = document.getElementById('evtD1').value;
  
  // Only for shots on net or saves
  const isShotOnNet = type === 'Shot' && (d1.includes('OnNet') || d1.includes('Goal'));
  const isSave = type === 'Save';
  
  if (!isShotOnNet && !isSave) return;
  
  if (isShotOnNet) {
    // Add opposing goalie as opp_team_player_1
    const oppTeam = S.evtTeam === 'home' ? 'away' : 'home';
    const oppGoalie = S.slots[oppTeam]?.G;
    
    if (oppGoalie) {
      // Check if goalie already added
      const existing = S.curr.players.find(p => p.num === oppGoalie.num);
      if (!existing) {
        S.curr.players.push({
          num: oppGoalie.num,
          name: oppGoalie.name,
          team: oppTeam,
          role: 'opp_team_player_1',
          roleNum: 1,
          xy: [],
          playD1: 'Save_Attempt',
          playD2: '',
          playSuccess: '',
          pressuredBy: '',
          sideOfPuck: ''
        });
        renumberPlayers();
        renderQuickAdd();
        toast(`Auto-added goalie #${oppGoalie.num} as O1`, 'info');
      }
    }
  } else if (isSave) {
    // Add event team goalie as event_team_player_1
    const evtGoalie = S.slots[S.evtTeam]?.G;
    
    if (evtGoalie) {
      // Check if goalie already added
      const existing = S.curr.players.find(p => p.num === evtGoalie.num);
      if (!existing) {
        S.curr.players.push({
          num: evtGoalie.num,
          name: evtGoalie.name,
          team: S.evtTeam,
          role: 'event_team_player_1',
          roleNum: 1,
          xy: [],
          playD1: 'Save_Made',
          playD2: '',
          playSuccess: 's',
          pressuredBy: '',
          sideOfPuck: ''
        });
        renumberPlayers();
        renderQuickAdd();
        toast(`Auto-added goalie #${evtGoalie.num} as E1`, 'info');
      } else {
        // Goalie exists, ensure they're E1
        existing.role = 'event_team_player_1';
        existing.roleNum = 1;
        renumberPlayers();
        renderQuickAdd();
      }
    }
  }
}

/**
 * v23.3: Auto-link and setup for follow-up events (Shot ‚Üí Save, etc.)
 */
function autoLinkFollowUp(type) {
  const lastEvt = S.events[S.events.length - 1];
  if (!lastEvt) return;
  
  // Save after Shot_OnNet: auto-link, swap team, setup goalie
  if (type === 'Save' && lastEvt.type === 'Shot' && 
      (lastEvt.detail1?.includes('OnNet') || lastEvt.detail1?.includes('Goal'))) {
    // Auto-link to the shot
    S.linkedEventIdx = lastEvt.idx;
    document.getElementById('linkedEvt').value = lastEvt.idx + 1;
    
    // Swap to the other team (goalie's team)
    const newTeam = lastEvt.team === 'home' ? 'away' : 'home';
    setEvtTeam(newTeam);
    
    // Copy time from shot
    document.getElementById('evtStartTime').value = lastEvt.start_time;
    
    // Copy puck position from shot
    if (lastEvt.puckXY?.length) {
      S.curr.puckXY = lastEvt.puckXY.map(xy => ({...xy}));
    }
    
    // Copy net position from shot
    if (lastEvt.netXY) {
      S.curr.netXY = {...lastEvt.netXY};
    }
    
    toast(`Auto-linked to Shot #${lastEvt.idx + 1}`, 'info');
  }
  
  // Rebound after Save: auto-link
  if (type === 'Rebound' && lastEvt.type === 'Save') {
    S.linkedEventIdx = lastEvt.idx;
    document.getElementById('linkedEvt').value = lastEvt.idx + 1;
    document.getElementById('evtStartTime').value = lastEvt.start_time;
    toast(`Auto-linked to Save #${lastEvt.idx + 1}`, 'info');
  }
}

function clearEvent() {
  const preserveStartTime = document.getElementById('evtStartTime').value;
  // v23.9: Preserve players - don't clear them (they'll be carried over)
  const preservedPlayers = S.curr.players || [];
  S.curr = { type: null, players: preservedPlayers, puckXY: [], netXY: null };
  S.selectedPlayer = null;
  S.xySlot = 1;
  S.xyHistory = [];
  // Clear highlighting when clearing event
  S.highlightedXYSeq = null;
  S.highlightedXYType = null;
  S.highlightedXYPlayerNum = null;
  document.querySelectorAll('.evt-btn').forEach(b => b.classList.remove('active'));
  document.getElementById('evtD1').innerHTML = '<option value="">--</option>';
  document.getElementById('evtD2').innerHTML = '<option value="">--</option>';
  document.getElementById('evtZone').value = '';
  document.getElementById('evtSuccess').value = '';
  document.getElementById('evtStartTime').value = preserveStartTime; // Keep for chaining
  document.getElementById('evtEndTime').value = '';
  document.getElementById('isHighlight').checked = false;
  document.getElementById('evtVideoUrl').value = '';
  const highlightVideoUrlRow = document.getElementById('highlightVideoUrlRow');
  if (highlightVideoUrlRow) highlightVideoUrlRow.style.display = 'none';
  const zoneDisplay = document.getElementById('zoneDisplay');
  if (zoneDisplay) zoneDisplay.innerHTML = '';
  renderQuickAdd(); renderXYSlots(); renderMarkers();
}

// Ensure clearEvent is globally accessible
if (typeof window !== 'undefined') {
  window.clearEvent = clearEvent;
}

// v23.7: Toggle highlight video URL field visibility
function toggleHighlightFields() {
  const isHighlight = document.getElementById('isHighlight').checked;
  document.getElementById('highlightVideoUrlRow').style.display = isHighlight ? 'block' : 'none';
  if (!isHighlight) {
    document.getElementById('evtVideoUrl').value = '';
  }
}

// v23.7: Toggle edit highlight video URL field visibility
function toggleEditHighlightFields() {
  const isHighlight = document.getElementById('editHighlight').checked;
  document.getElementById('editHighlightVideoUrlRow').style.display = isHighlight ? 'block' : 'none';
  if (!isHighlight) {
    document.getElementById('editVideoUrl').value = '';
  }
}

// v23.7: Toggle confirm highlight video URL field visibility
function toggleConfirmHighlightFields() {
  const isHighlight = document.getElementById('confirmHighlight').checked;
  document.getElementById('confirmHighlightVideoUrlRow').style.display = isHighlight ? 'block' : 'none';
  if (!isHighlight) {
    document.getElementById('confirmVideoUrl').value = '';
  }
}

// ============================================================
// QUICK TIME & EVENT HELPERS (v5)
// ============================================================

/**
 * Copy current clock time to start time field
 */
function copyClockToStart() {
  const clock = document.getElementById('clock').value;
  document.getElementById('evtStartTime').value = clock;
  toast(`Start: ${clock}`, 'info');
}

/**
 * Copy current clock time to end time field
 */
function copyClockToEnd() {
  const clock = document.getElementById('clock').value;
  document.getElementById('evtEndTime').value = clock;
  toast(`End: ${clock}`, 'info');
}

/**
 * Copy last event's end time to current start time
 */
function copyLastEventTime() {
  if (S.events.length === 0) {
    toast('No previous events', 'info');
    return;
  }
  const lastEvt = S.events[S.events.length - 1];
  const time = lastEvt.end_time || lastEvt.start_time || '';
  document.getElementById('evtStartTime').value = time;
  toast(`Copied: ${time}`, 'info');
}

/**
 * v6: Nudge start time by variable seconds
 */
function nudgeStartTime(direction) {
  const amount = parseInt(document.getElementById('timeNudgeAmount').value) || 5;
  const startTimeEl = document.getElementById('evtStartTime');
  const newTime = nudgeTime(startTimeEl.value, direction * amount);
  startTimeEl.value = newTime;
  toast(`Start: ${newTime}`, 'info');
}

/**
 * v6: Nudge end time by variable seconds
 */
function nudgeEndTime(direction) {
  const amount = parseInt(document.getElementById('timeNudgeAmount').value) || 5;
  const endTimeEl = document.getElementById('evtEndTime');
  const newTime = nudgeTime(endTimeEl.value, direction * amount);
  endTimeEl.value = newTime;
  toast(`End: ${newTime}`, 'info');
}

/**
 * v6: Helper to add/subtract seconds from a time string (MM:SS)
 * Hockey clock counts DOWN, so adding seconds means earlier in period
 */
function nudgeTime(timeStr, seconds) {
  if (!timeStr) {
    // Use clock if no time set
    timeStr = document.getElementById('clock').value || '20:00';
  }
  const [min, sec] = (timeStr || '20:00').split(':').map(Number);
  let totalSec = (min || 0) * 60 + (sec || 0);
  totalSec += seconds; // Add seconds (hockey clock, so + goes earlier)
  
  // Clamp to 0:00 - 20:00
  totalSec = Math.max(0, Math.min(1200, totalSec));
  
  const newMin = Math.floor(totalSec / 60);
  const newSec = totalSec % 60;
  return `${newMin}:${String(newSec).padStart(2, '0')}`;
}

/**
 * v23.9: Apply next event player/team mapping rules from templates
 * @param {Object} loggedEvent - The event that was just logged
 * @returns {Object|null} - Modified players array or null if no mapping applied
 */
function applyNextEventMappingRules(loggedEvent) {
  if (!S.eventChainTemplates || S.eventChainTemplates.length === 0) {
    loadDefaultEventTemplates();
  }
  
  // Find matching template for the logged event
  for (const template of S.eventChainTemplates) {
    if (matchesTemplateTrigger(loggedEvent, template.trigger)) {
      let mappedPlayers = null;
      
      // Apply next event player mapping if defined
      if (template.nextEventPlayerMapping && Object.keys(template.nextEventPlayerMapping).length > 0) {
        mappedPlayers = [];
        const sourcePlayers = loggedEvent.players || [];
        
        // Map players according to template rules
        Object.entries(template.nextEventPlayerMapping).forEach(([sourceRole, targetRole]) => {
          // Find source player by role - support various role formats
          const sourcePlayer = sourcePlayers.find(p => {
            const role = p.role || `event_team_player_${p.roleNum || 1}`;
            // Match exact role or with/without prefixes
            return role === sourceRole || 
                   role === `event_${sourceRole}` || 
                   role === `event_team_${sourceRole}` ||
                   role === `event_team_player_${sourceRole.replace(/[^0-9]/g, '')}` ||
                   (p.roleNum && `event_team_player_${p.roleNum}` === sourceRole);
          });
          
          if (sourcePlayer) {
            const newPlayer = JSON.parse(JSON.stringify(sourcePlayer));
            // Set new role (e.g., event_player_2 ‚Üí event_player_1)
            if (targetRole.startsWith('event_player_') || targetRole.startsWith('event_team_player_')) {
              const roleNum = parseInt(targetRole.replace(/[^0-9]/g, '')) || 1;
              newPlayer.role = `event_team_player_${roleNum}`;
              newPlayer.roleNum = roleNum;
              newPlayer.team = loggedEvent.team; // Keep same team unless template says otherwise
            } else if (targetRole.startsWith('opp_player_') || targetRole.startsWith('opp_team_player_')) {
              const roleNum = parseInt(targetRole.replace(/[^0-9]/g, '')) || 1;
              newPlayer.role = `opp_team_player_${roleNum}`;
              newPlayer.roleNum = roleNum;
              newPlayer.team = loggedEvent.team === 'home' ? 'away' : 'home';
            }
            // Clear XY data for next event (user can add new XY)
            newPlayer.xy = [];
            // Only carry over play details if events are linked
            const isLinked = loggedEvent.linkedEventIdx !== null && loggedEvent.linkedEventIdx !== undefined;
            if (!isLinked) {
              newPlayer.playD1 = '';
              newPlayer.playD2 = '';
              newPlayer.playSuccess = '';
            }
            mappedPlayers.push(newPlayer);
          }
        });
      }
      
      // Apply next event team rule if defined
      if (template.nextEventTeam) {
        if (template.nextEventTeam === 'opposite') {
          const newTeam = loggedEvent.team === 'home' ? 'away' : 'home';
          setEvtTeam(newTeam);
        } else if (template.nextEventTeam === 'same') {
          // Already set, no change needed
        } else if (template.nextEventTeam === 'home' || template.nextEventTeam === 'away') {
          setEvtTeam(template.nextEventTeam);
        }
      }
      
      // Return mapped players if any mapping was applied
      return mappedPlayers;
    }
  }
  
  return null; // No matching template
}

/**
 * v23.9: Determine if team should auto-switch based on event type and details
 * @param {string} type - Event type
 * @param {string} detail1 - Event detail 1
 * @param {string} detail2 - Event detail 2
 * @returns {boolean} - True if team should switch
 */
function shouldAutoSwitchTeam(type, detail1, detail2) {
  if (!type) return false;
  
  const d1 = (detail1 || '').toLowerCase();
  const d2 = (detail2 || '').toLowerCase();
  
  // Turnover events that indicate possession change
  if (type === 'Turnover') {
    // Giveaway = team loses possession, next event is usually other team
    if (d1.includes('giveaway') || d2.includes('giveaway')) {
      return true;
    }
    // Takeaway = team gains possession, but this is the gaining team's event, so don't switch
    // (the previous team's event would have been the giveaway)
  }
  
  // Pass intercepted = possession changes
  if (type === 'Pass' && (d1.includes('intercepted') || d2.includes('intercepted'))) {
    return true;
  }
  
  // Pass missed to opponent = possession might change
  if (type === 'Pass' && (d1.includes('missed') || d2.includes('missed'))) {
    // Could switch, but might be recovered by same team - be conservative
    // Only switch if explicitly intercepted
    return false;
  }
  
  // Zone exit by one team often leads to zone entry by other team
  if (type === 'Zone_Entry_Exit') {
    if (d1.includes('exit') || d2.includes('exit')) {
      // Exit often leads to other team's entry, but not always
      // Be conservative - don't auto-switch for exits
      return false;
    }
  }
  
  // Rebound recovered by opponent = possession changes
  if (type === 'Rebound') {
    if (d1.includes('opprecovered') || d2.includes('opprecovered')) {
      return true;
    }
  }
  
  // Save = goalie stops shot, next event is often other team (rebound, faceoff, etc.)
  // But save is the defending team's event, so don't switch
  // The next event (rebound, faceoff) will be logged separately
  
  return false;
}

/**
 * v23.8: Increment time by seconds (hockey clock counts down, so negative = forward in time)
 * @param {string} timeStr - Time string in MM:SS format
 * @param {number} seconds - Number of seconds to add (negative = forward in time, positive = backward)
 * @returns {string} - New time string in MM:SS format
 */
function incrementTimeBySeconds(timeStr, seconds) {
  if (!timeStr) return '18:00'; // Default if no time
  
  const parts = String(timeStr).split(':');
  if (parts.length !== 2) return timeStr; // Invalid format
  
  const min = parseInt(parts[0]) || 0;
  const sec = parseInt(parts[1]) || 0;
  let totalSec = min * 60 + sec;
  
  // Add seconds (negative = forward in time = less time on clock)
  totalSec += seconds;
  
  // Clamp to valid range (0:00 to period length)
  const periodLength = getPeriodLength(S.period) * 60; // Convert to seconds
  totalSec = Math.max(0, Math.min(periodLength, totalSec));
  
  const newMin = Math.floor(totalSec / 60);
  const newSec = totalSec % 60;
  return `${newMin}:${String(newSec).padStart(2, '0')}`;
}

/**
 * Duplicate the last event with current time
 */
function duplicateLastEvent() {
  if (S.events.length === 0) {
    toast('No events to duplicate', 'info');
    return;
  }
  
  const lastEvt = S.events[S.events.length - 1];
  
  // Set event type
  setEvtType(lastEvt.type);
  
  // Set team
  setEvtTeam(lastEvt.team);
  
  // Set details
  setTimeout(() => {
    document.getElementById('evtD1').value = lastEvt.detail1 || '';
    onD1Change();
    setTimeout(() => {
      document.getElementById('evtD2').value = lastEvt.detail2 || '';
    }, 50);
  }, 50);
  
  // Set zone, success, strength
  document.getElementById('evtZone').value = lastEvt.zone || '';
  document.getElementById('evtSuccess').value = lastEvt.success || '';
  document.getElementById('evtStrength').value = lastEvt.strength || '5v5';
  
  // Copy players
  S.curr.players = lastEvt.players.map(p => ({
    ...p,
    xy: [] // Don't copy XY - needs new positions
  }));
  
  renderQuickAdd();
  toast(`Duplicated: ${lastEvt.type}`, 'success');
}

/**
 * v23.3: Auto-format time as user types
 * 1534 ‚Üí 15:34, 0709 ‚Üí 07:09, 709 ‚Üí 7:09, 1800 ‚Üí 18:00
 * v23.8: Fixed to handle 4-digit inputs correctly (1800 ‚Üí 18:00, not 1:800)
 */
function autoFormatTime(input) {
  let val = input.value.replace(/[^0-9:]/g, '');
  
  // If already has colon, check if it's in the wrong position (e.g., "1:800")
  if (val.includes(':')) {
    const parts = val.split(':');
    // If we have something like "1:800", reformat it
    if (parts.length === 2 && parts[0].length === 1 && parts[1].length >= 2) {
      // Reconstruct: take first 2 digits from combined, then colon, then rest
      const combined = parts[0] + parts[1];
      if (combined.length === 4) {
        val = combined.slice(0, 2) + ':' + combined.slice(2);
      } else {
        // Keep as is if not 4 digits total
        input.value = val;
        return;
      }
    } else {
      // Colon is in correct position, just clean it
      input.value = val;
      return;
    }
  }
  
  // Auto-insert colon for 3-4 digit entries
  if (val.length === 3 && !val.includes(':')) {
    // 709 ‚Üí 7:09
    val = val.slice(0, 1) + ':' + val.slice(1);
  } else if (val.length === 4 && !val.includes(':')) {
    // 1534 ‚Üí 15:34, 0709 ‚Üí 07:09, 1800 ‚Üí 18:00
    val = val.slice(0, 2) + ':' + val.slice(2);
  }
  
  input.value = val;
}

// ============================================================
// v23.3: WORKFLOW AUTOMATION FEATURES
// ============================================================

/**
 * Add all players from current shift slots to the event
 */
function addAllOnIce() {
  const evtTeam = S.evtTeam;
  const oppTeam = evtTeam === 'home' ? 'away' : 'home';
  
  // Add event team players
  Object.entries(S.slots[evtTeam]).forEach(([pos, player]) => {
    if (player && !S.curr.players.find(p => p.num === player.num)) {
      const roleNum = S.curr.players.filter(p => p.role?.startsWith('event')).length + 1;
      S.curr.players.push({
        num: player.num,
        name: player.name,
        team: evtTeam,
        role: `event_team_player_${roleNum}`,
        roleNum,
        xy: [],
        playD1: '',
        playD2: '',
        playSuccess: '',
        pressuredBy: '',
        sideOfPuck: ''
      });
    }
  });
  
  // Add opposing team players
  Object.entries(S.slots[oppTeam]).forEach(([pos, player]) => {
    if (player && !S.curr.players.find(p => p.num === player.num)) {
      const roleNum = S.curr.players.filter(p => p.role?.startsWith('opp')).length + 1;
      S.curr.players.push({
        num: player.num,
        name: player.name,
        team: oppTeam,
        role: `opp_team_player_${roleNum}`,
        roleNum,
        xy: [],
        playD1: '',
        playD2: '',
        playSuccess: '',
        pressuredBy: '',
        sideOfPuck: ''
      });
    }
  });
  
  renumberPlayers();
  renderQuickAdd();
  toast(`Added ${S.curr.players.length} players from ice`, 'success');
}

/**
 * Copy all players from the last event
 */
function copyPlayersFromLast() {
  if (S.events.length === 0) {
    toast('No previous events', 'error');
    return;
  }
  
  const lastEvt = S.events[S.events.length - 1];
  if (!lastEvt.players?.length) {
    toast('Last event has no players', 'error');
    return;
  }
  
  // Copy players without XY
  S.curr.players = lastEvt.players.map(p => ({
    ...p,
    team: p.team || (p.role?.startsWith('event') ? S.evtTeam : (S.evtTeam === 'home' ? 'away' : 'home')), // v23.8: Ensure team is set
    xy: [] // Clear XY for new positions
  }));
  
  renumberPlayers();
  renderQuickAdd();
  toast(`Copied ${S.curr.players.length} players from event #${lastEvt.idx + 1}`, 'success');
}

/**
 * Quick add player by jersey number
 */
function quickAddByNumber(num, role = 'evt') {
  // Find player in rosters
  const team = role === 'evt' ? S.evtTeam : (S.evtTeam === 'home' ? 'away' : 'home');
  const roster = S.rosters[team] || [];
  const player = roster.find(p => p.num === num || p.num === String(num));
  
  if (!player) {
    // v23.3: Check if player is on opposite team
    const otherTeam = team === 'home' ? 'away' : 'home';
    const otherRoster = S.rosters[otherTeam] || [];
    const otherPlayer = otherRoster.find(p => p.num === num || p.num === String(num));
    if (otherPlayer) {
      toast(`#${num} is on ${otherTeam} team - use ${role === 'evt' ? 'Opp' : 'Event'} side`, 'warning');
    } else {
      toast(`Player #${num} not found in either roster`, 'error');
    }
    return false;
  }
  
  // Check if already added
  if (S.curr.players.find(p => p.num === player.num)) {
    toast(`#${num} already in event`, 'warning');
    return false;
  }
  
  // v23.3: Guard - check if adding this player would create mixed teams
  const existingPlayers = S.curr.players.filter(p => p.role?.startsWith(role === 'evt' ? 'event' : 'opp'));
  if (existingPlayers.length > 0) {
    const existingTeam = existingPlayers[0].team;
    if (existingTeam !== team) {
      toast(`${role === 'evt' ? 'Event' : 'Opp'} players must all be from same team (${existingTeam})`, 'error');
      return false;
    }
  }
  
  const roleNum = S.curr.players.filter(p => p.role?.startsWith(role === 'evt' ? 'event' : 'opp')).length + 1;
  S.curr.players.push({
    num: player.num,
    name: player.name,
    team: team,
    role: `${role === 'evt' ? 'event' : 'opp'}_team_player_${roleNum}`,
    roleNum,
    xy: [],
    playD1: '',
    playD2: '',
    playSuccess: '',
    pressuredBy: '',
    sideOfPuck: ''
  });
  
  renumberPlayers();
  renderQuickAdd();
  toast(`Added #${num} ${player.name} as ${role === 'evt' ? 'E' : 'O'}${roleNum}`, 'success');
  return true;
}

/**
 * Toggle sequence mode - auto-links events and keeps same time
 */
let sequenceModeActive = false;
function toggleSequenceMode() {
  sequenceModeActive = !sequenceModeActive;
  const btn = document.getElementById('seqModeBtn');
  if (btn) {
    btn.classList.toggle('active', sequenceModeActive);
    btn.style.background = sequenceModeActive ? 'var(--accent)' : '';
    btn.style.color = sequenceModeActive ? '#000' : '';
  }
  toast(`Sequence mode: ${sequenceModeActive ? 'ON' : 'OFF'}`, sequenceModeActive ? 'success' : 'info');
  
  if (sequenceModeActive && S.events.length > 0) {
    // Auto-link to last event
    const lastEvt = S.events[S.events.length - 1];
    S.linkedEventIdx = lastEvt.idx;
    document.getElementById('linkedEvt').value = lastEvt.idx + 1;
    document.getElementById('evtStartTime').value = lastEvt.start_time;
  }
}

/**
 * Get suggested next event type based on last event
 */
function getSuggestedNextEvent() {
  if (S.events.length === 0) return null;
  
  const lastEvt = S.events[S.events.length - 1];
  const type = lastEvt.type;
  const d1 = lastEvt.detail1 || '';
  
  // Shot on net ‚Üí Save
  if (type === 'Shot' && (d1.includes('OnNet') || d1.includes('Goal'))) {
    return { type: 'Save', reason: 'after shot on net' };
  }
  
  // Save ‚Üí Rebound or Possession
  if (type === 'Save') {
    return { type: 'Rebound', reason: 'after save', alt: 'Possession' };
  }
  
  // Faceoff ‚Üí Possession
  if (type === 'Faceoff') {
    return { type: 'Possession', reason: 'after faceoff' };
  }
  
  // Zone entry ‚Üí Possession or Shot
  if (type === 'Zone_Entry_Exit' && d1.includes('Entry')) {
    return { type: 'Possession', reason: 'after zone entry', alt: 'Shot' };
  }
  
  // Turnover takeaway ‚Üí Possession
  if (type === 'Turnover' && d1.includes('Takeaway')) {
    return { type: 'Possession', reason: 'after takeaway' };
  }
  
  // Pass completed ‚Üí continue possession or shot
  if (type === 'Pass' && lastEvt.success === 's') {
    return { type: 'Shot', reason: 'after pass', alt: 'Pass' };
  }
  
  return null;
}

/**
 * Highlight suggested next event button
 */
function highlightSuggestedEvent() {
  // Clear previous highlights
  document.querySelectorAll('.evt-btn.suggested').forEach(b => b.classList.remove('suggested'));
  
  const suggestion = getSuggestedNextEvent();
  if (suggestion) {
    const btn = document.querySelector(`.evt-btn[data-type="${suggestion.type}"]`);
    if (btn) {
      btn.classList.add('suggested');
      btn.title = `Suggested: ${suggestion.reason}`;
    }
    if (suggestion.alt) {
      const altBtn = document.querySelector(`.evt-btn[data-type="${suggestion.alt}"]`);
      if (altBtn) altBtn.classList.add('suggested');
    }
  }
}

/**
 * Quick faceoff - click zone and winner
 */
function quickFaceoff(zone, winner) {
  // Set event type
  setEvtType('Faceoff');

  // Set zone
  document.getElementById('evtZone').value = zone;

  // Set team and detail based on winner
  if (winner === 'evt') {
    document.getElementById('evtD1').value = 'Faceoff_Won';
    document.getElementById('evtSuccess').value = 's';
  } else {
    document.getElementById('evtD1').value = 'Faceoff_Lost';
    document.getElementById('evtSuccess').value = 'u';
  }

  // v23.8: Auto-populate F1 players for faceoff
  autoPopulateFaceoffPlayers();

  // Copy clock time
  document.getElementById('evtStartTime').value = document.getElementById('clock').value;

  renderQuickAdd();
  toast(`Faceoff: ${zone.toUpperCase()} zone, ${winner === 'evt' ? 'Won' : 'Lost'}`, 'success');
}

/**
 * v23.8: Auto-populate F1 players for faceoff events
 */
function autoPopulateFaceoffPlayers() {
  // Clear current players first
  S.curr.players = [];
  
  // Get F1 from event team
  const eventF1 = S.slots[S.evtTeam]?.F1;
  if (eventF1) {
    S.curr.players.push({
      num: eventF1.num,
      name: eventF1.name,
      role: 'event_player_1',
      team: S.evtTeam
    });
  }
  
  // Get F1 from opponent team
  const oppTeam = S.evtTeam === 'home' ? 'away' : 'home';
  const oppF1 = S.slots[oppTeam]?.F1;
  if (oppF1) {
    S.curr.players.push({
      num: oppF1.num,
      name: oppF1.name,
      role: 'opp_player_1',
      team: oppTeam
    });
  }
  
  // Update UI
  if (typeof renderCurrentPlayers === 'function') renderCurrentPlayers();
  if (typeof renderQuickAdd === 'function') renderQuickAdd();
}

/**
 * Smart first click: if puck mode and no puck XY, place puck; else place player
 * Called from rink click handler
 */
function smartFirstClick() {
  // If in player mode but no players added, switch to puck first
  if (S.xyMode === 'player' && S.curr.players.length === 0 && S.curr.puckXY.length === 0) {
    setXYMode('puck');
    toast('No players - placing puck first', 'info');
    return true; // Handled
  }
  return false; // Let normal handler proceed
}

/**
 * Handle jersey number input (type number to add player)
 */
let jerseyInputBuffer = '';
let jerseyInputTimeout = null;

function handleJerseyInput(key) {
  // Only handle if a digit
  if (!/^\d$/.test(key)) {
    jerseyInputBuffer = '';
    return false;
  }
  
  jerseyInputBuffer += key;
  
  // Clear timeout
  if (jerseyInputTimeout) clearTimeout(jerseyInputTimeout);
  
  // Wait for more digits or timeout
  jerseyInputTimeout = setTimeout(() => {
    if (jerseyInputBuffer.length > 0) {
      const num = parseInt(jerseyInputBuffer);
      if (num > 0 && num < 100) {
        quickAddByNumber(num, 'evt');
      }
      jerseyInputBuffer = '';
    }
  }, 500); // 500ms timeout
  
  return true;
}

// Add CSS for suggested events
const suggestedStyle = document.createElement('style');
suggestedStyle.textContent = `
  .evt-btn.suggested { 
    box-shadow: 0 0 0 2px var(--accent), 0 0 8px var(--accent); 
    animation: pulse-suggest 1s infinite;
  }
  @keyframes pulse-suggest {
    0%, 100% { box-shadow: 0 0 0 2px var(--accent), 0 0 8px var(--accent); }
    50% { box-shadow: 0 0 0 2px var(--accent), 0 0 15px var(--accent); }
  }
  .btn-sm.mode-active {
    background: var(--accent) !important;
    color: #000 !important;
  }
`;
document.head.appendChild(suggestedStyle);

// ============================================================
// v23.3: QUICK PENALTY
// ============================================================

/**
 * Populate quick penalty player dropdown based on event team
 */
function updateQuickPenaltyPlayers() {
  const team = S.evtTeam;
  const roster = S.rosters[team] || [];
  const select = document.getElementById('quickPenPlayer');
  if (!select) return;
  
  select.innerHTML = '<option value="">Player #</option>' + 
    roster.map(p => `<option value="${p.num}">#${p.num} ${p.name}</option>`).join('');
}

/**
 * Log a penalty quickly
 */
function quickPenalty() {
  const playerNum = document.getElementById('quickPenPlayer').value;
  const penType = document.getElementById('quickPenType').value;
  
  if (!playerNum || !penType) {
    toast('Select player and penalty type', 'error');
    return;
  }
  
  // Set event type
  setEvtType('Penalty');
  
  // Set detail
  setTimeout(() => {
    document.getElementById('evtD1').value = penType;
    
    // Add player
    quickAddByNumber(parseInt(playerNum), 'evt');
    
    // Set time
    document.getElementById('evtStartTime').value = document.getElementById('clock').value;
    
    // Auto-log
    logEventDirect();
    
    // Reset dropdowns
    document.getElementById('quickPenPlayer').value = '';
    document.getElementById('quickPenType').value = '';
    
    // v23.4: Start power play timer
    startPowerPlay(S.evtTeam === 'home' ? 'away' : 'home');
    
    toast(`Penalty: #${playerNum} - ${penType.replace('Penalty_', '')}`, 'success');
  }, 50);
}

// ============================================================
// v23.4: QUICK STOPPAGE
// ============================================================

/**
 * Log a stoppage quickly
 */
function quickStoppage(type) {
  setEvtType('Stoppage');
  
  setTimeout(() => {
    document.getElementById('evtD1').value = `Stoppage_${type}`;
    document.getElementById('evtStartTime').value = document.getElementById('clock').value;
    document.getElementById('evtZone').value = type === 'Icing' ? 'd' : 'n';
    
    // Auto-log
    logEventDirect();
    
    toast(`Stoppage: ${type}`, 'success');
  }, 50);
}

// ============================================================
// v23.4: UNDO LAST EVENT
// ============================================================

/**
 * Undo the last logged event
 */
function undoLastEvent() {
  if (S.events.length === 0) {
    toast('No events to undo', 'warning');
    return;
  }
  
  const lastEvt = S.events.pop();
  S.evtIdx = Math.max(0, S.evtIdx - 1);
  
  toast(`Undid event #${lastEvt.idx + 1}: ${lastEvt.type}`, 'success');
  
  renderEvents();
  renderMarkers();
  updateScores();
  updateBoxScore();
  updateNextPlaySuggestions();
  autoSave();
}

// ============================================================
// v23.4: POWER PLAY TIMER
// ============================================================
let ppTimerInterval = null;
let ppTimerSeconds = 180; // Default 3 minutes for rec league
let ppTeam = null;
let penaltyMinutes = 3; // Configurable penalty minutes

/**
 * Update penalty minutes setting
 */
function updatePPMinutes() {
  const input = document.getElementById('ppMinutes');
  if (input) {
    penaltyMinutes = parseInt(input.value) || 3;
    localStorage.setItem('benchsight_penaltyMinutes', penaltyMinutes);
  }
}

/**
 * Start power play timer
 */
function startPowerPlay(team) {
  ppTeam = team;
  
  // Use configurable penalty minutes
  const mins = parseInt(document.getElementById('ppMinutes')?.value) || penaltyMinutes;
  ppTimerSeconds = mins * 60;
  
  const row = document.getElementById('ppTimerRow');
  const teamEl = document.getElementById('ppTimerTeam');
  const displayEl = document.getElementById('ppTimerDisplay');
  
  if (!row) return;
  
  row.style.display = 'flex';
  teamEl.textContent = `${team === 'home' ? (S.homeTeam || 'Home') : (S.awayTeam || 'Away')} PP:`;
  row.style.background = team === 'home' ? 'var(--home)' : 'var(--away)';
  
  // Update display
  displayEl.textContent = `${mins}:00`;
  
  // Update strength dropdown
  document.getElementById('evtStrength').value = team === S.evtTeam ? '5v4' : '4v5';
  
  // Clear existing timer
  if (ppTimerInterval) clearInterval(ppTimerInterval);
  
  // Start countdown
  ppTimerInterval = setInterval(() => {
    ppTimerSeconds--;
    const min = Math.floor(ppTimerSeconds / 60);
    const sec = ppTimerSeconds % 60;
    displayEl.textContent = `${min}:${String(sec).padStart(2, '0')}`;
    
    if (ppTimerSeconds <= 0) {
      endPowerPlay();
    }
  }, 1000);
  
  toast(`Power Play started: ${team === 'home' ? S.homeTeam : S.awayTeam} (${mins} min)`, 'info');
}

/**
 * End power play timer
 */
function endPowerPlay() {
  if (ppTimerInterval) {
    clearInterval(ppTimerInterval);
    ppTimerInterval = null;
  }
  
  const row = document.getElementById('ppTimerRow');
  if (row) row.style.display = 'none';
  
  document.getElementById('evtStrength').value = '5v5';
  ppTeam = null;
  
  toast('Power Play ended', 'info');
}

// ============================================================
// v23.4: EVENT TEMPLATES
// ============================================================

const EVENT_TEMPLATES = {
  dumpAndChase: {
    name: 'Dump & Chase',
    events: [
      { type: 'Zone_Entry_Exit', d1: 'Zone_Entry', d2: 'Entry_Dump', zone: 'o' },
      { type: 'Possession', d1: 'Possession_Recovered', zone: 'o' }
    ]
  },
  cyclePlay: {
    name: 'Cycle Play',
    events: [
      { type: 'Possession', d1: 'Possession_Cycle', zone: 'o' },
      { type: 'Pass', d1: 'Pass_Cycle', zone: 'o' }
    ]
  },
  breakout: {
    name: 'Breakout',
    events: [
      { type: 'Possession', d1: 'Possession_Breakout', zone: 'd' },
      { type: 'Zone_Entry_Exit', d1: 'Zone_Exit', d2: 'Exit_Pass', zone: 'd' }
    ]
  },
  forecheck: {
    name: 'Forecheck',
    events: [
      { type: 'Possession', d1: 'Possession_Forecheck', zone: 'o' },
      { type: 'Turnover', d1: 'Turnover_Takeaway', zone: 'o', success: 's' }
    ]
  },
  oddManRush: {
    name: 'Odd-Man Rush',
    events: [
      { type: 'Zone_Entry_Exit', d1: 'Zone_Entry', d2: 'Entry_Rush', zone: 'o' },
      { type: 'Shot', d1: 'Shot_OnNet', zone: 'o' }
    ]
  }
};

/**
 * Apply selected event template
 */
function applyTemplate() {
  const select = document.getElementById('eventTemplates');
  const templateKey = select.value;
  
  if (!templateKey || !EVENT_TEMPLATES[templateKey]) {
    toast('Select a template', 'warning');
    return;
  }
  
  const template = EVENT_TEMPLATES[templateKey];
  const firstEvent = template.events[0];
  
  // Set up first event
  setEvtType(firstEvent.type);
  
  setTimeout(() => {
    if (firstEvent.d1) document.getElementById('evtD1').value = firstEvent.d1;
    if (firstEvent.d2) {
      onD1Change();
      setTimeout(() => {
        document.getElementById('evtD2').value = firstEvent.d2;
      }, 50);
    }
    if (firstEvent.zone) document.getElementById('evtZone').value = firstEvent.zone;
    if (firstEvent.success) document.getElementById('evtSuccess').value = firstEvent.success;
    
    // Enable sequence mode for multi-event templates
    if (template.events.length > 1 && !sequenceModeActive) {
      toggleSequenceMode();
    }
    
    toast(`Template: ${template.name} - ${template.events.length} events`, 'success');
  }, 50);
  
  // Reset dropdown
  select.value = '';
}

// ============================================================
// v23.4: PERIOD END CHECKLIST
// ============================================================

/**
 * Show period end checklist modal
 */
function showPeriodEndChecklist() {
  const issues = [];
  
  // Check goal count
  const homeGoals = S.events.filter(e => e.type === 'Goal' && e.detail1 === 'Goal_Scored' && e.team === 'home').length;
  const awayGoals = S.events.filter(e => e.type === 'Goal' && e.detail1 === 'Goal_Scored' && e.team === 'away').length;
  
  // Check for unclosed shifts
  const currentPeriodShifts = S.shifts.filter(sh => sh.period === S.period);
  const unclosedShifts = currentPeriodShifts.filter(sh => !sh.end_time);
  if (unclosedShifts.length > 0) {
    issues.push(`‚ö†Ô∏è ${unclosedShifts.length} unclosed shift(s) in P${S.period}`);
  }
  
  // Check for events without players
  const eventsWithoutPlayers = S.events.filter(e => e.period === S.period && (!e.players || e.players.length === 0));
  if (eventsWithoutPlayers.length > 0) {
    issues.push(`‚ö†Ô∏è ${eventsWithoutPlayers.length} event(s) without players`);
  }
  
  // Check shot-save ratio
  const shotsOnNet = S.events.filter(e => e.period === S.period && e.type === 'Shot' && 
    (e.detail1?.includes('OnNet') || e.detail1?.includes('Goal'))).length;
  const saves = S.events.filter(e => e.period === S.period && e.type === 'Save').length;
  const goals = S.events.filter(e => e.period === S.period && e.type === 'Goal' && e.detail1 === 'Goal_Scored').length;
  
  if (shotsOnNet > saves + goals) {
    issues.push(`‚ö†Ô∏è ${shotsOnNet - saves - goals} shot(s) on net missing saves`);
  }
  
  // Faceoff balance check
  const foWins = S.events.filter(e => e.period === S.period && e.type === 'Faceoff' && e.detail1?.includes('Won')).length;
  const foLosses = S.events.filter(e => e.period === S.period && e.type === 'Faceoff' && e.detail1?.includes('Lost')).length;
  
  // Build checklist HTML
  let html = `
    <h3>üìã Period ${S.period} Checklist</h3>
    <div style="margin:15px 0;">
      <h4 style="color:var(--accent);">Score</h4>
      <div style="display:flex;justify-content:space-around;margin:10px 0;">
        <div style="text-align:center;">
          <div style="font-size:24px;font-weight:bold;color:var(--home);">${homeGoals}</div>
          <div style="font-size:10px;color:var(--muted);">${S.homeTeam || 'Home'}</div>
        </div>
        <div style="font-size:24px;color:var(--muted);">-</div>
        <div style="text-align:center;">
          <div style="font-size:24px;font-weight:bold;color:var(--away);">${awayGoals}</div>
          <div style="font-size:10px;color:var(--muted);">${S.awayTeam || 'Away'}</div>
        </div>
      </div>
    </div>
    <div style="margin:15px 0;">
      <h4 style="color:var(--accent);">Stats</h4>
      <div style="font-size:11px;color:var(--text);">
        <div>Shots on Net: ${shotsOnNet}</div>
        <div>Saves: ${saves}</div>
        <div>Faceoffs: ${foWins}W - ${foLosses}L (${foWins + foLosses > 0 ? Math.round(foWins / (foWins + foLosses) * 100) : 0}%)</div>
        <div>Events: ${S.events.filter(e => e.period === S.period).length}</div>
        <div>Shifts: ${currentPeriodShifts.length}</div>
      </div>
    </div>
  `;
  
  if (issues.length > 0) {
    html += `
      <div style="margin:15px 0;background:rgba(245,158,11,0.1);padding:10px;border-radius:4px;">
        <h4 style="color:var(--warning);">Issues Found</h4>
        <ul style="font-size:11px;margin:5px 0 0 15px;">
          ${issues.map(i => `<li>${i}</li>`).join('')}
        </ul>
      </div>
    `;
  } else {
    html += `
      <div style="margin:15px 0;background:rgba(34,197,94,0.1);padding:10px;border-radius:4px;">
        <h4 style="color:var(--success);">‚úì All Checks Passed</h4>
      </div>
    `;
  }
  
  html += `
    <div class="modal-actions" style="margin-top:15px;">
      <button onclick="document.getElementById('checklistModal').classList.remove('show')">Close</button>
      <button class="btn-primary" onclick="advancePeriod()">Next Period ‚Üí</button>
    </div>
  `;
  
  // Show in a modal
  let modal = document.getElementById('checklistModal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'checklistModal';
    modal.className = 'overlay';
    modal.innerHTML = `<div class="modal" style="min-width:350px;"></div>`;
    document.body.appendChild(modal);
  }
  modal.querySelector('.modal').innerHTML = html;
  modal.classList.add('show');
}

/**
 * Advance to next period
 */
function advancePeriod() {
  document.getElementById('checklistModal')?.classList.remove('show');
  
  if (S.period === 1) S.period = 2;
  else if (S.period === 2) S.period = 3;
  else if (S.period === 3) S.period = 'OT';
  
  document.querySelectorAll('.period-btn').forEach(b => b.classList.remove('active'));
  document.querySelector(`.period-btn[data-period="${S.period}"]`)?.classList.add('active');
  
  // Reset clock to new period length
  const newPeriodLength = getPeriodLength(S.period);
  document.getElementById('clock').value = `${newPeriodLength}:00`;
  
  toast(`Advanced to Period ${S.period} (${newPeriodLength} min)`, 'success');
}

// ============================================================
// v23.4: SHIFT LENGTH WARNING
// ============================================================
let shiftWarningInterval = null;

/**
 * Start shift length monitoring
 */
function startShiftMonitoring() {
  if (shiftWarningInterval) clearInterval(shiftWarningInterval);
  
  shiftWarningInterval = setInterval(() => {
    const shiftStart = document.getElementById('shiftStart').value;
    const currentClock = document.getElementById('clock').value;
    
    if (!shiftStart || !currentClock) return;
    
    const startParts = shiftStart.split(':').map(Number);
    const currentParts = currentClock.split(':').map(Number);
    
    const startSec = startParts[0] * 60 + startParts[1];
    const currentSec = currentParts[0] * 60 + currentParts[1];
    
    // Clock counts down
    const shiftLength = startSec - currentSec;
    
    if (shiftLength >= 90 && shiftLength < 92) { // Only warn once
      toast('‚ö†Ô∏è Shift is 90+ seconds - consider ending', 'warning');
    }
  }, 2000);
}

// ============================================================
// v23.4: RECENT PLAYERS PINNED
// ============================================================

/**
 * Get recently used players (from last 3 events)
 */
function getRecentPlayers() {
  const recentEvents = S.events.slice(-3);
  const recentNums = new Set();
  
  recentEvents.forEach(evt => {
    evt.players?.forEach(p => {
      recentNums.add(p.num);
    });
  });
  
  return Array.from(recentNums);
}

// ============================================================
// v23.4: VIDEO TIME SYNC
// ============================================================
let videoOffset = 0; // Seconds between video time and game clock

/**
 * Set video offset
 */
function setVideoOffset() {
  const videoTime = prompt('Enter video timestamp (MM:SS) when clock shows current time:');
  if (!videoTime) return;
  
  const videoParts = videoTime.split(':').map(Number);
  const videoSec = videoParts[0] * 60 + videoParts[1];
  
  const clockTime = document.getElementById('clock').value;
  const clockParts = clockTime.split(':').map(Number);
  const clockSec = clockParts[0] * 60 + clockParts[1];
  
  // Video offset = video time when game clock shows current value
  // For period 1 at 18:00, if video shows 2:30, offset = 150 seconds
  videoOffset = videoSec;
  
  localStorage.setItem('benchsight_videoOffset', videoOffset);
  toast(`Video offset set: ${videoTime}`, 'success');
}

/**
 * Get video timestamp for a game clock time
 */
function getVideoTimestamp(clockTime, period) {
  const clockParts = clockTime.split(':').map(Number);
  const clockSec = clockParts[0] * 60 + clockParts[1];
  const periodLengthSec = getPeriodLengthSeconds(period);
  
  // Time elapsed in period = periodLength - clockSec
  const elapsedInPeriod = periodLengthSec - clockSec;
  
  // Add previous periods (using their specific lengths)
  let totalElapsed = elapsedInPeriod;
  if (period >= 2) totalElapsed += getPeriodLengthSeconds(1) + (S.intermission1 || 900);
  if (period >= 3) totalElapsed += getPeriodLengthSeconds(2) + (S.intermission2 || 900);
  if (period === 'OT' || period === 4) totalElapsed += getPeriodLengthSeconds(3) + (S.intermission3 || 300);
  
  // Add video offset
  const videoTime = videoOffset + totalElapsed;
  
  const min = Math.floor(videoTime / 60);
  const sec = videoTime % 60;
  return `${min}:${String(sec).padStart(2, '0')}`;
}

// ============================================================
// v23.4: ZONE CLICK SUGGESTIONS
// ============================================================

/**
 * Suggest event type based on zone clicked
 */
function suggestEventFromZone(zone) {
  if (S.curr.type) return; // Don't suggest if type already set
  
  const suggestions = {
    'o': ['Shot', 'Pass', 'Possession'],
    'd': ['Possession', 'Zone_Entry_Exit', 'Pass'],
    'n': ['Zone_Entry_Exit', 'Faceoff', 'Pass']
  };
  
  const zoneSuggestions = suggestions[zone] || [];
  if (zoneSuggestions.length > 0) {
    // Highlight suggested buttons
    document.querySelectorAll('.evt-btn').forEach(b => b.classList.remove('zone-suggested'));
    zoneSuggestions.forEach(type => {
      const btn = document.querySelector(`.evt-btn[data-type="${type}"]`);
      if (btn) btn.classList.add('zone-suggested');
    });
  }
}

// Add CSS for zone suggestions
const zoneSuggestStyle = document.createElement('style');
zoneSuggestStyle.textContent = `
  .evt-btn.zone-suggested {
    border: 2px dashed var(--accent);
  }
`;
document.head.appendChild(zoneSuggestStyle);

// ============================================================
// v23.4: SORT AND REINDEX EVENTS
// ============================================================

/**
 * Convert time string to seconds for comparison
 */
function timeToSeconds(timeStr) {
  if (!timeStr) return 0;
  const parts = timeStr.split(':').map(Number);
  return parts[0] * 60 + (parts[1] || 0);
}

/**
 * Get period number for sorting (P1=1, P2=2, P3=3, OT=4)
 */
function periodToNumber(period) {
  if (period === 'OT' || period === 'ot') return 4;
  return parseInt(period) || 1;
}

/**
 * Sort events by period and time, then reindex all events and fix linked references
 */
function sortAndReindexEvents() {
  if (!S.events || S.events.length === 0) return;
  
  // Build old->new index mapping before sorting
  const oldIndexes = S.events.map(e => e.idx);
  
  // Sort by period (ascending), then by time (descending - higher time = earlier in period)
  S.events.sort((a, b) => {
    const periodA = periodToNumber(a.period);
    const periodB = periodToNumber(b.period);
    if (periodA !== periodB) return periodA - periodB;
    
    // Within same period, sort by time descending (18:00 before 17:00)
    const timeA = timeToSeconds(a.start_time);
    const timeB = timeToSeconds(b.start_time);
    return timeB - timeA;
  });
  
  // Build old->new index mapping
  const indexMap = {};
  oldIndexes.forEach((oldIdx, i) => {
    const newIdx = S.events.findIndex(e => e.idx === oldIdx);
    if (newIdx >= 0) {
      indexMap[oldIdx] = newIdx;
    }
  });
  
  // Reassign sequential indexes
  S.events.forEach((evt, i) => {
    evt.idx = i;
  });
  
  // Update all linkedEventIdx references
  S.events.forEach(evt => {
    if (evt.linkedEventIdx !== null && evt.linkedEventIdx !== undefined) {
      // Find the new index for the linked event
      const linkedEvt = S.events.find(e => oldIndexes[indexMap[evt.linkedEventIdx]] === e.idx || 
                                           S.events[indexMap[evt.linkedEventIdx]] === e);
      if (linkedEvt) {
        evt.linkedEventIdx = linkedEvt.idx;
      }
    }
    
    // Update linked event chain
    if (evt.linkedEventChain?.length > 0) {
      evt.linkedEventChain = evt.linkedEventChain.map(oldIdx => {
        const newEvt = S.events.find((e, i) => indexMap[oldIdx] === i);
        return newEvt ? newEvt.idx : oldIdx;
      });
    }
  });
  
  // Update evtIdx counter
  S.evtIdx = S.events.length;
}

/**
 * Manual reindex button handler
 */
function manualReindexEvents() {
  sortAndReindexEvents();
  renderEvents();
  toast('Events reindexed by time', 'success');
}

/**
 * v23.8: Move event up in the list (swap with previous event)
 */
function moveEventUp(eventIdx) {
  if (eventIdx <= 0 || eventIdx >= S.events.length) {
    toast('Cannot move event', 'warning');
    return;
  }
  
  // Swap events
  const temp = S.events[eventIdx];
  S.events[eventIdx] = S.events[eventIdx - 1];
  S.events[eventIdx - 1] = temp;
  
  // Re-index all events
  reindexEventsAfterMove();
  
  // Update UI
  renderEvents();
  renderMarkers();
  updateScores();
  updateBoxScore();
  autoSave();
  
  toast(`Event #${eventIdx + 1} moved up`, 'success');
}

/**
 * v23.8: Move event down in the list (swap with next event)
 */
function moveEventDown(eventIdx) {
  if (eventIdx < 0 || eventIdx >= S.events.length - 1) {
    toast('Cannot move event', 'warning');
    return;
  }
  
  // Swap events
  const temp = S.events[eventIdx];
  S.events[eventIdx] = S.events[eventIdx + 1];
  S.events[eventIdx + 1] = temp;
  
  // Re-index all events
  reindexEventsAfterMove();
  
  // Update UI
  renderEvents();
  renderMarkers();
  updateScores();
  updateBoxScore();
  autoSave();
  
  toast(`Event #${eventIdx + 1} moved down`, 'success');
}

/**
 * v23.8: Re-index events after moving (updates idx and linked references)
 */
function reindexEventsAfterMove() {
  // Reassign sequential indexes
  S.events.forEach((evt, i) => {
    evt.idx = i;
  });
  
  // Update linkedEventIdx references (they point to array indices)
  S.events.forEach(evt => {
    if (evt.linkedEventIdx !== null && evt.linkedEventIdx !== undefined) {
      // linkedEventIdx is an array index, so it should still be valid
      // But we need to verify the linked event still exists at that index
      if (evt.linkedEventIdx >= 0 && evt.linkedEventIdx < S.events.length) {
        const linkedEvt = S.events[evt.linkedEventIdx];
        if (linkedEvt) {
          // Reference is still valid
          evt.linkedEventIdx = linkedEvt.idx;
        } else {
          // Linked event not found, clear the link
          evt.linkedEventIdx = null;
        }
      }
    }
    
    // Update assistToGoalIdx references
    if (evt.assistToGoalIdx !== null && evt.assistToGoalIdx !== undefined) {
      if (evt.assistToGoalIdx >= 0 && evt.assistToGoalIdx < S.events.length) {
        const goalEvt = S.events[evt.assistToGoalIdx];
        if (goalEvt && goalEvt.type === 'Goal') {
          evt.assistToGoalIdx = goalEvt.idx;
        } else {
          // Goal not found, clear the link
          evt.assistToGoalIdx = null;
        }
      }
    }
    
    // Update linked event chain
    if (evt.linkedEventChain?.length > 0) {
      evt.linkedEventChain = evt.linkedEventChain.map(oldIdx => {
        if (oldIdx >= 0 && oldIdx < S.events.length) {
          const chainEvt = S.events[oldIdx];
          return chainEvt ? chainEvt.idx : oldIdx;
        }
        return oldIdx;
      }).filter(idx => idx >= 0 && idx < S.events.length);
    }
  });
  
  // Update evtIdx counter
  S.evtIdx = S.events.length;
}

// ============================================================
// v23.4: CUSTOM CHAIN PRESETS
// ============================================================

// User-defined chain presets (saved to localStorage)
let customChainPresets = [];

/**
 * Load custom chain presets from localStorage
 */
function loadCustomChainPresets() {
  try {
    const saved = localStorage.getItem('benchsight_customChains');
    if (saved) {
      customChainPresets = JSON.parse(saved);
      updateChainPresetsUI();
    }
  } catch (e) {
    console.error('Error loading custom chains:', e);
  }
}

/**
 * Save custom chain presets to localStorage
 */
function saveCustomChainPresets() {
  localStorage.setItem('benchsight_customChains', JSON.stringify(customChainPresets));
  updateChainPresetsUI();
}

/**
 * Add current event setup as a new chain preset
 */
function saveAsChainPreset() {
  const name = prompt('Enter preset name (e.g., "Zone Exit Rush"):');
  if (!name) return;
  
  // Get current event configuration
  const currentSetup = {
    type: S.curr.type,
    d1: document.getElementById('evtD1').value,
    d2: document.getElementById('evtD2').value,
    zone: document.getElementById('evtZone').value,
    success: document.getElementById('evtSuccess').value
  };
  
  // Ask for follow-up event
  const followUpType = prompt('Follow-up event type (e.g., "Possession", "Shot"):', '');
  const followUpD1 = followUpType ? prompt('Follow-up Detail 1:', '') : '';
  
  const preset = {
    id: Date.now(),
    name: name,
    events: [
      currentSetup,
      ...(followUpType ? [{ type: followUpType, d1: followUpD1, zone: currentSetup.zone }] : [])
    ]
  };
  
  customChainPresets.push(preset);
  saveCustomChainPresets();
  toast(`Saved chain preset: ${name}`, 'success');
}

/**
 * Delete a custom chain preset
 */
function deleteChainPreset(id) {
  customChainPresets = customChainPresets.filter(p => p.id !== id);
  saveCustomChainPresets();
  toast('Preset deleted', 'info');
}

/**
 * Apply a custom chain preset
 */
function applyCustomChain(id) {
  const preset = customChainPresets.find(p => p.id === id);
  if (!preset || !preset.events.length) return;
  
  const firstEvent = preset.events[0];
  
  setEvtType(firstEvent.type);
  
  setTimeout(() => {
    if (firstEvent.d1) document.getElementById('evtD1').value = firstEvent.d1;
    if (firstEvent.d2) {
      onD1Change();
      setTimeout(() => {
        document.getElementById('evtD2').value = firstEvent.d2;
      }, 50);
    }
    if (firstEvent.zone) document.getElementById('evtZone').value = firstEvent.zone;
    if (firstEvent.success) document.getElementById('evtSuccess').value = firstEvent.success;
    
    // Enable sequence mode for multi-event chains
    if (preset.events.length > 1 && !sequenceModeActive) {
      toggleSequenceMode();
    }
    
    toast(`Applied: ${preset.name}`, 'success');
  }, 50);
}

/**
 * Update the chain presets dropdown
 */
function updateChainPresetsUI() {
  const select = document.getElementById('eventTemplates');
  if (!select) return;
  
  // Keep built-in templates, add custom ones
  const builtInOptions = `
    <option value="">üìã Templates...</option>
    <option value="dumpAndChase">Dump & Chase</option>
    <option value="cyclePlay">Cycle Play</option>
    <option value="breakout">Breakout</option>
    <option value="forecheck">Forecheck</option>
    <option value="oddManRush">Odd-Man Rush</option>
  `;
  
  const customOptions = customChainPresets.length > 0 
    ? `<optgroup label="‚îÄ‚îÄ My Presets ‚îÄ‚îÄ">` + 
      customChainPresets.map(p => `<option value="custom_${p.id}">‚≠ê ${p.name}</option>`).join('') +
      `</optgroup>`
    : '';
  
  select.innerHTML = builtInOptions + customOptions;
}

/**
 * Extended apply template to handle custom presets
 */
const originalApplyTemplate = applyTemplate;
applyTemplate = function() {
  const select = document.getElementById('eventTemplates');
  const value = select.value;
  
  if (value.startsWith('custom_')) {
    const id = parseInt(value.replace('custom_', ''));
    applyCustomChain(id);
    select.value = '';
    return;
  }
  
  originalApplyTemplate();
};

// ============================================================
// v23.4: SETTINGS EXPORT/IMPORT
// ============================================================

/**
 * Export all settings, presets, and configurations to JSON file
 */
function exportSettings() {
  const settings = {
    exportDate: new Date().toISOString(),
    version: '23.4',
    
    // Custom chain presets
    customChainPresets: customChainPresets,
    
    // Penalty minutes
    penaltyMinutes: penaltyMinutes,
    
    // Video offset
    videoOffset: videoOffset,
    
    // BS settings (stored in localStorage)
    bsSettings: JSON.parse(localStorage.getItem('bs_settings') || '{}'),
    
    // Current game rosters (if loaded)
    homeRoster: S.homeRoster || [],
    awayRoster: S.awayRoster || [],
    
    // Team colors
    homeColor: S.homeColor,
    awayColor: S.awayColor,
    
    // Team names
    homeTeam: S.homeTeam,
    awayTeam: S.awayTeam
  };
  
  const blob = new Blob([JSON.stringify(settings, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `benchsight_settings_${new Date().toISOString().slice(0,10)}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  
  toast('Settings exported!', 'success');
}

/**
 * Import settings from JSON file
 */
function importSettings(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const settings = JSON.parse(e.target.result);
      
      // Import custom chain presets
      if (settings.customChainPresets) {
        customChainPresets = settings.customChainPresets;
        saveCustomChainPresets();
      }
      
      // Import penalty minutes
      if (settings.penaltyMinutes) {
        penaltyMinutes = settings.penaltyMinutes;
        localStorage.setItem('benchsight_penaltyMinutes', penaltyMinutes);
        const ppInput = document.getElementById('ppMinutes');
        if (ppInput) ppInput.value = penaltyMinutes;
      }
      
      // Import video offset
      if (settings.videoOffset !== undefined) {
        videoOffset = settings.videoOffset;
        localStorage.setItem('benchsight_videoOffset', videoOffset);
      }
      
      // Import BS settings
      if (settings.bsSettings) {
        localStorage.setItem('bs_settings', JSON.stringify(settings.bsSettings));
      }
      
      // Import rosters if present
      if (settings.homeRoster?.length) {
        S.homeRoster = settings.homeRoster;
        renderQuickAdd();
      }
      if (settings.awayRoster?.length) {
        S.awayRoster = settings.awayRoster;
        renderQuickAdd();
      }
      
      // Import colors
      if (settings.homeColor) S.homeColor = settings.homeColor;
      if (settings.awayColor) S.awayColor = settings.awayColor;
      
      // Import team names
      if (settings.homeTeam) S.homeTeam = settings.homeTeam;
      if (settings.awayTeam) S.awayTeam = settings.awayTeam;
      
      toast(`Imported settings from ${file.name}`, 'success');
    } catch (err) {
      console.error('Import error:', err);
      toast(`Import error: ${err.message}`, 'error');
    }
  };
  reader.readAsText(file);
  
  // Reset file input
  event.target.value = '';
}

/**
 * v23.8: Export all localStorage data to a file
 * Allows user to save to a folder or download
 */
async function exportLocalStorage() {
  try {
    // Collect all localStorage items
    const allData = {};
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key) {
        try {
          // Try to parse as JSON, if it fails, store as string
          const value = localStorage.getItem(key);
          try {
            allData[key] = JSON.parse(value);
          } catch {
            allData[key] = value;
          }
        } catch (e) {
          console.warn(`Failed to export localStorage key: ${key}`, e);
        }
      }
    }
    
    // Create export object with metadata
    const exportData = {
      exportDate: new Date().toISOString(),
      version: '23.8',
      localStorageData: allData,
      itemCount: Object.keys(allData).length
    };
    
    const fileName = `benchsight_localStorage_backup_${new Date().toISOString().slice(0,19).replace(/:/g, '-')}.json`;
    const jsonContent = JSON.stringify(exportData, null, 2);
    
    // Try to save to folder if available (game folder or save directory)
    const targetDirectory = S.gameFolderHandle || S.saveDirectoryHandle;
    if (targetDirectory && 'getFileHandle' in targetDirectory) {
      try {
        const fileHandle = await targetDirectory.getFileHandle(fileName, { create: true });
        const writable = await fileHandle.createWritable();
        await writable.write(jsonContent);
        await writable.close();
        toast(`localStorage exported to ${fileName}`, 'success');
        return;
      } catch (e) {
        console.warn('Failed to save to folder, falling back to download:', e);
      }
    }
    
    // Fallback to download
    const blob = new Blob([jsonContent], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    toast(`localStorage exported (${Object.keys(allData).length} items)`, 'success');
  } catch (e) {
    console.error('Export localStorage error:', e);
    toast(`Export error: ${e.message}`, 'error');
  }
}

/**
 * v23.8: Import and restore localStorage from a file
 */
function importLocalStorage(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const importData = JSON.parse(e.target.result);
      
      // Check if this is a game backup file (has events, shifts, gameId)
      if (importData.events || importData.shifts || importData.gameId) {
        // This is a game backup file, not a localStorage export
        // Redirect to restoreFromBackup function
        toast('Detected game backup file. Use "Restore from Backup" button instead.', 'info', 5000);
        // Create a synthetic event to call restoreFromBackup
        const syntheticEvent = {
          target: {
            files: [file],
            value: ''
          }
        };
        // Read the file again for restoreFromBackup
        const backupReader = new FileReader();
        backupReader.onload = function(backupE) {
          try {
            const backupData = JSON.parse(backupE.target.result);
            // Call restoreFromBackup with the data
            const fakeEvent = { target: { files: [file], value: '' } };
            // We need to manually trigger the restore logic
            // Since we can't easily call restoreFromBackup with the parsed data,
            // we'll show a message and let the user use the correct button
            if (confirm('This appears to be a game backup file (contains events/shifts).\n\nWould you like to restore it as game data?\n\n(Click OK to restore, or Cancel and use the "Restore from Backup" button)')) {
              // Manually call the restore logic
              restoreBackupData(backupData);
            }
          } catch (err) {
            console.error('Error parsing backup file:', err);
            toast(`Error: ${err.message}`, 'error');
          }
        };
        backupReader.readAsText(file);
        event.target.value = '';
        return;
      }
      
      // Check if this is a game backup file (has events, shifts, gameId)
      if (importData.events || importData.shifts || importData.gameId) {
        // This is a game backup file - ask user if they want to restore it
        const backupInfo = [
          `Game ID: ${importData.gameId || 'N/A'}`,
          `Export Date: ${importData.exportDate || importData.savedAt || 'Unknown'}`,
          `Events: ${importData.events?.length || 0}`,
          `Shifts: ${importData.shifts?.length || 0}`,
          `Home Team: ${importData.homeTeam || 'N/A'}`,
          `Away Team: ${importData.awayTeam || 'N/A'}`
        ].join('\n');
        
        const confirmMsg = `This appears to be a game backup file (not a localStorage export).\n\n${backupInfo}\n\nWould you like to restore this game data?\n\n‚ö†Ô∏è WARNING: This will OVERWRITE all current game data.\n\n(Click OK to restore, or Cancel and use the "Restore from Backup" button instead)`;
        if (confirm(confirmMsg)) {
          restoreBackupData(importData);
        }
        event.target.value = '';
        return;
      }
      
      // Check if it's a valid export format
      if (!importData.localStorageData) {
        // Might be old format - try to use the whole object
        console.warn('Import file format not recognized, attempting to use entire object');
        
        // If the file has localStorage-like keys, use them directly
        if (importData.bs_ || importData.benchsight_) {
          // This might be a direct localStorage dump
          Object.keys(importData).forEach(key => {
            try {
              if (typeof importData[key] === 'object') {
                localStorage.setItem(key, JSON.stringify(importData[key]));
              } else {
                localStorage.setItem(key, importData[key]);
              }
            } catch (err) {
              console.warn(`Failed to import key: ${key}`, err);
            }
          });
        } else {
          throw new Error('Invalid import file format. Expected localStorage export or game backup file.');
        }
      } else {
        // New format with localStorageData property
        const itemCount = Object.keys(importData.localStorageData).length;
        let importedCount = 0;
        let skippedCount = 0;
        
        // Ask for confirmation before overwriting
        const confirmMsg = `This will restore ${itemCount} localStorage items from the file.\n\nThis will OVERWRITE existing localStorage data.\n\nContinue?`;
        if (!confirm(confirmMsg)) {
          event.target.value = '';
          return;
        }
        
        // Import each item
        Object.keys(importData.localStorageData).forEach(key => {
          try {
            const value = importData.localStorageData[key];
            if (typeof value === 'object') {
              localStorage.setItem(key, JSON.stringify(value));
            } else {
              localStorage.setItem(key, value);
            }
            importedCount++;
          } catch (err) {
            console.warn(`Failed to import key: ${key}`, err);
            skippedCount++;
          }
        });
        
        // Reload relevant data
        loadSettings();
        loadCustomRules();
        loadCustomLinkingRules();
        loadAutoSettings();
        
        // Reload video sources, macros, etc.
        loadVideoSources();
        if (typeof loadMacros === 'function') {
          loadMacros();
        }
        
        // Update UI
        renderAll();
        
        toast(`localStorage restored: ${importedCount} items imported${skippedCount > 0 ? `, ${skippedCount} skipped` : ''}. Page may need refresh.`, 'success', 5000);
        
        // Suggest refresh
        setTimeout(() => {
          if (confirm('localStorage restored successfully. Refresh the page to ensure all changes are applied?')) {
            window.location.reload();
          }
        }, 1000);
      }
    } catch (err) {
      console.error('Import localStorage error:', err);
      toast(`Import error: ${err.message}`, 'error');
    }
  };
  reader.readAsText(file);
  
  // Reset file input
  event.target.value = '';
}

/**
 * v26.0: Internal function to restore backup data (extracted for reuse)
 */
function restoreBackupData(backupData) {
  try {
    // Validate backup format
    if (!backupData.gameId && !backupData.events && !backupData.shifts) {
      throw new Error('Invalid backup file format. Expected game data with events, shifts, etc.');
    }
    
    // Restore game metadata
    if (backupData.gameId) S.gameId = backupData.gameId;
    if (backupData.homeTeam) S.homeTeam = backupData.homeTeam;
    if (backupData.awayTeam) S.awayTeam = backupData.awayTeam;
    if (backupData.homeColor) S.homeColor = backupData.homeColor;
    if (backupData.awayColor) S.awayColor = backupData.awayColor;
    if (backupData.homeLogo) S.homeLogo = backupData.homeLogo;
    if (backupData.awayLogo) S.awayLogo = backupData.awayLogo;
    
    // Restore rosters
    if (backupData.rosters) {
      if (backupData.rosters.home) S.rosters.home = backupData.rosters.home;
      if (backupData.rosters.away) S.rosters.away = backupData.rosters.away;
    }
    
    // Restore core game data
    if (backupData.events) {
      S.events = backupData.events;
      // Reindex events
      S.events.forEach((evt, idx) => {
        evt.idx = idx;
      });
    }
    if (backupData.shifts) {
      S.shifts = backupData.shifts;
      // Reindex shifts
      S.shifts.forEach((shift, idx) => {
        shift.idx = idx;
      });
    }
    if (backupData.evtIdx !== undefined) S.evtIdx = backupData.evtIdx;
    if (backupData.shiftIdx !== undefined) S.shiftIdx = backupData.shiftIdx;
    
    // Restore video data
    if (backupData.videos) S.videos = backupData.videos;
    if (backupData.videoTiming) S.videoTiming = backupData.videoTiming;
    if (backupData.highlightVideos) S.highlightVideos = backupData.highlightVideos;
    
    // Restore game settings
    if (backupData.periodLengths) S.periodLengths = backupData.periodLengths;
    if (backupData.penaltyLengths) S.penaltyLengths = backupData.penaltyLengths;
    if (backupData.homeAttacksRightP1 !== undefined) S.homeAttacksRightP1 = backupData.homeAttacksRightP1;
    
    // Restore current state
    if (backupData.currentPeriod) S.period = backupData.currentPeriod;
    if (backupData.currentTeam) S.evtTeam = backupData.currentTeam;
    if (backupData.slots) S.slots = backupData.slots;
    
    // Restore settings and configurations (optional - ask user)
    if (backupData.settings || backupData.autoSettings || backupData.customRules || backupData.customLinkingRules) {
      const restoreSettings = confirm('Backup contains settings and configurations. Restore these as well?\n\n(Click Cancel to only restore game data: events, shifts, rosters)');
      if (restoreSettings) {
        if (backupData.settings) {
          Object.keys(backupData.settings).forEach(key => {
            localStorage.setItem(key, JSON.stringify(backupData.settings[key]));
          });
        }
        if (backupData.autoSettings) {
          Object.keys(backupData.autoSettings).forEach(key => {
            localStorage.setItem(key, JSON.stringify(backupData.autoSettings[key]));
          });
        }
        if (backupData.customRules) S.customRules = backupData.customRules;
        if (backupData.customLinkingRules) S.customLinkingRules = backupData.customLinkingRules;
        if (backupData.customChainPresets) {
          // Restore chain presets to localStorage
          localStorage.setItem('benchsight_chainPresets', JSON.stringify(backupData.customChainPresets));
        }
        if (backupData.linePresets) S.linePresets = backupData.linePresets;
        if (backupData.eventMacros) {
          localStorage.setItem('benchsight_macros', JSON.stringify(backupData.eventMacros));
        }
        
        // Reload settings
        loadSettings();
        loadCustomRules();
        loadCustomLinkingRules();
        loadAutoSettings();
        loadVideoSources();
      }
    }
    
    // Update UI
    // Update team names in header if elements exist
    const homeLbl = document.getElementById('homeLbl');
    const awayLbl = document.getElementById('awayLbl');
    if (homeLbl && S.homeTeam) homeLbl.textContent = S.homeTeam;
    if (awayLbl && S.awayTeam) awayLbl.textContent = S.awayTeam;
    
    // Use renderAll() which handles all UI updates
    if (typeof renderAll === 'function') {
      renderAll();
    } else {
      // Fallback to individual functions if renderAll doesn't exist
      if (typeof renderEvents === 'function') renderEvents();
      if (typeof renderShiftLog === 'function') renderShiftLog();
      if (typeof updateScores === 'function') updateScores();
      if (typeof updateBoxScore === 'function') updateBoxScore();
      if (typeof renderQuickAdd === 'function') renderQuickAdd();
      if (typeof updateQuickStats === 'function') updateQuickStats();
    }
    
    // Auto-save
    autoSave();
    
    toast(`Game data restored successfully! Events: ${S.events.length}, Shifts: ${S.shifts.length}`, 'success', 5000);
  } catch (err) {
    console.error('Restore backup data error:', err);
    toast(`Restore error: ${err.message}`, 'error');
    throw err; // Re-throw so calling function can handle it
  }
}

/**
 * v26.0: Restore game data from JSON backup file
 * Restores events, shifts, rosters, settings, and all game data
 */
function restoreFromBackup(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const backupData = JSON.parse(e.target.result);
      
      // Show confirmation with backup info
      const backupInfo = [
        `Game ID: ${backupData.gameId || 'N/A'}`,
        `Export Date: ${backupData.exportDate || backupData.savedAt || 'Unknown'}`,
        `Events: ${backupData.events?.length || 0}`,
        `Shifts: ${backupData.shifts?.length || 0}`,
        `Home Team: ${backupData.homeTeam || 'N/A'}`,
        `Away Team: ${backupData.awayTeam || 'N/A'}`
      ].join('\n');
      
      const confirmMsg = `This will restore game data from backup:\n\n${backupInfo}\n\n‚ö†Ô∏è WARNING: This will OVERWRITE all current game data (events, shifts, rosters, settings, etc.)\n\nContinue?`;
      if (!confirm(confirmMsg)) {
        event.target.value = '';
        return;
      }
      
      restoreBackupData(backupData);
      
    } catch (err) {
      console.error('Restore backup error:', err);
      toast(`Restore error: ${err.message}`, 'error');
    }
  };
  reader.readAsText(file);
  
  // Reset file input
  event.target.value = '';
}

/**
 * v26.0: Browse backups folder and restore from a backup file
 * Allows user to select a backups directory and choose a backup to restore
 */
async function browseBackupsFolder() {
  try {
    // Check if File System Access API is available
    if (!('showDirectoryPicker' in window)) {
      toast('File System Access API not supported in this browser. Use "Restore from Backup" button instead.', 'error');
      return;
    }
    
    // Ask user to select the backups directory
    let backupsDir;
    try {
      backupsDir = await window.showDirectoryPicker({
        mode: 'read',
        startIn: 'downloads' // Suggest downloads folder
      });
    } catch (err) {
      if (err.name === 'AbortError') {
        return; // User cancelled
      }
      throw err;
    }
    
    // Try to navigate to backups subfolder if it exists
    let targetDir = backupsDir;
    try {
      // Try common backup folder names
      const backupFolderNames = ['backups', 'bkup', 'json_backups', 'tracking_bkups'];
      for (const folderName of backupFolderNames) {
        try {
          targetDir = await backupsDir.getDirectoryHandle(folderName);
          break;
        } catch (e) {
          // Folder doesn't exist, try next
          continue;
        }
      }
    } catch (e) {
      // No backups subfolder, use selected directory
      targetDir = backupsDir;
    }
    
    // List all JSON files in the directory
    const jsonFiles = [];
    for await (const [name, handle] of targetDir.entries()) {
      if (handle.kind === 'file' && name.toLowerCase().endsWith('.json')) {
        jsonFiles.push({ name, handle });
      }
    }
    
    if (jsonFiles.length === 0) {
      toast('No JSON backup files found in selected directory.', 'error');
      return;
    }
    
    // Sort by name (most recent first if timestamped)
    jsonFiles.sort((a, b) => b.name.localeCompare(a.name));
    
    // Show selection dialog
    const fileList = jsonFiles.map((f, idx) => `${idx + 1}. ${f.name}`).join('\n');
    const selection = prompt(`Found ${jsonFiles.length} backup file(s):\n\n${fileList}\n\nEnter the number of the file to restore (1-${jsonFiles.length}):`);
    
    if (!selection) return; // User cancelled
    
    const fileIndex = parseInt(selection) - 1;
    if (isNaN(fileIndex) || fileIndex < 0 || fileIndex >= jsonFiles.length) {
      toast('Invalid selection.', 'error');
      return;
    }
    
    const selectedFile = jsonFiles[fileIndex];
    
    // Read the file
    const file = await selectedFile.handle.getFile();
    const text = await file.text();
    const backupData = JSON.parse(text);
    
    // Show confirmation with backup info
    const backupInfo = [
      `File: ${selectedFile.name}`,
      `Game ID: ${backupData.gameId || 'N/A'}`,
      `Export Date: ${backupData.exportDate || backupData.savedAt || 'Unknown'}`,
      `Events: ${backupData.events?.length || 0}`,
      `Shifts: ${backupData.shifts?.length || 0}`,
      `Home Team: ${backupData.homeTeam || 'N/A'}`,
      `Away Team: ${backupData.awayTeam || 'N/A'}`
    ].join('\n');
    
    const confirmMsg = `This will restore game data from backup:\n\n${backupInfo}\n\n‚ö†Ô∏è WARNING: This will OVERWRITE all current game data (events, shifts, rosters, settings, etc.)\n\nContinue?`;
    if (!confirm(confirmMsg)) {
      return;
    }
    
    // Restore the backup
    restoreBackupData(backupData);
    
  } catch (err) {
    console.error('Browse backups folder error:', err);
    toast(`Error: ${err.message}`, 'error');
  }
}

// ============================================================
// v23.4: ROSTER IMPORT FROM EXCEL/CSV
// ============================================================

/**
 * Import roster from Excel/CSV file
 */
async function importRosterFromFile(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  const extension = file.name.split('.').pop().toLowerCase();
  
  try {
    if (extension === 'csv') {
      // Parse CSV
      const text = await file.text();
      const roster = parseCSVRoster(text);
      showRosterImportPreview(roster, file.name);
    } else if (extension === 'xlsx' || extension === 'xls') {
      // Parse Excel using SheetJS (must be loaded)
      if (typeof XLSX === 'undefined') {
        // Try to load SheetJS dynamically
        toast('Loading Excel parser...', 'info');
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js';
        script.onload = () => {
          parseExcelFile(file);
        };
        script.onerror = () => {
          toast('Could not load Excel parser. Try CSV format.', 'error');
        };
        document.head.appendChild(script);
      } else {
        parseExcelFile(file);
      }
    } else {
      toast('Unsupported file type. Use .xlsx, .xls, or .csv', 'error');
    }
  } catch (err) {
    console.error('Roster import error:', err);
    toast(`Import error: ${err.message}`, 'error');
  }
  
  // Reset file input
  event.target.value = '';
}

/**
 * Parse Excel file using SheetJS
 */
function parseExcelFile(file) {
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const data = new Uint8Array(e.target.result);
      const workbook = XLSX.read(data, { type: 'array' });
      
      // Get first sheet
      const firstSheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[firstSheetName];
      
      // Convert to JSON
      const json = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
      
      // Parse roster from rows
      const roster = parseRosterRows(json);
      showRosterImportPreview(roster, file.name);
    } catch (err) {
      console.error('Excel parse error:', err);
      toast(`Excel parse error: ${err.message}`, 'error');
    }
  };
  reader.readAsArrayBuffer(file);
}

/**
 * Parse CSV text to roster
 */
function parseCSVRoster(text) {
  const lines = text.split(/\r?\n/).filter(line => line.trim());
  const rows = lines.map(line => {
    // Handle quoted fields
    const result = [];
    let current = '';
    let inQuotes = false;
    
    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      if (char === '"') {
        inQuotes = !inQuotes;
      } else if (char === ',' && !inQuotes) {
        result.push(current.trim());
        current = '';
      } else {
        current += char;
      }
    }
    result.push(current.trim());
    return result;
  });
  
  return parseRosterRows(rows);
}

/**
 * Parse roster from 2D array of rows
 * Expects: jersey_number, first_name, last_name, position (optional)
 */
function parseRosterRows(rows) {
  if (rows.length === 0) return [];
  
  // Try to detect header row
  const headerRow = rows[0].map(h => String(h).toLowerCase().trim());
  
  // Find column indices
  let jerseyCol = -1, firstNameCol = -1, lastNameCol = -1, nameCol = -1, posCol = -1;
  
  headerRow.forEach((h, i) => {
    if (h.includes('jersey') || h.includes('number') || h === '#' || h === 'num') jerseyCol = i;
    if (h.includes('first') || h === 'fname') firstNameCol = i;
    if (h.includes('last') || h === 'lname') lastNameCol = i;
    if (h === 'name' || h === 'player') nameCol = i;
    if (h.includes('pos') || h === 'position') posCol = i;
  });
  
  // If no header detected, assume: jersey, first, last or jersey, name
  const hasHeader = jerseyCol >= 0 || firstNameCol >= 0 || nameCol >= 0;
  const startRow = hasHeader ? 1 : 0;
  
  if (!hasHeader) {
    // Assume first column is jersey number
    jerseyCol = 0;
    if (rows[0].length >= 3) {
      firstNameCol = 1;
      lastNameCol = 2;
    } else if (rows[0].length >= 2) {
      nameCol = 1;
    }
  }
  
  const roster = [];
  
  for (let i = startRow; i < rows.length; i++) {
    const row = rows[i];
    if (!row || row.length === 0) continue;
    
    let jersey = jerseyCol >= 0 ? row[jerseyCol] : null;
    let firstName = firstNameCol >= 0 ? row[firstNameCol] : '';
    let lastName = lastNameCol >= 0 ? row[lastNameCol] : '';
    let fullName = nameCol >= 0 ? row[nameCol] : '';
    let position = posCol >= 0 ? row[posCol] : '';
    
    // Parse jersey number
    jersey = parseInt(String(jersey).replace(/\D/g, ''));
    if (isNaN(jersey) || jersey <= 0) continue;
    
    // Build name
    let name = '';
    if (fullName) {
      name = String(fullName).trim();
    } else if (firstName || lastName) {
      name = `${String(firstName).trim()} ${String(lastName).trim()}`.trim();
    }
    
    if (!name) name = `Player ${jersey}`;
    
    roster.push({
      num: jersey,
      name: name,
      pos: String(position).trim().toUpperCase() || ''
    });
  }
  
  // Sort by jersey number
  roster.sort((a, b) => a.num - b.num);
  
  return roster;
}

/**
 * Show roster import preview modal
 */
function showRosterImportPreview(roster, filename) {
  if (roster.length === 0) {
    toast('No valid roster data found in file', 'error');
    return;
  }
  
  const rosterHtml = roster.map(p => 
    `<tr><td>${p.num}</td><td>${p.name}</td><td>${p.pos || '-'}</td></tr>`
  ).join('');
  
  const html = `
    <h3>üìã Import Roster</h3>
    <p style="font-size:11px;color:var(--muted);">File: ${filename} (${roster.length} players)</p>
    <div style="max-height:300px;overflow-y:auto;margin:10px 0;">
      <table style="width:100%;font-size:11px;border-collapse:collapse;">
        <thead><tr style="background:var(--panel);"><th>#</th><th>Name</th><th>Pos</th></tr></thead>
        <tbody>${rosterHtml}</tbody>
      </table>
    </div>
    <div style="margin-top:15px;">
      <label style="font-size:11px;">Import as:</label>
      <div style="display:flex;gap:8px;margin-top:5px;">
        <button class="btn-sm btn-primary" onclick="applyImportedRoster('home')" style="flex:1;">üè† Home Team</button>
        <button class="btn-sm btn-primary" onclick="applyImportedRoster('away')" style="flex:1;">‚úàÔ∏è Away Team</button>
      </div>
    </div>
    <div style="margin-top:10px;text-align:right;">
      <button class="btn-sm" onclick="closeModal()">Cancel</button>
    </div>
  `;
  
  // Store roster for apply function
  window._pendingRosterImport = roster;
  
  showModal(html);
}

/**
 * Apply imported roster to home or away team
 */
function applyImportedRoster(team) {
  const roster = window._pendingRosterImport;
  if (!roster) return;
  
  if (team === 'home') {
    S.homeRoster = roster;
    toast(`Imported ${roster.length} players to Home roster`, 'success');
  } else {
    S.awayRoster = roster;
    toast(`Imported ${roster.length} players to Away roster`, 'success');
  }
  
  window._pendingRosterImport = null;
  closeModal();
  renderQuickAdd();
}

/**
 * Show manual roster entry modal
 */
function showManualRosterEntry() {
  const html = `
    <h3>‚úèÔ∏è Manual Roster Entry</h3>
    <p style="font-size:11px;color:var(--muted);">Enter one player per line: <code>jersey_number, name</code></p>
    <p style="font-size:10px;color:var(--muted);">Example: <code>10, John Smith</code> or <code>10 John Smith</code></p>
    <textarea id="manualRosterText" style="width:100%;height:200px;font-family:monospace;font-size:11px;" placeholder="10, John Smith
23, Mike Johnson
88, Wayne Great
..."></textarea>
    <div style="margin-top:15px;">
      <label style="font-size:11px;">Import as:</label>
      <div style="display:flex;gap:8px;margin-top:5px;">
        <button class="btn-sm btn-primary" onclick="applyManualRoster('home')" style="flex:1;">üè† Home Team</button>
        <button class="btn-sm btn-primary" onclick="applyManualRoster('away')" style="flex:1;">‚úàÔ∏è Away Team</button>
      </div>
    </div>
    <div style="margin-top:10px;text-align:right;">
      <button class="btn-sm" onclick="closeModal()">Cancel</button>
    </div>
  `;
  
  showModal(html);
}

/**
 * Apply manually entered roster
 */
function applyManualRoster(team) {
  const text = document.getElementById('manualRosterText').value;
  if (!text.trim()) {
    toast('Enter roster data first', 'warning');
    return;
  }
  
  const lines = text.split(/\r?\n/).filter(l => l.trim());
  const roster = [];
  
  lines.forEach(line => {
    // Try to parse: "10, John Smith" or "10 John Smith" or "#10 John Smith"
    let match = line.match(/^#?(\d+)[,\s]+(.+)$/);
    if (match) {
      roster.push({
        num: parseInt(match[1]),
        name: match[2].trim(),
        pos: ''
      });
    }
  });
  
  if (roster.length === 0) {
    toast('Could not parse any players. Use format: 10, John Smith', 'error');
    return;
  }
  
  roster.sort((a, b) => a.num - b.num);
  
  if (team === 'home') {
    S.homeRoster = roster;
    toast(`Added ${roster.length} players to Home roster`, 'success');
  } else {
    S.awayRoster = roster;
    toast(`Added ${roster.length} players to Away roster`, 'success');
  }
  
  closeModal();
  renderQuickAdd();
}

// ============================================================
// v23.4: VALIDATION VS GAME DATA
// ============================================================

/**
 * Validate tracked data against fact_gameroster and dim_schedule
 */
async function validateAgainstGameData() {
  if (!S.connected || !S.sb || !S.gameId) {
    toast('Connect to database and select game first', 'error');
    return;
  }
  
  const issues = [];
  const successes = [];
  
  try {
    // Fetch fact_gameroster for this game
    const { data: gameroster, error: grError } = await S.sb
      .from('fact_gameroster')
      .select('*')
      .eq('game_id', S.gameId);
    
    if (grError) throw grError;
    
    // Fetch dim_schedule for this game
    const { data: schedule, error: schError } = await S.sb
      .from('dim_schedule')
      .select('*')
      .eq('game_id', S.gameId)
      .single();
    
    if (schError && schError.code !== 'PGRST116') throw schError;
    
    // ===== GOAL VALIDATION =====
    const trackedGoals = S.events.filter(e => e.type === 'Goal' && e.detail1 === 'Goal_Scored');
    const homeTrackedGoals = trackedGoals.filter(e => e.team === 'home').length;
    const awayTrackedGoals = trackedGoals.filter(e => e.team === 'away').length;
    
    if (schedule) {
      // Check total goals by period
      const p1HomeGoals = trackedGoals.filter(e => e.team === 'home' && e.period == 1).length;
      const p2HomeGoals = trackedGoals.filter(e => e.team === 'home' && e.period == 2).length;
      const p3HomeGoals = trackedGoals.filter(e => e.team === 'home' && e.period == 3).length;
      
      const p1AwayGoals = trackedGoals.filter(e => e.team === 'away' && e.period == 1).length;
      const p2AwayGoals = trackedGoals.filter(e => e.team === 'away' && e.period == 2).length;
      const p3AwayGoals = trackedGoals.filter(e => e.team === 'away' && e.period == 3).length;
      
      // Compare with dim_schedule
      if (schedule.home_goals_p1 !== undefined) {
        if (p1HomeGoals !== schedule.home_goals_p1) {
          issues.push(`‚ùå P1 Home Goals: Tracked ${p1HomeGoals}, Expected ${schedule.home_goals_p1}`);
        } else {
          successes.push(`‚úì P1 Home Goals match: ${p1HomeGoals}`);
        }
      }
      if (schedule.home_goals_p2 !== undefined) {
        if (p2HomeGoals !== schedule.home_goals_p2) {
          issues.push(`‚ùå P2 Home Goals: Tracked ${p2HomeGoals}, Expected ${schedule.home_goals_p2}`);
        } else {
          successes.push(`‚úì P2 Home Goals match: ${p2HomeGoals}`);
        }
      }
      if (schedule.home_goals_p3 !== undefined) {
        if (p3HomeGoals !== schedule.home_goals_p3) {
          issues.push(`‚ùå P3 Home Goals: Tracked ${p3HomeGoals}, Expected ${schedule.home_goals_p3}`);
        } else {
          successes.push(`‚úì P3 Home Goals match: ${p3HomeGoals}`);
        }
      }
      
      // Away goals
      if (schedule.away_goals_p1 !== undefined) {
        if (p1AwayGoals !== schedule.away_goals_p1) {
          issues.push(`‚ùå P1 Away Goals: Tracked ${p1AwayGoals}, Expected ${schedule.away_goals_p1}`);
        } else {
          successes.push(`‚úì P1 Away Goals match: ${p1AwayGoals}`);
        }
      }
      if (schedule.away_goals_p2 !== undefined) {
        if (p2AwayGoals !== schedule.away_goals_p2) {
          issues.push(`‚ùå P2 Away Goals: Tracked ${p2AwayGoals}, Expected ${schedule.away_goals_p2}`);
        } else {
          successes.push(`‚úì P2 Away Goals match: ${p2AwayGoals}`);
        }
      }
      if (schedule.away_goals_p3 !== undefined) {
        if (p3AwayGoals !== schedule.away_goals_p3) {
          issues.push(`‚ùå P3 Away Goals: Tracked ${p3AwayGoals}, Expected ${schedule.away_goals_p3}`);
        } else {
          successes.push(`‚úì P3 Away Goals match: ${p3AwayGoals}`);
        }
      }
      
      // Total goals
      const expectedHomeTotal = (schedule.home_goals_p1 || 0) + (schedule.home_goals_p2 || 0) + (schedule.home_goals_p3 || 0) + (schedule.home_goals_ot || 0);
      const expectedAwayTotal = (schedule.away_goals_p1 || 0) + (schedule.away_goals_p2 || 0) + (schedule.away_goals_p3 || 0) + (schedule.away_goals_ot || 0);
      
      if (homeTrackedGoals !== expectedHomeTotal) {
        issues.push(`‚ùå Total Home Goals: Tracked ${homeTrackedGoals}, Expected ${expectedHomeTotal}`);
      } else {
        successes.push(`‚úì Total Home Goals match: ${homeTrackedGoals}`);
      }
      
      if (awayTrackedGoals !== expectedAwayTotal) {
        issues.push(`‚ùå Total Away Goals: Tracked ${awayTrackedGoals}, Expected ${expectedAwayTotal}`);
      } else {
        successes.push(`‚úì Total Away Goals match: ${awayTrackedGoals}`);
      }
    }
    
    // ===== GOAL SCORER VALIDATION =====
    if (gameroster && gameroster.length > 0) {
      // Get players who should have goals
      const playersWithGoals = gameroster.filter(p => (p.goals || 0) > 0);
      
      playersWithGoals.forEach(player => {
        // Count goals by this player in tracked events
        const trackedPlayerGoals = trackedGoals.filter(e => {
          const scorer = e.players?.find(p => p.role === 'event_team_player_1');
          return scorer && (scorer.num == player.jersey_number || scorer.num == player.player_id);
        }).length;
        
        if (trackedPlayerGoals !== player.goals) {
          issues.push(`‚ùå #${player.jersey_number} Goals: Tracked ${trackedPlayerGoals}, Expected ${player.goals}`);
        } else if (player.goals > 0) {
          successes.push(`‚úì #${player.jersey_number} Goals match: ${player.goals}`);
        }
      });
      
      // Get players who should have assists
      const playersWithAssists = gameroster.filter(p => (p.assists || 0) > 0);
      
      playersWithAssists.forEach(player => {
        // v23.4 FIX: Assists are tracked via playD1/playD2 containing "Assist_Primary" or "Assist_Secondary"
        // Count assists by this player in tracked goal events
        let trackedPlayerAssists = 0;
        
        trackedGoals.forEach(e => {
          e.players?.forEach(p => {
            // Check if this player has an assist detail
            const hasAssist = (p.playD1 && (p.playD1.includes('Assist_Primary') || p.playD1.includes('Assist_Secondary'))) ||
                             (p.playD2 && (p.playD2.includes('Assist_Primary') || p.playD2.includes('Assist_Secondary')));
            
            if (hasAssist && (p.num == player.jersey_number || p.num == player.player_id)) {
              trackedPlayerAssists++;
            }
          });
        });
        
        if (trackedPlayerAssists < player.assists) {
          issues.push(`‚ö†Ô∏è #${player.jersey_number} Assists: Tracked ${trackedPlayerAssists}, Expected ${player.assists}`);
        } else if (player.assists > 0) {
          successes.push(`‚úì #${player.jersey_number} has ${trackedPlayerAssists} assist(s)`);
        }
      });
    }
    
    // Show validation results
    showValidationResults(issues, successes);
    
  } catch (error) {
    console.error('Validation error:', error);
    toast(`Validation error: ${error.message}`, 'error');
  }
}

/**
 * Show validation results in a modal
 */
function showValidationResults(issues, successes) {
  let html = `
    <h3>üîç Data Validation Results</h3>
    <div style="margin:15px 0;">
  `;
  
  if (successes.length > 0) {
    html += `
      <div style="background:rgba(34,197,94,0.1);padding:10px;border-radius:4px;margin-bottom:10px;">
        <h4 style="color:var(--success);margin-bottom:8px;">‚úì Matches (${successes.length})</h4>
        <ul style="font-size:11px;margin-left:15px;color:var(--text);">
          ${successes.slice(0, 10).map(s => `<li>${s}</li>`).join('')}
          ${successes.length > 10 ? `<li>... and ${successes.length - 10} more</li>` : ''}
        </ul>
      </div>
    `;
  }
  
  if (issues.length > 0) {
    html += `
      <div style="background:rgba(239,68,68,0.1);padding:10px;border-radius:4px;">
        <h4 style="color:var(--danger);margin-bottom:8px;">‚ùå Issues (${issues.length})</h4>
        <ul style="font-size:11px;margin-left:15px;color:var(--text);">
          ${issues.map(i => `<li>${i}</li>`).join('')}
        </ul>
      </div>
    `;
  } else {
    html += `
      <div style="background:rgba(34,197,94,0.1);padding:10px;border-radius:4px;text-align:center;">
        <h4 style="color:var(--success);">üéâ All validations passed!</h4>
      </div>
    `;
  }
  
  html += `
    </div>
    <div class="modal-actions" style="margin-top:15px;">
      <button onclick="document.getElementById('validationModal').classList.remove('show')">Close</button>
    </div>
  `;
  
  // Show in modal
  let modal = document.getElementById('validationModal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'validationModal';
    modal.className = 'overlay';
    modal.innerHTML = `<div class="modal" style="min-width:400px;max-height:80vh;overflow-y:auto;"></div>`;
    document.body.appendChild(modal);
  }
  modal.querySelector('.modal').innerHTML = html;
  modal.classList.add('show');
}

// ============================================================
// v23.4: PLAYER XY SELECTION IMPROVEMENTS
// ============================================================

/**
 * Click on player chip to select for XY editing
 * (Already implemented in selectPlayer, but let's enhance it)
 */
function selectPlayerForXY(num) {
  const player = S.curr.players.find(p => p.num === num);
  if (player) {
    S.selectedPlayer = player;
    setXYMode('player');
    S.xySlot = (player.xy?.length || 0) + 1;
    renderQuickAdd();
    renderXYSlots();
    toast(`Selected #${num} for XY placement`, 'info');
  }
}

// ============================================================
// v23.4: PLACE ALL PLAYERS HERE (Same Location)
// ============================================================

/**
 * Place all event players at the last puck XY position
 * Useful for hits, battles, board play where everyone is at puck
 */
function placeAllHere() {
  // Get last puck XY
  const lastPuckXY = S.curr.puckXY[S.curr.puckXY.length - 1] || S.curr.puckXY[0];
  
  if (!lastPuckXY) {
    toast('Place puck first, then click "All Here"', 'warning');
    return;
  }
  
  // Place all players at puck location (with slight offset to not overlap)
  let count = 0;
  S.curr.players.forEach((player, idx) => {
    // Small offset based on index so they don't all stack exactly
    const offsetX = (idx % 3 - 1) * 2; // -2, 0, +2
    const offsetY = (Math.floor(idx / 3) - 0.5) * 2; // slight Y spread
    
    player.xy = player.xy || [];
    player.xy[0] = { 
      x: lastPuckXY.x + offsetX, 
      y: lastPuckXY.y + offsetY, 
      seq: 1 
    };
    count++;
  });
  
  if (count > 0) {
    toast(`Placed ${count} player(s) at puck location`, 'success');
  } else {
    toast('Add players first', 'warning');
  }
  
  renderXYSlots(); renderMarkers(); renderQuickAdd();
}

// ============================================================
// v23.4: TIMELINE SCRUB
// ============================================================

/**
 * Render the timeline scrub showing recent events
 */
function renderTimeline() {
  const container = document.getElementById('timelineEvents');
  if (!container) return;
  
  // Get events for current period
  const periodEvents = S.events.filter(e => e.period === S.period);
  
  // v23.9: Show ALL events, not just last 20 - user can scroll horizontally
  const recentEvents = periodEvents;
  
  if (recentEvents.length === 0) {
    container.innerHTML = '<span style="font-size:8px;color:var(--muted);white-space:nowrap;">No events yet</span>';
    return;
  }
  
  // Color map for event types
  const typeColors = {
    Shot: '#ef4444',
    Goal: '#22c55e',
    Pass: '#3b82f6',
    Faceoff: '#8b5cf6',
    Turnover: '#f59e0b',
    Possession: '#06b6d4',
    Save: '#6366f1',
    Hit: '#ec4899',
    Penalty: '#dc2626',
    Zone_Entry_Exit: '#14b8a6',
    Stoppage: '#6b7280'
  };
  
  container.innerHTML = recentEvents.map((evt, idx) => {
    const evtType = evt.type || 'Event';
    const color = typeColors[evtType] || 'var(--muted)';
    const label = evtType.substring(0, 2).toUpperCase();
    const time = evt.start_time || '';
    const isHighlight = evt.isHighlight ? '‚≠ê' : '';
    const title = `#${evt.idx + 1} ${evtType} @ ${time}${isHighlight ? ' (highlight)' : ''}`;
    
    return `<button class="timeline-evt" onclick="jumpToEvent(${evt.idx})" title="${title}" style="min-width:18px;height:18px;padding:0 2px;font-size:7px;background:${color};color:#fff;border:none;border-radius:2px;cursor:pointer;flex-shrink:0;white-space:nowrap;">${label}${isHighlight}</button>`;
  }).join('');
  
  // Auto-scroll to the end (most recent events) after rendering
  setTimeout(() => {
    if (container && container.parentElement) {
      container.parentElement.scrollLeft = container.parentElement.scrollWidth;
    }
  }, 10);
}

/**
 * Jump to and edit a specific event
 */
function jumpToEvent(idx) {
  const evt = S.events.find(e => e.idx === idx);
  if (!evt) return;
  
  // Open edit modal for this event
  editEvent(S.events.indexOf(evt));
  
  // Also show it on the rink
  renderMarkers();
  
  toast(`Jumped to event #${idx + 1}`, 'info');
}

/**
 * v23.9: Load event into side panel for editing
 */
function loadEventToSidePanel(idx) {
  const evt = S.events[idx];
  if (!evt) return;
  
  S.editingEventInSidePanel = true;
  S.editingEvtIdx = idx;
  
  // Populate side panel form with event data
  setEvtType(evt.type);
  setEvtTeam(evt.team);
  document.getElementById('evtStartTime').value = evt.start_time || evt.time || '';
  document.getElementById('evtEndTime').value = evt.end_time || evt.start_time || evt.time || '';
  
  // Set zone and success
  if (evt.zone) {
    document.getElementById('evtZone').value = evt.zone;
    document.querySelectorAll('.zone-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.zone === evt.zone);
    });
  }
  if (evt.success !== null && evt.success !== undefined) {
    const successVal = evt.success === true ? 's' : evt.success === false ? 'u' : String(evt.success || '');
    document.getElementById('evtSuccess').value = successVal;
    document.querySelectorAll('.success-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.success === successVal);
    });
  }
  if (evt.strength) document.getElementById('evtStrength').value = evt.strength;
  
  // Set details - setEvtType populates detail1 dropdown, then we set values
  setTimeout(() => {
    const detail1Value = evt.detail1 || evt.detail || '';
    if (detail1Value) {
      const d1El = document.getElementById('evtD1');
      if (d1El) {
        // Check if value exists in options, if not add it
        const d1Options = Array.from(d1El.options).map(o => o.value);
        if (!d1Options.includes(detail1Value)) {
          const option = document.createElement('option');
          option.value = detail1Value;
          option.textContent = detail1Value + ' (loaded)';
          d1El.appendChild(option);
        }
        d1El.value = detail1Value;
        
        // Verify value was set - if not, try case-insensitive match or code/name matching
        if (d1El.value !== detail1Value) {
          // Try case-insensitive match
          const caseInsensitiveMatch = Array.from(d1El.options).find(o => 
            o.value.toLowerCase() === detail1Value.toLowerCase()
          );
          if (caseInsensitiveMatch) {
            d1El.value = caseInsensitiveMatch.value;
          } else {
            // Try matching by code or name from eventDetails1
            const detail1Match = S.eventDetails1?.find(e => 
              (e.code === detail1Value || e.name === detail1Value) && 
              String(e.eventType || '').toLowerCase() === String(evt.type || '').toLowerCase()
            );
            if (detail1Match) {
              const codeOrName = detail1Match.code || detail1Match.name;
              const optionMatch = Array.from(d1El.options).find(o => o.value === codeOrName);
              if (optionMatch) {
                d1El.value = codeOrName;
              }
            }
          }
        }
        
        onD1Change();
        setTimeout(() => {
          const detail2Value = evt.detail2 || '';
          if (detail2Value) {
            const d2El = document.getElementById('evtD2');
            if (d2El) {
              // Check if value exists in options, if not add it
              const d2Options = Array.from(d2El.options).map(o => o.value);
              if (!d2Options.includes(detail2Value)) {
                const option = document.createElement('option');
                option.value = detail2Value;
                option.textContent = detail2Value + ' (loaded)';
                d2El.appendChild(option);
              }
              d2El.value = detail2Value;
              
              // Verify value was set - if not, try case-insensitive match or code/name matching
              if (d2El.value !== detail2Value) {
                // Try case-insensitive match
                const caseInsensitiveMatch = Array.from(d2El.options).find(o => 
                  o.value.toLowerCase() === detail2Value.toLowerCase()
                );
                if (caseInsensitiveMatch) {
                  d2El.value = caseInsensitiveMatch.value;
                } else {
                  // Try matching by code or name from eventDetails2
                  const detail2Match = S.eventDetails2?.find(e => 
                    (e.code === detail2Value || e.name === detail2Value) &&
                    e.code?.startsWith(d1El.value?.split('_')[0] || '')
                  );
                  if (detail2Match) {
                    const codeOrName = detail2Match.code || detail2Match.name;
                    const optionMatch = Array.from(d2El.options).find(o => o.value === codeOrName);
                    if (optionMatch) {
                      d2El.value = codeOrName;
                    }
                  }
                }
              }
            }
          }
        }, 200);
      }
    }
  }, 150);
  
  // Load players with all their data including play_details
  S.curr.players = (evt.players || []).map(p => ({
    ...p, 
    xy: [...(p.xy || [])],
    playD1: p.playD1 || '',
    playD2: p.playD2 || '',
    playSuccess: p.playSuccess || '',
    pressuredBy: p.pressuredBy || p.pressure || '',
    sideOfPuck: p.sideOfPuck || ''
  }));
  S.curr.puckXY = [...(evt.puckXY || [])];
  S.curr.netXY = evt.netXY ? {...evt.netXY} : null;
  
  renderQuickAdd();
  renderXYSlots();
  renderMarkers();
  
  // Show indicator with inline actions
  const panelHeader = document.querySelector('#rightPanel .panel-header');
  if (panelHeader) {
    panelHeader.innerHTML = `
      <span>Editing Event #${idx + 1}</span>
      <div style="display:flex;gap:4px;">
        <button class="btn-sm" onclick="insertEventBeforeFromSidePanel(${idx});" title="Insert event before" style="font-size:8px;padding:2px 4px;">‚ûï Before</button>
        <button class="btn-sm" onclick="insertEventAfterFromSidePanel(${idx});" title="Insert event after" style="font-size:8px;padding:2px 4px;">‚ûï After</button>
        <button class="btn-sm btn-danger" onclick="deleteEventFromSidePanel(${idx});" title="Delete event" style="font-size:8px;padding:2px 4px;">‚úï Delete</button>
        <button class="btn-sm" onclick="saveEventFromSidePanel();" style="background:var(--success);">Save</button>
        <button class="btn-sm" onclick="clearEvent(); cancelSidePanelEdit();" title="New Entry" style="background:var(--accent);color:#000;">New Entry</button>
        <button class="btn-sm" onclick="cancelSidePanelEdit();">Cancel</button>
      </div>`;
  }
  
  toast(`Event #${idx + 1} loaded into side panel`, 'info');
}

/**
 * v23.9: Save event from side panel
 */
function saveEventFromSidePanel() {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  
  // Update event from side panel form
  evt.type = S.curr.type || document.getElementById('evtTypeGrid')?.querySelector('.evt-btn.active')?.textContent?.trim() || evt.type;
  evt.team = S.evtTeam || document.getElementById('evtTeam')?.value || evt.team;
  evt.start_time = document.getElementById('evtStartTime').value || evt.start_time;
  evt.end_time = document.getElementById('evtEndTime').value || evt.end_time;
  evt.zone = document.getElementById('evtZone').value || evt.zone;
  evt.success = document.getElementById('evtSuccess').value || evt.success;
  evt.strength = document.getElementById('evtStrength').value || evt.strength;
  evt.detail1 = document.getElementById('evtD1').value || evt.detail1;
  evt.detail2 = document.getElementById('evtD2').value || evt.detail2;
  evt.players = S.curr.players ? S.curr.players.map(p => ({...p, xy: [...(p.xy || [])]})) : evt.players;
  evt.puckXY = S.curr.puckXY && S.curr.puckXY.length > 0 ? [...S.curr.puckXY] : evt.puckXY;
  evt.netXY = S.curr.netXY ? {...S.curr.netXY} : evt.netXY;
  
  // Update type codes and IDs for export
  if (evt.type) {
    const typeInfo = getEventTypeCodeAndId(evt.type);
    evt.typeCode = typeInfo.code;
    evt.typeId = typeInfo.id;
  }
  if (evt.detail1) {
    const detail1Info = getEventDetailCodeAndId(evt.detail1, evt.type);
    evt.detail1Code = detail1Info.code;
    evt.detail1Id = detail1Info.id;
  }
  if (evt.detail2) {
    const detail2Info = getEventDetail2CodeAndId(evt.detail2);
    evt.detail2Code = detail2Info.code;
    evt.detail2Id = detail2Info.id;
  }
  
  // Apply custom rules
  applyCustomRules(evt);
  
  // Sort and reindex events after save
  sortAndReindexEvents();
  
  // Restore panel header
  const panelHeader = document.querySelector('#rightPanel .panel-header');
  if (panelHeader) {
    panelHeader.innerHTML = '<span>Event Entry</span><span id="zoneDisplay"></span>';
  }
  
  S.editingEventInSidePanel = false;
  S.editingEvtIdx = null;
  
  renderEvents();
  updateScores();
  updateBoxScore();
  autoSave();
  toast('Event updated from side panel', 'success');
}

/**
 * v23.9: Cancel side panel edit
 */
function closeSidePanelEdit() {
  cancelSidePanelEdit();
}

function cancelSidePanelEdit() {
  clearEvent();
  S.editingEventInSidePanel = false;
  S.editingEvtIdx = null;
  
  // Restore panel header
  const panelHeader = document.querySelector('#rightPanel .panel-header');
  if (panelHeader) {
    panelHeader.innerHTML = '<span>Event Entry</span><span id="zoneDisplay"></span>';
  }
  
  toast('Edit cancelled', 'info');
}

/**
 * v23.9: Insert event before from side panel
 */
function insertEventBeforeFromSidePanel(idx) {
  if (idx < 0 || idx >= S.events.length) return;
  
  const currentEvt = S.events[idx];
  const newEvt = {
    idx: S.evtIdx++,
    period: currentEvt.period,
    team: currentEvt.team,
    type: '',
    detail1: '',
    detail2: '',
    zone: currentEvt.zone || '',
    success: '',
    strength: currentEvt.strength || '5v5',
    start_time: currentEvt.start_time,
    end_time: '',
    players: [],
    puckXY: [],
    linkedEventIdx: null,
    assistToGoalIdx: null,
    isHighlight: false
  };
  
  S.events.splice(idx, 0, newEvt);
  markDataChanged();
  cancelSidePanelEdit();
  renderEvents(); updateScores(); updateBoxScore();
  autoSave();
  toast(`Inserted event #${idx + 1}`, 'success');
  
  // Load the new event into side panel
  setTimeout(() => loadEventToSidePanel(idx), 100);
}

/**
 * v23.9: Insert event after from side panel
 */
function insertEventAfterFromSidePanel(idx) {
  if (idx < 0 || idx >= S.events.length) return;
  
  const currentEvt = S.events[idx];
  const newEvt = {
    idx: S.evtIdx++,
    period: currentEvt.period,
    team: currentEvt.team,
    type: '',
    detail1: '',
    detail2: '',
    zone: currentEvt.zone || '',
    success: '',
    strength: currentEvt.strength || '5v5',
    start_time: currentEvt.end_time || currentEvt.start_time,
    end_time: '',
    players: [],
    puckXY: [],
    linkedEventIdx: null,
    assistToGoalIdx: null,
    isHighlight: false
  };
  
  const newIdx = idx + 1;
  S.events.splice(newIdx, 0, newEvt);
  markDataChanged();
  cancelSidePanelEdit();
  renderEvents(); updateScores(); updateBoxScore();
  autoSave();
  toast(`Inserted event #${newIdx + 1}`, 'success');
  
  // Load the new event into side panel
  setTimeout(() => loadEventToSidePanel(newIdx), 100);
}

/**
 * v23.9: Delete event from side panel
 */
function deleteEventFromSidePanel(idx) {
  if (idx < 0 || idx >= S.events.length) return;
  if (!confirm(`Delete event #${idx + 1}?`)) return;
  
  S.events.splice(idx, 1);
  markDataChanged();
  
  // Reindex linked event indexes after deletion
  reindexLinkedEventIndexes();
  
  cancelSidePanelEdit();
  renderEvents(); updateScores(); updateBoxScore();
  autoSave();
  toast('Event deleted', 'success');
}

/**
 * v23.9: Carry over XY from previous event if all players match and no XY is set
 */
function carryOverXYFromPreviousEvent(loggedEvent) {
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'carryOverXYFromPreviousEvent:entry',message:'XY carry-over check',data:{enabled:S.xyCarryOverEnabled,hasLoggedEvent:!!loggedEvent,currPlayersCount:S.curr.players?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
  // #endregion
  
  // v23.9: Check if XY carry-over is enabled
  if (S.xyCarryOverEnabled === false) {
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'carryOverXYFromPreviousEvent:disabled',message:'XY carry-over disabled',timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
    // #endregion
    return;
  }
  if (!loggedEvent || !S.curr.players || S.curr.players.length === 0) {
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'carryOverXYFromPreviousEvent:noData',message:'No data to carry over',data:{hasLoggedEvent:!!loggedEvent,hasCurrPlayers:!!S.curr.players,currPlayersCount:S.curr.players?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
    // #endregion
    return;
  }
  
  // Get previous event (the one just logged)
  const prevEvent = loggedEvent;
  if (!prevEvent.players || prevEvent.players.length === 0) {
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'carryOverXYFromPreviousEvent:noPrevPlayers',message:'Previous event has no players',timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
    // #endregion
    return;
  }
  
  // Check if all current players were in the previous event
  const currentPlayerKeys = S.curr.players.map(p => `${p.num}_${p.team || S.evtTeam}`).sort();
  const prevPlayerKeys = prevEvent.players.map(p => `${p.num}_${p.team || prevEvent.team}`).sort();
  
  // Check if all current players exist in previous event
  const allPlayersMatch = currentPlayerKeys.every(key => prevPlayerKeys.includes(key));
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'carryOverXYFromPreviousEvent:playerMatch',message:'Player match check',data:{allPlayersMatch,currentPlayerKeys,prevPlayerKeys},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
  // #endregion
  
  if (!allPlayersMatch) {
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'carryOverXYFromPreviousEvent:playersDontMatch',message:'Players dont match - skipping carry-over',timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
    // #endregion
    return; // Not all players match, skip
  }
  
  let playersCarriedOver = 0;
  let puckCarriedOver = false;
  
  // For each current player, if they have no XY but had XY in previous event, copy last XY
  S.curr.players.forEach(currPlayer => {
    // Skip if player already has XY
    if (currPlayer.xy && currPlayer.xy.length > 0) {
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'carryOverXYFromPreviousEvent:playerHasXY',message:'Player already has XY - skipping',data:{playerNum:currPlayer.num,xyCount:currPlayer.xy.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
      // #endregion
      return;
    }
    
    // Find matching player in previous event (by num and team)
    const prevPlayer = prevEvent.players.find(p => 
      p.num === currPlayer.num && 
      (p.team || prevEvent.team) === (currPlayer.team || S.evtTeam)
    );
    
    if (prevPlayer && prevPlayer.xy && prevPlayer.xy.length > 0) {
      // Copy the last XY point (end position) as the first XY point for next event
      const lastXY = prevPlayer.xy[prevPlayer.xy.length - 1];
      currPlayer.xy = [{ x: lastXY.x, y: lastXY.y, seq: 1 }];
      playersCarriedOver++;
      
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'carryOverXYFromPreviousEvent:playerCarried',message:'Carried over player XY',data:{playerNum:currPlayer.num,fromXY:{x:lastXY.x,y:lastXY.y,seq:lastXY.seq},toXY:{x:currPlayer.xy[0].x,y:currPlayer.xy[0].y,seq:1}},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
      // #endregion
    }
  });
  
  // Also carry over puck XY if no puck XY is set
  if ((!S.curr.puckXY || S.curr.puckXY.length === 0) && prevEvent.puckXY && prevEvent.puckXY.length > 0) {
    const lastPuckXY = prevEvent.puckXY[prevEvent.puckXY.length - 1];
    S.curr.puckXY = [{ x: lastPuckXY.x, y: lastPuckXY.y, seq: 1 }];
    puckCarriedOver = true;
    
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'carryOverXYFromPreviousEvent:puckCarried',message:'Carried over puck XY',data:{fromXY:{x:lastPuckXY.x,y:lastPuckXY.y,seq:lastPuckXY.seq},toXY:{x:S.curr.puckXY[0].x,y:S.curr.puckXY[0].y,seq:1}},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
    // #endregion
  }
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'carryOverXYFromPreviousEvent:complete',message:'XY carry-over complete',data:{playersCarriedOver,puckCarriedOver},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
  // #endregion
  
  // Re-render to show carried over XY
  renderMarkers();
  renderXYSlots();
  
  // Show visual feedback
  if (playersCarriedOver > 0 || puckCarriedOver) {
    toast(`XY carried over: ${playersCarriedOver} player(s)${puckCarriedOver ? ', puck' : ''}`, 'info');
  }
}

/**
 * v23.9: Enter XY drawing mode for an event
 */
function enterXYDrawingMode(idx) {
  const evt = S.events[idx];
  if (!evt) return;
  
  S.editingEvtIdx = idx;
  S.xyMode = 'puck';
  S.xySlot = 1;
  
  // Load event XY data
  S.curr.puckXY = [...(evt.puckXY || [])];
  S.curr.players = (evt.players || []).map(p => ({...p, xy: [...(p.xy || [])]}));
  S.curr.netXY = evt.netXY ? {...evt.netXY} : null;
  
  renderMarkers();
  
  // Show indicator
  toast(`XY Drawing Mode: Event #${idx + 1}. Click rink to add XY. Press Esc when done.`, 'info');
  
  // Set up escape handler
  const escapeHandler = (e) => {
    if (e.key === 'Escape' && S.editingEvtIdx === idx) {
      // Save XY and exit
      evt.puckXY = [...S.curr.puckXY];
      evt.players = S.curr.players.map(p => ({...p, xy: [...(p.xy || [])]}));
      evt.netXY = S.curr.netXY ? {...S.curr.netXY} : null;
      
      S.editingEvtIdx = null;
      renderEvents();
      autoSave();
      toast('XY saved', 'success');
      document.removeEventListener('keydown', escapeHandler);
    }
  };
  document.addEventListener('keydown', escapeHandler);
}

// ============================================================
// v23.4: ENHANCED QUICK EVENT CHAINS
// ============================================================

// Enhanced event chains with full workflow
const QUICK_CHAINS = {
  controlledEntry: {
    name: 'Controlled Entry',
    sequence: [
      { type: 'Zone_Entry_Exit', d1: 'Zone_Entry', d2: 'Entry_Carry', zone: 'o', autoPlayers: ['E1'] },
      { type: 'Possession', d1: 'Possession_Cycle', zone: 'o' }
    ]
  },
  dumpIn: {
    name: 'Dump In',
    sequence: [
      { type: 'Zone_Entry_Exit', d1: 'Zone_Entry', d2: 'Entry_Dump', zone: 'o', autoPlayers: ['E1'] },
      { type: 'Possession', d1: 'Possession_Forecheck', zone: 'o' }
    ]
  },
  shotSequence: {
    name: 'Shot ‚Üí Save ‚Üí Rebound',
    sequence: [
      { type: 'Shot', d1: 'Shot_OnNet', zone: 'o', autoPlayers: ['E1'] },
      { type: 'Save', d1: 'Save_Rebound', zone: 'o' },
      { type: 'Shot', d1: 'Shot_OnNet', zone: 'o' }
    ]
  },
  breakout: {
    name: 'Breakout to Rush',
    sequence: [
      { type: 'Possession', d1: 'Possession_Breakout', zone: 'd', autoPlayers: ['E1'] },
      { type: 'Pass', d1: 'Pass_Breakout', zone: 'd' },
      { type: 'Zone_Entry_Exit', d1: 'Zone_Exit', d2: 'Exit_Rush', zone: 'n' }
    ]
  },
  ppCycle: {
    name: 'PP Cycle',
    sequence: [
      { type: 'Possession', d1: 'Possession_Cycle', zone: 'o', strength: '5v4' },
      { type: 'Pass', d1: 'Pass_Cycle', zone: 'o', strength: '5v4' },
      { type: 'Shot', d1: 'Shot_OnNet', zone: 'o', strength: '5v4' }
    ]
  }
};

let currentChainIdx = 0;
let activeChain = null;

/**
 * Start a quick chain sequence
 */
function startQuickChain(chainKey) {
  const chain = QUICK_CHAINS[chainKey];
  if (!chain) return;
  
  activeChain = chain;
  currentChainIdx = 0;
  
  // Enable sequence mode
  if (!sequenceModeActive) toggleSequenceMode();
  
  // Apply first event in chain
  applyChainStep();
  
  toast(`Starting: ${chain.name} (${chain.sequence.length} steps)`, 'success');
}

/**
 * Apply current chain step
 */
function applyChainStep() {
  if (!activeChain || currentChainIdx >= activeChain.sequence.length) {
    // Chain complete
    activeChain = null;
    currentChainIdx = 0;
    toast('Chain complete!', 'success');
    return;
  }
  
  const step = activeChain.sequence[currentChainIdx];
  
  setEvtType(step.type);
  
  setTimeout(() => {
    if (step.d1) document.getElementById('evtD1').value = step.d1;
    if (step.d2) {
      onD1Change();
      setTimeout(() => {
        document.getElementById('evtD2').value = step.d2;
      }, 30);
    }
    if (step.zone) setZone(step.zone);
    if (step.strength) document.getElementById('evtStrength').value = step.strength;
    
    // Show progress
    const progress = `Step ${currentChainIdx + 1}/${activeChain.sequence.length}`;
    toast(`${activeChain.name}: ${progress}`, 'info');
  }, 50);
}

/**
 * Advance to next chain step (called after logging event)
 */
function advanceChain() {
  if (!activeChain) return;
  currentChainIdx++;
  applyChainStep();
}

// Hook into event logging to advance chain and auto-advance
const originalLogEventDirect = logEventDirect;
logEventDirect = function() {
  // v23.5: Push undo state before logging
  pushUndoState('Log event');
  
  originalLogEventDirect.apply(this, arguments);
  advanceChain();
  renderTimeline();
  if (typeof setupAutoAdvance === 'function') setupAutoAdvance();
  
  // v23.5: Update recent players
  if (S.curr && S.curr.players) {
    S.curr.players.forEach(p => addToRecentPlayers(p));
  }
  
  // v23.5: Update suggestions
  renderEventSuggestions();
};

// ============================================================
// v23.4: KEYBOARD NAVIGATION
// ============================================================

/**
 * Setup keyboard navigation for dropdowns
 */
function setupKeyboardNav() {
  // Tab order enhancement
  const focusableElements = [
    'evtD1', 'evtD2', 'evtZone', 'evtSuccess', 'evtStrength',
    'evtStartTime', 'evtEndTime'
  ];
  
  focusableElements.forEach((id, idx) => {
    const el = document.getElementById(id);
    if (el) {
      el.tabIndex = idx + 1;
    }
  });
}

// Initialize on load
document.addEventListener('DOMContentLoaded', () => {
  setTimeout(() => {
    startShiftMonitoring();
    setupKeyboardNav();
    loadCustomChainPresets();
    
    // Load video offset from storage
    const savedOffset = localStorage.getItem('benchsight_videoOffset');
    if (savedOffset) videoOffset = parseInt(savedOffset);
    
    // Load penalty minutes from storage (default 3 for rec league)
    const savedPenMins = localStorage.getItem('benchsight_penaltyMinutes');
    if (savedPenMins) {
      penaltyMinutes = parseInt(savedPenMins);
      const ppInput = document.getElementById('ppMinutes');
      if (ppInput) ppInput.value = penaltyMinutes;
    }
  }, 1000);
});

// ============================================================
// v23.3: SHOT CHART MODE
// ============================================================
let shotChartModeActive = false;

/**
 * Toggle shot chart mode - click rink to create shots
 */
function toggleShotChartMode() {
  shotChartModeActive = !shotChartModeActive;
  possessionModeActive = false; // Turn off possession mode
  
  const shotBtn = document.getElementById('shotChartModeBtn');
  const possBtn = document.getElementById('possessionModeBtn');
  
  if (shotBtn) shotBtn.classList.toggle('mode-active', shotChartModeActive);
  if (possBtn) possBtn.classList.remove('mode-active');
  
  if (shotChartModeActive) {
    setEvtType('Shot');
    toast('Shot Chart Mode ON: Click rink to place shots', 'success');
  } else {
    toast('Shot Chart Mode OFF', 'info');
  }
}

/**
 * Handle shot chart click - creates shot at click location
 */
function handleShotChartClick(svgX, svgY, relX, relY) {
  if (!shotChartModeActive) return false;
  
  // Determine shot type based on location
  const zone = getZoneFromClick(svgX);
  if (zone !== 'o') {
    toast('Click in offensive zone to place shot', 'warning');
    return true; // Consumed the click
  }
  
  // Set shot type
  setEvtType('Shot');
  document.getElementById('evtZone').value = 'o';
  
  // Set puck position
  S.curr.puckXY = [{ x: relX, y: relY, seq: 1 }];
  
  // Set time
  document.getElementById('evtStartTime').value = document.getElementById('clock').value;
  
  // Show shot type modal or default to Shot_OnNet
  setTimeout(() => {
    document.getElementById('evtD1').value = 'Shot_OnNet';
    onD1Change();
    
    // Open net modal for shot location
    document.getElementById('netModal').classList.add('show');
  }, 50);
  
  renderMarkers();
  toast('Shot placed - select net location', 'info');
  return true; // Consumed the click
}

// ============================================================
// v23.3: POSSESSION MODE (sequence tracking)
// ============================================================
let possessionModeActive = false;
let possessionModeStartTime = null;  // Renamed to avoid conflict with v23.5
let possessionModeTeam = null;       // Renamed to avoid conflict with v23.5

/**
 * Toggle possession tracking mode
 */
function togglePossessionMode() {
  possessionModeActive = !possessionModeActive;
  shotChartModeActive = false; // Turn off shot mode
  
  const shotBtn = document.getElementById('shotChartModeBtn');
  const possBtn = document.getElementById('possessionModeBtn');
  
  if (shotBtn) shotBtn.classList.remove('mode-active');
  if (possBtn) possBtn.classList.toggle('mode-active', possessionModeActive);
  
  if (possessionModeActive) {
    possessionModeStartTime = document.getElementById('clock').value;
    possessionModeTeam = S.evtTeam;
    setEvtType('Possession');
    toggleSequenceMode(); // Also turn on sequence mode
    toast('Possession Mode ON: Track possession chain', 'success');
  } else {
    possessionModeStartTime = null;
    possessionModeTeam = null;
    if (sequenceModeActive) toggleSequenceMode(); // Turn off sequence mode
    toast('Possession Mode OFF', 'info');
  }
}

/**
 * End possession and log a turnover/shot
 */
function endPossession(reason) {
  if (!possessionModeActive) return;
  
  const duration = calculatePossessionModeDuration();
  
  if (reason === 'shot') {
    setEvtType('Shot');
  } else if (reason === 'turnover') {
    setEvtType('Turnover');
    document.getElementById('evtD1').value = 'Turnover_Giveaway';
  } else if (reason === 'pass') {
    // Continue possession with pass
    setEvtType('Pass');
    return;
  }
  
  toast(`Possession ended: ${duration}s - ${reason}`, 'info');
}

/**
 * Calculate possession duration
 */
function calculatePossessionModeDuration() {
  if (!possessionModeStartTime) return 0;
  
  const startParts = possessionModeStartTime.split(':').map(Number);
  const startSec = startParts[0] * 60 + startParts[1];
  
  const currentTime = document.getElementById('clock').value;
  const currentParts = currentTime.split(':').map(Number);
  const currentSec = currentParts[0] * 60 + currentParts[1];
  
  // Clock counts down, so start > current
  return startSec - currentSec;
}

// ============================================================
// v23.3: SHIFT AUTO-END
// ============================================================

/**
 * Auto-end shift on stoppage events
 */
function checkAutoEndShift(evt) {
  if (!evt) return;
  
  // Events that typically end a shift
  const shiftEndingEvents = ['Stoppage', 'Faceoff', 'Penalty', 'Goal'];
  const shiftEndingDetails = ['Icing', 'Offside', 'PeriodEnd', 'Timeout'];
  
  if (shiftEndingEvents.includes(evt.type) || 
      shiftEndingDetails.some(d => (evt.detail1 || '').includes(d))) {
    
    // Auto-fill shift end time
    const shiftEndEl = document.getElementById('shiftEnd');
    if (shiftEndEl && !shiftEndEl.value) {
      shiftEndEl.value = evt.start_time;
      toast('Shift end time auto-filled', 'info');
    }
  }
}

// ============================================================
// v23.3: BATCH PLAYER PLACEMENT
// ============================================================
let batchPlacementPlayers = [];

/**
 * Select multiple players for batch placement
 */
function toggleBatchPlayer(num) {
  const idx = batchPlacementPlayers.indexOf(num);
  if (idx >= 0) {
    batchPlacementPlayers.splice(idx, 1);
  } else {
    batchPlacementPlayers.push(num);
  }
  renderQuickAdd(); // Re-render to show selection
}

/**
 * Place all batch-selected players at a position
 */
function placeBatchPlayers(x, y) {
  if (batchPlacementPlayers.length === 0) return false;
  
  batchPlacementPlayers.forEach((num, i) => {
    const player = S.curr.players.find(p => p.num === num);
    if (player) {
      // Offset each player slightly so they don't overlap
      const offsetX = (i % 3 - 1) * 3;
      const offsetY = Math.floor(i / 3) * 3;
      player.xy.push({ x: x + offsetX, y: y + offsetY, seq: 1 });
    }
  });
  
  batchPlacementPlayers = [];
  renderMarkers();
  renderQuickAdd();
  toast('Players placed', 'success');
  return true;
}

// ============================================================
// v23.3: AUTO-ADVANCE FEATURES
// ============================================================

/**
 * Auto-advance to next event after logging
 */
function setupAutoAdvance() {
  // After logging, check if we should auto-setup next event
  const lastEvt = S.events[S.events.length - 1];
  if (!lastEvt) return;
  
  const suggestion = getSuggestedNextEvent();
  if (suggestion && sequenceModeActive) {
    // Auto-set suggested event type
    setEvtType(suggestion.type);
  }
  
  // Check for shift auto-end
  checkAutoEndShift(lastEvt);
}

// Hook into event logging
const originalDoLogEvent = doLogEvent;
doLogEvent = function() {
  originalDoLogEvent();
  setupAutoAdvance();
};

// Update penalty player dropdown when team changes
const originalSetEvtTeam = setEvtTeam;
setEvtTeam = function(team) {
  originalSetEvtTeam(team);
  updateQuickPenaltyPlayers();
};

// Initialize penalty dropdown on load
document.addEventListener('DOMContentLoaded', () => {
  setTimeout(updateQuickPenaltyPlayers, 1000);
});

/**
 * Quick time entry: type 1530 and it becomes 15:30
 */
function setupTimeInputs() {
  ['evtStartTime', 'evtEndTime', 'clock', 'shiftStart', 'shiftEnd'].forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      el.addEventListener('blur', () => {
        let val = el.value.replace(/[^0-9:]/g, '');
        // If no colon and 3-4 digits, auto-format
        if (!val.includes(':') && val.length >= 3) {
          val = val.slice(0, -2) + ':' + val.slice(-2);
        }
        // Ensure seconds are padded
        if (val.includes(':')) {
          const [min, sec] = val.split(':');
          val = min + ':' + (sec || '00').padStart(2, '0');
        }
        el.value = val;
      });
    }
  });
}

// ============================================================
// EDIT EVENT MODAL
// ============================================================
function editEvent(idx) {
  try {
    console.log('Opening edit modal for event', idx);
    
    // Bounds check
    if (idx < 0 || idx >= S.events.length) {
      console.error('Invalid event index:', idx);
      toast('Invalid event index', 'error');
      return;
    }
    
  S.editingEvtIdx = idx;
  const evt = S.events[idx];
    
    if (!evt) {
      console.error('Event not found at index', idx);
      toast('Event not found', 'error');
      return;
    }

  // v24.0: Update zone labels based on event's period when editing
  // Store editing period for use in updateZoneLabels
  if (evt.period) {
    const editingPeriod = evt.period === 'OT' ? 4 : parseInt(evt.period) || 1;
    S.editingPeriod = editingPeriod; // Store for dynamic updates
    updateZoneLabels(editingPeriod);
  } else {
    S.editingPeriod = S.period; // Default to current period
    updateZoneLabels(S.period);
  }

  // Ensure players array exists
  if (!evt.players) evt.players = [];
  if (!evt.puckXY) evt.puckXY = [];
  
  // v24.0: Clean up invalid XY items when opening edit modal
  if (evt.puckXY && evt.puckXY.length > 0) {
    evt.puckXY = evt.puckXY.filter(xy => 
      xy && xy.x !== null && xy.x !== undefined && xy.y !== null && xy.y !== undefined
    );
    // Renumber after filtering
    evt.puckXY.forEach((p, i) => { p.seq = i + 1; });
  }
  
  // Clean up invalid player XY items
  if (evt.players && evt.players.length > 0) {
    evt.players.forEach(p => {
      if (p.xy && p.xy.length > 0) {
        p.xy = p.xy.filter(xy => 
          xy && xy.x !== null && xy.x !== undefined && xy.y !== null && xy.y !== undefined
        );
        // Renumber after filtering
        p.xy.forEach((pt, i) => { pt.seq = i + 1; });
      }
    });
  }
  
  // v23.9: Initialize XY editing state
  S.editingXYType = null;
  S.editingXYIdx = null;
  S.editingXYPlayerIdx = null;
  
  // v23.8: Show/hide net visualization for Shot/Goal events
  updateNetVisibility();
  
  document.getElementById('editEvtIdx').textContent = idx + 1;
  document.getElementById('editHighlightBadge').textContent = evt.isHighlight ? '‚≠ê' : '';
  document.getElementById('editType').value = evt.type;
  
  // Update team dropdown with actual team names
  const editTeamSel = document.getElementById('editTeam');
  editTeamSel.innerHTML = `<option value="home">${S.homeTeam || 'Home'}</option><option value="away">${S.awayTeam || 'Away'}</option>`;
  editTeamSel.value = evt.team;
  document.getElementById('editStartTime').value = evt.start_time || evt.time || '';
  document.getElementById('editEndTime').value = evt.end_time || evt.start_time || evt.time || '';
  document.getElementById('editZone').value = evt.zone || '';
  document.getElementById('editSuccess').value = evt.success || '';
  document.getElementById('editStrength').value = evt.strength || '5v5';
  document.getElementById('editHighlight').checked = evt.isHighlight || false;
  document.getElementById('editVideoUrl').value = evt.videoUrl || '';
  toggleEditHighlightFields(); // v23.7: Show/hide video URL field
  
  // Linked event index (editable)
  // v23.9: Only auto-populate for linked events, set to last linked event index + 1
  const linkedIdxEl = document.getElementById('editLinkedIdx');
  if (linkedIdxEl) {
    if (evt.linkedEventIdx !== null && evt.linkedEventIdx !== undefined) {
      // Display linked index (1-based for user input)
      linkedIdxEl.value = evt.linkedEventIdx + 1;
    } else {
      // Not linked - leave empty
      linkedIdxEl.value = '';
    }
  }
  
  // v23.8: Sequence and play keys (now editable)
  const seqKeyEl = document.getElementById('editSeqKey');
  const playKeyEl = document.getElementById('editPlayKey');
  if (seqKeyEl) seqKeyEl.value = evt.sequenceIdx || evt.seqIdx || evt.sequence_key || evt.sequence_id || '';
  if (playKeyEl) playKeyEl.value = evt.playIdx || evt.play_key || evt.play_id || '';
  
  // v23.8: Event ID (now editable)
  const eventIdEl = document.getElementById('editEventId');
  const eventIndexEl = document.getElementById('editEventIndex');
  if (eventIdEl) eventIdEl.value = evt.eventId || evt.event_id || '';
  if (eventIndexEl) eventIndexEl.textContent = evt.idx || (idx + 1);
  
  // Show linked chain - find all events with the same linked index
  let chainText = '--';
  const unlinkButton = document.getElementById('editUnlinkButton');
  const chainElement = document.getElementById('editLinkedChain');
  let chainEvents = [];
  
  if (evt.linkedEventIdx !== null && evt.linkedEventIdx !== undefined) {
    chainEvents = S.events.filter(e => e.linkedEventIdx === evt.linkedEventIdx);
    if (chainEvents.length > 1) {
      chainText = `Linked #${evt.linkedEventIdx + 1}: ${chainEvents.map(e => `#${S.events.indexOf(e) + 1}`).join(' ‚Üí ')}`;
    } else {
      chainText = `Linked #${evt.linkedEventIdx + 1}`;
    }
    if (unlinkButton) unlinkButton.style.display = 'block';
    
    // Make chain clickable - navigate to next event in chain
    if (chainElement && chainEvents.length > 1) {
      chainElement.textContent = chainText;
      chainElement.style.cursor = 'pointer';
      chainElement.style.textDecoration = 'underline';
      chainElement.title = 'Click to navigate to next event in chain';
      // Remove existing click handler if any
      chainElement.onclick = null;
      // Add click handler to navigate to next event in chain
      chainElement.onclick = function(e) {
        e.stopPropagation();
        // Prompt to save if there are unsaved changes
        if (!promptSaveBeforeNavigate()) {
          return; // User cancelled
        }
        
        // Find current event's position in chain
        const currentIdx = chainEvents.findIndex(e => e === evt);
        if (currentIdx !== -1) {
          // Navigate to next event in chain (wrap around)
          const nextIdx = (currentIdx + 1) % chainEvents.length;
          const nextEvent = chainEvents[nextIdx];
          const nextEventIdx = S.events.indexOf(nextEvent);
          if (nextEventIdx !== -1) {
            editEvent(nextEventIdx);
          }
        }
      };
    } else if (chainElement) {
      chainElement.textContent = chainText;
      chainElement.style.cursor = 'default';
      chainElement.style.textDecoration = 'none';
      chainElement.title = '';
      chainElement.onclick = null;
    }
  } else {
    if (unlinkButton) unlinkButton.style.display = 'none';
    if (chainElement) {
      chainElement.textContent = chainText;
      chainElement.style.cursor = 'default';
      chainElement.style.textDecoration = 'none';
      chainElement.title = '';
      chainElement.onclick = null;
    }
  }
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'editEvent:15207',message:'editEvent: Setting event type and details',data:{idx,type:evt.type,detail1:evt.detail1,detail2:evt.detail2,eventDetails1Loaded:S.eventDetails1?.length||0,eventDetails2Loaded:S.eventDetails2?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
  // #endregion
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'editEvent:15207',message:'editEvent: Before onEditTypeChange',data:{idx,type:evt.type,detail1:evt.detail1,detail2:evt.detail2,eventDetails1Count:S.eventDetails1?.length||0,eventDetails2Count:S.eventDetails2?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
  // #endregion
  
  onEditTypeChange();
  
  // Set detail1 value - use setTimeout to ensure dropdown is fully populated
  setTimeout(() => {
    const editD1El = document.getElementById('editD1');
    const detail1Value = evt.detail1 || evt.detail || '';
    
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'editEvent:15208',message:'editEvent: Setting editD1 value',data:{detail1Value,editD1OptionsCount:editD1El?.options?.length||0,editD1Options:Array.from(editD1El?.options||[]).map(o=>o.value).slice(0,5)},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
    // #endregion
    
    if (editD1El && detail1Value) {
      // Check if value exists in options, if not add it
      const d1Options = Array.from(editD1El.options).map(o => o.value);
      if (!d1Options.includes(detail1Value)) {
        // Value not in dropdown - add it
        const option = document.createElement('option');
        option.value = detail1Value;
        option.textContent = detail1Value + ' (loaded)';
        editD1El.insertBefore(option, editD1El.firstChild.nextSibling);
      }
      
      editD1El.value = detail1Value;
      
      // Verify value was set - if not, try case-insensitive match or code/name matching
      if (editD1El.value !== detail1Value) {
        // Try case-insensitive match
        const caseInsensitiveMatch = Array.from(editD1El.options).find(o => 
          o.value.toLowerCase() === detail1Value.toLowerCase()
        );
        if (caseInsensitiveMatch) {
          editD1El.value = caseInsensitiveMatch.value;
        } else {
          // Try matching by code or name from eventDetails1
          const detail1Match = S.eventDetails1?.find(e => 
            (e.code === detail1Value || e.name === detail1Value) && 
            String(e.eventType || '').toLowerCase() === String(evt.type || '').toLowerCase()
          );
          if (detail1Match) {
            const codeOrName = detail1Match.code || detail1Match.name;
            const optionMatch = Array.from(editD1El.options).find(o => o.value === codeOrName);
            if (optionMatch) {
              editD1El.value = codeOrName;
            }
          }
        }
      }
      
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'editEvent:15209',message:'editEvent: After setting editD1.value',data:{detail1Value,editD1Value:editD1El.value,valueMatches:editD1El.value===detail1Value},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
      // #endregion
      
      // Now trigger onEditD1Change to populate detail2 dropdown
      onEditD1Change(evt.detail2 || '');
      
      // Set detail2 value after dropdown is populated
      setTimeout(() => {
        const editD2El = document.getElementById('editD2');
        const detail2Value = evt.detail2 || '';
        
        // #region agent log
        fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'editEvent:15210',message:'editEvent: Setting editD2 value',data:{detail2Value,editD2OptionsCount:editD2El?.options?.length||0,editD2Options:Array.from(editD2El?.options||[]).map(o=>o.value).slice(0,5)},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
        // #endregion
        
        if (detail2Value && editD2El) {
          // Check if value exists in options, if not add it
          const d2Options = Array.from(editD2El.options).map(o => o.value);
          if (!d2Options.includes(detail2Value)) {
            const option = document.createElement('option');
            option.value = detail2Value;
            option.textContent = detail2Value + ' (loaded)';
            editD2El.appendChild(option);
          }
          
          editD2El.value = detail2Value;
          
          // Verify value was set - if not, try case-insensitive match or code/name matching
          if (editD2El.value !== detail2Value) {
            // Try case-insensitive match
            const caseInsensitiveMatch = Array.from(editD2El.options).find(o => 
              o.value.toLowerCase() === detail2Value.toLowerCase()
            );
            if (caseInsensitiveMatch) {
              editD2El.value = caseInsensitiveMatch.value;
            } else {
              // Try matching by code or name from eventDetails2
              const detail2Match = S.eventDetails2?.find(e => 
                (e.code === detail2Value || e.name === detail2Value) &&
                e.code?.startsWith(editD1El.value?.split('_')[0] || '')
              );
              if (detail2Match) {
                const codeOrName = detail2Match.code || detail2Match.name;
                const optionMatch = Array.from(editD2El.options).find(o => o.value === codeOrName);
                if (optionMatch) {
                  editD2El.value = codeOrName;
                }
              }
            }
          }
          
          // #region agent log
          fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'editEvent:15211',message:'editEvent: After setting editD2.value',data:{detail2Value,editD2Value:editD2El.value,valueMatches:editD2El.value===detail2Value},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
          // #endregion
        }
        
        // v24.0: Update net visibility after all dropdowns are populated
        updateNetVisibility();
      }, 200);
    }
  }, 100);
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'editEvent:15210',message:'editEvent: After onEditD1Change, checking editD2',data:{detail2:evt.detail2,editD2Value:document.getElementById('editD2').value,editD2Options:document.getElementById('editD2').options.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
  // #endregion
  
  renderEditPlayers(evt.players);
  renderEditPuckXY(evt.puckXY);
  
  // Populate XY target dropdown (puck + each player)
  const xyTargetSel = document.getElementById('editXYTarget');
  xyTargetSel.innerHTML = '<option value="puck">Puck</option>' + 
    (evt.players || []).map((p, i) => `<option value="player_${i}">#${p.num} ${p.name}</option>`).join('');
  
  renderEditRinkMarkers();
  
  // v24.0: Show/hide net section for Goal OR Shot_OnNetSaved OR Shot_OnNetGoal
  const type = evt.type || '';
  const d1 = evt.detail1 || '';
  const d1Lower = (d1 || '').toLowerCase();
  const showNet = type === 'Goal' || 
                  d1 === 'Shot_OnNetSaved' ||
                  d1 === 'Shot_OnNetGoal' ||
                  d1Lower === 'shot_onnetsaved' ||
                  d1Lower === 'shot_onnetgoal' ||
                  d1Lower.includes('shot_onnetsaved') ||
                  d1Lower.includes('shot_onnetgoal');
  document.getElementById('editNetSection').style.display = showNet ? 'block' : 'none';
  if (showNet && evt.netXY) {
    renderEditNetMarker(evt.netXY);
    document.getElementById('editNetLocation').textContent = getNetLocationName(evt.netXY) || '--';
  } else if (showNet) {
    // Net section visible but no location yet
    renderEditNetMarker(null);
    document.getElementById('editNetLocation').textContent = '--';
  }
  
  // v23.8: Show/hide assists section for goals
  const showAssists = evt.type === 'Goal';
  document.getElementById('editAssistsSection').style.display = showAssists ? 'block' : 'none';
  if (showAssists) {
    renderEditAssists(evt);
  }
  
  // v23.8: Show/hide assist-to-goal link field (for Pass events or events with assist markers)
  const hasAssistMarker = evt.players?.some(p => {
    const pd1 = (p.playD1 || '').toLowerCase();
    const pd2 = (p.playD2 || '').toLowerCase();
    return pd1.includes('assist') || pd2.includes('assist');
  });
  const showAssistToGoal = evt.type === 'Pass' || hasAssistMarker;
  const assistToGoalSection = document.getElementById('editAssistToGoalSection');
  if (assistToGoalSection) {
    assistToGoalSection.style.display = showAssistToGoal ? 'block' : 'none';
    if (showAssistToGoal) {
      const assistToGoalEl = document.getElementById('editAssistToGoalIdx');
      if (assistToGoalEl) {
        assistToGoalEl.value = (evt.assistToGoalIdx !== null && evt.assistToGoalIdx !== undefined) ? evt.assistToGoalIdx + 1 : '';
      }
    }
  }
  
    const modal = document.getElementById('editModal');
    if (!modal) {
      console.error('editModal element not found!');
      toast('Edit modal not found. Please refresh the page.', 'error');
      return;
    }
    
    // Ensure modal is in body (move if needed)
    if (modal.parentElement !== document.body) {
      document.body.appendChild(modal);
    }
    
    // Ensure modal overlay is visible - set ALL properties immediately
    // Temporarily disable transition for instant visibility
    const originalTransition = modal.style.transition;
    modal.style.transition = 'none';
      modal.classList.add('show');
    modal.style.display = 'flex';
    modal.style.visibility = 'visible';
    modal.style.opacity = '1';
    modal.style.zIndex = '10000';
    modal.style.position = 'fixed';
    modal.style.top = '0';
    modal.style.left = '0';
    modal.style.right = '0';
    modal.style.bottom = '0';
    modal.style.width = '100%';
    modal.style.height = '100%';
    modal.style.background = 'rgba(0,0,0,0.85)';
    
    // Ensure the modal content div is properly positioned
    const modalContent = modal.querySelector('.modal');
    if (modalContent) {
      modalContent.style.position = 'relative';
      modalContent.style.zIndex = '10001';
    }
    
    // Remove ALL existing handlers that might interfere
    if (modal._overlayClickHandler) {
      modal.removeEventListener('click', modal._overlayClickHandler);
      modal.removeEventListener('mousedown', modal._overlayClickHandler);
      delete modal._overlayClickHandler;
    }
    modal.onclick = null;
    modal.removeAttribute('onclick');
    
    // Use simple inline onclick pattern - only closes when clicking overlay itself
    modal.setAttribute('onclick', 'if(event.target===this)closeEditModal()');
    
    // Make ALL buttons work
    ensureModalButtonsWork(modal);
    
    console.log('Edit event modal opened - show class added, z-index:', modal.style.zIndex, 'display:', modal.style.display, 'visibility:', modal.style.visibility);
    
    // Re-enable transition after a brief delay
    setTimeout(() => {
      modal.style.transition = originalTransition || '';
    }, 50);
    
    // Force visibility immediately with multiple checks
    requestAnimationFrame(() => {
      const computedStyle = window.getComputedStyle(modal);
      console.log('Modal computed display:', computedStyle.display, 'visibility:', computedStyle.visibility, 'opacity:', computedStyle.opacity, 'z-index:', computedStyle.zIndex);
      if (computedStyle.display === 'none' || computedStyle.visibility === 'hidden' || computedStyle.opacity === '0') {
        console.error('Modal still not visible, forcing display again');
        modal.style.transition = 'none';
        modal.style.display = 'flex';
        modal.style.visibility = 'visible';
        modal.style.opacity = '1';
        modal.style.zIndex = '10000';
        modal.style.background = 'rgba(0,0,0,0.85)';
        // Also check parent elements
        let parent = modal.parentElement;
        while (parent && parent !== document.body) {
          const parentStyle = window.getComputedStyle(parent);
          if (parentStyle.display === 'none' || parentStyle.visibility === 'hidden') {
            console.error('Parent element is hiding modal:', parent);
            parent.style.display = 'block';
            parent.style.visibility = 'visible';
          }
          parent = parent.parentElement;
        }
        setTimeout(() => {
          modal.style.transition = originalTransition || '';
        }, 50);
      }
    });
    
  // v23.8: Update box score to show stats up to this event
  updateBoxScore(idx);
  } catch (err) {
    console.error('Error opening edit event modal:', err);
    toast('Error opening edit event: ' + err.message, 'error');
  }
}

function renderEditNetMarker(netXY) {
  const g = document.getElementById('editNetMarker');
  if (!g) return;
  
  if (netXY?.x != null && netXY?.y != null) {
    // v24.0: Handle both coordinate systems
    let editNetXY = netXY;
    
    // If coordinates are in rink net format (center-relative), convert to edit net format
    if (netXY.x < 0 || netXY.x > 72 || netXY.y < 0 || netXY.y > 48) {
      // Likely in rink net format (center-relative, -30 to +30, -20 to +20)
      editNetXY = convertRinkNetToEditNet(netXY);
    }
    
    // Clamp to bounds
    const x = Math.max(0, Math.min(72, editNetXY.x));
    const y = Math.max(0, Math.min(48, editNetXY.y));
    
    g.innerHTML = `<circle cx="${x}" cy="${y}" r="4" fill="#10b981" stroke="#fff" stroke-width="1"/>`;
  } else {
    g.innerHTML = '';
  }
}

function getNetLocationName(netXY) {
  if (!netXY?.x || !netXY?.y) return null;
  
  // v23.9: Net coordinates are in net SVG system (0-72 for x, 0-48 for y)
  // Check if coordinates are in center-relative format and convert to net SVG format
  let x = netXY.x;
  let y = netXY.y;
  
  // If coordinates are in center-relative format (negative values or > 72/48), they need conversion
  // But net SVG uses its own coordinate system, so we'll assume they're already in net format
  // If they're center-relative, we'd need to map them, but for now assume net format
  if (x < 0 || x > 72 || y < 0 || y > 48) {
    // Coordinates might be in center-relative format, but net uses its own system
    // For now, just use the values as-is and clamp to net bounds
    x = Math.max(0, Math.min(72, x));
    y = Math.max(0, Math.min(48, y));
  }
  
  // Divide net into zones (72x48 viewbox)
  if (y < 16) {
    return x < 36 ? 'Top Left' : 'Top Right';
  } else if (y > 32) {
    return x < 36 ? 'Low Left' : 'Low Right';
  } else {
    return 'Five Hole';
  }
}

function handleEditNetClick(event) {
  if (S.editingEvtIdx === null) return;
  
  const svg = document.getElementById('editNetSvg');
  const pt = svg.createSVGPoint();
  pt.x = event.clientX; pt.y = event.clientY;
  const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
  
  // v24.0: Net SVG uses its own coordinate system (0-72 for x, 0-48 for y)
  // Store coordinates in net SVG format
  const editNetXY = { 
    x: Math.round(svgPt.x * 100) / 100, 
    y: Math.round(svgPt.y * 100) / 100 
  };
  
  // Clamp to net bounds
  editNetXY.x = Math.max(0, Math.min(72, editNetXY.x));
  editNetXY.y = Math.max(0, Math.min(48, editNetXY.y));
  
  // Store in event
  S.events[S.editingEvtIdx].netXY = editNetXY;
  markDataChanged();
  
  // v24.0: Sync to rink-side net visualization
  renderEditNetMarker(editNetXY);
  renderNetMarkers(); // Also update rink-side net
  
  document.getElementById('editNetLocation').textContent = getNetLocationName(editNetXY);
  autoSave();
  toast('Net location set: ' + getNetLocationName(editNetXY), 'success');
}

function clearEditNetXY() {
  if (S.editingEvtIdx === null) return;
  S.events[S.editingEvtIdx].netXY = null;
  markDataChanged();
  renderEditNetMarker(null);
  renderNetMarkers(); // Also clear rink-side net
  document.getElementById('editNetLocation').textContent = '--';
  autoSave();
  toast('Net location cleared', 'info');
}

/**
 * v23.9: Convert center-relative coordinates to SVG coordinates for display
 * Handles both center-relative (x: -100 to +100, y: -42.5 to +42.5) and SVG (x: 0-200, y: 0-85) formats
 * 
 * Detection logic:
 * - If coordinates are clearly outside center-relative range (x > 120 or x < -120, y > 50 or y < -50), assume SVG
 * - If coordinates are in center-relative range (-120 to 120 for x, -50 to 50 for y), convert them
 * - Otherwise, check if converting would result in valid SVG coordinates; if not, assume already SVG
 */
function relativeToSvg(relative) {
  if (!relative || typeof relative.x !== 'number' || typeof relative.y !== 'number') {
    return { x: 100, y: 42.5 }; // Default to center
  }
  
  // Check if coordinates are clearly outside center-relative range (likely already SVG)
  if (relative.x > 120 || relative.x < -120 || relative.y > 50 || relative.y < -50) {
    // Already in SVG format (legacy data)
    return { x: relative.x, y: relative.y };
  }
  
  // Coordinates are in center-relative range - convert to SVG
  const svgX = relative.x + 100;
  const svgY = relative.y + 42.5;
  
  // Validate converted coordinates are within SVG bounds
  if (svgX >= 0 && svgX <= 200 && svgY >= 0 && svgY <= 85) {
    return { x: svgX, y: svgY };
  }
  
  // If conversion results in invalid coordinates, assume already SVG (shouldn't happen with valid data)
  return { x: relative.x, y: relative.y };
}

/**
 * v23.9: Convert SVG coordinates to center-relative for storage
 */
function svgToRelative(svgX, svgY) {
  return {
    x: svgX - 100,  // Convert to center-relative (center ice = 0)
    y: svgY - 42.5  // Convert to center-relative (center ice = 0)
  };
}

function renderEditRinkMarkers() {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  const g = document.getElementById('editRinkMarkers');
  if (!g) return;
  
  // Clear existing markers
  g.innerHTML = '';
  
  const target = document.getElementById('editXYTarget')?.value || 'puck';
  
  // Render puck XY - v23.9: Convert center-relative to SVG coordinates
  (evt.puckXY || []).forEach((xy, i) => {
    const svgCoords = relativeToSvg(xy);
    const isActive = target === 'puck';
    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('cx', svgCoords.x);
    circle.setAttribute('cy', svgCoords.y);
    circle.setAttribute('r', '3');
    circle.setAttribute('fill', isActive ? '#ef4444' : '#666');
    circle.setAttribute('stroke', '#fff');
    circle.setAttribute('stroke-width', '0.5');
    circle.style.cursor = 'pointer';
    circle.addEventListener('click', (e) => {
      e.stopPropagation();
      selectEditXY('puck', i);
    });
    g.appendChild(circle);
    
    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text.setAttribute('x', svgCoords.x + 4);
    text.setAttribute('y', svgCoords.y - 2);
    text.setAttribute('font-size', '4');
    text.setAttribute('fill', '#fff');
    text.textContent = `P${i+1}`;
    g.appendChild(text);
  });
  
  // Render player XYs - v23.9: Convert center-relative to SVG coordinates
  (evt.players || []).forEach((p, pi) => {
    const isActive = target === `player_${pi}`;
    (p.xy || []).forEach((xy, i) => {
      const svgCoords = relativeToSvg(xy);
      const color = p.role?.startsWith('event') ? '#3b82f6' : '#ef4444';
      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle.setAttribute('cx', svgCoords.x);
      circle.setAttribute('cy', svgCoords.y);
      circle.setAttribute('r', '2.5');
      circle.setAttribute('fill', isActive ? color : '#666');
      circle.setAttribute('stroke', '#fff');
      circle.setAttribute('stroke-width', '0.3');
      circle.style.cursor = 'pointer';
      circle.addEventListener('click', (e) => {
        e.stopPropagation();
        selectEditXY(`player_${pi}`, i);
      });
      g.appendChild(circle);
      
      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text.setAttribute('x', svgCoords.x + 3);
      text.setAttribute('y', svgCoords.y - 1);
      text.setAttribute('font-size', '3');
      text.setAttribute('fill', '#fff');
      text.textContent = `${p.num}.${i+1}`;
      g.appendChild(text);
    });
  });
}

function handleEditRinkClick(event) {
  if (S.editingEvtIdx === null) return;
  
  const svg = document.getElementById('editRinkSvg');
  const pt = svg.createSVGPoint();
  pt.x = event.clientX; pt.y = event.clientY;
  const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
  
  // v23.9: Convert SVG coordinates to center-relative for storage
  const relativeCoords = svgToRelative(svgPt.x, svgPt.y);
  const xy = { 
    x: Math.round(relativeCoords.x * 100) / 100, 
    y: Math.round(relativeCoords.y * 100) / 100, 
    seq: 1 
  };
  
  const evt = S.events[S.editingEvtIdx];
  const target = document.getElementById('editXYTarget').value;
  
  if (target === 'puck') {
    if (S.editingXYIdx !== null && evt.puckXY?.[S.editingXYIdx]) {
      evt.puckXY[S.editingXYIdx] = xy;
    } else {
      evt.puckXY = evt.puckXY || [];
      xy.seq = evt.puckXY.length + 1;
      evt.puckXY.push(xy);
    }
    
    // Propagate to linked events
    if (evt.linkedEventIdx !== null) {
      propagateXYToLinkedEvents(evt.idx, 'puck', null, evt.puckXY);
    }
    
    renderEditPuckXY(evt.puckXY);
  } else if (target.startsWith('player_')) {
    const pi = parseInt(target.split('_')[1]);
    if (evt.players?.[pi]) {
      const player = evt.players[pi];
      if (S.editingXYIdx !== null && player.xy?.[S.editingXYIdx]) {
        player.xy[S.editingXYIdx] = xy;
      } else {
        player.xy = player.xy || [];
        xy.seq = player.xy.length + 1;
        player.xy.push(xy);
      }
      
      // Propagate to linked events
      if (evt.linkedEventIdx !== null && player.num) {
        propagateXYToLinkedEvents(evt.idx, 'player', player.num, player.xy);
      }
    }
  }
  
  S.editingXYIdx = null;
  S.editingXYPlayerIdx = null;
  renderEditRinkMarkers();
  renderEditPlayers(evt.players);
  renderMarkers(); // Update main rink view
}

function selectEditXY(target, idx) {
  document.getElementById('editXYTarget').value = target;
  S.editingXYIdx = idx;
  
  // v23.9: Parse player index if target is a player
  if (target.startsWith('player_')) {
    S.editingXYPlayerIdx = parseInt(target.split('_')[1]);
    S.editingXYType = 'player';
  } else {
    S.editingXYPlayerIdx = null;
    S.editingXYType = 'puck';
  }
  
  renderEditRinkMarkers();
  toast(`Selected ${target} point ${idx + 1} - click rink to move`, 'info');
}

function addEditXYPoint() {
  // Just click on rink to add
  toast('Click on rink to add XY point', 'info');
}

function onEditTypeChange() {
  const type = document.getElementById('editType').value;
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onEditTypeChange:15513',message:'onEditTypeChange: Entry',data:{type,eventDetails1Count:S.eventDetails1?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
  // #endregion
  
  // v16.06: Use S.eventDetails1 from dim_event_detail if available
  let d1Options = [];
  if (S.eventDetails1?.length > 0) {
    // Case-insensitive filtering for event type
    const filtered = S.eventDetails1.filter(e => 
      String(e.eventType || '').toLowerCase() === String(type || '').toLowerCase()
    );
    d1Options = filtered.map(e => e.code || e.name); // Use code, fallback to name
    
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onEditTypeChange:15522',message:'onEditTypeChange: After Supabase filter',data:{type,filteredCount:filtered.length,d1OptionsCount:d1Options.length,firstFew:d1Options.slice(0,3)},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
    // #endregion
    
    // Debug logging for Penalty type
    if (type === 'Penalty') {
      console.log('Penalty detail1 options from Supabase:', {
        totalEventDetails: S.eventDetails1.length,
        penaltyMatches: filtered.length,
        options: d1Options,
        allPenaltyTypes: S.eventDetails1.filter(e => 
          String(e.eventType || '').toLowerCase().includes('penalty')
        ).map(e => ({ eventType: e.eventType, name: e.name }))
      });
      
      // Check if Supabase data is invalid (just "penalty" instead of specific types)
      const hasInvalidData = d1Options.length > 0 && 
        d1Options.every(opt => opt.toLowerCase() === 'penalty' || opt.toLowerCase().includes('penalty_') === false);
      
      if (hasInvalidData) {
        console.warn('‚ö†Ô∏è Supabase penalty data appears invalid - event_detail_name values are generic "penalty" instead of specific types (Penalty_Minor, Penalty_Major, etc.)');
        console.warn('Falling back to LISTS.details. Please fix dim_event_detail table in Supabase.');
        d1Options = []; // Clear invalid data to trigger fallback
      }
    }
  }
  
  // Fall back to LISTS.details if no Supabase data or insufficient/invalid options
  // For Penalty, we expect at least 3 options (Minor, Major, Misconduct) with proper naming
  const supabaseCount = d1Options.length;
  const needsFallback = d1Options.length === 0 || 
    (type === 'Penalty' && (d1Options.length < 3 || !d1Options.some(opt => opt.includes('Minor') || opt.includes('Major') || opt.includes('Misconduct'))));
  
  if (needsFallback) {
    const opts = LISTS.details[type] || { d1: [], d2: [] };
    const fallbackOptions = opts.d1 || [];
    if (fallbackOptions.length > 0) {
      d1Options = fallbackOptions;
      if (type === 'Penalty') {
        console.warn('Using fallback LISTS.details for Penalty:', {
          reason: supabaseCount === 0 ? 'No Supabase data' : 'Supabase data insufficient/invalid',
          supabaseCount: supabaseCount,
          supabaseOptions: S.eventDetails1?.filter(e => 
            String(e.eventType || '').toLowerCase() === 'penalty'
          ).map(e => e.code || e.name),
          fallbackOptions: fallbackOptions
        });
      }
    }
  }
  
  const editD1Html = '<option value="">--</option>' + 
    d1Options.map(o => `<option value="${o}">${o}</option>`).join('');
  const editD1El = document.getElementById('editD1');
  const editD2El = document.getElementById('editD2');
  if (editD1El) editD1El.innerHTML = editD1Html;
  if (editD2El) editD2El.innerHTML = '<option value="">--</option>';
  
  // v24.0: Show/hide net visualization when event type or detail1 changes
  updateNetVisibility();
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onEditTypeChange:15573',message:'onEditTypeChange: Exit',data:{type,d1OptionsCount:d1Options.length,editD1OptionsAfter:document.getElementById('editD1').options.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
  // #endregion
}

/**
 * v24.0: Update net visibility based on current event type and detail1
 * Shows net for: Goal events OR Shot_Goal OR Shot_OnNetSaved
 */
function updateNetVisibility() {
  // Update main rink net visualization
  const netContainer = document.getElementById('netVisualizationContainer');
  const rinkWrap = document.getElementById('rinkWrapContainer');
  
  // Update edit modal net section
  const editNetSection = document.getElementById('editNetSection');
  
  // Get current values from modal or event
  let type = '';
  let d1 = '';
  let evt = null;
  
  if (S.editingEvtIdx !== null && S.editingEvtIdx !== undefined) {
    evt = S.events[S.editingEvtIdx];
    if (evt) {
      type = document.getElementById('editType')?.value || evt.type || '';
      d1 = document.getElementById('editD1')?.value || evt.detail1 || '';
    }
  }
  
  // v24.0: Show net for Goal OR Shot_OnNetSaved OR Shot_OnNetGoal
  // Check both exact match and case-insensitive
  const d1Lower = (d1 || '').toLowerCase();
  const shouldShowNet = type === 'Goal' || 
                        d1 === 'Shot_OnNetSaved' ||
                        d1 === 'Shot_OnNetGoal' ||
                        d1Lower === 'shot_onnetsaved' ||
                        d1Lower === 'shot_onnetgoal' ||
                        d1Lower.includes('shot_onnetsaved') ||
                        d1Lower.includes('shot_onnetgoal');
  
  // Update main rink net visualization
  if (netContainer && rinkWrap) {
    if (S.editingEvtIdx === null || S.editingEvtIdx === undefined || !evt || !shouldShowNet) {
      netContainer.style.display = 'none';
      rinkWrap.classList.remove('with-net');
    } else {
      netContainer.style.display = 'block';
      rinkWrap.classList.add('with-net');
      renderNetMarkers();
    }
  }
  
  // Update edit modal net section
  if (editNetSection) {
    if (S.editingEvtIdx === null || S.editingEvtIdx === undefined || !evt || !shouldShowNet) {
      editNetSection.style.display = 'none';
    } else {
      editNetSection.style.display = 'block';
      
      // Render net marker if netXY exists
      if (evt.netXY) {
        renderEditNetMarker(evt.netXY);
        const netLocationEl = document.getElementById('editNetLocation');
        if (netLocationEl) {
          netLocationEl.textContent = getNetLocationName(evt.netXY) || '--';
        }
      } else {
        renderEditNetMarker(null);
        const netLocationEl = document.getElementById('editNetLocation');
        if (netLocationEl) {
          netLocationEl.textContent = '--';
        }
      }
    }
  }
}

function onEditD1Change(preserveD2Value = null) {
  const type = document.getElementById('editType').value;
  const d1 = document.getElementById('editD1').value;
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onEditD1Change:15578',message:'onEditD1Change: Entry',data:{type,d1,preserveD2Value,eventDetails2Count:S.eventDetails2?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
  // #endregion
  
  // Get current d2 value or use preserved value
  const currentD2 = preserveD2Value || document.getElementById('editD2').value;
  
  let d2Opts = [];
  
  // Special handling for Penalty - always use LISTS.details
  if (d1.startsWith('Penalty_')) {
    const penaltyOpts = LISTS.details.Penalty || {};
    if (penaltyOpts.d2 && penaltyOpts.d2.length > 0) {
      d2Opts = penaltyOpts.d2;
      
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onEditD1Change:15605',message:'onEditD1Change: Penalty detail2 from LISTS',data:{d1,penaltyD2Count:d2Opts.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
      // #endregion
    }
  }
  // v16.08: Use S.eventDetails2 from dim_event_detail_2 - filter by code prefix
  else if (S.eventDetails2?.length > 0 && d1) {
    // Determine code prefix based on detail1 value
    let codePrefix = null;
    if (d1.startsWith('Shot_')) codePrefix = 'Shot_';
    else if (d1.startsWith('Pass_')) codePrefix = 'Pass_';
    else if (d1.startsWith('Goal_')) codePrefix = 'Goal_';
    else if (d1.startsWith('Save_')) codePrefix = 'Save_';
    // v23.9: Giveaway can be 'Turnover_Giveaway' or just 'Giveaway', match both
    else if (d1.includes('Giveaway') || d1 === 'Turnover_Giveaway') {
      codePrefix = 'Giveaway_';
    }
    else if (d1.includes('Takeaway') || d1 === 'Turnover_Takeaway') codePrefix = 'Takeaway_';
    else if (d1.includes('Entry')) codePrefix = 'ZoneEntry_';
    else if (d1.includes('Exit') || d1.includes('Keepin')) codePrefix = 'ZoneExit_';
    else if (d1 === 'Stoppage_Play') codePrefix = 'Stoppage_';
    else if (d1 === 'Play_Offensive') codePrefix = 'PlayOffensive_';
    else if (d1 === 'Play_Defensive') codePrefix = 'PlayDefensive_';
    else if (d1.startsWith('Faceoff_') || (type === 'Faceoff' && d1.includes('Faceoff'))) codePrefix = 'Faceoff_';
    else if (d1.startsWith('Possession_')) codePrefix = 'Possession_';
    else if (d1.startsWith('Rebound_')) codePrefix = 'Rebound_';
    
    if (codePrefix) {
      d2Opts = S.eventDetails2
        .filter(e => e.code && e.code.startsWith(codePrefix))
        .map(e => e.code || e.name); // Use code, fallback to name
      
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onEditD1Change:15642',message:'onEditD1Change: After Supabase filter',data:{d1,codePrefix,d2OptsCount:d2Opts.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
      // #endregion
    }
  }
  
  // v23.9: Fall back to LISTS.details - also merge with Supabase for giveaway types to ensure all options
  const opts = LISTS.details[type] || {};
  
  // For giveaway types, always merge fallback options to ensure all types are available
  if ((d1.includes('Giveaway') || d1 === 'Turnover_Giveaway') && opts.d2_Giveaway) {
    const fallbackOpts = opts.d2_Giveaway || [];
    fallbackOpts.forEach(opt => {
      if (!d2Opts.includes(opt)) d2Opts.push(opt);
    });
  }
  
  // If no Supabase results at all, use fallback
  if (d2Opts.length === 0) {
    d2Opts = opts.d2 || [];
    if (d1.includes('Takeaway') && opts.d2_Takeaway) d2Opts = opts.d2_Takeaway;
    else if (d1.includes('Entry') && opts.d2_Entry) d2Opts = opts.d2_Entry;
    else if (d1.includes('Exit') && opts.d2_Exit) d2Opts = opts.d2_Exit;
    else if (d1.includes('Play') && opts.d2_Play) d2Opts = opts.d2_Play;
    else if (d1.includes('Offensive') && opts.d2_Offensive) d2Opts = opts.d2_Offensive;
    else if (d1.includes('Defensive') && opts.d2_Defensive) d2Opts = opts.d2_Defensive;
    else if (d1.includes('Keepin') && opts.d2_Exit) d2Opts = opts.d2_Exit;
    
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onEditD1Change:15624',message:'onEditD1Change: Using fallback LISTS',data:{type,d1,d2OptsCount:d2Opts.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
    // #endregion
  }
  
  // Build options HTML
  let optionsHtml = '<option value="">--</option>' + d2Opts.map(o => `<option value="${o}">${o}</option>`).join('');
  
  // If current/preserved value not in options, add it at top
  if (currentD2 && !d2Opts.includes(currentD2)) {
    optionsHtml = `<option value="">--</option><option value="${currentD2}">${currentD2} (loaded)</option>` + 
                  d2Opts.map(o => `<option value="${o}">${o}</option>`).join('');
  }
  
  document.getElementById('editD2').innerHTML = optionsHtml;
  
  // Restore selection if it existed
  const editD2El = document.getElementById('editD2');
  if (currentD2) {
    editD2El.value = currentD2;
    
    // Verify value was set - if not, try case-insensitive match
    if (editD2El.value !== currentD2) {
      const caseInsensitiveMatch = Array.from(editD2El.options).find(o => 
        o.value.toLowerCase() === currentD2.toLowerCase()
      );
      if (caseInsensitiveMatch) {
        editD2El.value = caseInsensitiveMatch.value;
      }
    }
    
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onEditD1Change:15639',message:'onEditD1Change: After setting editD2.value',data:{currentD2,editD2Value:editD2El.value,valueMatches:editD2El.value===currentD2,optionsIncludeValue:Array.from(editD2El.options).some(o=>o.value===currentD2)},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
    // #endregion
  }
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onEditD1Change:15641',message:'onEditD1Change: Exit',data:{type,d1,d2OptsCount:d2Opts.length,currentD2,editD2OptionsAfter:editD2El.options.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
  // #endregion
}

function renderEditPlayers(players) {
  const container = document.getElementById('editPlayersContainer');
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'renderEditPlayers:15644',message:'renderEditPlayers: Entry',data:{playersCount:players?.length||0,playDetails1Count:S.playDetails1?.length||0,playDetails2Count:S.playDetails2?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
  // #endregion
  
  // v16.06: Build options with player-specific selection
  const buildPD1Options = (playerValue) => {
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'renderEditPlayers:buildPD1Options',message:'buildPD1Options: Entry',data:{playerValue,playDetails1Count:S.playDetails1?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
    // #endregion
    
    let opts = S.playDetails1.length > 0 
      ? S.playDetails1.map(p => `<option value="${p.name}" ${p.name === playerValue ? 'selected' : ''}>${p.name}</option>`).join('')
      : LISTS.playOffensive.concat(LISTS.playDefensive).map(o => `<option value="${o}" ${o === playerValue ? 'selected' : ''}>${o}</option>`).join('');
    
    // If player has a value not in options, add it
    const valueInOptions = S.playDetails1.length > 0 
      ? S.playDetails1.find(pd => pd.name === playerValue)
      : LISTS.playOffensive.concat(LISTS.playDefensive).includes(playerValue);
    
    if (playerValue && !valueInOptions) {
      opts = `<option value="${playerValue}" selected>${playerValue}</option>` + opts;
    }
    
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'renderEditPlayers:buildPD1Options',message:'buildPD1Options: Exit',data:{playerValue,valueInOptions:!!valueInOptions,optionsLength:opts.split('</option>').length-1},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
    // #endregion
    
    return opts;
  };
  
  const buildPD2Options = (playerValue) => {
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'renderEditPlayers:buildPD2Options',message:'buildPD2Options: Entry',data:{playerValue,playDetails2Count:S.playDetails2?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
    // #endregion
    
    let opts = S.playDetails2.length > 0 
      ? S.playDetails2.map(p => `<option value="${p.name}" ${p.name === playerValue ? 'selected' : ''}>${p.name}</option>`).join('')
      : '';
    
    // If player has a value not in options, add it
    const valueInOptions = S.playDetails2.length > 0 
      ? S.playDetails2.find(pd => pd.name === playerValue)
      : false;
    
    if (playerValue && !valueInOptions) {
      opts = `<option value="${playerValue}" selected>${playerValue}</option>` + opts;
    }
    
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'renderEditPlayers:buildPD2Options',message:'buildPD2Options: Exit',data:{playerValue,valueInOptions:!!valueInOptions,optionsLength:opts.split('</option>').length-1},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
    // #endregion
    
    return opts;
  };
  
  // Player role options
  const eventRoles = S.playerRoles.filter(r => r.type === 'event_team');
  const oppRoles = S.playerRoles.filter(r => r.type === 'opp_team');
  
  container.innerHTML = (players || []).map((p, i) => {
    const isOpp = p.role?.startsWith('opp');
    const roleOptions = isOpp ? oppRoles : eventRoles;
    const roleOpts = roleOptions.length > 0 
      ? roleOptions.map(r => `<option value="${r.code}" ${p.role===r.code?'selected':''}>${r.name}</option>`).join('')
      : `<option value="event_player_1">Event Player 1</option><option value="event_player_2">Event Player 2</option><option value="opp_player_1">Opp Player 1</option>`;
    
    // Build role select with current value highlighted
    const currentRole = p.role || '';
    const buildRoleOption = (val, label) => {
      const selected = currentRole === val ? 'selected' : '';
      return `<option value="${val}" ${selected}>${label}</option>`;
    };
    
    return `
    <div class="edit-player-row" data-idx="${i}" style="display:grid;grid-template-columns:80px 90px 130px 130px 60px 25px;gap:4px;align-items:center;margin-bottom:6px;padding:4px;background:var(--panel);border-radius:3px;">
      <span class="pnum" style="font-weight:bold;font-size:10px;">#${p.num} ${p.name?.split(' ').pop() || ''}</span>
      <select onchange="updateEditPlayer(${i}, 'role', this.value)" style="font-size:9px;" title="Player Role">
        <option value="">-- Role --</option>
        <optgroup label="Event Team">
          ${buildRoleOption('event_player_1', 'Event P1')}
          ${buildRoleOption('event_player_2', 'Event P2')}
          ${buildRoleOption('event_player_3', 'Event P3')}
          ${buildRoleOption('event_player_4', 'Event P4')}
          ${buildRoleOption('event_player_5', 'Event P5')}
          ${buildRoleOption('event_player_6', 'Event P6')}
          ${buildRoleOption('event_goalie', 'Event Goalie')}
        </optgroup>
        <optgroup label="Opponent">
          ${buildRoleOption('opp_player_1', 'Opp P1')}
          ${buildRoleOption('opp_player_2', 'Opp P2')}
          ${buildRoleOption('opp_player_3', 'Opp P3')}
          ${buildRoleOption('opp_player_4', 'Opp P4')}
          ${buildRoleOption('opp_player_5', 'Opp P5')}
          ${buildRoleOption('opp_player_6', 'Opp P6')}
          ${buildRoleOption('opp_goalie', 'Opp Goalie')}
        </optgroup>
      </select>
      <select onchange="updateEditPlayer(${i}, 'playD1', this.value)" style="font-size:9px;" title="Play Detail 1">
        <option value="">-- Play D1 --</option>
        ${buildPD1Options(p.playD1)}
      </select>
      <select onchange="updateEditPlayer(${i}, 'playD2', this.value)" style="font-size:9px;" title="Play Detail 2">
        <option value="">-- Play D2 --</option>
        ${buildPD2Options(p.playD2)}
      </select>
      <select onchange="updateEditPlayer(${i}, 'playSuccess', this.value)" style="font-size:9px;" title="Success">
        <option value="">Succ</option>
        <option value="s" ${p.playSuccess==='s'?'selected':''}>S</option>
        <option value="u" ${p.playSuccess==='u'?'selected':''}>U</option>
      </select>
      <button class="btn-sm btn-danger" onclick="removeEditPlayer(${i})" style="padding:2px 4px;">‚úï</button>
    </div>`;
  }).join('') || '<p style="color:var(--muted);font-size:9px;">No players - click + Add to add players</p>';
}

function renderEditPuckXY(puckXY) {
  const container = document.getElementById('editPuckXY');
  if (!container) return;
  
  // v24.0: Filter out invalid/null XY items and track original indices
  const validItems = [];
  if (puckXY && puckXY.length > 0) {
    puckXY.forEach((xy, originalIdx) => {
      // Only include valid XY items
      if (xy && xy.x !== null && xy.x !== undefined && xy.y !== null && xy.y !== undefined) {
        validItems.push({ xy, originalIdx });
      }
    });
  }
  
  // Use exact same pattern as renderEditPlayers - inline onclick handlers
  // Use original indices for deleteXYPoint so it works correctly
  let html = validItems.map((item, displayIdx) => {
    const { xy, originalIdx } = item;
    return `<button class="edit-xy-btn has" onclick="editXYPoint('puck', ${originalIdx});event.stopPropagation();" title="(${xy.x}, ${xy.y})">${displayIdx + 1}: (${Math.round(xy.x)}, ${Math.round(xy.y)})</button>
     <button class="btn-sm btn-danger" onclick="deleteXYPoint('puck', ${originalIdx});event.stopPropagation();return false;" style="padding:2px 4px;">‚úï</button>`;
  }).join('');
  html += `<button class="edit-xy-btn" onclick="addXYPoint('puck');event.stopPropagation();">+ Add XY</button>`;
  
  container.innerHTML = html;
}

function renderEditPlayerXY(players) {
  // Add player XY display to edit modal
  const playerContainer = document.getElementById('editPlayersContainer');
  if (!playerContainer || !players?.length) return;
  
  // Append XY info to each player row (already in renderEditPlayers)
}

// v23.9: XY editing functions - regular function declarations like other working functions
function editXYPoint(type, idx) {
  console.log('editXYPoint called', type, idx);
  if (S.editingEvtIdx === null) {
    toast('No event being edited', 'error');
    return;
  }
  S.editingXYType = type;
  S.editingXYIdx = idx;
  
  const modal = document.getElementById('xyEditModal');
  if (modal) {
    modal.classList.add('show');
    renderXYEditRink();
  }
}

function addXYPoint(type) {
  console.log('addXYPoint called', type);
  if (S.editingEvtIdx === null) {
    toast('No event being edited', 'error');
    return;
  }
  const evt = S.events[S.editingEvtIdx];
  if (!evt) return;
  
  if (type === 'puck') {
    evt.puckXY = evt.puckXY || [];
    evt.puckXY.push({ x: 0, y: 0, seq: evt.puckXY.length + 1 });
    renderEditPuckXY(evt.puckXY);
    renderEditRinkMarkers();
    toast('XY point added', 'success');
  }
}

function deleteXYPoint(type, idx) {
  console.log('deleteXYPoint called', type, idx);
  if (S.editingEvtIdx === null) {
    toast('No event being edited', 'error');
    return;
  }
  const evt = S.events[S.editingEvtIdx];
  if (!evt) return;
  
  if (type === 'puck' && evt.puckXY) {
    // v24.0: Validate index before deleting
    if (idx < 0 || idx >= evt.puckXY.length) {
      console.error('Invalid XY index:', idx, 'array length:', evt.puckXY.length);
      toast('Invalid XY index', 'error');
      return;
    }
    
    evt.puckXY.splice(idx, 1);
    // Renumber remaining slots
    evt.puckXY.forEach((p, i) => { if (p) p.seq = i + 1; });
    
    // v24.0: If array is empty, set to empty array (clean up)
    if (evt.puckXY.length === 0) {
      evt.puckXY = [];
    }
    
    // Propagate to linked events
    if (evt.linkedEventIdx !== null && evt.puckXY.length > 0) {
      propagateXYToLinkedEvents(evt.idx, 'puck', null, evt.puckXY);
    } else if (evt.linkedEventIdx !== null && evt.puckXY.length === 0) {
      // Clear XY from linked events when this one is cleared
      propagateXYToLinkedEvents(evt.idx, 'puck', null, []);
    }
    
    renderEditPuckXY(evt.puckXY);
    renderEditRinkMarkers();
    renderEvents(); // Update event list display
    toast('XY point deleted', 'success');
  }
}

function renderXYEditRink() {
  // Highlight current point on mini rink
  const marker = document.getElementById('xyEditMarker');
  if (!marker) return;
  
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  
  let xy = null;
  if (S.editingXYType === 'puck' && evt.puckXY?.[S.editingXYIdx]) {
    xy = evt.puckXY[S.editingXYIdx];
  } else if (S.editingXYType === 'player' && S.editingXYPlayerIdx !== null && evt.players?.[S.editingXYPlayerIdx]?.xy?.[S.editingXYIdx]) {
    xy = evt.players[S.editingXYPlayerIdx].xy[S.editingXYIdx];
  }
  
  if (xy) {
    // v23.9: Convert center-relative to SVG coordinates for display
    const svgCoords = relativeToSvg(xy);
    marker.innerHTML = `<circle cx="${svgCoords.x}" cy="${svgCoords.y}" r="3" fill="#ef4444" stroke="#fff" stroke-width="0.5"/>`;
  } else {
    marker.innerHTML = '';
  }
}

function handleXYEditClick(event) {
  if (S.editingEvtIdx === null) return;
  
  const evt = S.events[S.editingEvtIdx];
  if (!evt) return;
  
  const svg = document.getElementById('xyEditSvg');
  const rect = svg.getBoundingClientRect();
  const pt = svg.createSVGPoint();
  pt.x = event.clientX; pt.y = event.clientY;
  const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
  
  // v23.9: Convert SVG coordinates to center-relative for storage
  const relativeCoords = svgToRelative(svgPt.x, svgPt.y);
  const xy = { 
    x: Math.round(relativeCoords.x * 100) / 100, 
    y: Math.round(relativeCoords.y * 100) / 100 
  };
  
  if (S.editingXYType === 'puck' && evt.puckXY?.[S.editingXYIdx]) {
    evt.puckXY[S.editingXYIdx].x = xy.x;
    evt.puckXY[S.editingXYIdx].y = xy.y;
    
    // Propagate to linked events
    if (evt.linkedEventIdx !== null) {
      propagateXYToLinkedEvents(evt.idx, 'puck', null, evt.puckXY);
    }
    
    renderEditPuckXY(evt.puckXY);
  } else if (S.editingXYType === 'player' && S.editingXYPlayerIdx !== null && evt.players?.[S.editingXYPlayerIdx]?.xy?.[S.editingXYIdx]) {
    const player = evt.players[S.editingXYPlayerIdx];
    player.xy[S.editingXYIdx].x = xy.x;
    player.xy[S.editingXYIdx].y = xy.y;
    
    // Propagate to linked events
    if (evt.linkedEventIdx !== null && player.num) {
      propagateXYToLinkedEvents(evt.idx, 'player', player.num, player.xy);
    }
  }
  
  renderXYEditRink();
  renderEditRinkMarkers(); // Update main edit modal rink too
  renderMarkers(); // Update main rink view
}

function closeXYEditModal() {
  document.getElementById('xyEditModal').classList.remove('show');
  S.editingXYType = null;
  S.editingXYIdx = null;
  S.editingXYPlayerIdx = null;
  renderEditRinkMarkers(); // Update main edit modal rink
}

function updateEditPlayer(idx, field, val) {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  if (evt.players[idx]) evt.players[idx][field] = val;
}

function removeEditPlayer(idx) {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  evt.players.splice(idx, 1);
  renderEditPlayers(evt.players);
}

/**
 * v23.9: Clear all players of a specific team type from edit modal
 */
function clearEditPlayers(teamType) {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  if (!evt.players) return;
  
  if (teamType === 'event_team') {
    // Remove all event team players
    evt.players = evt.players.filter(p => !p.role?.startsWith('event'));
  } else if (teamType === 'opp_team') {
    // Remove all opponent team players
    evt.players = evt.players.filter(p => !p.role?.startsWith('opp'));
  }
  
  renderEditPlayers(evt.players);
  toast(`Cleared all ${teamType === 'event_team' ? 'event' : 'opponent'} team players`, 'info');
}

function addPlayerToEdit() {
  if (S.editingEvtIdx === null) {
    toast('No event being edited', 'error');
    return;
  }
  
  const evt = S.events[S.editingEvtIdx];
  
  // Update picker dropdown with team names
  const pickerTeamSel = document.getElementById('pickerTeam');
  pickerTeamSel.innerHTML = `<option value="home">${S.homeTeam || 'Home'}</option><option value="away">${S.awayTeam || 'Away'}</option>`;
  
  // Set team based on event being edited
  pickerTeamSel.value = evt.team || S.evtTeam;
  
  // Check if rosters are loaded
  if (!S.rosters.home?.length && !S.rosters.away?.length) {
    toast('No rosters loaded - select a game first', 'error');
    return;
  }
  
  renderPlayerPicker();
  document.getElementById('playerPickerModal').classList.add('show');
}

// ============================================================
// SAVE FOLDER MANAGEMENT (File System Access API)
// v23.8: Updated to use S.saveDirectoryHandle and backup system
// ============================================================

// Legacy function - now redirects to new implementation
async function pickSaveFolder() {
  await promptForSaveDirectory();
}

// Legacy function - now uses new implementation
function quickSaveToFolder() {
  if (!S.saveDirectoryHandle) {
    toast('No folder selected. Click "Choose" to pick a save folder.', 'error');
    return;
  }

  if (!S.gameId) {
    toast('No game loaded', 'error');
    return;
  }

  // Trigger manual save which will save to file system
  manualSave();
}

// Initialize save folder UI on page load
function initSaveFolderUI() {
  const lastFolderName = localStorage.getItem('bs_lastFolderName');
  if (lastFolderName) {
    document.getElementById('saveFolderPath').textContent = `${lastFolderName} (re-select to enable)`;
    document.getElementById('saveFolderPath').classList.remove('empty');
    document.getElementById('saveFolderStatus').textContent = 'üí° Re-select folder to enable Quick Save (browser security)';
  }
  
  // Update autosave display
  const autoSaveInt = document.getElementById('autoSaveInt');
  if (autoSaveInt) {
    const display = document.getElementById('autoSaveDisplay');
    if (display) display.textContent = autoSaveInt.value || '30';
    autoSaveInt.addEventListener('change', () => {
      if (display) display.textContent = autoSaveInt.value;
    });
  }
}

function renderPlayerPicker() {
  const team = document.getElementById('pickerTeam').value;
  const roster = S.rosters[team] || [];
  
  document.getElementById('playerPickerList').innerHTML = roster.map(p => `
    <div class="picker-player" onclick="selectPlayerFromPicker('${p.num}', '${p.name}')" 
         style="padding:6px;margin:2px 0;background:var(--card);border-radius:3px;cursor:pointer;display:flex;justify-content:space-between;">
      <span><strong>#${p.num}</strong> ${p.name}</span>
      <span style="color:var(--muted);">${p.pos || 'F'}</span>
    </div>
  `).join('') || '<div style="color:var(--muted);">No players</div>';
}

function selectPlayerFromPicker(num, name) {
  if (S.editingEvtIdx === null) {
    toast('No event being edited', 'error');
    return;
  }
  const evt = S.events[S.editingEvtIdx];
  
  // Ensure players array exists
  if (!evt.players) evt.players = [];
  
  const role = document.getElementById('pickerRole').value;
  const team = document.getElementById('pickerTeam').value;
  
  // Check if player already in event
  if (evt.players.some(p => p.num === num)) {
    toast(`#${num} already in event`, 'error');
    return;
  }
  
  // Determine next role number
  const existingRoles = evt.players.filter(p => p.role?.startsWith(role)).length;
  const roleNum = existingRoles + 1;
  
  evt.players.push({
    num, name, 
    role: `${role}_${roleNum}`,
    roleNum,
    team,
    xy: [],
    playD1: '', playD2: '', playSuccess: '', pressure: '', sideOfPuck: ''
  });
  
  renderEditPlayers(evt.players);
  
  // Update XY target dropdown
  const xyTargetSel = document.getElementById('editXYTarget');
  xyTargetSel.innerHTML = '<option value="puck">Puck</option>' + 
    evt.players.map((p, i) => `<option value="player_${i}">#${p.num} ${p.name}</option>`).join('');
  
  closePlayerPicker();
  toast(`Added #${num} ${name}`, 'success');
}

function closePlayerPicker() {
  document.getElementById('playerPickerModal').classList.remove('show');
}

// ============================================================
// VERIFICATION PANEL
// ============================================================
async function openVerifyModal() {
  console.log('openVerifyModal called');
  try {
    console.log('Opening verify modal');
    const modal = document.getElementById('verifyModal');
    if (!modal) {
      console.error('verifyModal element not found');
      toast('Verify modal not found', 'error');
      return;
    }
    
    // Ensure modal is in body (move if needed)
    if (modal.parentElement !== document.body) {
      document.body.appendChild(modal);
    }
    
  // Set noradhockey link
  const link = document.getElementById('noradGameLink');
    if (S.gameId && link) {
    link.href = `https://noradhockey.com/event/${S.gameId}/`;
    link.style.display = 'inline';
    
    // v15.02: Auto-populate official score from dim_schedule if connected
    if (S.connected) {
      try {
        console.log('Loading official score for game', S.gameId);
        const { data: schedData, error: schedError } = await S.sb.from('dim_schedule')
          .select('home_total_goals,away_total_goals,home_team_period1_goals,home_team_period2_goals,home_team_period3_goals,away_team_period1_goals,away_team_period2_goals,away_team_period3_goals')
          .eq('game_id', S.gameId)
          .single();
        
        if (schedError) {
          console.error('Error loading official score:', schedError);
        }
        
        console.log('Official score data:', schedData);
        
        if (schedData) {
          // Store in hidden fields
            const homeGoalsEl = document.getElementById('officialHomeGoals');
            const awayGoalsEl = document.getElementById('officialAwayGoals');
            if (homeGoalsEl) homeGoalsEl.value = schedData.home_total_goals ?? 0;
            if (awayGoalsEl) awayGoalsEl.value = schedData.away_total_goals ?? 0;
          
          // Display total goals
            const homeDisplayEl = document.getElementById('officialHomeGoalsDisplay');
            const awayDisplayEl = document.getElementById('officialAwayGoalsDisplay');
            if (homeDisplayEl) homeDisplayEl.textContent = schedData.home_total_goals ?? 0;
            if (awayDisplayEl) awayDisplayEl.textContent = schedData.away_total_goals ?? 0;
          
          // Display by period
          const hp1 = schedData.home_team_period1_goals ?? '-';
          const hp2 = schedData.home_team_period2_goals ?? '-';
          const hp3 = schedData.home_team_period3_goals ?? '-';
          const ap1 = schedData.away_team_period1_goals ?? '-';
          const ap2 = schedData.away_team_period2_goals ?? '-';
          const ap3 = schedData.away_team_period3_goals ?? '-';
          
            const homePeriodEl = document.getElementById('officialHomeByPeriod');
            const awayPeriodEl = document.getElementById('officialAwayByPeriod');
            if (homePeriodEl) homePeriodEl.textContent = `P1: ${hp1} | P2: ${hp2} | P3: ${hp3}`;
            if (awayPeriodEl) awayPeriodEl.textContent = `P1: ${ap1} | P2: ${ap2} | P3: ${ap3}`;
          
          // Store period data for comparison
          S.officialPeriodGoals = {
            home: { 1: hp1, 2: hp2, 3: hp3 },
            away: { 1: ap1, 2: ap2, 3: ap3 }
          };
          
          console.log('Official score loaded successfully');
        } else {
          console.log('No schedule data found for game', S.gameId);
        }
        
        // v6: Load fact_gameroster for verification
        const { data: rosterData } = await S.sb.from('fact_gameroster')
          .select('player_game_number,player_full_name,goals,assist,team_venue')
          .eq('game_id', S.gameId);
        
        if (rosterData) {
          S.rosterStats = {};
          rosterData.forEach(p => {
            S.rosterStats[String(p.player_game_number)] = {
              name: p.player_full_name,
              goals: parseInt(p.goals) || 0,
              assists: parseInt(p.assist) || 0,
              team: (p.team_venue || '').toLowerCase() === 'home' ? 'home' : 'away'
            };
          });
        }
        } catch(e) { 
          console.log('Could not auto-populate score:', e); 
    }
      }
    } else if (link) {
    link.style.display = 'none';
  }
  
  runVerification();
    modal.classList.add('show');
    modal.style.display = 'flex';
    modal.style.visibility = 'visible';
    modal.style.opacity = '1';
    modal.style.zIndex = '10000';
    modal.style.position = 'fixed';
    modal.style.top = '0';
    modal.style.left = '0';
    modal.style.right = '0';
    modal.style.bottom = '0';
    modal.style.width = '100%';
    modal.style.height = '100%';
    modal.style.background = 'rgba(0,0,0,0.85)';
    
    // Ensure the modal content div is properly positioned
    const modalContent = modal.querySelector('.modal');
    if (modalContent) {
      modalContent.style.position = 'relative';
      modalContent.style.zIndex = '10001';
    }
    
    // Remove ALL existing handlers that might interfere
    if (modal._overlayClickHandler) {
      modal.removeEventListener('click', modal._overlayClickHandler);
      modal.removeEventListener('mousedown', modal._overlayClickHandler);
      delete modal._overlayClickHandler;
    }
    modal.onclick = null;
    modal.removeAttribute('onclick');
    
    // Use simple inline onclick pattern - only closes when clicking overlay itself
    modal.setAttribute('onclick', 'if(event.target===this)closeVerifyModal()');
    
    // Make ALL buttons work
    ensureModalButtonsWork(modal);
    
    console.log('Verify modal opened');
  } catch (err) {
    console.error('Error opening verify modal:', err);
    toast('Error opening verify: ' + err.message, 'error');
  }
}

function closeVerifyModal() {
  console.log('closeVerifyModal() called');
  const modal = document.getElementById('verifyModal');
  if (modal) {
    modal.classList.remove('show');
    // Force all styles to hide - use !important via setProperty
    modal.style.setProperty('display', 'none', 'important');
    modal.style.setProperty('visibility', 'hidden', 'important');
    modal.style.setProperty('opacity', '0', 'important');
    console.log('Verify modal closed');
  }
}

function runVerification() {
  // v6: Count tracked goals by team and period
  const homeGoals = S.events.filter(e => e.type === 'Goal' && e.detail1 === 'Goal_Scored' && e.team === 'home');
  const awayGoals = S.events.filter(e => e.type === 'Goal' && e.detail1 === 'Goal_Scored' && e.team === 'away');
  
  // Count by period
  const homeP1 = homeGoals.filter(g => g.period === 1 || g.period === '1').length;
  const homeP2 = homeGoals.filter(g => g.period === 2 || g.period === '2').length;
  const homeP3 = homeGoals.filter(g => g.period === 3 || g.period === '3').length;
  const awayP1 = awayGoals.filter(g => g.period === 1 || g.period === '1').length;
  const awayP2 = awayGoals.filter(g => g.period === 2 || g.period === '2').length;
  const awayP3 = awayGoals.filter(g => g.period === 3 || g.period === '3').length;
  
  document.getElementById('verifyHomeGoals').textContent = homeGoals.length;
  document.getElementById('verifyAwayGoals').textContent = awayGoals.length;
  document.getElementById('verifyHomeByPeriod').textContent = `P1: ${homeP1} | P2: ${homeP2} | P3: ${homeP3}`;
  document.getElementById('verifyAwayByPeriod').textContent = `P1: ${awayP1} | P2: ${awayP2} | P3: ${awayP3}`;
  
  // Compare to official
  const officialHome = parseInt(document.getElementById('officialHomeGoals').value) || 0;
  const officialAway = parseInt(document.getElementById('officialAwayGoals').value) || 0;
  
  const resultEl = document.getElementById('verifyResult');
  if (homeGoals.length === officialHome && awayGoals.length === officialAway) {
    resultEl.innerHTML = '‚úÖ VERIFIED - Goals match official score!';
    resultEl.style.background = 'rgba(16, 185, 129, 0.2)';
    resultEl.style.color = 'var(--success)';
  } else {
    const diff = `Home: ${homeGoals.length} vs ${officialHome}, Away: ${awayGoals.length} vs ${officialAway}`;
    resultEl.innerHTML = `‚ùå MISMATCH - ${diff}`;
    resultEl.style.background = 'rgba(239, 68, 68, 0.2)';
    resultEl.style.color = 'var(--danger)';
  }
  
  // v6: Build goal list with scorer # and assist # (from %assist% in play_detail)
  const allGoals = [...homeGoals, ...awayGoals].sort((a, b) => {
    if (a.period !== b.period) return a.period - b.period;
    return (b.start_time || '20:00').localeCompare(a.start_time || '20:00');
  });
  
  // Track for warnings
  const warnings = [];
  
  document.getElementById('verifyGoalsList').innerHTML = allGoals.map(g => {
    const scorer = g.players?.find(p => p.role === 'event_player_1');
    
    // v6: Find assists by checking for '%assist%' in play_detail1 or play_detail2 (within goal event)
    const assistersInGoal = (g.players || []).filter(p => {
      const pd1 = (p.playD1 || '').toLowerCase();
      const pd2 = (p.playD2 || '').toLowerCase();
      return pd1.includes('assist') || pd2.includes('assist');
    });
    
    // v23.8: Also check for linked Pass events (for imported data and auto-detected assists)
    const linkedPassEvents = [];
    if (g.linkedEventIdx !== null && g.linkedEventIdx !== undefined) {
      // Goal is linked to another event (unlikely, but check)
      const linkedEvt = S.events.find(e => e.idx === g.linkedEventIdx);
      if (linkedEvt && linkedEvt.type === 'Pass') {
        linkedPassEvents.push(linkedEvt);
      }
    }
    
    // v23.8: Find Pass events that assist this goal (using assistToGoalIdx, not linkedEventIdx)
    const passEventsLinkedToGoal = S.events.filter(e => {
      if (e.type !== 'Pass') return false;
      if (e.assistToGoalIdx === null || e.assistToGoalIdx === undefined) return false;
      return e.assistToGoalIdx === g.idx;
    });
    
    // Combine all linked Pass events
    const allLinkedPasses = [...linkedPassEvents, ...passEventsLinkedToGoal];
    
    // Extract assisters from linked Pass events
    const assistersFromPasses = [];
    allLinkedPasses.forEach(passEvt => {
      // Check if Pass event has assist markers in player details
      const passAssisters = (passEvt.players || []).filter(p => {
        const pd1 = (p.playD1 || '').toLowerCase();
        const pd2 = (p.playD2 || '').toLowerCase();
        return pd1.includes('assist') || pd2.includes('assist');
      });
      
      // If no assist markers, check primary player (event_player_1) as potential assist
      if (passAssisters.length === 0) {
        const primaryPlayer = passEvt.players?.find(p => 
          p.role === 'event_player_1' || p.role === 'event_team_player_1'
        );
        if (primaryPlayer) {
          // Add as potential assist (will show with ? indicator)
          assistersFromPasses.push({ ...primaryPlayer, source: 'linked_pass', needsMarking: true });
        }
      } else {
        // Add marked assisters
        passAssisters.forEach(a => {
          assistersFromPasses.push({ ...a, source: 'linked_pass', needsMarking: false });
        });
      }
    });
    
    // Combine all assisters (from goal event + from linked Pass events)
    const allAssisters = [
      ...assistersInGoal.map(a => ({ ...a, source: 'goal_event', needsMarking: false })),
      ...assistersFromPasses
    ];
    
    // Remove duplicates by player number
    const uniqueAssisters = [];
    const seenNums = new Set();
    allAssisters.forEach(a => {
      if (a.num && !seenNums.has(a.num)) {
        seenNums.add(a.num);
        uniqueAssisters.push(a);
      }
    });
    
    const scorerNum = scorer?.num || '';
    const scorerName = scorer?.name || '';
    
    // Build assist string with indicators
    let assistStr = 'Unassisted';
    if (uniqueAssisters.length > 0) {
      assistStr = uniqueAssisters.map(a => {
        let display = `#${a.num}`;
        if (a.needsMarking) {
          display += '?'; // Indicates assist from linked Pass but not marked
        }
        if (a.source === 'linked_pass') {
          display += 'üîó'; // Indicates assist from linked Pass event
        }
        return display;
      }).join(', ');
    }
    
    // v6: Check against roster stats
    let rosterMatch = '‚úì';
    if (S.rosterStats && scorerNum) {
      const rosterPlayer = S.rosterStats[scorerNum];
      if (rosterPlayer) {
        // Check if roster shows this player has a goal
        if (rosterPlayer.goals === 0) {
          rosterMatch = '‚ö†Ô∏è';
          warnings.push(`#${scorerNum} ${scorerName} scored but roster shows 0 goals`);
        }
      } else {
        rosterMatch = '?';
        warnings.push(`#${scorerNum} ${scorerName} not found in roster`);
      }
      
      // Check assisters
      uniqueAssisters.forEach(a => {
        const assistRoster = S.rosterStats[a.num];
        if (assistRoster && assistRoster.assists === 0) {
          warnings.push(`#${a.num} has assist but roster shows 0 assists`);
        }
        if (a.needsMarking) {
          warnings.push(`#${a.num} has linked Pass assist but not marked with '%assist%' in play_detail`);
        }
      });
    }
    
    // Warn if goal has linked Pass events but no assists found
    if (allLinkedPasses.length > 0 && uniqueAssisters.length === 0) {
      warnings.push(`Goal #${g.idx} has ${allLinkedPasses.length} linked Pass event(s) but no assists detected`);
    }
    
    return `<tr>
      <td>P${g.period}</td>
      <td>${g.start_time || '--'}</td>
      <td style="color:${g.team === 'home' ? 'var(--home)' : 'var(--away)'};">${g.team === 'home' ? (S.homeTeam || 'HOME') : (S.awayTeam || 'AWAY')}</td>
      <td><strong>#${scorerNum}</strong> ${scorerName}</td>
      <td>${assistStr}</td>
      <td>${rosterMatch}</td>
    </tr>`;
  }).join('') || '<tr><td colspan="6" style="text-align:center;color:var(--muted);">No goals recorded</td></tr>';
  
  // v6: Additional warnings
  if (homeGoals.length !== officialHome) warnings.push(`Home goals off by ${Math.abs(homeGoals.length - officialHome)}`);
  if (awayGoals.length !== officialAway) warnings.push(`Away goals off by ${Math.abs(awayGoals.length - officialAway)}`);
  
  // Check period mismatches
  if (S.officialPeriodGoals) {
    if (S.officialPeriodGoals.home[1] !== '-' && homeP1 !== parseInt(S.officialPeriodGoals.home[1])) {
      warnings.push(`P1 home goals: ${homeP1} tracked vs ${S.officialPeriodGoals.home[1]} official`);
    }
    if (S.officialPeriodGoals.home[2] !== '-' && homeP2 !== parseInt(S.officialPeriodGoals.home[2])) {
      warnings.push(`P2 home goals: ${homeP2} tracked vs ${S.officialPeriodGoals.home[2]} official`);
    }
    if (S.officialPeriodGoals.away[1] !== '-' && awayP1 !== parseInt(S.officialPeriodGoals.away[1])) {
      warnings.push(`P1 away goals: ${awayP1} tracked vs ${S.officialPeriodGoals.away[1]} official`);
    }
    if (S.officialPeriodGoals.away[2] !== '-' && awayP2 !== parseInt(S.officialPeriodGoals.away[2])) {
      warnings.push(`P2 away goals: ${awayP2} tracked vs ${S.officialPeriodGoals.away[2]} official`);
    }
  }
  
  // Goals without scorers
  const goalsWithoutScorer = allGoals.filter(g => !g.players?.find(p => p.role === 'event_player_1'));
  if (goalsWithoutScorer.length > 0) warnings.push(`${goalsWithoutScorer.length} goal(s) missing scorer`);
  
  // Goals without highlights or XY data
  const goalsWithoutHighlightOrXY = allGoals.filter(g => {
    const hasHighlight = g.isHighlight === true || g.isHighlight === 1 || g.videoUrl;
    const hasXY = (g.puckXY && g.puckXY.length > 0) || (g.players && g.players.some(p => p.xy && p.xy.length > 0));
    return !hasHighlight && !hasXY;
  });
  if (goalsWithoutHighlightOrXY.length > 0) {
    const goalList = goalsWithoutHighlightOrXY.map(g => `#${g.idx + 1} (P${g.period} ${g.start_time})`).join(', ');
    warnings.push(`${goalsWithoutHighlightOrXY.length} goal(s) missing highlight or XY data: ${goalList}`);
  }
  
  // v23.8: Calculate player-level assist counts
  const playerAssistCounts = {};
  
  // Count assists from play_detail markers in goal events
  allGoals.forEach(goal => {
    const assistersInGoal = (goal.players || []).filter(p => {
      const pd1 = (p.playD1 || '').toLowerCase();
      const pd2 = (p.playD2 || '').toLowerCase();
      return pd1.includes('assist') || pd2.includes('assist');
    });
    
    assistersInGoal.forEach(a => {
      const num = String(a.num);
      if (!playerAssistCounts[num]) {
        playerAssistCounts[num] = {
          num: num,
          name: a.name || '',
          team: goal.team,
          tracked: 0,
          roster: 0
        };
      }
      playerAssistCounts[num].tracked++;
    });
  });
  
  // Count assists from linked Pass events (v23.8: Count ALL linked Pass events, not just those with markers)
  allGoals.forEach(goal => {
    const passEventsLinkedToGoal = S.events.filter(e => {
      if (e.type !== 'Pass') return false;
      if (e.assistToGoalIdx === null || e.assistToGoalIdx === undefined) return false;
      return e.assistToGoalIdx === goal.idx;
    });
    
    passEventsLinkedToGoal.forEach(passEvt => {
      // Find the passer (event_player_1 or event_team_player_1)
      const passer = passEvt.players?.find(p => 
        p.role === 'event_player_1' || p.role === 'event_team_player_1'
      );
      
      if (passer && passer.num) {
        const num = String(passer.num);
        // Check if already counted for THIS goal via play_detail markers in goal event
        // (to avoid double-counting the same assist)
        const alreadyCountedForThisGoal = (goal.players || []).some(p => 
          String(p.num) === num && 
          ((p.playD1 || '').toLowerCase().includes('assist') || (p.playD2 || '').toLowerCase().includes('assist'))
        );
        
        // Always count linked Pass events as assists (the link itself is proof of assist)
        // Only skip if we've already counted this player for this specific goal
        if (!alreadyCountedForThisGoal) {
          if (!playerAssistCounts[num]) {
            playerAssistCounts[num] = {
              num: num,
              name: passer.name || '',
              team: passEvt.team || goal.team,
              tracked: 0,
              roster: 0
            };
          }
          playerAssistCounts[num].tracked++;
        }
      }
      
      // Note: The passer was already counted above if not already counted via markers
      // This section is for legacy support if there are additional marked assisters
      // (but we've already counted the primary passer above, so this is mostly redundant)
    });
  });
  
  // Get roster assist counts
  if (S.rosterStats) {
    Object.keys(S.rosterStats).forEach(num => {
      const rosterPlayer = S.rosterStats[num];
      if (rosterPlayer.assists > 0) {
        if (!playerAssistCounts[num]) {
          playerAssistCounts[num] = {
            num: num,
            name: rosterPlayer.name || '',
            team: rosterPlayer.team || 'unknown',
            tracked: 0,
            roster: 0
          };
        }
        playerAssistCounts[num].roster = rosterPlayer.assists;
      }
    });
    
    // Also add tracked players to roster comparison
    Object.keys(playerAssistCounts).forEach(num => {
      if (S.rosterStats[num]) {
        playerAssistCounts[num].roster = S.rosterStats[num].assists || 0;
        playerAssistCounts[num].name = playerAssistCounts[num].name || S.rosterStats[num].name || '';
      }
    });
  }
  
  // Render player assist counts table
  const assistCountsList = document.getElementById('verifyAssistCountsList');
  if (assistCountsList) {
    const playersWithAssists = Object.values(playerAssistCounts).filter(p => p.tracked > 0 || p.roster > 0);
    
    if (playersWithAssists.length === 0) {
      assistCountsList.innerHTML = '<tr><td colspan="6" style="text-align:center;color:var(--muted);padding:8px;font-size:9px;">No assists tracked</td></tr>';
    } else {
      // Sort by team, then by tracked assists (desc), then by roster assists (desc)
      playersWithAssists.sort((a, b) => {
        if (a.team !== b.team) return a.team === 'home' ? -1 : 1;
        if (b.tracked !== a.tracked) return b.tracked - a.tracked;
        return b.roster - a.roster;
      });
      
      assistCountsList.innerHTML = playersWithAssists.map(p => {
        const match = p.tracked === p.roster;
        const mismatch = p.tracked !== p.roster;
        const status = match ? '‚úì' : (p.tracked > p.roster ? '‚ö†Ô∏è +' + (p.tracked - p.roster) : '‚ö†Ô∏è -' + (p.roster - p.tracked));
        const statusColor = match ? 'var(--success)' : 'var(--warn)';
        
        if (mismatch) {
          warnings.push(`#${p.num} ${p.name}: ${p.tracked} tracked assist(s) vs ${p.roster} roster assist(s)`);
        }
        
        return `
          <tr style="border-bottom:1px solid var(--border);cursor:pointer;" onclick="showPlayerEvents('${p.num}', '${p.name || ''}')" title="Click to view all events for #${p.num} ${p.name || ''}">
            <td style="padding:4px;font-weight:600;color:var(--${p.team});">#${p.num}</td>
            <td style="padding:4px;">${p.name || 'Unknown'}</td>
            <td style="padding:4px;font-size:8px;color:var(--muted);">${p.team === 'home' ? (S.homeTeam || 'HOME') : (S.awayTeam || 'AWAY')}</td>
            <td style="padding:4px;text-align:center;font-weight:600;">${p.tracked}</td>
            <td style="padding:4px;text-align:center;font-weight:600;">${p.roster}</td>
            <td style="padding:4px;text-align:center;color:${statusColor};font-weight:600;">${status}</td>
          </tr>
        `;
      }).join('');
    }
  }
  
  // v23.8: Count assist detection methods for summary
  let assistsFromPlayDetails = 0;
  let assistsFromLinkedPasses = 0;
  let assistsNeedingMarking = 0;
  allGoals.forEach(g => {
    const assistersInGoal = (g.players || []).filter(p => {
      const pd1 = (p.playD1 || '').toLowerCase();
      const pd2 = (p.playD2 || '').toLowerCase();
      return pd1.includes('assist') || pd2.includes('assist');
    });
    assistsFromPlayDetails += assistersInGoal.length;
    
    const passEventsLinkedToGoal = S.events.filter(e => {
      if (e.type !== 'Pass') return false;
      if (e.assistToGoalIdx === null || e.assistToGoalIdx === undefined) return false;
      return e.assistToGoalIdx === g.idx;
    });
    
    passEventsLinkedToGoal.forEach(passEvt => {
      const passAssisters = (passEvt.players || []).filter(p => {
        const pd1 = (p.playD1 || '').toLowerCase();
        const pd2 = (p.playD2 || '').toLowerCase();
        return pd1.includes('assist') || pd2.includes('assist');
      });
      if (passAssisters.length > 0) {
        assistsFromLinkedPasses += passAssisters.length;
      } else {
        assistsNeedingMarking += 1; // Linked Pass but not marked
      }
    });
  });
  
  // Add summary to warnings if there are linked assists
  if (assistsFromLinkedPasses > 0 || assistsNeedingMarking > 0) {
    const summary = [];
    if (assistsFromPlayDetails > 0) {
      summary.push(`${assistsFromPlayDetails} assist(s) from play_details`);
    }
    if (assistsFromLinkedPasses > 0) {
      summary.push(`${assistsFromLinkedPasses} assist(s) from linked Pass events üîó`);
    }
    if (assistsNeedingMarking > 0) {
      summary.push(`${assistsNeedingMarking} linked Pass event(s) need assist marking`);
    }
    if (summary.length > 0) {
      console.log('Assist verification summary:', summary.join(', '));
    }
  }
  
  // v6: Display warnings in dedicated section
  const warningsEl = document.getElementById('verifyWarnings');
  const warningsListEl = document.getElementById('verifyWarningsList');
  if (warnings.length > 0) {
    warningsEl.style.display = 'block';
    warningsListEl.innerHTML = warnings.map(w => {
      // Extract player number from warning (format: "#XX Name" or "#XX")
      const playerMatch = w.match(/#(\d+)/);
      if (playerMatch) {
        const playerNum = playerMatch[1];
        // Try to extract player name if present
        const nameMatch = w.match(/#\d+\s+([^:]+)/);
        const playerName = nameMatch ? nameMatch[1].trim() : '';
        return `<div style="cursor:pointer;padding:2px 0;" onclick="showPlayerEvents('${playerNum}', '${playerName}')" title="Click to view all events for #${playerNum} ${playerName}">‚Ä¢ ${w}</div>`;
      }
      return `<div>‚Ä¢ ${w}</div>`;
    }).join('');
  } else {
    warningsEl.style.display = 'none';
  }
}

// ============================================================
// LOAD EXISTING GAME
// ============================================================
function openLoadGameModal() {
  try {
  if (!S.connected) {
    toast('Connect to Supabase first', 'error');
    return;
  }
  populateLoadGameSelect();
    const modal = document.getElementById('loadGameModal');
    if (!modal) {
      console.error('loadGameModal not found');
      toast('Load game modal not found', 'error');
      return;
    }
    
    // Ensure modal is in body (move if needed)
    if (modal.parentElement !== document.body) {
      document.body.appendChild(modal);
    }
    
    modal.classList.add('show');
    modal.style.display = 'flex';
    modal.style.visibility = 'visible';
    modal.style.opacity = '1';
    modal.style.zIndex = '10000';
    modal.style.position = 'fixed';
    modal.style.top = '0';
    modal.style.left = '0';
    modal.style.right = '0';
    modal.style.bottom = '0';
    modal.style.width = '100%';
    modal.style.height = '100%';
    modal.style.background = 'rgba(0,0,0,0.85)';
    
    // Ensure the modal content div is properly positioned
    const modalContent = modal.querySelector('.modal');
    if (modalContent) {
      modalContent.style.position = 'relative';
      modalContent.style.zIndex = '10001';
    }
    
    // Remove ALL existing handlers that might interfere
    if (modal._overlayClickHandler) {
      modal.removeEventListener('click', modal._overlayClickHandler);
      modal.removeEventListener('mousedown', modal._overlayClickHandler);
      delete modal._overlayClickHandler;
    }
    modal.onclick = null; // Clear any existing onclick
    
    // Use simple inline onclick pattern like genericModal - proven to work
    // This doesn't interfere with buttons because it only runs if e.target === modal
    modal.onclick = function(e) {
      if (e.target === this) {
        closeSettings();
      }
    };
    console.log('Load game modal opened');
  } catch (err) {
    console.error('Error opening load game modal:', err);
    toast('Error opening load game: ' + err.message, 'error');
  }
}

function closeLoadGameModal() {
  document.getElementById('loadGameModal').classList.remove('show');
}

async function populateLoadGameSelect() {
  const select = document.getElementById('loadGameSelect');
  select.innerHTML = '<option value="">Loading tracked games...</option>';
  
  try {
    // Paginate through fact_events to get ALL game_ids
    console.log('Load modal: Querying fact_events...');
    const allGameIds = new Set();
    let offset = 0;
    const pageSize = 1000;
    let hasMore = true;
    
    while (hasMore && offset < 50000) {
      const { data, error } = await S.sb.from('fact_events')
        .select('game_id')
        .range(offset, offset + pageSize - 1);
      
      if (error) break;
      if (!data || data.length === 0) {
        hasMore = false;
      } else {
        data.forEach(r => allGameIds.add(r.game_id));
        offset += pageSize;
        if (data.length < pageSize) hasMore = false;
      }
    }
    
    const trackedGameIds = Array.from(allGameIds);
    console.log('Load modal: Found game IDs:', trackedGameIds);
    
    if (trackedGameIds.length === 0) {
      select.innerHTML = '<option value="">No tracked games found</option>';
      return;
    }
    
    // Get game details for tracked games
    const { data: games } = await S.sb.from('dim_schedule')
      .select('game_id,date,home_team_name,away_team_name')
      .in('game_id', trackedGameIds)
      .order('date', { ascending: false });
    
    console.log('Load modal: Schedule returned', games?.length, 'rows');
    
    // Dedupe
    const seen = new Set();
    const uniqueGames = (games || []).filter(g => {
      if (seen.has(g.game_id)) return false;
      seen.add(g.game_id);
      return true;
    });
    
    select.innerHTML = '<option value="">Select tracked game (' + uniqueGames.length + ')</option>' + 
      uniqueGames.map(g => `<option value="${g.game_id}">${g.game_id} - ${g.date?.split('T')[0]} ${g.home_team_name} vs ${g.away_team_name}</option>`).join('');
      
    console.log('Load game modal:', uniqueGames.length, 'tracked games');
  } catch(e) {
    toast('Failed to load games', 'error');
    console.error(e);
  }
}

async function previewLoadGame() {
  const gameId = document.getElementById('loadGameSelect').value;
  if (!gameId) {
    document.getElementById('loadPreviewEvents').textContent = '--';
    document.getElementById('loadPreviewShifts').textContent = '--';
    return;
  }
  
  try {
    const { count: evtCount } = await S.sb.from('fact_events').select('*', { count: 'exact', head: true }).eq('game_id', gameId);
    const { count: shiftCount } = await S.sb.from('fact_shifts').select('*', { count: 'exact', head: true }).eq('game_id', gameId);
    
    document.getElementById('loadPreviewEvents').textContent = evtCount || 0;
    document.getElementById('loadPreviewShifts').textContent = shiftCount || 0;
  } catch(e) {
    console.error(e);
  }
}

async function confirmLoadGame() {
  const gameId = document.getElementById('loadGameSelect').value;
  if (!gameId) { toast('Select a game', 'error'); return; }
  
  // v23.8: Don't prompt for save directory automatically (requires user gesture)
  // User can select it manually from Settings if desired
  
  try {
    toast('Loading game data from Supabase...', 'info');
    console.log('=== LOADING GAME:', gameId, '===');
    
    // First set the game ID and find game info
    S.gameId = parseInt(gameId);
    
    // Create/get game folder if default folder is set
    await ensureGameFolder();
    const g = S.games.find(x => x.game_id == gameId);
    if (g) {
      S.homeTeam = g.home_team_name;
      S.awayTeam = g.away_team_name;
      console.log('Game info:', S.homeTeam, 'vs', S.awayTeam);
      
      // v16: Load team colors and logos from S.teams (loaded in loadReferenceData)
      const homeTeamData = S.teams[S.homeTeam] || {};
      const awayTeamData = S.teams[S.awayTeam] || {};
      S.homeColor = homeTeamData.color1 || '#3b82f6';
      S.awayColor = awayTeamData.color1 || '#ef4444';
      S.homeLogo = homeTeamData.logo || null;
      S.awayLogo = awayTeamData.logo || null;
      console.log('Team colors:', S.homeColor, S.awayColor);
      console.log('Team logos:', S.homeLogo, S.awayLogo);
      
      // v16: Apply team colors to CSS variables
      document.documentElement.style.setProperty('--home', S.homeColor);
      document.documentElement.style.setProperty('--away', S.awayColor);
      
      // v16: Update UI labels with team names (not Home/Away)
      document.getElementById('homeLbl').textContent = S.homeTeam;
      document.getElementById('awayLbl').textContent = S.awayTeam;
      document.getElementById('evtHomeLbl').textContent = S.homeTeam;
      document.getElementById('evtAwayLbl').textContent = S.awayTeam;
      
      // v16: Update team logos if available
      updateTeamLogos();
      updateZoneLabels();
    }
    
    // Update the main game dropdown
    document.getElementById('gameSelect').value = gameId;
    
    // Load events with pagination (Supabase 1000 row limit)
    console.log('Loading events...');
    let allEvents = [];
    let offset = 0;
    let hasMore = true;
    
    while (hasMore) {
      const { data, error } = await S.sb.from('fact_events')
        .select('*')
        .eq('game_id', gameId)
        .order('event_id')
        .range(offset, offset + 999);
      
      if (error) {
        console.error('Event load error:', error);
        throw error;
      }
      
      if (!data || data.length === 0) {
        hasMore = false;
      } else {
        allEvents = allEvents.concat(data);
        console.log(`  Events page: ${data.length} (total: ${allEvents.length})`);
        offset += 1000;
        if (data.length < 1000) hasMore = false;
      }
    }
    console.log('Total events loaded:', allEvents.length);
    
    // Load shifts with pagination
    console.log('Loading shifts...');
    let allShifts = [];
    offset = 0;
    hasMore = true;
    
    while (hasMore) {
      const { data, error } = await S.sb.from('fact_shifts')
        .select('*')
        .eq('game_id', gameId)
        .order('shift_index')
        .range(offset, offset + 999);
      
      if (error) {
        console.error('Shift load error:', error);
        throw error;
      }
      
      if (!data || data.length === 0) {
        hasMore = false;
      } else {
        allShifts = allShifts.concat(data);
        console.log(`  Shifts page: ${data.length} (total: ${allShifts.length})`);
        offset += 1000;
        if (data.length < 1000) hasMore = false;
      }
    }
    console.log('Total shifts loaded:', allShifts.length);
    
    // Load event players for player details
    console.log('Loading event players...');
    let allPlayers = [];
    offset = 0;
    hasMore = true;
    
    while (hasMore) {
      const { data, error } = await S.sb.from('fact_event_players')
        .select('*')
        .eq('game_id', gameId)
        .range(offset, offset + 999);
      
      if (error) {
        console.error('Player load error:', error);
        throw error;
      }
      
      if (!data || data.length === 0) {
        hasMore = false;
      } else {
        allPlayers = allPlayers.concat(data);
        console.log(`  Players page: ${data.length} (total: ${allPlayers.length})`);
        offset += 1000;
        if (data.length < 1000) hasMore = false;
      }
    }
    console.log('Total player rows loaded:', allPlayers.length);
    
    // v16.02: Debug - log column names from first player row
    if (allPlayers.length > 0) {
      console.log('Player columns:', Object.keys(allPlayers[0]));
      // Find a player with play_detail data for debugging
      const playerWithPD = allPlayers.find(p => p.play_detail1 || p.play_detail_1 || p['play_detail1']);
      if (playerWithPD) {
        console.log('Sample player with play_detail:', {
          event_id: playerWithPD.event_id,
          player_game_number: playerWithPD.player_game_number,
          play_detail1: playerWithPD.play_detail1,
          'play_detail_1': playerWithPD.play_detail_1,
          play_detail_2: playerWithPD.play_detail_2,
          'play_detail2': playerWithPD.play_detail2
        });
      } else {
        console.log('No players with play_detail found in sample');
        // Log first 3 players to see all fields
        console.log('First 3 players:', allPlayers.slice(0, 3).map(p => ({...p})));
      }
    }
    
    // Group players by event_id
    const playersByEvent = {};
    allPlayers.forEach(p => {
      const evtId = p.event_id;
      if (!playersByEvent[evtId]) playersByEvent[evtId] = [];
      playersByEvent[evtId].push(p);
    });
    console.log('Events with players:', Object.keys(playersByEvent).length);
    
    // Convert events to tracker format
    console.log('Converting events to tracker format...');
    
    // First pass: create events with event_id mapping for linked events
    const eventsWithIds = allEvents.map((e, i) => {
      const evtPlayers = playersByEvent[e.event_id] || [];
      
      // v15: Fix team loading - use player_team from event_player_1, compare to home_team
      // The team_venue column in fact_events is unreliable (often all 'Away')
      // Instead, find the event_player_1 and check their player_team vs home_team
      let isHome = false;
      const eventPlayer1 = evtPlayers.find(p => 
        p.player_role === 'event_player_1' || p.player_role === 'event_team_player_1'
      );
      if (eventPlayer1) {
        // Compare player_team to home_team to determine if home or away
        isHome = eventPlayer1.player_team === e.home_team || eventPlayer1.player_team === S.homeTeam;
      } else {
        // Fallback: try team_venue but normalize case
        const teamVenue = (e.team_venue || e.team || '').toLowerCase();
        isHome = teamVenue === 'home' || teamVenue === 'h';
      }
      
      return {
        idx: i,
        eventId: e.event_id,
        game_id: e.game_id,
        period: e.period,
        start_time: `${e.event_start_min || 0}:${String(e.event_start_sec || 0).padStart(2, '0')}`,
        end_time: `${e.event_end_min || e.event_start_min || 0}:${String(e.event_end_sec || e.event_start_sec || 0).padStart(2, '0')}`,
        team: isHome ? 'home' : 'away',
        type: e.event_type,
        detail1: e.event_detail,
        detail2: e.event_detail_2,
        zone: e.event_team_zone?.charAt(0).toLowerCase() || '',
        success: e.event_successful,
        strength: e.strength || '5v5',
        isHighlight: e.is_highlight === 1 || e.is_highlight === true,
        linkedEventId: e.linked_event_key || null, // Store event_id for now
        assistToGoalIdx: e.assist_to_goal_index ? (parseInt(e.assist_to_goal_index) - 1000) : (e.assist_to_goal_index_flag_ ? parseInt(e.assist_to_goal_index_flag_) - 1 : null), // v23.8: Separate column for assists
        sequenceIdx: e.sequence_key || null,
        playIdx: e.play_key || null,
        puckXY: (e.puck_x_start != null && e.puck_y_start != null) ? 
          [{ x: e.puck_x_start, y: e.puck_y_start }] : [],
        // v23.5: Load net target XY if available
        netXY: (e.net_x != null && e.net_y != null) ? 
          { x: e.net_x, y: e.net_y } : null,
        players: evtPlayers.map(p => {
          // v16.02: Debug play_detail mapping
          const pd1 = p.play_detail1 || p.play_detail_1 || p.player_play_detail_1 || '';
          const pd2 = p.play_detail_2 || p.play_detail2 || p.player_play_detail_2 || '';
          // v16.03: Target debug for specific event/player
          if (e.event_id === 'EV1896901058' || (pd1 && pd1.toLowerCase().includes('forced'))) {
            console.log(`üéØ TARGET DEBUG - Event ${e.event_id}, Player #${p.player_game_number}:`);
            console.log('  Raw play_detail1:', p.play_detail1);
            console.log('  Raw play_detail_2:', p.play_detail_2);
            console.log('  Mapped pd1:', pd1);
            console.log('  Mapped pd2:', pd2);
          }
          return {
          num: String(p.player_game_number || ''),
          name: p.player_name || '',
          role: p.player_role || 'event_team_player_1',
          roleNum: p.role_number || 1,
          // v16.02: Enhanced column checking with debug
          playD1: pd1,
          playD2: pd2,
          playSuccess: p.play_detail_successful || p.play_successful || '',
          pressure: p.pressured_pressurer || '',
          sideOfPuck: p.side_of_puck || '',
          teamVenue: p.team_venue || '',
          xy: (p.player_x != null && p.player_y != null) ? 
            [{ x: p.player_x, y: p.player_y }] : []
        };})
      };
    });
    
    // Second pass: Map linked_event_id to linkedEventIdx (event index)
    // Create a map of event_id -> idx
    const eventIdToIdx = {};
    eventsWithIds.forEach((evt, idx) => {
      eventIdToIdx[evt.eventId] = idx;
    });
    
    // Now convert linked_event_id to linkedEventIdx
    S.events = eventsWithIds.map(evt => {
      if (evt.linkedEventId) {
        const linkedIdx = eventIdToIdx[evt.linkedEventId];
        if (linkedIdx !== undefined) {
          evt.linkedEventIdx = linkedIdx;
          console.log(`Mapped linked event: ${evt.eventId} ‚Üí linked to event at idx ${linkedIdx} (${eventsWithIds[linkedIdx]?.eventId})`);
        } else {
          console.warn(`Linked event not found: ${evt.linkedEventId} for event ${evt.eventId}`);
          evt.linkedEventIdx = null;
        }
      } else {
        evt.linkedEventIdx = null;
      }
      // Remove temporary linkedEventId field
      delete evt.linkedEventId;
      // Fix idx to be 1-based for display
      evt.idx = evt.idx + 1;
      return evt;
    });
    
    console.log('Converted', S.events.length, 'events');
    
    // v16.03: Debug summary - count events with play_detail data
    const eventsWithPD = S.events.filter(e => e.players?.some(p => p.playD1 || p.playD2));
    console.log(`Events with play_detail data: ${eventsWithPD.length}/${S.events.length}`);
    if (eventsWithPD.length > 0) {
      console.log('Sample events with PD:', eventsWithPD.slice(0, 5).map(e => ({
        eventId: e.eventId,
        type: e.type,
        players: e.players?.map(p => ({ num: p.num, playD1: p.playD1, playD2: p.playD2 }))
      })));
    }
    // Check for specific event
    const targetEvent = S.events.find(e => e.eventId === 'EV1896901058');
    if (targetEvent) {
      console.log('üéØ Found EV1896901058:', targetEvent);
    } else {
      console.log('‚ö†Ô∏è EV1896901058 not found in loaded events');
    }
    
    // Convert shifts to tracker format
    console.log('Converting shifts to tracker format...');
    S.shifts = allShifts.map((sh, i) => ({
      idx: i + 1,
      shiftId: sh.shift_id,
      period: sh.period,
      start_time: `${sh.shift_start_min || 0}:${String(sh.shift_start_sec || 0).padStart(2, '0')}`,
      end_time: `${sh.shift_end_min || 0}:${String(sh.shift_end_sec || 0).padStart(2, '0')}`,
      start_type: sh.shift_start_type || 'OnTheFly',  // v17: Fixed to match LISTS format
      stop_type: sh.shift_stop_type || 'OnTheFly',    // v17: Fixed to match LISTS format
      strength: sh.strength || '5v5',
      stoppageTime: sh.stoppage_time || 0,
      home: {
        F1: sh.home_forward_1 ? { num: String(sh.home_forward_1) } : null,
        F2: sh.home_forward_2 ? { num: String(sh.home_forward_2) } : null,
        F3: sh.home_forward_3 ? { num: String(sh.home_forward_3) } : null,
        D1: sh.home_defense_1 ? { num: String(sh.home_defense_1) } : null,
        D2: sh.home_defense_2 ? { num: String(sh.home_defense_2) } : null,
        G: sh.home_goalie ? { num: String(sh.home_goalie) } : null,
        X: sh.home_xtra ? { num: String(sh.home_xtra) } : null
      },
      away: {
        F1: sh.away_forward_1 ? { num: String(sh.away_forward_1) } : null,
        F2: sh.away_forward_2 ? { num: String(sh.away_forward_2) } : null,
        F3: sh.away_forward_3 ? { num: String(sh.away_forward_3) } : null,
        D1: sh.away_defense_1 ? { num: String(sh.away_defense_1) } : null,
        D2: sh.away_defense_2 ? { num: String(sh.away_defense_2) } : null,
        G: sh.away_goalie ? { num: String(sh.away_goalie) } : null,
        X: sh.away_xtra ? { num: String(sh.away_xtra) } : null
      }
    }));
    console.log('Converted', S.shifts.length, 'shifts');
    
    S.evtIdx = S.events.length;
    S.shiftIdx = S.shifts.length;
    
    // Load rosters
    console.log('Loading rosters...');
    await loadRosters(gameId);
    
    // Close modal and render everything
    closeLoadGameModal();
    
    // v23.8: Process all goals to detect and link assists after loading from Supabase
    if (S.events && S.events.length > 0) {
      processAllGoalsForAssists();
      
      // v23.8: Auto-mark all Goal events as highlights
      const goals = S.events.filter(e => e.type === 'Goal' && e.detail1 === 'Goal_Scored');
      goals.forEach(goal => {
        if (!goal.isHighlight) {
          goal.isHighlight = true;
        }
      });
    }
    
    // Full render
    console.log('Rendering UI...');
    renderAll();
    renderRosters();
    renderEvents();
    renderShiftLog();
    updateScores();
    updateBoxScore();
    
    // Update localStorage
    localStorage.setItem('bs_lastGame', gameId);
    
    // v23.8: Show video URL entry modal for goals if any exist and don't have URLs
    if (S.events && S.events.length > 0) {
      const goalsWithoutUrls = S.events.filter(e => 
        e.type === 'Goal' && 
        e.detail1 === 'Goal_Scored' && 
        (!e.videoUrl || e.videoUrl.trim() === '')
      );
      if (goalsWithoutUrls.length > 0) {
        setTimeout(() => {
          showGoalVideoUrlsModal(goalsWithoutUrls);
        }, 1000);
      }
    }
    
    toast(`‚úÖ Loaded ${S.events.length} events, ${S.shifts.length} shifts`, 'success');
    console.log('=== LOAD COMPLETE ===');
    
  } catch(e) {
    toast('Failed to load game: ' + e.message, 'error');
    console.error('Load game error:', e);
  }
}

// ============================================================
// CLEAR ALL DATA
// ============================================================
function clearAllData() {
  if (!confirm('‚ö†Ô∏è Clear ALL events and shifts for this game?\n\nThis cannot be undone!')) return;
  if (!confirm('Are you REALLY sure? All tracking data will be lost.')) return;
  
  S.events = [];
  S.shifts = [];
  S.evtIdx = 0;
  S.shiftIdx = 0;
  S.lastSave = null;
  
  // Clear localStorage
  if (S.gameId) {
    localStorage.removeItem(`bs_${S.gameId}`);
  }
  
  renderAll();
  updateScores();
  updateBoxScore();
  
  toast('All data cleared', 'success');
  closeSettings();
}

/**
 * Clear all events (with confirmation)
 */
function clearAllEvents() {
  if (S.events.length === 0) {
    toast('No events to clear', 'info');
    return;
  }
  if (!confirm(`‚ö†Ô∏è Clear ALL ${S.events.length} events?\n\nThis cannot be undone!`)) return;
  
  S.events = [];
  S.evtIdx = 0;
  
  renderEvents();
  updateScores();
  updateBoxScore();
  renderMarkers();
  autoSave();
  
  toast(`Cleared all events`, 'success');
}

/**
 * Clear all shifts (with confirmation)
 */
function clearAllShifts() {
  if (S.shifts.length === 0) {
    toast('No shifts to clear', 'info');
    return;
  }
  if (!confirm(`‚ö†Ô∏è Clear ALL ${S.shifts.length} shifts?\n\nThis cannot be undone!`)) return;
  
  S.shifts = [];
  S.shiftIdx = 0;
  
  renderShiftLog();
  updateBoxScore();
  autoSave();
  
  toast(`Cleared all shifts`, 'success');
}

// ============================================================
// LINKED EVENT LOGIC
// ============================================================
function applyLinkedEventData() {
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'applyLinkedEventData:entry',message:'Applying linked event data',data:{linkedEventIdx:S.linkedEventIdx,currType:S.curr.type},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
  // #endregion
  
  // Copy XY data from linked event chain to current event
  // This applies to ALL linked event types
  if (S.linkedEventIdx === null && S.linkedEventIdx !== 0) {
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'applyLinkedEventData:noLink',message:'No linked event index',timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
    // #endregion
    return;
  }
  
  const currType = S.curr.type;
  
  // ============================================================
  // FIND THE BEST SOURCE FOR XY DATA
  // Priority: 1) Most recent sibling (same linked_event), 2) Source event, 3) Previous event
  // ============================================================
  
  let sourceEvt = null;
  let sourceDesc = '';
  
  // 1. Check for sibling events (same linked_event) - get the most recent one with XY
  const siblings = S.events
    .filter(e => e.linkedEventIdx === S.linkedEventIdx && e.puckXY?.length)
    .sort((a, b) => b.idx - a.idx); // Most recent first
  
  if (siblings.length > 0) {
    sourceEvt = siblings[0];
    sourceDesc = `sibling #${sourceEvt.idx + 1} (${sourceEvt.type})`;
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'applyLinkedEventData:sourceFound',message:'Source found - sibling event',data:{sourceType:'sibling',sourceEventIdx:sourceEvt.idx,sourceType:sourceEvt.type,puckXYCount:sourceEvt.puckXY?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
    // #endregion
  }
  
  // 2. If no sibling has XY, check the source event itself
  if (!sourceEvt) {
    const linkedEvt = S.events.find(e => e.idx === S.linkedEventIdx);
    if (linkedEvt?.puckXY?.length) {
      sourceEvt = linkedEvt;
      sourceDesc = `source #${linkedEvt.idx + 1} (${linkedEvt.type})`;
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'applyLinkedEventData:sourceFound',message:'Source found - linked event',data:{sourceType:'linked',sourceEventIdx:linkedEvt.idx,sourceType:linkedEvt.type,puckXYCount:linkedEvt.puckXY?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
      // #endregion
    }
  }
  
  // 3. If still no XY, check the most recent event (regardless of linked_event)
  if (!sourceEvt && S.events.length > 0) {
    const lastEvt = S.events[S.events.length - 1];
    if (lastEvt?.puckXY?.length) {
      sourceEvt = lastEvt;
      sourceDesc = `previous #${lastEvt.idx + 1} (${lastEvt.type})`;
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'applyLinkedEventData:sourceFound',message:'Source found - previous event',data:{sourceType:'previous',sourceEventIdx:lastEvt.idx,sourceType:lastEvt.type,puckXYCount:lastEvt.puckXY?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
      // #endregion
    }
  }
  
  // If no source found with XY, just copy zone from linked event
  if (!sourceEvt) {
    const linkedEvt = S.events.find(e => e.idx === S.linkedEventIdx);
    if (linkedEvt?.zone) {
      document.getElementById('evtZone').value = linkedEvt.zone;
    }
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'applyLinkedEventData:noXYSource',message:'No XY source found',timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
    // #endregion
    toast(`Linked to #${S.linkedEventIdx + 1} (no XY to copy)`, 'info');
    return;
  }
  
  // ============================================================
  // COPY ALL XY DATA FROM SOURCE
  // ============================================================
  
  // Copy puck XY
  if (sourceEvt.puckXY?.length) {
    S.curr.puckXY = JSON.parse(JSON.stringify(sourceEvt.puckXY));
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'applyLinkedEventData:puckXYCopied',message:'Puck XY copied from source',data:{sourceDesc,puckXYCount:S.curr.puckXY.length,sourcePuckXYCount:sourceEvt.puckXY.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
    // #endregion
  }
  
  // Copy net XY if available
  if (sourceEvt.netXY) {
    S.curr.netXY = JSON.parse(JSON.stringify(sourceEvt.netXY));
  }
  
  // Copy ALL player positions from source event
  let playersCopied = 0;
  let playersWithXY = 0;
  if (sourceEvt.players?.length) {
    // Determine if teams should swap roles (e.g., Shot‚ÜíSave)
    const shouldSwapTeams = (
      (currType === 'Save' && sourceEvt.type === 'Shot') ||
      (currType === 'Block' && sourceEvt.type === 'Shot')
    );
    
    sourceEvt.players.forEach(srcPlayer => {
      // Deep copy the player
      const newPlayer = JSON.parse(JSON.stringify(srcPlayer));
      
      // Map role if teams should swap
      if (shouldSwapTeams && newPlayer.role) {
        if (newPlayer.role.includes('event_team')) {
          newPlayer.role = newPlayer.role.replace('event_team', 'opp_team');
        } else if (newPlayer.role.includes('opp_team')) {
          newPlayer.role = newPlayer.role.replace('opp_team', 'event_team');
        }
      }
      
      // Check if this player already exists in current event
      const existingIdx = S.curr.players.findIndex(p => 
        p.num === newPlayer.num && p.team === newPlayer.team
      );
      
      if (existingIdx >= 0) {
        // Merge XY data into existing player
        if (newPlayer.xy?.length) {
          S.curr.players[existingIdx].xy = newPlayer.xy;
          playersWithXY++;
        }
        playersCopied++;
      } else {
        // Add player with XY
        S.curr.players.push(newPlayer);
        playersCopied++;
        if (newPlayer.xy?.length) {
          playersWithXY++;
        }
      }
    });
    
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'applyLinkedEventData:playersCopied',message:'Players copied from source',data:{sourceDesc,playersCopied,playersWithXY,shouldSwapTeams},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
    // #endregion
  }
  
  // Copy zone from source or linked event
  const zoneSource = sourceEvt.zone || S.events.find(e => e.idx === S.linkedEventIdx)?.zone;
  if (zoneSource) {
    document.getElementById('evtZone').value = zoneSource;
  }
  
  // Re-render to show copied data
  renderQuickAdd();
  renderMarkers();
  
  // Show confirmation
  toast(`Copied XY from ${sourceDesc}`, 'info');
}

// ============================================================
// v23.9: EVENT CHAIN TEMPLATES & AUTO-SUGGEST
// ============================================================

/**
 * v23.9: Check if logged event matches any template triggers and suggest next event
 */
function checkAndSuggestNextEvent(loggedEvt) {
  if (!S.eventChainTemplates || S.eventChainTemplates.length === 0) {
    // Load default templates if none exist
    loadDefaultEventTemplates();
  }
  
  // Check each template for matches
  for (const template of S.eventChainTemplates) {
    if (matchesTemplateTrigger(loggedEvt, template.trigger)) {
      showEventSuggestion(loggedEvt, template);
      return; // Only show first match
    }
  }
}

/**
 * v23.9: Check if event matches template trigger conditions
 */
function matchesTemplateTrigger(evt, trigger) {
  // Check type
  if (trigger.type && evt.type !== trigger.type) return false;
  
  // Check detail1 (supports partial match with includes)
  if (trigger.detail1) {
    if (trigger.detail1Exact) {
      if (evt.detail1 !== trigger.detail1) return false;
    } else {
      if (!evt.detail1 || !evt.detail1.includes(trigger.detail1)) return false;
    }
  }
  
  // Check detail2 (supports partial match with includes)
  if (trigger.detail2) {
    if (trigger.detail2Exact) {
      if (evt.detail2 !== trigger.detail2) return false;
    } else {
      if (!evt.detail2 || !evt.detail2.includes(trigger.detail2)) return false;
    }
  }
  
  // Check play_detail_1 or play_detail_2 on event_player_1
  if (trigger.playDetail1 || trigger.playDetail2) {
    const evtPlayer1 = evt.players?.find(p => 
      p.role === 'event_team_player_1' || p.role === 'event_player_1' || p.roleNum === 1
    );
    
    if (trigger.playDetail1) {
      const pd1 = (evtPlayer1?.playD1 || '').toLowerCase();
      const triggerPd1 = trigger.playDetail1.toLowerCase();
      if (!pd1.includes(triggerPd1)) return false;
    }
    
    if (trigger.playDetail2) {
      const pd2 = (evtPlayer1?.playD2 || '').toLowerCase();
      const triggerPd2 = trigger.playDetail2.toLowerCase();
      if (!pd2.includes(triggerPd2)) return false;
    }
  }
  
  return true;
}

/**
 * v23.9: Show event suggestion modal
 */
function showEventSuggestion(sourceEvt, template) {
  // Create or update suggestion modal
  let modal = document.getElementById('eventSuggestionModal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'eventSuggestionModal';
    modal.className = 'overlay';
    modal.innerHTML = `
      <div class="modal" style="min-width:400px;max-width:500px;">
        <h3>üîó Suggest Next Event</h3>
        <div id="suggestionContent" style="margin:16px 0;"></div>
        <div style="display:flex;gap:8px;justify-content:flex-end;">
          <button class="btn-sm btn-danger" onclick="rejectEventSuggestion()">‚úï Deny</button>
          <button class="btn-sm" onclick="acceptEventSuggestion()" style="background:var(--success);">‚úì Accept</button>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
  }
  
  // Populate suggestion content
  const content = document.getElementById('suggestionContent');
  const suggestedType = template.suggested.type || '';
  const suggestedD1 = template.suggested.detail1 || '';
  const suggestedD2 = template.suggested.detail2 || '';
  
  let playerMappingText = '';
  if (template.playerMapping && Object.keys(template.playerMapping).length > 0) {
    const mappings = Object.entries(template.playerMapping).map(([from, to]) => 
      `${from} ‚Üí ${to}`
    ).join(', ');
    playerMappingText = `<p style="font-size:9px;color:var(--muted);margin-top:4px;">Player mapping: ${mappings}</p>`;
  }
  
  content.innerHTML = `
    <p><strong>Template:</strong> ${template.name || 'Untitled'}</p>
    <p><strong>Suggested Event:</strong> ${suggestedType}${suggestedD1 ? ' - ' + suggestedD1 : ''}${suggestedD2 ? ' - ' + suggestedD2 : ''}</p>
    ${template.copyXY ? '<p style="font-size:9px;color:var(--accent);">‚úì Will copy XY data</p>' : ''}
    ${template.copyZone ? '<p style="font-size:9px;color:var(--accent);">‚úì Will copy zone</p>' : ''}
    ${playerMappingText}
  `;
  
  // Store template and source event for accept/reject handlers
  S.pendingEventSuggestion = { template, sourceEvt };
  
  // Show modal
  modal.classList.add('show');
}

/**
 * v23.9: Auto-create next linked event based on templates (without showing suggestion modal)
 */
function autoCreateNextLinkedEvent(sourceEvt) {
  if (!S.eventChainTemplates || S.eventChainTemplates.length === 0) {
    loadDefaultEventTemplates();
  }
  
  // Check each template for matches
  for (const template of S.eventChainTemplates) {
    if (matchesTemplateTrigger(sourceEvt, template.trigger)) {
      // Auto-accept the suggestion (create the event directly)
      applyEventTemplate(sourceEvt, template);
      return true; // Created event
    }
  }
  
  return false; // No matching template
}

/**
 * v23.9: Apply event template to create next event (extracted from acceptEventSuggestion)
 */
function applyEventTemplate(sourceEvt, template) {
  // Set event type
  setEvtType(template.suggested.type);
  
  // Set detail1 and detail2
  if (template.suggested.detail1) {
    document.getElementById('evtD1').value = template.suggested.detail1;
    onD1Change();
    if (template.suggested.detail2) {
      setTimeout(() => {
        document.getElementById('evtD2').value = template.suggested.detail2;
      }, 100);
    }
  }
  
  // Copy XY if specified
  if (template.copyXY && sourceEvt.puckXY?.length > 0) {
    S.curr.puckXY = JSON.parse(JSON.stringify(sourceEvt.puckXY));
    
    // Also copy player XY with mapping if specified
    if (template.playerMapping && sourceEvt.players?.length > 0) {
      S.curr.players = [];
      sourceEvt.players.forEach(srcPlayer => {
        const srcRole = srcPlayer.role || `event_team_player_${srcPlayer.roleNum || 1}`;
        const targetRole = template.playerMapping[srcRole];
        
        if (targetRole) {
          const newPlayer = JSON.parse(JSON.stringify(srcPlayer));
          // Map role (e.g., event_player_1 ‚Üí opp_player_1 for Save events)
          if (targetRole.startsWith('opp')) {
            newPlayer.role = targetRole;
            newPlayer.team = sourceEvt.team === 'home' ? 'away' : 'home';
          } else {
            newPlayer.role = targetRole;
          }
          newPlayer.xy = srcPlayer.xy ? JSON.parse(JSON.stringify(srcPlayer.xy)) : [];
          S.curr.players.push(newPlayer);
        } else if (srcRole.startsWith('event')) {
          // Keep event players if not mapped
          const newPlayer = JSON.parse(JSON.stringify(srcPlayer));
          S.curr.players.push(newPlayer);
        }
      });
      
      // If teams need to swap (e.g., Shot‚ÜíSave), swap event team
      if (template.suggested.type === 'Save' && sourceEvt.type === 'Shot') {
        S.evtTeam = sourceEvt.team === 'home' ? 'away' : 'home';
        document.getElementById('evtTeam').value = S.evtTeam;
        updateEvtTeamUI();
      }
      
      renumberPlayers();
    } else if (template.copyXY && !template.playerMapping) {
      // Copy all players as-is if no mapping
      S.curr.players = sourceEvt.players ? sourceEvt.players.map(p => ({
        ...p,
        xy: p.xy ? JSON.parse(JSON.stringify(p.xy)) : []
      })) : [];
    }
  }
  
  // Copy zone if specified
  if (template.copyZone && sourceEvt.zone) {
    document.getElementById('evtZone').value = sourceEvt.zone;
  }
  
  // Link to source event - use the next available linked index (max + 1)
  const nextLinkedIdx = getNextLinkedEventIdx();
  S.linkedEventIdx = nextLinkedIdx;
  const linkedSel = document.getElementById('linkedEvtSelect');
  if (linkedSel) {
    linkedSel.value = nextLinkedIdx; // Store linked index, not event idx
  }
  
  // Update UI
  renderQuickAdd();
  renderMarkers();
  updateLinkedEventsDropdown();
  
  toast(`Created linked ${template.suggested.type} event from template`, 'success');
}

/**
 * v23.9: Accept event suggestion and create suggested event
 */
function acceptEventSuggestion() {
  const suggestion = S.pendingEventSuggestion;
  if (!suggestion) return;
  
  const { template, sourceEvt } = suggestion;
  
  // Use the shared applyEventTemplate function
  applyEventTemplate(sourceEvt, template);
  
  // Close modal
  rejectEventSuggestion();
}

/**
 * v23.9: Reject event suggestion
 */
function rejectEventSuggestion() {
  const modal = document.getElementById('eventSuggestionModal');
  if (modal) modal.classList.remove('show');
  S.pendingEventSuggestion = null;
}

/**
 * v23.9: Load default event chain templates
 */
/**
 * v23.9: Load default event chain templates if none exist
 */
function loadDefaultEventTemplates() {
  // Try to load from localStorage first
  const stored = localStorage.getItem('bs_event_chain_templates');
  if (stored) {
    try {
      S.eventChainTemplates = JSON.parse(stored);
      return;
    } catch (e) {
      console.warn('Failed to load templates from localStorage:', e);
    }
  }
  
  // Load defaults
  S.eventChainTemplates = [
    {
      id: 'shot-onnet-save',
      name: 'Shot On Net ‚Üí Save',
      trigger: { type: 'Shot', detail1: 'OnNetSaved' },
      suggested: { type: 'Save', detail1: 'Save_Played' },
      playerMapping: { 
        'event_team_player_1': 'opp_team_player_1' // Shooter becomes goalie
      },
      copyXY: true,
      copyZone: true
    },
    {
      id: 'pass-breakout-zoneexit',
      name: 'Pass Breakout ‚Üí Zone Exit',
      trigger: { type: 'Pass', playDetail1: 'breakout' },
      suggested: { type: 'Zone_Entry_Exit', detail1: 'Zone_Exit', detail2: 'ZoneExit-Rush' },
      copyXY: true,
      copyZone: true
    },
    {
      id: 'pass-intercepted-turnover',
      name: 'Pass Intercepted ‚Üí Turnover Giveaway',
      trigger: { type: 'Pass', detail1: 'Intercepted' },
      suggested: { type: 'Turnover', detail1: 'Turnover_Giveaway', detail2: 'Giveaway-PassIntercepted' },
      copyXY: true,
      copyZone: true
    }
  ];
  
  // Save to localStorage
  localStorage.setItem('bs_event_chain_templates', JSON.stringify(S.eventChainTemplates));
}

/**
 * v23.9: Load event chain templates on initialization
 */
function loadEventChainTemplates() {
  loadDefaultEventTemplates();
}

/**
 * v23.9: Save event chain templates to localStorage
 */
function saveEventChainTemplates() {
  localStorage.setItem('bs_event_chain_templates', JSON.stringify(S.eventChainTemplates));
}

/**
 * v23.9: Open event chain templates management modal
 */
function openEventTemplatesManager() {
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'openEventTemplatesManager:18403',message:'Function entry',data:{},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
  // #endregion
  
  const modal = document.getElementById('eventTemplatesManagerModal');
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'openEventTemplatesManager:18408',message:'After getElementById',data:{modalExists:!!modal,modalId:modal?.id,modalInnerHTML:modal?.innerHTML?.substring(0,100)},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
  // #endregion
  
  // Check if modal exists AND has content (templatesList element)
  const templatesList = modal ? modal.querySelector('#templatesList') : null;
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'openEventTemplatesManager:18412',message:'After checking templatesList',data:{modalExists:!!modal,templatesListExists:!!templatesList},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
  // #endregion
  
  if (!modal || !templatesList) {
    // Modal doesn't exist or is empty - create/populate it
    if (!modal) {
      // Create modal
      const newModal = document.createElement('div');
      newModal.id = 'eventTemplatesManagerModal';
      newModal.className = 'overlay';
      newModal.onclick = function(e) {
        if (e.target === newModal) {
          closeEventTemplatesManager();
        }
      };
      newModal.innerHTML = `
        <div class="modal" style="min-width:600px;max-width:800px;max-height:80vh;overflow-y:auto;">
          <h3>üîó Event Chain Templates</h3>
          <p style="font-size:10px;color:var(--muted);margin:8px 0;">Define templates that auto-suggest next events based on triggers.</p>
          <div id="templatesList" style="margin:16px 0;"></div>
          <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:16px;">
            <button class="btn-sm" onclick="closeEventTemplatesManager()">Close</button>
            <button class="btn-sm" onclick="addNewEventTemplate()" style="background:var(--success);">+ Add Template</button>
          </div>
        </div>
      `;
      document.body.appendChild(newModal);
      
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'openEventTemplatesManager:18435',message:'Created new modal',data:{},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
      // #endregion
    } else {
      // Modal exists but is empty - populate it
      modal.onclick = function(e) {
        if (e.target === modal) {
          closeEventTemplatesManager();
        }
      };
      modal.innerHTML = `
        <div class="modal" style="min-width:600px;max-width:800px;max-height:80vh;overflow-y:auto;">
          <h3>üîó Event Chain Templates</h3>
          <p style="font-size:10px;color:var(--muted);margin:8px 0;">Define templates that auto-suggest next events based on triggers.</p>
          <div id="templatesList" style="margin:16px 0;"></div>
          <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:16px;">
            <button class="btn-sm" onclick="closeEventTemplatesManager()">Close</button>
            <button class="btn-sm" onclick="addNewEventTemplate()" style="background:var(--success);">+ Add Template</button>
          </div>
        </div>
      `;
      
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'openEventTemplatesManager:18450',message:'Populated existing empty modal',data:{},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
      // #endregion
    }
  }
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'openEventTemplatesManager:18455',message:'Before renderEventTemplatesList',data:{templatesListExists:!!document.getElementById('templatesList')},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
  // #endregion
  
  renderEventTemplatesList();
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'openEventTemplatesManager:18460',message:'Before showing modal',data:{modalExists:!!document.getElementById('eventTemplatesManagerModal'),modalHasShowClass:document.getElementById('eventTemplatesManagerModal')?.classList.contains('show')},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
  // #endregion
  
  const finalModal = document.getElementById('eventTemplatesManagerModal');
  if (finalModal) {
    // Ensure click-outside-to-close handler is set
    if (!finalModal.onclick) {
      finalModal.onclick = function(e) {
        if (e.target === finalModal) {
          closeEventTemplatesManager();
        }
      };
    }
    finalModal.classList.add('show');
    finalModal.style.display = 'flex'; // Match CSS .overlay.show { display: flex; }
    
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'openEventTemplatesManager:18468',message:'After showing modal',data:{modalDisplay:finalModal.style.display,modalHasShowClass:finalModal.classList.contains('show')},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
    // #endregion
  } else {
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'openEventTemplatesManager:18472',message:'ERROR: Modal not found after creation',data:{},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
    // #endregion
  }
}

/**
 * v23.9: Close event templates manager
 */
function closeEventTemplatesManager() {
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'closeEventTemplatesManager:18492',message:'Function entry',data:{},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'F'})}).catch(()=>{});
  // #endregion
  
  const modal = document.getElementById('eventTemplatesManagerModal');
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'closeEventTemplatesManager:18497',message:'Before closing',data:{modalExists:!!modal,hasShowClass:modal?.classList.contains('show'),display:modal?.style.display},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'F'})}).catch(()=>{});
  // #endregion
  
  if (modal) {
    modal.classList.remove('show');
    modal.style.display = 'none';
    
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'closeEventTemplatesManager:18505',message:'After closing',data:{hasShowClass:modal.classList.contains('show'),display:modal.style.display},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'F'})}).catch(()=>{});
    // #endregion
  } else {
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'closeEventTemplatesManager:18510',message:'ERROR: Modal not found',data:{},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'F'})}).catch(()=>{});
    // #endregion
  }
}

/**
 * v23.9: Render list of event chain templates
 */
function renderEventTemplatesList() {
  const container = document.getElementById('templatesList');
  if (!container) return;
  
  if (!S.eventChainTemplates || S.eventChainTemplates.length === 0) {
    container.innerHTML = '<p style="color:var(--muted);font-size:10px;text-align:center;padding:20px;">No templates yet. Click "Add Template" to create one.</p>';
    return;
  }
  
  container.innerHTML = S.eventChainTemplates.map((template, idx) => {
    const trigger = template.trigger;
    const suggested = template.suggested;
    const triggerDesc = [
      trigger.type ? `Type: ${trigger.type}` : '',
      trigger.detail1 ? `Detail1: ${trigger.detail1}` : '',
      trigger.detail2 ? `Detail2: ${trigger.detail2}` : '',
      trigger.playDetail1 ? `PlayDetail1: ${trigger.playDetail1}` : '',
      trigger.playDetail2 ? `PlayDetail2: ${trigger.playDetail2}` : ''
    ].filter(Boolean).join(', ');
    
    const suggestedDesc = [
      suggested.type || '',
      suggested.detail1 || '',
      suggested.detail2 || ''
    ].filter(Boolean).join(' - ');
    
    return `
      <div style="border:1px solid var(--border);border-radius:4px;padding:12px;margin-bottom:8px;background:var(--card);">
        <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:8px;">
          <div style="flex:1;">
            <strong style="font-size:11px;">${template.name || 'Untitled Template'}</strong>
            <div style="font-size:9px;color:var(--muted);margin-top:4px;">
              <div><strong>When:</strong> ${triggerDesc || 'Any event'}</div>
              <div><strong>Suggest:</strong> ${suggestedDesc || 'None'}</div>
              ${template.playerMapping && Object.keys(template.playerMapping).length > 0 ? 
                `<div><strong>Linked event player mapping:</strong> ${Object.entries(template.playerMapping).map(([f,t]) => `${f}‚Üí${t}`).join(', ')}</div>` : ''}
              ${template.nextEventPlayerMapping && Object.keys(template.nextEventPlayerMapping).length > 0 ? 
                `<div><strong>Next event player mapping:</strong> ${Object.entries(template.nextEventPlayerMapping).map(([f,t]) => `${f}‚Üí${t}`).join(', ')}</div>` : ''}
              ${template.nextEventTeam ? `<div><strong>Next event team:</strong> ${template.nextEventTeam}</div>` : ''}
              ${template.copyXY ? '<span style="color:var(--accent);font-size:8px;">‚úì Copy XY</span>' : ''}
              ${template.copyZone ? '<span style="color:var(--accent);font-size:8px;">‚úì Copy Zone</span>' : ''}
            </div>
          </div>
          <div style="display:flex;gap:4px;">
            <button class="btn-sm" onclick="editEventTemplate(${idx});event.stopPropagation();" style="font-size:8px;padding:2px 6px;" title="Edit template">‚úèÔ∏è</button>
            <button class="btn-sm btn-danger" onclick="deleteEventTemplate(${idx});event.stopPropagation();" style="font-size:8px;padding:2px 6px;" title="Delete template">‚úï</button>
          </div>
        </div>
      </div>
    `;
  }).join('');
}

/**
 * v23.9: Add new event template
 */
function addNewEventTemplate() {
  const template = {
    id: 'template_' + Date.now(),
    name: 'New Template',
    trigger: { type: '', detail1: '', detail2: '', playDetail1: '', playDetail2: '' },
    suggested: { type: '', detail1: '', detail2: '' },
    playerMapping: {}, // For linked events
    copyXY: true,
    copyZone: true,
    nextEventPlayerMapping: {}, // For next sequential event (e.g., event_player_2 ‚Üí event_player_1)
    nextEventTeam: '' // 'same', 'opposite', 'home', or 'away'
  };
  
  S.eventChainTemplates.push(template);
  saveEventChainTemplates();
  renderEventTemplatesList();
  editEventTemplate(S.eventChainTemplates.length - 1);
}

/**
 * v23.9: Edit event template - proper modal form
 */
function editEventTemplate(idx) {
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'editEventTemplate:18578',message:'Function entry',data:{idx,templateExists:!!S.eventChainTemplates[idx],templatesCount:S.eventChainTemplates?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
  // #endregion
  
  const template = S.eventChainTemplates[idx];
  if (!template) {
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'editEventTemplate:18582',message:'Template not found',data:{idx,templatesCount:S.eventChainTemplates?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
    // #endregion
    toast('Template not found', 'error');
    return;
  }
  
  // Store editing index
  window.editingTemplateIdx = idx;
  
  // Build event type options
  const eventTypeOptions = S.eventTypesDB.length > 0
    ? S.eventTypesDB.map(e => `<option value="${e.code || e.name}">${e.code || e.name}</option>`).join('')
    : (LISTS.eventTypes || []).map(t => `<option value="${t}">${t}</option>`).join('');
  
  const html = `
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
      <h3 style="margin:0;">‚úèÔ∏è Edit Event Chain Template</h3>
      <button onclick="closeEditTemplateModal();return false;" style="background:none;border:none;font-size:18px;cursor:pointer;color:var(--muted);padding:0;width:24px;height:24px;line-height:1;" title="Close">√ó</button>
    </div>
    <div style="max-height:70vh;overflow-y:auto;">
      <div class="form-group">
        <label>Template Name</label>
        <input type="text" id="editTemplateName" value="${(template.name || '').replace(/"/g, '&quot;')}" style="width:100%;">
      </div>
      
      <div style="margin:16px 0;padding:12px;background:var(--panel);border-radius:4px;">
        <strong style="font-size:11px;">Trigger (When this event occurs):</strong>
        <div class="form-group" style="margin-top:8px;">
          <label>Event Type</label>
          <select id="editTemplateTriggerType" style="width:100%;">
            <option value="">-- Any Event Type --</option>
            ${eventTypeOptions}
          </select>
        </div>
        <div class="form-group">
          <label>Detail1 (or part of, e.g., "OnNetSaved")</label>
          <input type="text" id="editTemplateTriggerD1" value="${(template.trigger.detail1 || '').replace(/"/g, '&quot;')}" style="width:100%;" placeholder="Leave empty for any">
        </div>
        <div class="form-group">
          <label>Detail2</label>
          <input type="text" id="editTemplateTriggerD2" value="${(template.trigger.detail2 || '').replace(/"/g, '&quot;')}" style="width:100%;" placeholder="Leave empty for any">
        </div>
        <div class="form-group">
          <label>PlayDetail1 on event_player_1 (e.g., "breakout")</label>
          <input type="text" id="editTemplateTriggerPD1" value="${(template.trigger.playDetail1 || '').replace(/"/g, '&quot;')}" style="width:100%;" placeholder="Leave empty for any">
        </div>
        <div class="form-group">
          <label>PlayDetail2 on event_player_1</label>
          <input type="text" id="editTemplateTriggerPD2" value="${(template.trigger.playDetail2 || '').replace(/"/g, '&quot;')}" style="width:100%;" placeholder="Leave empty for any">
        </div>
      </div>
      
      <div style="margin:16px 0;padding:12px;background:var(--panel);border-radius:4px;">
        <strong style="font-size:11px;">Suggested Event (What to suggest/create):</strong>
        <div class="form-group" style="margin-top:8px;">
          <label>Event Type</label>
          <select id="editTemplateSuggestedType" style="width:100%;">
            <option value="">-- None --</option>
            ${eventTypeOptions}
          </select>
        </div>
        <div class="form-group">
          <label>Detail1</label>
          <input type="text" id="editTemplateSuggestedD1" value="${(template.suggested.detail1 || '').replace(/"/g, '&quot;')}" style="width:100%;">
        </div>
        <div class="form-group">
          <label>Detail2</label>
          <input type="text" id="editTemplateSuggestedD2" value="${(template.suggested.detail2 || '').replace(/"/g, '&quot;')}" style="width:100%;">
        </div>
      </div>
      
      <div style="margin:16px 0;padding:12px;background:var(--panel);border-radius:4px;">
        <strong style="font-size:11px;">Linked Event Player Mapping:</strong>
        <p style="font-size:9px;color:var(--muted);margin:4px 0;">Map players when creating linked events (e.g., Shot‚ÜíSave: event_team_player_1:opp_team_player_1)</p>
        <div class="form-group">
          <label>Mapping (format: "from:to,from2:to2")</label>
          <input type="text" id="editTemplatePlayerMapping" value="${template.playerMapping ? Object.entries(template.playerMapping).map(([f,t]) => `${f}:${t}`).join(',') : ''}" style="width:100%;" placeholder="event_team_player_1:opp_team_player_1">
        </div>
      </div>
      
      <div style="margin:16px 0;padding:12px;background:var(--panel);border-radius:4px;">
        <strong style="font-size:11px;">Next Event Player/Team Mapping:</strong>
        <p style="font-size:9px;color:var(--muted);margin:4px 0;">Map players for the next sequential event (e.g., Pass Completed: event_player_2:event_player_1)</p>
        <div class="form-group">
          <label>Next Event Player Mapping (format: "from:to,from2:to2")</label>
          <input type="text" id="editTemplateNextEventPlayerMapping" value="${template.nextEventPlayerMapping ? Object.entries(template.nextEventPlayerMapping).map(([f,t]) => `${f}:${t}`).join(',') : ''}" style="width:100%;" placeholder="event_player_2:event_player_1">
        </div>
        <div class="form-group">
          <label>Next Event Team</label>
          <select id="editTemplateNextEventTeam" style="width:100%;">
            <option value="">-- No change --</option>
            <option value="same" ${template.nextEventTeam === 'same' ? 'selected' : ''}>Same Team</option>
            <option value="opposite" ${template.nextEventTeam === 'opposite' ? 'selected' : ''}>Opposite Team</option>
            <option value="home" ${template.nextEventTeam === 'home' ? 'selected' : ''}>Home</option>
            <option value="away" ${template.nextEventTeam === 'away' ? 'selected' : ''}>Away</option>
          </select>
        </div>
      </div>
      
      <div class="form-row" style="margin:16px 0;">
        <div class="form-group">
          <label style="display:flex;align-items:center;gap:4px;">
            <input type="checkbox" id="editTemplateCopyXY" ${template.copyXY ? 'checked' : ''}> Copy XY Data
          </label>
        </div>
        <div class="form-group">
          <label style="display:flex;align-items:center;gap:4px;">
            <input type="checkbox" id="editTemplateCopyZone" ${template.copyZone ? 'checked' : ''}> Copy Zone
          </label>
        </div>
      </div>
    </div>
    <div class="modal-actions" style="margin-top:16px;">
      <button class="btn-primary" onclick="saveEventTemplateEdit()">Save</button>
      <button onclick="closeEditTemplateModal();return false;">Cancel</button>
    </div>
  `;
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'editEventTemplate:18650',message:'Before showModal',data:{htmlLength:html.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
  // #endregion
  
  showModal(html);
  
  // Set initial values
  setTimeout(() => {
    const triggerTypeEl = document.getElementById('editTemplateTriggerType');
    const suggestedTypeEl = document.getElementById('editTemplateSuggestedType');
    if (triggerTypeEl && template.trigger.type) triggerTypeEl.value = template.trigger.type;
    if (suggestedTypeEl && template.suggested.type) suggestedTypeEl.value = template.suggested.type;
    
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'editEventTemplate:18660',message:'After setting initial values',data:{triggerTypeSet:triggerTypeEl?.value,suggestedTypeSet:suggestedTypeEl?.value},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
    // #endregion
  }, 50);
}

/**
 * v23.9: Save edited template from modal
 */
function saveEventTemplateEdit() {
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'saveEventTemplateEdit:18665',message:'Function entry',data:{editingTemplateIdx:window.editingTemplateIdx},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
  // #endregion
  
  const idx = window.editingTemplateIdx;
  if (idx === null || idx === undefined || !S.eventChainTemplates[idx]) {
    toast('Template not found', 'error');
    closeEditTemplateModal();
    return;
  }
  
  const template = S.eventChainTemplates[idx];
  
  // Get values from form
  template.name = document.getElementById('editTemplateName').value.trim() || 'Untitled Template';
  template.trigger.type = document.getElementById('editTemplateTriggerType').value || '';
  template.trigger.detail1 = document.getElementById('editTemplateTriggerD1').value.trim() || '';
  template.trigger.detail2 = document.getElementById('editTemplateTriggerD2').value.trim() || '';
  template.trigger.playDetail1 = document.getElementById('editTemplateTriggerPD1').value.trim() || '';
  template.trigger.playDetail2 = document.getElementById('editTemplateTriggerPD2').value.trim() || '';
  template.suggested.type = document.getElementById('editTemplateSuggestedType').value || '';
  template.suggested.detail1 = document.getElementById('editTemplateSuggestedD1').value.trim() || '';
  template.suggested.detail2 = document.getElementById('editTemplateSuggestedD2').value.trim() || '';
  template.copyXY = document.getElementById('editTemplateCopyXY').checked;
  template.copyZone = document.getElementById('editTemplateCopyZone').checked;
  template.nextEventTeam = document.getElementById('editTemplateNextEventTeam').value || '';
  
  // Parse player mappings
  const playerMappingStr = document.getElementById('editTemplatePlayerMapping').value.trim();
  template.playerMapping = {};
  if (playerMappingStr) {
    playerMappingStr.split(',').forEach(pair => {
      const [from, to] = pair.split(':').map(s => s.trim());
      if (from && to) template.playerMapping[from] = to;
    });
  }
  
  const nextEventPlayerMappingStr = document.getElementById('editTemplateNextEventPlayerMapping').value.trim();
  template.nextEventPlayerMapping = {};
  if (nextEventPlayerMappingStr) {
    nextEventPlayerMappingStr.split(',').forEach(pair => {
      const [from, to] = pair.split(':').map(s => s.trim());
      if (from && to) template.nextEventPlayerMapping[from] = to;
    });
  }
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'saveEventTemplateEdit:18705',message:'Before save',data:{templateName:template.name,triggerType:template.trigger.type,suggestedType:template.suggested.type},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
  // #endregion
  
  saveEventChainTemplates();
  renderEventTemplatesList();
  closeEditTemplateModal();
  toast('Template updated', 'success');
}

/**
 * v23.9: Close edit template modal
 */
function closeEditTemplateModal() {
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'closeEditTemplateModal:18783',message:'Function entry',data:{editingTemplateIdx:window.editingTemplateIdx},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
  // #endregion
  
  window.editingTemplateIdx = null;
  
  const overlay = document.getElementById('genericModal');
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'closeEditTemplateModal:18790',message:'Before closeModal',data:{overlayExists:!!overlay,hasShowClass:overlay?.classList.contains('show')},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
  // #endregion
  
  if (overlay) {
    overlay.classList.remove('show');
    overlay.style.display = 'none';
  }
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'closeEditTemplateModal:18798',message:'After closeModal',data:{hasShowClass:overlay?.classList.contains('show'),display:overlay?.style.display},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
  // #endregion
}

/**
 * v23.9: Delete event template
 */
function deleteEventTemplate(idx) {
  if (!confirm('Delete this template?')) return;
  S.eventChainTemplates.splice(idx, 1);
  saveEventChainTemplates();
  renderEventTemplatesList();
  toast('Template deleted', 'info');
}

// ============================================================
// v23.9: CUSTOM RULES SYSTEM
// ============================================================

/**
 * v23.9: Open custom rules manager
 */
function openCustomRulesManager() {
  const modal = document.getElementById('customRulesManagerModal');
  if (!modal) return;
  
  const rulesList = modal.querySelector('#customRulesList');
  if (!modal || !rulesList) {
    // Populate modal
    modal.innerHTML = `
      <div class="modal" style="min-width:700px;max-width:900px;max-height:80vh;overflow-y:auto;">
        <h3>‚öôÔ∏è Custom Rules</h3>
        <p style="font-size:10px;color:var(--muted);margin:8px 0;">Define custom logic for auto-zone, auto-success, and field mappings. Example: All zone_entry_carried ‚Üí O zone</p>
        <div id="customRulesList" style="margin:16px 0;"></div>
        <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:16px;">
          <button class="btn-sm" onclick="closeCustomRulesManager()">Close</button>
          <button class="btn-sm" onclick="addNewCustomRule()" style="background:var(--success);">+ Add Rule</button>
        </div>
      </div>
    `;
    modal.onclick = function(e) {
      if (e.target === modal) closeCustomRulesManager();
    };
  }
  
  renderCustomRulesList();
  
  const finalModal = document.getElementById('customRulesManagerModal');
  if (finalModal) {
    finalModal.classList.add('show');
    finalModal.style.display = 'flex';
  }
}

/**
 * v23.9: Close custom rules manager
 */
function closeCustomRulesManager() {
  const modal = document.getElementById('customRulesManagerModal');
  if (modal) {
    modal.classList.remove('show');
    modal.style.display = 'none';
  }
}

/**
 * v23.9: Render list of custom rules
 */
function renderCustomRulesList() {
  const container = document.getElementById('customRulesList');
  if (!container) return;
  
  if (!S.customRules || S.customRules.length === 0) {
    container.innerHTML = '<p style="color:var(--muted);font-size:10px;text-align:center;padding:20px;">No rules yet. Click "Add Rule" to create one.</p>';
    return;
  }
  
  container.innerHTML = S.customRules.map((rule, idx) => {
    const triggerDesc = [
      rule.trigger.type ? `Type: ${rule.trigger.type}` : '',
      rule.trigger.detail1 ? `Detail1: ${rule.trigger.detail1}` : '',
      rule.trigger.detail2 ? `Detail2: ${rule.trigger.detail2}` : ''
    ].filter(Boolean).join(', ');
    
    const actionsDesc = (rule.actions || []).map(a => {
      if (a.field === 'zone') return `Zone ‚Üí ${a.value}`;
      if (a.field === 'success') return `Success ‚Üí ${a.value}`;
      return `${a.field} ‚Üí ${a.value}`;
    }).join(', ');
    
    const crossEventDesc = (rule.crossEventRules || []).map(r => {
      return `If next is ${r.ifNextType}${r.ifNextDetail1 ? ' + ' + r.ifNextDetail1 : ''}, set prev success ‚Üí ${r.setPrevSuccess}`;
    }).join('; ');
    
    return `
      <div style="border:1px solid var(--border);border-radius:4px;padding:12px;margin-bottom:8px;background:var(--card);">
        <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:8px;">
          <div style="flex:1;">
            <strong style="font-size:11px;">${rule.name || 'Untitled Rule'} ${rule.enabled ? '‚úì' : '‚úó'}</strong>
            <div style="font-size:9px;color:var(--muted);margin-top:4px;">
              <div><strong>When:</strong> ${triggerDesc || 'Any event'}</div>
              <div><strong>Actions:</strong> ${actionsDesc || 'None'}</div>
              ${crossEventDesc ? `<div><strong>Cross-Event:</strong> ${crossEventDesc}</div>` : ''}
            </div>
          </div>
          <div style="display:flex;gap:4px;">
            <button class="btn-sm" onclick="toggleCustomRule(${idx});event.stopPropagation();" style="font-size:8px;padding:2px 6px;" title="Toggle enabled">${rule.enabled ? '‚úì' : '‚úó'}</button>
            <button class="btn-sm" onclick="editCustomRule(${idx});event.stopPropagation();" style="font-size:8px;padding:2px 6px;" title="Edit rule">‚úèÔ∏è</button>
            <button class="btn-sm btn-danger" onclick="deleteCustomRule(${idx});event.stopPropagation();" style="font-size:8px;padding:2px 6px;" title="Delete rule">‚úï</button>
          </div>
        </div>
      </div>
    `;
  }).join('');
}

/**
 * v23.9: Add new custom rule
 */
function addNewCustomRule() {
  const rule = {
    id: 'rule_' + Date.now(),
    name: 'New Rule',
    enabled: true,
    trigger: { type: '', detail1: '', detail2: '' },
    actions: [],
    crossEventRules: []
  };
  
  S.customRules = S.customRules || [];
  S.customRules.push(rule);
  saveCustomRules();
  renderCustomRulesList();
  editCustomRule(S.customRules.length - 1);
}

/**
 * v23.9: Edit custom rule
 */
function editCustomRule(idx) {
  const rule = S.customRules[idx];
  if (!rule) return;
  
  window.editingRuleIdx = idx;
  
  const eventTypeOptions = S.eventTypesDB.length > 0
    ? S.eventTypesDB.map(e => `<option value="${e.code || e.name}">${e.code || e.name}</option>`).join('')
    : (LISTS.eventTypes || []).map(t => `<option value="${t}">${t}</option>`).join('');
  
  const actionsHtml = (rule.actions || []).map((a, i) => `
    <div style="display:flex;gap:4px;margin:4px 0;">
      <select id="ruleActionField_${i}" style="flex:1;">
        <option value="zone" ${a.field === 'zone' ? 'selected' : ''}>Zone</option>
        <option value="success" ${a.field === 'success' ? 'selected' : ''}>Success</option>
        <option value="detail1" ${a.field === 'detail1' ? 'selected' : ''}>Detail1</option>
        <option value="detail2" ${a.field === 'detail2' ? 'selected' : ''}>Detail2</option>
      </select>
      <input type="text" id="ruleActionValue_${i}" value="${a.value || ''}" placeholder="Value" style="flex:1;">
      <button class="btn-sm btn-danger" onclick="removeRuleAction(${i})">‚úï</button>
    </div>
  `).join('');
  
  const crossEventHtml = (rule.crossEventRules || []).map((r, i) => `
    <div style="display:flex;gap:4px;margin:4px 0;padding:8px;background:var(--panel);border-radius:4px;">
      <div style="flex:1;">
        <div style="font-size:9px;margin-bottom:4px;">If NEXT event is:</div>
        <select id="crossEventType_${i}" style="width:100%;font-size:9px;">
          <option value="">-- Any Type --</option>
          ${eventTypeOptions}
        </select>
        <input type="text" id="crossEventDetail1_${i}" value="${r.ifNextDetail1 || ''}" placeholder="Detail1 (optional)" style="width:100%;margin-top:4px;font-size:9px;">
      </div>
      <div style="flex:1;">
        <div style="font-size:9px;margin-bottom:4px;">Set PREVIOUS event success:</div>
        <select id="crossEventSuccess_${i}" style="width:100%;font-size:9px;">
          <option value="u" ${r.setPrevSuccess === 'u' ? 'selected' : ''}>Unsuccessful (u)</option>
          <option value="s" ${r.setPrevSuccess === 's' ? 'selected' : ''}>Success (s)</option>
        </select>
      </div>
      <button class="btn-sm btn-danger" onclick="removeCrossEventRule(${i})" style="align-self:end;">‚úï</button>
    </div>
  `).join('');
  
  const html = `
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
      <h3 style="margin:0;">‚úèÔ∏è Edit Custom Rule</h3>
      <button onclick="closeEditRuleModal();return false;" style="background:none;border:none;font-size:18px;cursor:pointer;color:var(--muted);padding:0;width:24px;height:24px;line-height:1;" title="Close">√ó</button>
    </div>
    <div style="max-height:70vh;overflow-y:auto;">
      <div class="form-group">
        <label>Rule Name</label>
        <input type="text" id="editRuleName" value="${(rule.name || '').replace(/"/g, '&quot;')}" style="width:100%;">
      </div>
      
      <div style="margin:16px 0;padding:12px;background:var(--panel);border-radius:4px;">
        <strong style="font-size:11px;">Trigger (When this event occurs):</strong>
        <div class="form-group" style="margin-top:8px;">
          <label>Event Type</label>
          <select id="editRuleTriggerType" style="width:100%;">
            <option value="">-- Any Event Type --</option>
            ${eventTypeOptions}
          </select>
        </div>
        <div class="form-group">
          <label>Detail1 (or part of)</label>
          <input type="text" id="editRuleTriggerD1" value="${(rule.trigger.detail1 || '').replace(/"/g, '&quot;')}" style="width:100%;" placeholder="e.g., Carried">
        </div>
        <div class="form-group">
          <label>Detail2</label>
          <input type="text" id="editRuleTriggerD2" value="${(rule.trigger.detail2 || '').replace(/"/g, '&quot;')}" style="width:100%;">
        </div>
      </div>
      
      <div style="margin:16px 0;padding:12px;background:var(--panel);border-radius:4px;">
        <strong style="font-size:11px;">Actions (What to set):</strong>
        <div id="ruleActionsContainer">
          ${actionsHtml}
        </div>
        <button class="btn-sm" onclick="addRuleAction()" style="margin-top:8px;">+ Add Action</button>
      </div>
      
      <div style="margin:16px 0;padding:12px;background:var(--panel);border-radius:4px;">
        <strong style="font-size:11px;">Cross-Event Rules (e.g., if next is giveaway, previous is unsuccessful):</strong>
        <div id="crossEventRulesContainer">
          ${crossEventHtml}
        </div>
        <button class="btn-sm" onclick="addCrossEventRule()" style="margin-top:8px;">+ Add Cross-Event Rule</button>
      </div>
      
      <div class="form-group" style="margin:16px 0;">
        <label style="display:flex;align-items:center;gap:4px;">
          <input type="checkbox" id="editRuleEnabled" ${rule.enabled ? 'checked' : ''}> Enabled
        </label>
      </div>
    </div>
    <div class="modal-actions" style="margin-top:16px;">
      <button class="btn-primary" onclick="saveCustomRuleEdit()">Save</button>
      <button onclick="closeEditRuleModal()">Cancel</button>
    </div>
  `;
  
  showModal(html);
  
  setTimeout(() => {
    const triggerTypeEl = document.getElementById('editRuleTriggerType');
    if (triggerTypeEl && rule.trigger.type) triggerTypeEl.value = rule.trigger.type;
  }, 50);
}

/**
 * v23.9: Save edited custom rule
 */
function saveCustomRuleEdit() {
  const idx = window.editingRuleIdx;
  if (idx === null || idx === undefined || !S.customRules[idx]) {
    toast('Rule not found', 'error');
    closeEditRuleModal();
    return;
  }
  
  const rule = S.customRules[idx];
  
  rule.name = document.getElementById('editRuleName').value.trim() || 'Untitled Rule';
  rule.trigger.type = document.getElementById('editRuleTriggerType').value || '';
  rule.trigger.detail1 = document.getElementById('editRuleTriggerD1').value.trim() || '';
  rule.trigger.detail2 = document.getElementById('editRuleTriggerD2').value.trim() || '';
  rule.enabled = document.getElementById('editRuleEnabled').checked;
  
  // Collect actions
  rule.actions = [];
  let i = 0;
  while (document.getElementById(`ruleActionField_${i}`)) {
    const field = document.getElementById(`ruleActionField_${i}`).value;
    const value = document.getElementById(`ruleActionValue_${i}`).value.trim();
    if (field && value) {
      rule.actions.push({ field, value });
    }
    i++;
  }
  
  // Collect cross-event rules
  rule.crossEventRules = [];
  i = 0;
  while (document.getElementById(`crossEventType_${i}`)) {
    const type = document.getElementById(`crossEventType_${i}`).value;
    const detail1 = document.getElementById(`crossEventDetail1_${i}`).value.trim();
    const success = document.getElementById(`crossEventSuccess_${i}`).value;
    if (type && success) {
      rule.crossEventRules.push({
        ifNextType: type,
        ifNextDetail1: detail1,
        setPrevSuccess: success
      });
    }
    i++;
  }
  
  saveCustomRules();
  renderCustomRulesList();
  closeEditRuleModal();
  toast('Rule updated', 'success');
}

/**
 * v23.9: Close edit rule modal
 */
function closeEditRuleModal() {
  window.editingRuleIdx = null;
  closeModal();
}

/**
 * v23.9: Toggle custom rule enabled
 */
function toggleCustomRule(idx) {
  if (S.customRules[idx]) {
    S.customRules[idx].enabled = !S.customRules[idx].enabled;
    saveCustomRules();
    renderCustomRulesList();
  }
}

/**
 * v23.9: Delete custom rule
 */
function deleteCustomRule(idx) {
  if (!confirm('Delete this rule?')) return;
  S.customRules.splice(idx, 1);
  saveCustomRules();
  renderCustomRulesList();
  toast('Rule deleted', 'info');
}

/**
 * v23.9: Add rule action
 */
function addRuleAction() {
  const container = document.getElementById('ruleActionsContainer');
  if (!container) return;
  
  const count = container.children.length;
  const div = document.createElement('div');
  div.style.cssText = 'display:flex;gap:4px;margin:4px 0;';
  div.innerHTML = `
    <select id="ruleActionField_${count}" style="flex:1;">
      <option value="zone">Zone</option>
      <option value="success">Success</option>
      <option value="detail1">Detail1</option>
      <option value="detail2">Detail2</option>
    </select>
    <input type="text" id="ruleActionValue_${count}" placeholder="Value" style="flex:1;">
    <button class="btn-sm btn-danger" onclick="this.parentElement.remove()">‚úï</button>
  `;
  container.appendChild(div);
}

/**
 * v23.9: Add cross-event rule
 */
function addCrossEventRule() {
  const container = document.getElementById('crossEventRulesContainer');
  if (!container) return;
  
  const count = container.children.length;
  const eventTypeOptions = S.eventTypesDB.length > 0
    ? S.eventTypesDB.map(e => `<option value="${e.code || e.name}">${e.code || e.name}</option>`).join('')
    : (LISTS.eventTypes || []).map(t => `<option value="${t}">${t}</option>`).join('');
  
  const div = document.createElement('div');
  div.style.cssText = 'display:flex;gap:4px;margin:4px 0;padding:8px;background:var(--panel);border-radius:4px;';
  div.innerHTML = `
    <div style="flex:1;">
      <div style="font-size:9px;margin-bottom:4px;">If NEXT event is:</div>
      <select id="crossEventType_${count}" style="width:100%;font-size:9px;">
        <option value="">-- Any Type --</option>
        ${eventTypeOptions}
      </select>
      <input type="text" id="crossEventDetail1_${count}" placeholder="Detail1 (optional)" style="width:100%;margin-top:4px;font-size:9px;">
    </div>
    <div style="flex:1;">
      <div style="font-size:9px;margin-bottom:4px;">Set PREVIOUS event success:</div>
      <select id="crossEventSuccess_${count}" style="width:100%;font-size:9px;">
        <option value="u">Unsuccessful (u)</option>
        <option value="s">Success (s)</option>
      </select>
    </div>
    <button class="btn-sm btn-danger" onclick="this.parentElement.remove()" style="align-self:end;">‚úï</button>
  `;
  container.appendChild(div);
}

/**
 * v23.9: Save custom rules to localStorage
 */
function saveCustomRules() {
  localStorage.setItem('bs_custom_rules', JSON.stringify(S.customRules || []));
}

/**
 * v23.9: Load custom rules from localStorage
 */
function loadCustomRules() {
  const stored = localStorage.getItem('bs_custom_rules');
  if (stored) {
    try {
      S.customRules = JSON.parse(stored);
    } catch (e) {
      console.error('Failed to load custom rules:', e);
      S.customRules = [];
    }
  } else {
    S.customRules = [];
  }
}

/**
 * v23.8: Load custom linking rules from localStorage
 */
function loadCustomLinkingRules() {
  const stored = localStorage.getItem('bs_custom_linking_rules');
  if (stored) {
    try {
      S.customLinkingRules = JSON.parse(stored);
    } catch (e) {
      console.error('Failed to load custom linking rules:', e);
      S.customLinkingRules = [];
    }
  } else {
    S.customLinkingRules = [];
  }
}

/**
 * v23.8: Save custom linking rules to localStorage
 */
function saveCustomLinkingRules() {
  try {
    localStorage.setItem('bs_custom_linking_rules', JSON.stringify(S.customLinkingRules || []));
  } catch (e) {
    console.error('Failed to save custom linking rules:', e);
    toast('Failed to save custom linking rules', 'error');
  }
}

/**
 * v23.8: Open custom linking rules manager
 */
function openCustomLinkingRulesManager() {
  const modal = document.getElementById('customLinkingRulesManagerModal');
  if (!modal) return;
  
  const rulesList = modal.querySelector('#customLinkingRulesList');
  if (!rulesList) {
    // Populate modal
    modal.innerHTML = `
      <div class="modal" style="min-width:800px;max-width:1000px;max-height:85vh;overflow-y:auto;">
        <h3>üîó Custom Linking Rules</h3>
        <p style="font-size:10px;color:var(--muted);margin:8px 0;">Define rules to automatically link events. Example: If Pass event occurs, then link it to the next Shot event.</p>
        
        <!-- v24.0: Link removal utilities -->
        <div style="margin:16px 0;padding:12px;background:var(--warn-bg);border-radius:4px;border:1px solid var(--warn);">
          <strong style="font-size:11px;display:block;margin-bottom:8px;">üîß Link Removal Utilities</strong>
          <div style="display:flex;gap:8px;flex-wrap:wrap;">
            <button class="btn-sm btn-danger" onclick="removeAllLinks();" style="font-size:9px;" title="Remove all links from all events">Remove All Links</button>
            <button class="btn-sm btn-danger" onclick="openRemoveLinksByCondition();" style="font-size:9px;" title="Remove links based on conditions">Remove Links by Condition</button>
          </div>
        </div>
        
        <div id="customLinkingRulesList" style="margin:16px 0;"></div>
        <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:16px;">
          <button class="btn-sm" onclick="closeCustomLinkingRulesManager()">Close</button>
          <button class="btn-sm" onclick="addNewCustomLinkingRule()" style="background:var(--success);">+ Add Rule</button>
        </div>
      </div>
    `;
    modal.onclick = function(e) {
      if (e.target === modal) closeCustomLinkingRulesManager();
    };
  }
  
  renderCustomLinkingRulesList();
  
  const finalModal = document.getElementById('customLinkingRulesManagerModal');
  if (finalModal) {
    finalModal.classList.add('show');
    finalModal.style.display = 'flex';
  }
}

/**
 * v23.8: Close custom linking rules manager
 */
function closeCustomLinkingRulesManager() {
  const modal = document.getElementById('customLinkingRulesManagerModal');
  if (modal) {
    modal.classList.remove('show');
    modal.style.display = 'none';
  }
}

/**
 * v24.0: Render list of custom linking rules (enhanced to show multiple links)
 */
function renderCustomLinkingRulesList() {
  const container = document.getElementById('customLinkingRulesList');
  if (!container) return;
  
  if (!S.customLinkingRules || S.customLinkingRules.length === 0) {
    container.innerHTML = '<p style="color:var(--muted);font-size:10px;text-align:center;padding:20px;">No linking rules yet. Click "Add Rule" to create one.</p>';
    return;
  }
  
  container.innerHTML = S.customLinkingRules.map((rule, idx) => {
    const triggerDesc = [
      rule.trigger.type ? `Type: ${rule.trigger.type}` : 'Any event',
      rule.trigger.detail1 ? `Detail1: ${rule.trigger.detail1}` : '',
      rule.trigger.detail2 ? `Detail2: ${rule.trigger.detail2}` : '',
      rule.trigger.team ? `Team: ${rule.trigger.team}` : '',
      rule.trigger.zone ? `Zone: ${rule.trigger.zone}` : ''
    ].filter(Boolean).join(', ');
    
    // Build link chain description
    const links = rule.links || (rule.linkTo ? [rule.linkTo] : []);
    const linkChainDesc = links.map((link, i) => {
      const linkParts = [
        link.type || 'Any',
        link.detail1 ? `D1:${link.detail1}` : '',
        link.detail2 ? `D2:${link.detail2}` : '',
        link.direction || 'forward',
        link.swapTeams ? 'üîÑ' : ''
      ].filter(Boolean).join(' ');
      return `‚Üí Link${i + 1}: ${linkParts}`;
    }).join(' ');
    
    return `
      <div style="border:1px solid var(--border);border-radius:4px;padding:12px;margin-bottom:8px;background:var(--card);">
        <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:8px;">
          <div style="flex:1;">
            <strong style="font-size:11px;">${rule.name || 'Untitled Rule'} ${rule.enabled ? '‚úì' : '‚úó'}</strong>
            <div style="font-size:9px;color:var(--muted);margin-top:4px;">
              <div><strong>When:</strong> ${triggerDesc}</div>
              <div><strong>Chain:</strong> ${linkChainDesc || 'No links'}</div>
              ${rule.maxLookback ? `<div><strong>Max lookback:</strong> ${rule.maxLookback} events</div>` : ''}
              ${rule.runOnAllEvents ? `<div><strong>Run on all events:</strong> Yes</div>` : ''}
            </div>
          </div>
          <div style="display:flex;gap:4px;">
            <button class="btn-sm" onclick="toggleCustomLinkingRule(${idx});event.stopPropagation();" style="font-size:8px;padding:2px 6px;" title="Toggle enabled">${rule.enabled ? '‚úì' : '‚úó'}</button>
            <button class="btn-sm" onclick="editCustomLinkingRule(${idx});event.stopPropagation();" style="font-size:8px;padding:2px 6px;" title="Edit rule">‚úèÔ∏è</button>
            <button class="btn-sm btn-danger" onclick="deleteCustomLinkingRule(${idx});event.stopPropagation();" style="font-size:8px;padding:2px 6px;" title="Delete rule">‚úï</button>
          </div>
        </div>
      </div>
    `;
  }).join('');
}

/**
 * v23.8: Add new custom linking rule
 */
function addNewCustomLinkingRule() {
  const rule = {
    id: 'linking_rule_' + Date.now(),
    name: 'New Linking Rule',
    enabled: true,
    trigger: {
      type: '',
      detail1: '',
      detail2: '',
      team: '',
      zone: ''
    },
    links: [{
      type: '',
      detail1: '',
      detail2: '',
      direction: 'forward', // 'forward', 'backward', or 'both'
      swapTeams: false // v24.0: Swap teams for player mapping
    }],
    maxLookback: 10,
    runOnAllEvents: false, // v24.0: Apply to all existing events
    autoOpenEditor: false // v25.0: Auto-open event editor when trigger matches
  };
  
  S.customLinkingRules = S.customLinkingRules || [];
  S.customLinkingRules.push(rule);
  saveCustomLinkingRules();
  renderCustomLinkingRulesList();
  editCustomLinkingRule(S.customLinkingRules.length - 1);
}

/**
 * v24.0: Build detail dropdown HTML with option for text input (%{text}% pattern)
 */
function buildDetailDropdown(fieldId, currentValue, detailsArray, placeholder) {
  const isPattern = currentValue && currentValue.includes('%{') && currentValue.includes('}%');
  const detailOptions = detailsArray && detailsArray.length > 0
    ? detailsArray.map(d => {
        const value = d.code || d.name || d;
        const label = d.name || d.code || d;
        const selected = !isPattern && currentValue === value ? 'selected' : '';
        return `<option value="${value}" ${selected}>${label}</option>`;
      }).join('')
    : '';
  
  return `
    <div style="display:flex;gap:4px;align-items:center;">
      <select id="${fieldId}_mode" onchange="toggleDetailInputMode('${fieldId}')" style="width:80px;font-size:9px;">
        <option value="dropdown" ${!isPattern ? 'selected' : ''}>Dropdown</option>
        <option value="text" ${isPattern ? 'selected' : ''}>Text/Pattern</option>
      </select>
      <select id="${fieldId}_dropdown" style="flex:1;display:${isPattern ? 'none' : 'block'};">
        <option value="">-- Any --</option>
        ${detailOptions}
      </select>
      <input type="text" id="${fieldId}_text" value="${(currentValue || '').replace(/"/g, '&quot;')}" 
             style="flex:1;display:${isPattern ? 'block' : 'none'};" 
             placeholder="${placeholder || 'e.g., %{text}% or exact match'}">
    </div>
    <div style="font-size:8px;color:var(--muted);margin-top:2px;">
      Use %{text}% for pattern matching (e.g., %{Shot}% matches any detail containing "Shot")
    </div>
  `;
}

/**
 * v24.0: Toggle between dropdown and text input for detail fields
 */
function toggleDetailInputMode(fieldId) {
  const mode = document.getElementById(fieldId + '_mode').value;
  const dropdown = document.getElementById(fieldId + '_dropdown');
  const textInput = document.getElementById(fieldId + '_text');
  
  if (mode === 'dropdown') {
    dropdown.style.display = 'block';
    textInput.style.display = 'none';
  } else {
    dropdown.style.display = 'none';
    textInput.style.display = 'block';
  }
}

/**
 * v24.0: Get detail value from dropdown or text input
 */
function getDetailValue(fieldId) {
  const mode = document.getElementById(fieldId + '_mode').value;
  if (mode === 'dropdown') {
    return document.getElementById(fieldId + '_dropdown').value || '';
  } else {
    return document.getElementById(fieldId + '_text').value || '';
  }
}

/**
 * v24.0: Add a new link to the chain
 */
function addLinkingRuleLink() {
  const linksContainer = document.getElementById('linkingRuleLinksContainer');
  if (!linksContainer) return;
  
  const linkIndex = linksContainer.children.length;
  const linkHtml = buildLinkHTML(linkIndex, { type: '', detail1: '', detail2: '', direction: 'forward', swapTeams: false });
  const linkDiv = document.createElement('div');
  linkDiv.className = 'linking-rule-link';
  linkDiv.innerHTML = linkHtml;
  linksContainer.appendChild(linkDiv);
}

/**
 * v24.0: Remove a link from the chain
 */
function removeLinkingRuleLink(index) {
  const linkDiv = document.querySelector(`#linkingRuleLinksContainer .linking-rule-link[data-link-index="${index}"]`);
  if (linkDiv) {
    linkDiv.remove();
    // Renumber remaining links
    const links = document.querySelectorAll('#linkingRuleLinksContainer .linking-rule-link');
    links.forEach((link, i) => {
      link.setAttribute('data-link-index', i);
      const header = link.querySelector('.link-header');
      if (header) header.textContent = `Link ${i + 1}`;
    });
  }
}

/**
 * v24.0: Build HTML for a single link in the chain
 */
function buildLinkHTML(linkIndex, linkData) {
  const eventTypeOptions = S.eventTypesDB.length > 0
    ? S.eventTypesDB.map(e => `<option value="${e.code || e.name}">${e.code || e.name}</option>`).join('')
    : (LISTS.eventTypes || []).map(t => `<option value="${t}">${t}</option>`).join('');
  
  const detail1Options = S.eventDetails1 && S.eventDetails1.length > 0
    ? S.eventDetails1.map(d => `<option value="${d.code || d.name}">${d.name || d.code}</option>`).join('')
    : '';
  
  const detail2Options = S.eventDetails2 && S.eventDetails2.length > 0
    ? S.eventDetails2.map(d => `<option value="${d.code || d.name}">${d.name || d.code}</option>`).join('')
    : '';
  
  return `
    <div class="linking-rule-link" data-link-index="${linkIndex}" style="border:1px solid var(--border);border-radius:4px;padding:12px;margin-bottom:8px;background:var(--card);">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <strong class="link-header" style="font-size:11px;">Link ${linkIndex + 1}</strong>
        <button class="btn-sm btn-danger" onclick="removeLinkingRuleLink(${linkIndex});event.stopPropagation();" style="font-size:8px;padding:2px 6px;">‚úï Remove</button>
      </div>
      <div class="form-group">
        <label>Event Type</label>
        <select id="link_${linkIndex}_type" style="width:100%;">
          <option value="">-- Any Event Type --</option>
          ${eventTypeOptions}
        </select>
      </div>
      <div class="form-group">
        <label>Detail1</label>
        ${buildDetailDropdown(`link_${linkIndex}_detail1`, linkData.detail1 || '', S.eventDetails1 || [], 'e.g., %{Shot}%')}
      </div>
      <div class="form-group">
        <label>Detail2</label>
        ${buildDetailDropdown(`link_${linkIndex}_detail2`, linkData.detail2 || '', S.eventDetails2 || [], 'e.g., %{Goal}%')}
      </div>
      <div class="form-group">
        <label>Link Direction</label>
        <select id="link_${linkIndex}_direction" style="width:100%;">
          <option value="forward" ${linkData.direction === 'forward' ? 'selected' : ''}>Forward (link to next matching event)</option>
          <option value="backward" ${linkData.direction === 'backward' ? 'selected' : ''}>Backward (link to previous matching event)</option>
          <option value="both" ${linkData.direction === 'both' ? 'selected' : ''}>Both (link to both previous and next)</option>
        </select>
      </div>
      <div class="form-group">
        <label>
          <input type="checkbox" id="link_${linkIndex}_swapTeams" ${linkData.swapTeams ? 'checked' : ''} style="margin-right:4px;">
          Swap Teams (event_player_1 ‚Üí Opp_player_1, etc.)
        </label>
        <div style="font-size:8px;color:var(--muted);margin-top:2px;">
          When enabled, players from trigger event are mapped to opposite team on linked event
        </div>
      </div>
    </div>
  `;
}

/**
 * v24.0: Edit custom linking rule (enhanced with multiple links, dropdowns, swap teams)
 */
function editCustomLinkingRule(idx) {
  const rule = S.customLinkingRules[idx];
  if (!rule) return;
  
  // Migrate old format to new format if needed
  if (rule.linkTo && !rule.links) {
    rule.links = [{
      type: rule.linkTo.type || '',
      detail1: rule.linkTo.detail1 || '',
      detail2: rule.linkTo.detail2 || '',
      direction: rule.linkTo.direction || 'forward',
      swapTeams: rule.linkTo.swapTeams || false
    }];
  }
  if (!rule.links || rule.links.length === 0) {
    rule.links = [{ type: '', detail1: '', detail2: '', direction: 'forward', swapTeams: false }];
  }
  
  window.editingLinkingRuleIdx = idx;
  
  const eventTypeOptions = S.eventTypesDB.length > 0
    ? S.eventTypesDB.map(e => `<option value="${e.code || e.name}">${e.code || e.name}</option>`).join('')
    : (LISTS.eventTypes || []).map(t => `<option value="${t}">${t}</option>`).join('');
  
  // Build links HTML
  const linksHTML = rule.links.map((link, i) => buildLinkHTML(i, link)).join('');
  
  const html = `
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
      <h3 style="margin:0;">‚úèÔ∏è Edit Custom Linking Rule</h3>
      <button onclick="closeEditLinkingRuleModal();return false;" style="background:none;border:none;font-size:18px;cursor:pointer;color:var(--muted);padding:0;width:24px;height:24px;line-height:1;" title="Close">√ó</button>
    </div>
    <div style="max-height:70vh;overflow-y:auto;">
      <div class="form-group">
        <label>Rule Name</label>
        <input type="text" id="editLinkingRuleName" value="${(rule.name || '').replace(/"/g, '&quot;')}" style="width:100%;">
      </div>
      
      <div style="margin:16px 0;padding:12px;background:var(--panel);border-radius:4px;">
        <strong style="font-size:11px;">Trigger (When this event occurs):</strong>
        <div class="form-group" style="margin-top:8px;">
          <label>Event Type</label>
          <select id="editLinkingRuleTriggerType" style="width:100%;">
            <option value="">-- Any Event Type --</option>
            ${eventTypeOptions}
          </select>
        </div>
        <div class="form-group">
          <label>Detail1</label>
          ${buildDetailDropdown('editLinkingRuleTriggerD1', rule.trigger.detail1 || '', S.eventDetails1 || [], 'e.g., %{Pass}%')}
        </div>
        <div class="form-group">
          <label>Detail2</label>
          ${buildDetailDropdown('editLinkingRuleTriggerD2', rule.trigger.detail2 || '', S.eventDetails2 || [], 'e.g., %{Forward}%')}
        </div>
        <div class="form-group">
          <label>Team (optional)</label>
          <select id="editLinkingRuleTriggerTeam" style="width:100%;">
            <option value="">-- Any Team --</option>
            <option value="home" ${rule.trigger.team === 'home' ? 'selected' : ''}>Home</option>
            <option value="away" ${rule.trigger.team === 'away' ? 'selected' : ''}>Away</option>
          </select>
        </div>
        <div class="form-group">
          <label>Zone (optional)</label>
          <select id="editLinkingRuleTriggerZone" style="width:100%;">
            <option value="">-- Any Zone --</option>
            <option value="o" ${rule.trigger.zone === 'o' ? 'selected' : ''}>Offensive</option>
            <option value="d" ${rule.trigger.zone === 'd' ? 'selected' : ''}>Defensive</option>
            <option value="n" ${rule.trigger.zone === 'n' ? 'selected' : ''}>Neutral</option>
          </select>
        </div>
      </div>
      
      <div style="margin:16px 0;padding:12px;background:var(--panel);border-radius:4px;">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
          <strong style="font-size:11px;">Link Chain (trigger ‚Üí link1 ‚Üí link2, etc.):</strong>
          <button class="btn-sm" onclick="addLinkingRuleLink();event.stopPropagation();" style="background:var(--success);">+ Add Link</button>
        </div>
        <div id="linkingRuleLinksContainer">
          ${linksHTML}
        </div>
      </div>
      
      <div style="margin:16px 0;padding:12px;background:var(--panel);border-radius:4px;">
        <div class="form-group">
          <label>Max Lookback (events to search back/forward)</label>
          <input type="number" id="editLinkingRuleMaxLookback" value="${rule.maxLookback || 10}" min="1" max="50" style="width:100%;">
        </div>
        <div class="form-group">
          <label>
            <input type="checkbox" id="editLinkingRuleRunOnAll" ${rule.runOnAllEvents ? 'checked' : ''} style="margin-right:4px;">
            Run on all current events (apply rule retroactively)
          </label>
          <div style="font-size:8px;color:var(--muted);margin-top:2px;">
            When enabled, rule will be applied to all existing events in the game
          </div>
        </div>
        <div class="form-group" style="margin-top:12px;">
          <label>
            <input type="checkbox" id="editLinkingRuleAutoOpenEditor" ${rule.autoOpenEditor ? 'checked' : ''} style="margin-right:4px;">
            Auto-open event editor when trigger matches
          </label>
          <div style="font-size:8px;color:var(--muted);margin-top:2px;">
            When enabled, automatically opens event editor modal with pre-populated data from the first link when a new event matches the trigger. Useful for quick workflows like Shot ‚Üí Save.
          </div>
        </div>
      </div>
      
      <div style="margin:16px 0;padding:12px;background:var(--panel);border-radius:4px;">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
          <strong style="font-size:11px;">Preview (What would this rule match?):</strong>
          <button class="btn-sm" onclick="previewCustomLinkingRule();event.stopPropagation();" style="background:var(--accent2);">üîç Preview</button>
        </div>
        <div id="linkingRulePreview" style="font-size:9px;color:var(--muted);padding:8px;background:var(--card);border-radius:4px;max-height:200px;overflow-y:auto;display:none;">
          <div>Click "Preview" to see what this rule would match</div>
        </div>
      </div>
      
      <div style="margin:16px 0;padding:8px;background:var(--warn-bg);border-radius:4px;font-size:9px;color:var(--muted);">
        <strong>üí° Tip:</strong> Use pattern matching with %{text}% to match any detail containing that text. Chain multiple links for complex sequences.
      </div>
      
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:16px;padding-top:16px;border-top:1px solid var(--border);">
        <button class="btn-sm" onclick="closeEditLinkingRuleModal()">Cancel</button>
        <button class="btn-sm btn-success" onclick="saveCustomLinkingRuleEdit()">Save Rule</button>
      </div>
    </div>
  `;
  
  const modal = document.getElementById('customLinkingRulesManagerModal');
  if (!modal) return;
  
  const editModal = document.createElement('div');
  editModal.id = 'editLinkingRuleModal';
  editModal.className = 'overlay show';
  editModal.style.display = 'flex';
  editModal.innerHTML = `<div class="modal" style="min-width:700px;max-width:900px;max-height:85vh;overflow-y:auto;">${html}</div>`;
  editModal.onclick = function(e) {
    if (e.target === editModal) closeEditLinkingRuleModal();
  };
  document.body.appendChild(editModal);
  
  // Set current values
  if (rule.trigger.type) document.getElementById('editLinkingRuleTriggerType').value = rule.trigger.type;
  
  // Set link values
  rule.links.forEach((link, i) => {
    if (link.type) document.getElementById(`link_${i}_type`).value = link.type;
  });
}

/**
 * v24.0: Preview what a custom linking rule would match
 */
function previewCustomLinkingRule() {
  const previewContainer = document.getElementById('linkingRulePreview');
  if (!previewContainer) return;
  
  // Build temporary rule from current form values
  const tempRule = {
    trigger: {
      type: document.getElementById('editLinkingRuleTriggerType').value || '',
      detail1: getDetailValue('editLinkingRuleTriggerD1'),
      detail2: getDetailValue('editLinkingRuleTriggerD2'),
      team: document.getElementById('editLinkingRuleTriggerTeam').value || '',
      zone: document.getElementById('editLinkingRuleTriggerZone').value || ''
    },
    links: [],
    maxLookback: parseInt(document.getElementById('editLinkingRuleMaxLookback').value) || 10
  };
  
  // Collect links from form
  const linksContainer = document.getElementById('linkingRuleLinksContainer');
  if (linksContainer) {
    const linkDivs = linksContainer.querySelectorAll('.linking-rule-link');
    linkDivs.forEach((linkDiv, i) => {
      tempRule.links.push({
        type: document.getElementById(`link_${i}_type`).value || '',
        detail1: getDetailValue(`link_${i}_detail1`),
        detail2: getDetailValue(`link_${i}_detail2`),
        direction: document.getElementById(`link_${i}_direction`).value || 'forward'
      });
    });
  }
  
  // Find matching events
  const matchingEvents = S.events.filter(evt => checkLinkingRuleTrigger(evt, tempRule.trigger));
  
  if (matchingEvents.length === 0) {
    previewContainer.innerHTML = `<div style="color:var(--muted);">No events match this trigger condition.</div>`;
    previewContainer.style.display = 'block';
    return;
  }
  
  // Try to find matching links for each trigger event
  let matchedChains = 0;
  const examples = [];
  const maxExamples = 5;
  
  matchingEvents.forEach((evt, idx) => {
    if (examples.length >= maxExamples) return;
    
    const evtIdx = S.events.indexOf(evt);
    if (evtIdx === -1) return;
    
    // Try to find matches for each link in the chain
    let currentEvent = evt;
    const chain = [evt];
    let chainComplete = true;
    
    for (const link of tempRule.links) {
      if (!link.type && !link.detail1 && !link.detail2) {
        // Empty link, skip
        continue;
      }
      
      const matchingLink = findMatchingEventForLink(currentEvent, link, tempRule.maxLookback || 10, 'forward');
      if (matchingLink) {
        chain.push(matchingLink);
        currentEvent = matchingLink;
      } else {
        // Try backward
        const matchingLinkBackward = findMatchingEventForLink(currentEvent, link, tempRule.maxLookback || 10, 'backward');
        if (matchingLinkBackward) {
          chain.push(matchingLinkBackward);
          currentEvent = matchingLinkBackward;
        } else {
          chainComplete = false;
          break;
        }
      }
    }
    
    if (chainComplete && chain.length > 1) {
      matchedChains++;
      if (examples.length < maxExamples) {
        const chainDesc = chain.map((e, i) => {
          const idx = S.events.indexOf(e);
          return `<strong>${e.type}${e.detail1 ? ':' + e.detail1 : ''}</strong> #${idx + 1}`;
        }).join(' ‚Üí ');
        examples.push({
          chainDesc,
          chain
        });
      }
    }
  });
  
  // Build preview HTML
  let previewHTML = `
    <div style="margin-bottom:8px;">
      <strong>Trigger Matches:</strong> ${matchingEvents.length} event(s)
    </div>
  `;
  
  if (matchedChains > 0) {
    previewHTML += `
      <div style="margin-bottom:8px;">
        <strong>Complete Chains Found:</strong> ${matchedChains} chain(s)
      </div>
      <div style="margin-top:8px;">
        <strong>Examples (first ${Math.min(examples.length, maxExamples)}):</strong>
        <div style="margin-top:4px;font-size:8px;">
          ${examples.map(ex => `<div style="margin:2px 0;padding:4px;background:var(--bg);border-radius:3px;">${ex.chainDesc}</div>`).join('')}
        </div>
      </div>
    `;
  } else {
    previewHTML += `
      <div style="margin-top:8px;color:var(--warn);">
        ‚ö†Ô∏è No complete chains found. Check link criteria and max lookback.
      </div>
    `;
  }
  
  previewContainer.innerHTML = previewHTML;
  previewContainer.style.display = 'block';
}

/**
 * v24.0: Analyze event chains in the data
 */
function analyzeEventChains() {
  const chainStats = {};
  
  // Build chain map from linkedEventIdx
  const chainMap = new Map(); // linkedIdx -> [events in chain]
  
  S.events.forEach((evt, idx) => {
    if (evt.linkedEventIdx !== null && evt.linkedEventIdx !== undefined) {
      const linkedIdx = evt.linkedEventIdx;
      if (!chainMap.has(linkedIdx)) {
        chainMap.set(linkedIdx, []);
      }
      chainMap.get(linkedIdx).push(evt);
    }
  });
  
  // Analyze each chain
  chainMap.forEach((chainEvents, linkedIdx) => {
    if (chainEvents.length < 2) return; // Need at least 2 events for a chain
    
    // Sort by event index to get order
    chainEvents.sort((a, b) => {
      const idxA = S.events.indexOf(a);
      const idxB = S.events.indexOf(b);
      return idxA - idxB;
    });
    
    // Build chain string (e.g., "Shot>Save>Rebound")
    const chainStr = chainEvents.map(e => {
      const typeStr = e.type;
      const detailStr = e.detail1 ? ':' + e.detail1 : '';
      return typeStr + detailStr;
    }).join('>');
    
    // Count this chain
    if (!chainStats[chainStr]) {
      chainStats[chainStr] = {
        count: 0,
        examples: []
      };
    }
    
    chainStats[chainStr].count++;
    if (chainStats[chainStr].examples.length < 3) {
      const exampleIndices = chainEvents.map(e => S.events.indexOf(e) + 1).join(', ');
      chainStats[chainStr].examples.push(exampleIndices);
    }
  });
  
  // Sort by count (descending)
  const sortedChains = Object.entries(chainStats)
    .sort((a, b) => b[1].count - a[1].count)
    .slice(0, 50); // Top 50 chains
  
  return sortedChains;
}

/**
 * v24.0: Filter events by chain pattern
 */
function filterEventsByChain(pattern) {
  if (!pattern || !pattern.includes('>')) return S.events;
  
  const chainParts = pattern.split('>').map(p => p.trim());
  if (chainParts.length < 2) return S.events;
  
  // Find all chains that match this pattern
  const chainMap = new Map();
  S.events.forEach(evt => {
    if (evt.linkedEventIdx !== null && evt.linkedEventIdx !== undefined) {
      const linkedIdx = evt.linkedEventIdx;
      if (!chainMap.has(linkedIdx)) {
        chainMap.set(linkedIdx, []);
      }
      chainMap.get(linkedIdx).push(evt);
    }
  });
  
  const matchingEventIndices = new Set();
  
  chainMap.forEach(chainEvents => {
    if (chainEvents.length !== chainParts.length) return;
    
    // Sort by index
    chainEvents.sort((a, b) => {
      const idxA = S.events.indexOf(a);
      const idxB = S.events.indexOf(b);
      return idxA - idxB;
    });
    
    // Check if chain matches pattern
    let matches = true;
    for (let i = 0; i < chainParts.length; i++) {
      const part = chainParts[i].toLowerCase();
      const evt = chainEvents[i];
      
      const typeMatch = evt.type.toLowerCase() === part;
      const detailMatch = evt.detail1 && evt.detail1.toLowerCase().includes(part);
      
      if (!typeMatch && !detailMatch) {
        // Try splitting part by colon (Type:Detail)
        const [typePart, detailPart] = part.split(':');
        if (typePart && evt.type.toLowerCase() !== typePart.toLowerCase()) {
          matches = false;
          break;
        }
        if (detailPart && (!evt.detail1 || !evt.detail1.toLowerCase().includes(detailPart))) {
          matches = false;
          break;
        }
      }
    }
    
    if (matches) {
      chainEvents.forEach(evt => {
        const idx = S.events.indexOf(evt);
        if (idx !== -1) matchingEventIndices.add(idx);
      });
    }
  });
  
  return Array.from(matchingEventIndices)
    .sort((a, b) => a - b)
    .map(idx => S.events[idx])
    .filter(Boolean);
}

/**
 * v24.0: Save custom linking rule edit (enhanced with multiple links)
 */
function saveCustomLinkingRuleEdit() {
  const idx = window.editingLinkingRuleIdx;
  if (idx === undefined || !S.customLinkingRules[idx]) return;
  
  const rule = S.customLinkingRules[idx];
  rule.name = document.getElementById('editLinkingRuleName').value || 'Untitled Rule';
  
  // Save trigger
  rule.trigger.type = document.getElementById('editLinkingRuleTriggerType').value || '';
  rule.trigger.detail1 = getDetailValue('editLinkingRuleTriggerD1');
  rule.trigger.detail2 = getDetailValue('editLinkingRuleTriggerD2');
  rule.trigger.team = document.getElementById('editLinkingRuleTriggerTeam').value || '';
  rule.trigger.zone = document.getElementById('editLinkingRuleTriggerZone').value || '';
  
  // Save links (collect all links from the container)
  rule.links = [];
  const linksContainer = document.getElementById('linkingRuleLinksContainer');
  if (linksContainer) {
    const linkDivs = linksContainer.querySelectorAll('.linking-rule-link');
    linkDivs.forEach((linkDiv, i) => {
      const linkData = {
        type: document.getElementById(`link_${i}_type`).value || '',
        detail1: getDetailValue(`link_${i}_detail1`),
        detail2: getDetailValue(`link_${i}_detail2`),
        direction: document.getElementById(`link_${i}_direction`).value || 'forward',
        swapTeams: document.getElementById(`link_${i}_swapTeams`).checked || false
      };
      rule.links.push(linkData);
    });
  }
  
  // If no links, create default empty link
  if (!rule.links || rule.links.length === 0) {
    rule.links = [{ type: '', detail1: '', detail2: '', direction: 'forward', swapTeams: false }];
  }
  
  rule.maxLookback = parseInt(document.getElementById('editLinkingRuleMaxLookback').value) || 10;
  rule.runOnAllEvents = document.getElementById('editLinkingRuleRunOnAll').checked || false;
  rule.autoOpenEditor = document.getElementById('editLinkingRuleAutoOpenEditor')?.checked || false;
  
  saveCustomLinkingRules();
  closeEditLinkingRuleModal();
  renderCustomLinkingRulesList();
  
  // If runOnAllEvents is enabled, show preview of impacted events before applying
  if (rule.runOnAllEvents && rule.enabled) {
    const skipReview = localStorage.getItem('bs_skip_linking_review') === 'true';
    if (skipReview) {
      // Skip review, apply immediately
      applyLinkingRuleToAllEvents(rule);
      toast('Linking rule saved and applied to all events', 'success');
    } else {
      // Show preview of impacted events
      const impactedEvents = previewLinkingRuleImpacts(rule);
      if (impactedEvents.length > 0) {
        showLinkingRuleImpactPreview(rule, impactedEvents);
      } else {
        toast('Linking rule saved. No events would be impacted by this rule.', 'info');
      }
    }
  } else {
    toast('Linking rule saved', 'success');
  }
}

/**
 * v23.8: Close edit linking rule modal
 */
function closeEditLinkingRuleModal() {
  const modal = document.getElementById('editLinkingRuleModal');
  if (modal) {
    modal.remove();
  }
  window.editingLinkingRuleIdx = undefined;
}

/**
 * v23.8: Toggle custom linking rule enabled
 */
function toggleCustomLinkingRule(idx) {
  if (!S.customLinkingRules[idx]) return;
  S.customLinkingRules[idx].enabled = !S.customLinkingRules[idx].enabled;
  saveCustomLinkingRules();
  renderCustomLinkingRulesList();
}

/**
 * v23.8: Delete custom linking rule
 */
function deleteCustomLinkingRule(idx) {
  if (!confirm('Delete this linking rule?')) return;
  S.customLinkingRules.splice(idx, 1);
  saveCustomLinkingRules();
  renderCustomLinkingRulesList();
  toast('Linking rule deleted', 'info');
}

/**
 * v24.0: Apply custom linking rules to an event (enhanced with multiple links, swap teams)
 * Checks both: 1) if new event matches trigger (link to past events)
 *              2) if past events match trigger (link to new event)
 */
function applyCustomLinkingRules(evt) {
  if (!S.customLinkingRules || S.customLinkingRules.length === 0) return;
  if (!evt) return;
  
  const evtIdx = evt.idx;
  
  for (const rule of S.customLinkingRules) {
    if (!rule.enabled) continue;
    
    // Check if new event matches trigger - if so, find past events to link to
    if (checkLinkingRuleTrigger(evt, rule.trigger)) {
      // v25.0: Auto-open event editor if enabled
      if (rule.autoOpenEditor && rule.links && rule.links.length > 0) {
        const firstLink = rule.links[0];
        if (firstLink.type || firstLink.detail1 || firstLink.detail2) {
          // Create a new event based on the first link and open editor
          setTimeout(() => {
            autoOpenEventEditorFromLink(evt, firstLink, rule);
          }, 300); // Small delay to ensure event is fully saved
        }
      }
      
      // Process link chain: trigger ‚Üí link1 ‚Üí link2 ‚Üí ...
      let currentEvent = evt;
      let linkedIdx = evt.linkedEventIdx !== null ? evt.linkedEventIdx : getNextLinkedEventIdx();
      
      for (const link of (rule.links || [])) {
        const matchingEvent = findMatchingEventForLink(currentEvent, link, rule.maxLookback || 10, 'backward');
        if (matchingEvent) {
          // Link the events
          if (matchingEvent.linkedEventIdx === null || matchingEvent.linkedEventIdx === undefined) {
            matchingEvent.linkedEventIdx = linkedIdx;
          }
          currentEvent.linkedEventIdx = linkedIdx;
          
          // Swap teams if enabled
          if (link.swapTeams) {
            swapTeamsForPlayers(currentEvent, matchingEvent);
          }
          
          console.log(`Custom linking rule: ${currentEvent.type} #${currentEvent.idx + 1} linked to ${matchingEvent.type} #${matchingEvent.idx + 1}`);
          toast(`Auto-linked: ${currentEvent.type} #${currentEvent.idx + 1} ‚Üî ${matchingEvent.type} #${matchingEvent.idx + 1}`, 'info', 3000);
          
          // Continue chain with the matched event
          currentEvent = matchingEvent;
        } else {
          // No match found, stop chain
          break;
        }
      }
    }
    
    // Check if past events match trigger and should link to new event
    // Process link chain in reverse
    for (let linkIdx = (rule.links || []).length - 1; linkIdx >= 0; linkIdx--) {
      const link = rule.links[linkIdx];
      if (checkLinkingRuleTrigger(evt, link)) {
        // Look backward for events that match the trigger
        for (let i = evtIdx - 1; i >= Math.max(0, evtIdx - (rule.maxLookback || 10)); i--) {
          const pastEvt = S.events[i];
          if (!pastEvt) continue;
          
          if (checkLinkingRuleTrigger(pastEvt, rule.trigger)) {
            const linkedIdx = evt.linkedEventIdx !== null ? evt.linkedEventIdx : getNextLinkedEventIdx();
            pastEvt.linkedEventIdx = linkedIdx;
            evt.linkedEventIdx = linkedIdx;
            
            // Swap teams if enabled
            if (link.swapTeams) {
              swapTeamsForPlayers(pastEvt, evt);
            }
            
            console.log(`Custom linking rule: ${pastEvt.type} #${pastEvt.idx + 1} linked to ${evt.type} #${evt.idx + 1}`);
            toast(`Auto-linked: ${pastEvt.type} #${pastEvt.idx + 1} ‚Üî ${evt.type} #${evt.idx + 1}`, 'info', 3000);
            break; // Only link to most recent matching event
          }
        }
      }
    }
  }
}

/**
 * v25.0: Auto-open event editor from linking rule
 * Creates a new event based on link data and opens the editor
 */
function autoOpenEventEditorFromLink(triggerEvt, link, rule) {
  if (!triggerEvt || !link) return;
  
  // Get current time and period
  const startTime = document.getElementById('clock').value || triggerEvt.start_time;
  const period = S.period;
  const team = triggerEvt.team || S.evtTeam;
  
  // Determine team for new event (swap if enabled)
  let newEventTeam = team;
  if (link.swapTeams) {
    newEventTeam = team === 'home' ? 'away' : 'home';
  }
  
  // Create new event based on link
  const newEvt = {
    idx: S.evtIdx++,
    game_id: S.gameId,
    period: period,
    start_time: startTime,
    end_time: startTime,
    team: newEventTeam,
    type: link.type || '',
    detail1: link.detail1 || '',
    detail2: link.detail2 || '',
    zone: triggerEvt.zone || '',
    success: '',
    strength: deriveStrength(),
    linkedEventIdx: null,
    isHighlight: false,
    puckXY: [],
    netXY: null,
    players: []
  };
  
  // Copy players from trigger event, swapping teams if enabled
  if (link.swapTeams && triggerEvt.players && triggerEvt.players.length > 0) {
    newEvt.players = triggerEvt.players.map(p => {
      const newPlayer = {...p, xy: [...(p.xy || [])]};
      // Swap player roles: event_player_1 ‚Üí opp_player_1, etc.
      if (p.role?.startsWith('event_')) {
        newPlayer.role = p.role.replace('event_', 'opp_');
      } else if (p.role?.startsWith('opp_')) {
        newPlayer.role = p.role.replace('opp_', 'event_');
      }
      // Swap team
      newPlayer.team = newPlayer.team === 'home' ? 'away' : 'home';
      return newPlayer;
    });
  } else if (triggerEvt.players && triggerEvt.players.length > 0) {
    // Copy players without swapping
    newEvt.players = triggerEvt.players.map(p => ({...p, xy: [...(p.xy || [])]}));
  }
  
  // Copy puck XY if available
  if (triggerEvt.puckXY && triggerEvt.puckXY.length > 0) {
    newEvt.puckXY = triggerEvt.puckXY.map(xy => ({...xy}));
  }
  
  // Add event to list
  S.events.push(newEvt);
  markDataChanged();
  sortAndReindexEvents();
  
  // Find the event index after sorting
  const newEvtIdx = S.events.findIndex(e => e.idx === newEvt.idx);
  if (newEvtIdx === -1) {
    console.error('Failed to find new event after sorting');
    return;
  }
  
  // Open editor for the new event
  editEvent(newEvtIdx);
  
  toast(`Auto-opened editor for ${link.type || 'new event'} based on linking rule`, 'info');
}

/**
 * v24.0: Unlink current event from its linked chain
 */
function unlinkCurrentEvent() {
  if (S.editingEvtIdx === null || S.editingEvtIdx === undefined) return;
  
  // Prompt to save if there are unsaved changes
  if (!promptSaveBeforeNavigate()) {
    return; // User cancelled
  }
  
  const evt = S.events[S.editingEvtIdx];
  if (!evt || evt.linkedEventIdx === null || evt.linkedEventIdx === undefined) return;
  
  // Remove link from current event
  evt.linkedEventIdx = null;
  
  // Update linked index field in editor
  const linkedIdxEl = document.getElementById('editLinkedIdx');
  if (linkedIdxEl) linkedIdxEl.value = '';
  
  // Update chain display
  document.getElementById('editLinkedChain').textContent = '--';
  const unlinkButton = document.getElementById('editUnlinkButton');
  if (unlinkButton) unlinkButton.style.display = 'none';
  
  // Save and refresh
  autoSave();
  renderEvents();
  toast('Event unlinked from chain', 'success');
}

/**
 * v24.0: Preview all events that would be impacted by a linking rule
 */
function previewLinkingRuleImpacts(rule) {
  if (!rule || !rule.enabled) return [];
  
  const impactedEvents = [];
  
  // Find all events matching the trigger
  const triggerMatches = S.events.filter(evt => checkLinkingRuleTrigger(evt, rule.trigger));
  
  triggerMatches.forEach(triggerEvt => {
    const triggerIdx = S.events.indexOf(triggerEvt);
    if (triggerIdx === -1) return;
    
    const chain = [triggerEvt];
    let currentEvent = triggerEvt;
    
    // Try to find matches for each link in the chain
    for (const link of (rule.links || [])) {
      if (!link.type && !link.detail1 && !link.detail2) continue;
      
      const matchingLink = findMatchingEventForLink(currentEvent, link, rule.maxLookback || 10, 'forward');
      if (matchingLink) {
        chain.push(matchingLink);
        currentEvent = matchingLink;
      } else {
        const matchingLinkBackward = findMatchingEventForLink(currentEvent, link, rule.maxLookback || 10, 'backward');
        if (matchingLinkBackward) {
          chain.push(matchingLinkBackward);
          currentEvent = matchingLinkBackward;
        } else {
          break; // Chain incomplete
        }
      }
    }
    
    if (chain.length > 1) {
      impactedEvents.push({
        trigger: triggerEvt,
        triggerIdx: triggerIdx,
        chain: chain,
        chainIndices: chain.map(e => S.events.indexOf(e) + 1)
      });
    }
  });
  
  return impactedEvents;
}

/**
 * v24.0: Show preview of impacted events before applying linking rule
 */
function showLinkingRuleImpactPreview(rule, impactedEvents) {
  const modal = document.createElement('div');
  modal.id = 'linkingRuleImpactPreviewModal';
  modal.className = 'overlay show';
  modal.style.display = 'flex';
  
  const uniqueEvents = new Set();
  impactedEvents.forEach(impact => {
    impact.chain.forEach(e => uniqueEvents.add(S.events.indexOf(e)));
  });
  
  const uniqueCount = uniqueEvents.size;
  const ruleIdx = window.editingLinkingRuleIdx !== undefined ? window.editingLinkingRuleIdx : S.customLinkingRules.length - 1;
  
  const html = `
    <div class="modal" style="min-width:700px;max-width:900px;max-height:85vh;overflow-y:auto;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
        <h3 style="margin:0;">üîó Linking Rule Impact Preview</h3>
        <button onclick="closeLinkingRuleImpactPreview();return false;" style="background:none;border:none;font-size:18px;cursor:pointer;color:var(--muted);padding:0;width:24px;height:24px;line-height:1;" title="Close">√ó</button>
      </div>
      <div style="margin-bottom:12px;padding:8px;background:var(--panel);border-radius:4px;font-size:10px;">
        <strong>Summary:</strong>
        <ul style="margin:4px 0;padding-left:20px;">
          <li>${impactedEvents.length} complete chain(s) would be created</li>
          <li>${uniqueCount} unique event(s) would be linked</li>
          <li>${impactedEvents.filter(i => i.chain.length > 2).length} chain(s) with 3+ events</li>
        </ul>
      </div>
      <div style="margin-bottom:12px;">
        <label style="font-size:10px;display:flex;align-items:center;gap:4px;">
          <input type="checkbox" id="skipReviewCheckbox" style="margin:0;">
          Skip review in future (apply rules immediately when saved)
        </label>
      </div>
      <div style="max-height:50vh;overflow-y:auto;border:1px solid var(--border);border-radius:4px;padding:8px;background:var(--card);">
        <strong style="font-size:11px;display:block;margin-bottom:8px;">Impacted Events:</strong>
        <div style="font-size:9px;display:flex;flex-direction:column;gap:4px;">
          ${impactedEvents.slice(0, 50).map((impact, i) => {
            const chainDesc = impact.chain.map((e, j) => {
              const idx = S.events.indexOf(e);
              const p1 = (e.players || []).find(p => p.role === 'event_player_1');
              const p1Name = p1 ? ` #${p1.num}` : '';
              return `<strong>${e.type}${e.detail1 ? ':' + e.detail1 : ''}</strong>${p1Name} (#${idx + 1})`;
            }).join(' ‚Üí ');
            return `<div style="padding:6px;background:var(--bg);border-radius:3px;border-left:3px solid var(--accent);">
              <div><strong>Chain ${i + 1}:</strong> ${chainDesc}</div>
            </div>`;
          }).join('')}
          ${impactedEvents.length > 50 ? `<div style="padding:6px;color:var(--muted);font-size:8px;">... and ${impactedEvents.length - 50} more chains</div>` : ''}
        </div>
      </div>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:16px;padding-top:16px;border-top:1px solid var(--border);">
        <button class="btn-sm" onclick="closeLinkingRuleImpactPreview()">Cancel</button>
        <button class="btn-sm btn-success" onclick="confirmApplyLinkingRuleToAllEvents(${ruleIdx});closeLinkingRuleImpactPreview();">Apply Rule to All Events</button>
      </div>
    </div>
  `;
  
  modal.innerHTML = html;
  modal.onclick = function(e) {
    if (e.target === modal) closeLinkingRuleImpactPreview();
  };
  document.body.appendChild(modal);
  
  // Store skip review preference
  const checkbox = document.getElementById('skipReviewCheckbox');
  if (checkbox) {
    checkbox.addEventListener('change', function() {
      localStorage.setItem('bs_skip_linking_review', this.checked ? 'true' : 'false');
    });
  }
}

/**
 * v24.0: Close linking rule impact preview modal
 */
function closeLinkingRuleImpactPreview() {
  const modal = document.getElementById('linkingRuleImpactPreviewModal');
  if (modal) {
    modal.remove();
  }
}

/**
 * v24.0: Remove all links from all events
 */
function removeAllLinks() {
  const linkedCount = S.events.filter(e => e.linkedEventIdx !== null && e.linkedEventIdx !== undefined).length;
  
  if (linkedCount === 0) {
    toast('No links found to remove', 'info');
    return;
  }
  
  if (!confirm(`Remove all links from ${linkedCount} event(s)? This cannot be undone.`)) {
    return;
  }
  
  // Track undo state
  pushUndoState('Remove all links');
  
  // Remove all links
  S.events.forEach(evt => {
    if (evt.linkedEventIdx !== null && evt.linkedEventIdx !== undefined) {
      evt.linkedEventIdx = null;
    }
  });
  
  renderEvents();
  autoSave();
  toast(`Removed links from ${linkedCount} event(s)`, 'success');
}

/**
 * v24.0: Open modal to remove links by condition
 */
function openRemoveLinksByCondition() {
  const modal = document.createElement('div');
  modal.id = 'removeLinksByConditionModal';
  modal.className = 'overlay show';
  modal.style.display = 'flex';
  
  const eventTypeOptions = S.eventTypesDB.length > 0
    ? S.eventTypesDB.map(e => `<option value="${e.code || e.name}">${e.code || e.name}</option>`).join('')
    : (LISTS.eventTypes || []).map(t => `<option value="${t}">${t}</option>`).join('');
  
  const html = `
    <div class="modal" style="min-width:600px;max-width:700px;max-height:80vh;overflow-y:auto;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
        <h3 style="margin:0;">üîß Remove Links by Condition</h3>
        <button onclick="closeRemoveLinksByCondition();return false;" style="background:none;border:none;font-size:18px;cursor:pointer;color:var(--muted);padding:0;width:24px;height:24px;line-height:1;" title="Close">√ó</button>
      </div>
      <p style="font-size:10px;color:var(--muted);margin:8px 0;">Remove links from events matching these conditions:</p>
      
      <div style="margin:16px 0;padding:12px;background:var(--panel);border-radius:4px;">
        <div class="form-group">
          <label>Event Type</label>
          <select id="removeLinkEventType" style="width:100%;">
            <option value="">-- Any Event Type --</option>
            ${eventTypeOptions}
          </select>
        </div>
        <div class="form-group">
          <label>Detail1</label>
          <input type="text" id="removeLinkDetail1" placeholder="e.g., Pass_Completed" style="width:100%;">
        </div>
        <div class="form-group">
          <label>Detail2</label>
          <input type="text" id="removeLinkDetail2" placeholder="e.g., Shot-Wrist" style="width:100%;">
        </div>
        <div class="form-group">
          <label>Team</label>
          <select id="removeLinkTeam" style="width:100%;">
            <option value="">-- Any Team --</option>
            <option value="home">Home</option>
            <option value="away">Away</option>
          </select>
        </div>
        <div class="form-group">
          <label>Linked Index (optional)</label>
          <input type="number" id="removeLinkLinkedIdx" placeholder="Remove from specific linked index" min="1" style="width:100%;">
        </div>
      </div>
      
      <div style="margin:16px 0;padding:8px;background:var(--warn-bg);border-radius:4px;font-size:9px;color:var(--muted);">
        <strong>‚ö†Ô∏è Warning:</strong> This action cannot be undone. Consider using Undo (Ctrl+Z / Cmd+Z) if you make a mistake.
      </div>
      
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:16px;padding-top:16px;border-top:1px solid var(--border);">
        <button class="btn-sm" onclick="closeRemoveLinksByCondition()">Cancel</button>
        <button class="btn-sm btn-danger" onclick="executeRemoveLinksByCondition();closeRemoveLinksByCondition();">Remove Links</button>
      </div>
    </div>
  `;
  
  modal.innerHTML = html;
  modal.onclick = function(e) {
    if (e.target === modal) closeRemoveLinksByCondition();
  };
  document.body.appendChild(modal);
}

/**
 * v24.0: Close remove links by condition modal
 */
function closeRemoveLinksByCondition() {
  const modal = document.getElementById('removeLinksByConditionModal');
  if (modal) {
    modal.remove();
  }
}

/**
 * v24.0: Execute link removal based on conditions
 */
function executeRemoveLinksByCondition() {
  const eventType = document.getElementById('removeLinkEventType').value || '';
  const detail1 = document.getElementById('removeLinkDetail1').value.trim() || '';
  const detail2 = document.getElementById('removeLinkDetail2').value.trim() || '';
  const team = document.getElementById('removeLinkTeam').value || '';
  const linkedIdxStr = document.getElementById('removeLinkLinkedIdx').value.trim();
  const linkedIdx = linkedIdxStr ? parseInt(linkedIdxStr) - 1 : null; // Convert from 1-based to 0-based
  
  // Find matching events
  const matchingEvents = S.events.filter(evt => {
    // Check if event has a link
    if (evt.linkedEventIdx === null || evt.linkedEventIdx === undefined) return false;
    
    // Check conditions
    if (eventType && evt.type !== eventType) return false;
    if (detail1 && (!evt.detail1 || !evt.detail1.includes(detail1))) return false;
    if (detail2 && (!evt.detail2 || !evt.detail2.includes(detail2))) return false;
    if (team && evt.team !== team) return false;
    if (linkedIdx !== null && evt.linkedEventIdx !== linkedIdx) return false;
    
    return true;
  });
  
  if (matchingEvents.length === 0) {
    toast('No events match the specified conditions', 'info');
    return;
  }
  
  if (!confirm(`Remove links from ${matchingEvents.length} event(s) matching these conditions? This cannot be undone.`)) {
    return;
  }
  
  // Track undo state
  pushUndoState(`Remove links from ${matchingEvents.length} events`);
  
  // Remove links from matching events
  matchingEvents.forEach(evt => {
    evt.linkedEventIdx = null;
  });
  
  renderEvents();
  autoSave();
  toast(`Removed links from ${matchingEvents.length} event(s)`, 'success');
}

/**
 * v24.0: Confirm and apply linking rule to all events
 */
function confirmApplyLinkingRuleToAllEvents(ruleIdx) {
  const rule = S.customLinkingRules[ruleIdx];
  if (!rule || !rule.enabled) return;
  
  applyLinkingRuleToAllEvents(rule);
  toast(`Linking rule applied to all events`, 'success');
}

/**
 * v24.0: Apply linking rule to all existing events
 */
function applyLinkingRuleToAllEvents(rule) {
  if (!rule || !rule.enabled) return;
  
  let appliedCount = 0;
  
  // Process all events
  for (let i = 0; i < S.events.length; i++) {
    const evt = S.events[i];
    if (!evt) continue;
    
    // Check if event matches trigger
    if (checkLinkingRuleTrigger(evt, rule.trigger)) {
      // Process link chain
      let currentEvent = evt;
      let linkedIdx = currentEvent.linkedEventIdx !== null ? currentEvent.linkedEventIdx : getNextLinkedEventIdx();
      
      for (const link of (rule.links || [])) {
        const matchingEvent = findMatchingEventForLink(currentEvent, link, rule.maxLookback || 10, 'forward');
        if (!matchingEvent) {
          // Try backward if forward didn't work
          const matchingEventBackward = findMatchingEventForLink(currentEvent, link, rule.maxLookback || 10, 'backward');
          if (matchingEventBackward) {
            if (matchingEventBackward.linkedEventIdx === null || matchingEventBackward.linkedEventIdx === undefined) {
              matchingEventBackward.linkedEventIdx = linkedIdx;
            }
            currentEvent.linkedEventIdx = linkedIdx;
            
            if (link.swapTeams) {
              swapTeamsForPlayers(currentEvent, matchingEventBackward);
            }
            
            appliedCount++;
            currentEvent = matchingEventBackward;
          } else {
            break;
          }
        } else {
          if (matchingEvent.linkedEventIdx === null || matchingEvent.linkedEventIdx === undefined) {
            matchingEvent.linkedEventIdx = linkedIdx;
          }
          currentEvent.linkedEventIdx = linkedIdx;
          
          if (link.swapTeams) {
            swapTeamsForPlayers(currentEvent, matchingEvent);
          }
          
          appliedCount++;
          currentEvent = matchingEvent;
        }
      }
    }
  }
  
  if (appliedCount > 0) {
    renderEvents();
    autoSave();
    toast(`Applied linking rule to ${appliedCount} event(s)`, 'success');
  }
}

/**
 * v24.0: Check if text matches pattern (supports %{text}% pattern matching)
 */
function matchesPattern(text, pattern) {
  if (!pattern) return true; // Empty pattern matches anything
  if (!text) return false; // No text to match
  
  // Check for pattern matching syntax %{text}%
  if (pattern.includes('%{') && pattern.includes('}%')) {
    const matchText = pattern.match(/%\{(.+?)\}%/);
    if (matchText) {
      return text.toLowerCase().includes(matchText[1].toLowerCase());
    }
  }
  
  // Exact match or contains match
  return text.includes(pattern);
}

/**
 * v24.0: Check if event matches linking rule trigger (enhanced with pattern matching)
 */
function checkLinkingRuleTrigger(evt, trigger) {
  if (trigger.type && evt.type !== trigger.type) return false;
  if (trigger.detail1 && evt.detail1 && !matchesPattern(evt.detail1, trigger.detail1)) return false;
  if (trigger.detail2 && evt.detail2 && !matchesPattern(evt.detail2, trigger.detail2)) return false;
  if (trigger.team && evt.team !== trigger.team) return false;
  if (trigger.zone && evt.zone !== trigger.zone) return false;
  return true;
}

/**
 * v24.0: Find matching event to link to based on rule (enhanced with pattern matching)
 */
function findMatchingEventForLink(evt, linkTo, maxLookback, preferredDirection) {
  if (!linkTo.type && !linkTo.detail1 && !linkTo.detail2) {
    // No criteria specified - don't link
    return null;
  }
  
  const evtIdx = evt.idx;
  const direction = preferredDirection || linkTo.direction || 'forward';
  
  if (direction === 'forward' || direction === 'both') {
    // Look forward (future events)
    for (let i = evtIdx + 1; i < Math.min(evtIdx + 1 + maxLookback, S.events.length); i++) {
      const candidate = S.events[i];
      if (!candidate) continue;
      
      if (linkTo.type && candidate.type !== linkTo.type) continue;
      if (linkTo.detail1 && candidate.detail1 && !matchesPattern(candidate.detail1, linkTo.detail1)) continue;
      if (linkTo.detail2 && candidate.detail2 && !matchesPattern(candidate.detail2, linkTo.detail2)) continue;
      
      return candidate;
    }
  }
  
  if (direction === 'backward' || direction === 'both') {
    // Look backward (past events)
    for (let i = evtIdx - 1; i >= Math.max(0, evtIdx - maxLookback); i--) {
      const candidate = S.events[i];
      if (!candidate) continue;
      
      if (linkTo.type && candidate.type !== linkTo.type) continue;
      if (linkTo.detail1 && candidate.detail1 && !matchesPattern(candidate.detail1, linkTo.detail1)) continue;
      if (linkTo.detail2 && candidate.detail2 && !matchesPattern(candidate.detail2, linkTo.detail2)) continue;
      
      return candidate;
    }
  }
  
  return null;
}

/**
 * v24.0: Swap teams for player mapping (event_player_1 ‚Üí opp_player_1, etc.)
 */
function swapTeamsForPlayers(sourceEvent, targetEvent) {
  if (!sourceEvent.players || !targetEvent.players) return;
  
  // Map players from source to target with team swap
  sourceEvent.players.forEach((sourcePlayer, idx) => {
    if (sourcePlayer.role && sourcePlayer.role.startsWith('event_')) {
      // Find corresponding player on target event
      const targetPlayer = targetEvent.players.find(p => 
        p.role && p.role.startsWith('opp_') && 
        (p.role.includes('player_1') && sourcePlayer.role.includes('player_1') ||
         p.role.includes('player_2') && sourcePlayer.role.includes('player_2'))
      );
      
      if (targetPlayer) {
        // Copy player data but keep opposite team role
        targetPlayer.num = sourcePlayer.num;
        targetPlayer.name = sourcePlayer.name;
        targetPlayer.team = sourcePlayer.team === 'home' ? 'away' : 'home';
        // Copy XY if exists
        if (sourcePlayer.xy) {
          targetPlayer.xy = JSON.parse(JSON.stringify(sourcePlayer.xy));
        }
      } else {
        // Create new opp player if doesn't exist
        const roleNum = sourcePlayer.role.match(/player_(\d+)/);
        if (roleNum) {
          const newPlayer = {
            num: sourcePlayer.num,
            name: sourcePlayer.name,
            team: sourcePlayer.team === 'home' ? 'away' : 'home',
            role: `opp_team_player_${roleNum[1]}`,
            xy: sourcePlayer.xy ? JSON.parse(JSON.stringify(sourcePlayer.xy)) : []
          };
          targetEvent.players.push(newPlayer);
        }
      }
    }
  });
}

/**
 * v23.9: Apply custom rules to an event
 */
function applyCustomRules(evt) {
  if (!S.customRules || S.customRules.length === 0) return;
  
  for (const rule of S.customRules) {
    if (!rule.enabled) continue;
    
    // Check if rule matches
    if (rule.trigger.type && evt.type !== rule.trigger.type) continue;
    if (rule.trigger.detail1 && (!evt.detail1 || !evt.detail1.includes(rule.trigger.detail1))) continue;
    if (rule.trigger.detail2 && (!evt.detail2 || !evt.detail2.includes(rule.trigger.detail2))) continue;
    
    // Apply actions
    for (const action of (rule.actions || [])) {
      if (action.field === 'zone') {
        evt.zone = action.value;
        if (document.getElementById('evtZone')) document.getElementById('evtZone').value = action.value;
      } else if (action.field === 'success') {
        evt.success = action.value;
        if (document.getElementById('evtSuccess')) document.getElementById('evtSuccess').value = action.value;
      } else if (action.field === 'detail1') {
        evt.detail1 = action.value;
        if (document.getElementById('evtD1')) document.getElementById('evtD1').value = action.value;
      } else if (action.field === 'detail2') {
        evt.detail2 = action.value;
        if (document.getElementById('evtD2')) document.getElementById('evtD2').value = action.value;
      }
    }
  }
}

/**
 * v23.9: Apply cross-event rules (e.g., if next is giveaway, previous is unsuccessful)
 */
function applyCrossEventRules(loggedEventIdx) {
  if (!S.customRules || S.customRules.length === 0) return;
  
  const loggedEvent = S.events[loggedEventIdx];
  if (!loggedEvent) return;
  
  // Find previous event
  const prevEventIdx = loggedEventIdx - 1;
  if (prevEventIdx < 0) return;
  const prevEvent = S.events[prevEventIdx];
  if (!prevEvent) return;
  
  // Check all rules for cross-event rules
  for (const rule of S.customRules) {
    if (!rule.enabled || !rule.crossEventRules || rule.crossEventRules.length === 0) continue;
    
    for (const crossRule of rule.crossEventRules) {
      // Check if logged event matches the "next" condition
      if (crossRule.ifNextType && loggedEvent.type !== crossRule.ifNextType) continue;
      if (crossRule.ifNextDetail1 && (!loggedEvent.detail1 || !loggedEvent.detail1.includes(crossRule.ifNextDetail1))) continue;
      
      // Set previous event's success
      prevEvent.success = crossRule.setPrevSuccess;
      
      toast(`Cross-event rule: Previous event #${prevEventIdx + 1} set to ${crossRule.setPrevSuccess === 'u' ? 'unsuccessful' : 'successful'}`, 'info');
    }
  }
}

// ============================================================
// EDIT SHIFT PLAYERS
// ============================================================
function editShiftPlayers(shiftIdx) {
  S.editingShiftIdx = shiftIdx;
  const shift = S.shifts[shiftIdx];
  if (!shift) return;
  
  // Open edit shift modal with player editing capability
  document.getElementById('editShiftIdx').textContent = shiftIdx + 1;
  document.getElementById('editShiftPeriod').value = shift.period;
  document.getElementById('editShiftStartTime').value = shift.start_time || '';
  document.getElementById('editShiftEndTime').value = shift.end_time || '';
  document.getElementById('editShiftStartType').value = shift.start_type || '';
  document.getElementById('editShiftStopType').value = shift.stop_type || '';
  document.getElementById('editShiftStrength').value = shift.strength || '5v5';
  
  // Render player slots in edit modal
  renderEditShiftPlayers(shift);
  
  const shiftModal = document.getElementById('editShiftModal');
  if (!shiftModal) {
    console.error('editShiftModal element not found!');
    toast('Edit shift modal not found. Please refresh the page.', 'error');
    return;
  }
  
  shiftModal.classList.add('show');
  console.log('Edit shift modal opened - show class added');
  
  // Double-check modal is visible
  if (!shiftModal.classList.contains('show')) {
    console.error('Failed to add show class to editShiftModal');
    shiftModal.classList.add('show');
  }
}

function renderEditShiftPlayers(shift) {
  const container = document.getElementById('editShiftPlayersContainer');
  if (!container) return;
  
  // Build player options for each team
  const buildPlayerOptions = (team, currentNum) => {
    const roster = S.rosters[team] || [];
    // Convert currentNum to string for comparison (Excel imports as number, roster might be string)
    const currentNumStr = currentNum != null ? String(currentNum) : '';
    
    // If roster is empty but we have a current number, show it as an option
    if (roster.length === 0 && currentNumStr) {
      return `<option value="">--</option><option value="${currentNumStr}" selected>#${currentNumStr}</option>`;
    }
    
    return `<option value="">--</option>` + roster.map(p => {
      const numStr = String(p.num);
      const selected = numStr === currentNumStr ? 'selected' : '';
      return `<option value="${numStr}" ${selected}>#${p.num} ${p.name?.split(' ').pop() || ''}</option>`;
    }).join('');
  };
  
  let html = '<div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;">';
  
  // Home players
  html += `<div>
    <div style="font-size:10px;font-weight:bold;color:var(--home);margin-bottom:6px;border-bottom:1px solid var(--home);padding-bottom:2px;">HOME</div>
    <div style="display:grid;gap:4px;">`;
  
  // Forwards
  html += `<div style="font-size:8px;color:var(--muted);margin-top:4px;">Forwards</div>`;
  ['F1','F2','F3'].forEach(pos => {
    const p = shift.home?.[pos];
    html += `<div style="display:flex;align-items:center;gap:4px;">
      <span style="width:20px;font-size:9px;color:var(--accent);">${pos}</span>
      <select onchange="updateShiftPlayer('home','${pos}',this.value)" style="flex:1;font-size:9px;padding:2px;">
        ${buildPlayerOptions('home', p?.num)}
      </select>
    </div>`;
  });
  
  // Defense
  html += `<div style="font-size:8px;color:var(--muted);margin-top:4px;">Defense</div>`;
  ['D1','D2'].forEach(pos => {
    const p = shift.home?.[pos];
    html += `<div style="display:flex;align-items:center;gap:4px;">
      <span style="width:20px;font-size:9px;color:var(--accent);">${pos}</span>
      <select onchange="updateShiftPlayer('home','${pos}',this.value)" style="flex:1;font-size:9px;padding:2px;">
        ${buildPlayerOptions('home', p?.num)}
      </select>
    </div>`;
  });
  
  // Goalie & Extra
  html += `<div style="font-size:8px;color:var(--muted);margin-top:4px;">Goalie / Extra</div>`;
  ['G','X'].forEach(pos => {
    const p = shift.home?.[pos];
    html += `<div style="display:flex;align-items:center;gap:4px;">
      <span style="width:20px;font-size:9px;color:var(--accent);">${pos}</span>
      <select onchange="updateShiftPlayer('home','${pos}',this.value)" style="flex:1;font-size:9px;padding:2px;">
        ${buildPlayerOptions('home', p?.num)}
      </select>
    </div>`;
  });
  
  html += '</div></div>';
  
  // Away players  
  html += `<div>
    <div style="font-size:10px;font-weight:bold;color:var(--away);margin-bottom:6px;border-bottom:1px solid var(--away);padding-bottom:2px;">AWAY</div>
    <div style="display:grid;gap:4px;">`;
  
  // Forwards
  html += `<div style="font-size:8px;color:var(--muted);margin-top:4px;">Forwards</div>`;
  ['F1','F2','F3'].forEach(pos => {
    const p = shift.away?.[pos];
    html += `<div style="display:flex;align-items:center;gap:4px;">
      <span style="width:20px;font-size:9px;color:var(--accent);">${pos}</span>
      <select onchange="updateShiftPlayer('away','${pos}',this.value)" style="flex:1;font-size:9px;padding:2px;">
        ${buildPlayerOptions('away', p?.num)}
      </select>
    </div>`;
  });
  
  // Defense
  html += `<div style="font-size:8px;color:var(--muted);margin-top:4px;">Defense</div>`;
  ['D1','D2'].forEach(pos => {
    const p = shift.away?.[pos];
    html += `<div style="display:flex;align-items:center;gap:4px;">
      <span style="width:20px;font-size:9px;color:var(--accent);">${pos}</span>
      <select onchange="updateShiftPlayer('away','${pos}',this.value)" style="flex:1;font-size:9px;padding:2px;">
        ${buildPlayerOptions('away', p?.num)}
      </select>
    </div>`;
  });
  
  // Goalie & Extra
  html += `<div style="font-size:8px;color:var(--muted);margin-top:4px;">Goalie / Extra</div>`;
  ['G','X'].forEach(pos => {
    const p = shift.away?.[pos];
    html += `<div style="display:flex;align-items:center;gap:4px;">
      <span style="width:20px;font-size:9px;color:var(--accent);">${pos}</span>
      <select onchange="updateShiftPlayer('away','${pos}',this.value)" style="flex:1;font-size:9px;padding:2px;">
        ${buildPlayerOptions('away', p?.num)}
      </select>
    </div>`;
  });
  
  html += '</div></div></div>';
  
  container.innerHTML = html;
}

/**
 * Update a player in the shift being edited
 */
function updateShiftPlayer(team, pos, playerNum) {
  if (S.editingShiftIdx === null) return;
  const shift = S.shifts[S.editingShiftIdx];
  
  if (!shift[team]) shift[team] = {};
  
  if (playerNum) {
    // Find player in roster
    const roster = S.rosters[team] || [];
    const player = roster.find(p => p.num === playerNum);
    shift[team][pos] = player ? { num: player.num, name: player.name } : { num: playerNum };
  } else {
    shift[team][pos] = null;
  }
  
  // Update strength
  shift.strength = deriveStrengthFromShift(shift);
  document.getElementById('editShiftStrength').value = shift.strength;
}

/**
 * Derive strength from shift player counts
 */
function deriveStrengthFromShift(shift) {
  const countPlayers = (team) => {
    let count = 0;
    ['F1','F2','F3','D1','D2','X'].forEach(pos => {
      if (shift[team]?.[pos]?.num) count++;
    });
    return count;
  };
  
  const homeSkaters = countPlayers('home');
  const awaySkaters = countPlayers('away');
  
  // Check for empty net
  const homeEN = !shift.home?.G?.num;
  const awayEN = !shift.away?.G?.num;
  
  if (homeEN || awayEN) return 'ENG';
  if (homeSkaters === awaySkaters) return `${homeSkaters}v${awaySkaters}`;
  return `${homeSkaters}v${awaySkaters}`;
}

// ============================================================
// RENDER ALL (utility)
// ============================================================
// (renderAll is defined earlier - this is a comment placeholder)
// ============================================================

// ============================================================
// EDIT MODAL AUTO-CALCULATE FUNCTIONS
// ============================================================

/**
 * Auto-calculate zone from event's puckXY or player XY
 */
function autoEditZone() {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  
  // Get XY from puckXY or event_player_1
  let lastXY = null;
  if (evt.puckXY?.length) {
    lastXY = evt.puckXY[evt.puckXY.length - 1];
  } else {
    const evtP1 = (evt.players || []).find(p => 
      p.role === 'event_team_player_1' || p.role === 'event_player_1' || p.roleNum === 1
    );
    if (evtP1?.xy?.length) {
      lastXY = evtP1.xy[evtP1.xy.length - 1];
    }
  }
  
  if (!lastXY) {
    toast('Add XY coordinates to auto-detect zone', 'error');
    return;
  }
  
  // Calculate zone from X position
  const x = lastXY.x;
  const period = evt.period || 1;
  const isOddPeriod = period === 1 || period === 3 || period === 'OT';
  const homeOffensiveRight = isOddPeriod ? S.homeAttacksRightP1 : !S.homeAttacksRightP1;
  const team = evt.team || 'home';
  
  let zone = '';
  if (team === 'home') {
    if (homeOffensiveRight) {
      if (x > 125) zone = 'o';
      else if (x < 75) zone = 'd';
      else zone = 'n';
    } else {
      if (x < 75) zone = 'o';
      else if (x > 125) zone = 'd';
      else zone = 'n';
    }
  } else {
    if (homeOffensiveRight) {
      if (x < 75) zone = 'o';
      else if (x > 125) zone = 'd';
      else zone = 'n';
    } else {
      if (x > 125) zone = 'o';
      else if (x < 75) zone = 'd';
      else zone = 'n';
    }
  }
  
  document.getElementById('editZone').value = zone;
  toast(`Zone: ${zone === 'o' ? 'Offensive' : zone === 'd' ? 'Defensive' : 'Neutral'}`, 'success');
}

/**
 * Auto-calculate success from event type and detail
 */
function autoEditSuccess() {
  if (S.editingEvtIdx === null) return;
  
  const type = document.getElementById('editType').value;
  const d1 = document.getElementById('editD1').value;
  
  let success = '';
  
  if (type === 'Shot') {
    if (d1.includes('OnNet') || d1.includes('Goal')) success = 's';
    else if (d1.includes('Missed') || d1.includes('Blocked')) success = 'u';
  } else if (type === 'Pass') {
    if (d1.includes('Completed')) success = 's';
    else if (d1.includes('Missed') || d1.includes('Intercepted')) success = 'u';
  } else if (type === 'Zone_Entry_Exit') {
    if (d1.includes('Failed')) success = 'u';
    else if (d1.includes('Entry') || d1.includes('Exit') || d1.includes('Keepin')) success = 's';
  } else if (type === 'Turnover') {
    if (d1.includes('Takeaway')) success = 's';
    else if (d1.includes('Giveaway')) success = 'u';
  } else if (type === 'Goal' || type === 'Save') {
    success = 's';
  } else if (type === 'Faceoff') {
    if (d1.includes('Won')) success = 's';
    else if (d1.includes('Lost')) success = 'u';
  }
  
  if (success) {
    document.getElementById('editSuccess').value = success;
    toast(`Success: ${success === 's' ? 'Successful' : 'Unsuccessful'}`, 'success');
  } else {
    toast('Could not auto-derive success from type/detail', 'warning');
  }
}

/**
 * Auto-calculate strength from shift at event time
 */
function autoEditStrength() {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  
  // Find the shift that contains this event's time
  const eventTime = evt.start_time || evt.time;
  const eventPeriod = evt.period;
  
  const shift = S.shifts.find(s => 
    s.period === eventPeriod && isTimeBetween(eventTime, s.start_time, s.end_time)
  );
  
  if (shift) {
    const strength = deriveStrengthFromShift(shift);
    if (strength) {
      document.getElementById('editStrength').value = strength;
      toast(`Strength: ${strength} (from shift)`, 'success');
      return;
    }
  }
  
  // Fallback to current slot configuration
  const strength = deriveStrength();
  if (strength) {
    document.getElementById('editStrength').value = strength;
    toast(`Strength: ${strength} (from current slots)`, 'success');
  } else {
    toast('Could not determine strength', 'warning');
  }
}

function saveEditEvent() {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  const currentIdx = S.editingEvtIdx;
  
  // Helper to parse time string (MM:SS) to seconds (clock counts down)
  const parseTime = (timeStr) => {
    if (!timeStr) return null;
    const [min, sec] = timeStr.split(':').map(Number);
    return (min || 0) * 60 + (sec || 0);
  };
  
  // Helper to format seconds back to MM:SS
  const formatTime = (seconds) => {
    if (seconds === null || seconds === undefined) return '';
    const min = Math.floor(seconds / 60);
    const sec = seconds % 60;
    return `${min}:${String(sec).padStart(2, '0')}`;
  };
  
  // Get old values before updating
  const oldStartTime = evt.start_time;
  const oldEndTime = evt.end_time;
  
  // Get new values from form
  const newStartTime = document.getElementById('editStartTime').value;
  const newEndTime = document.getElementById('editEndTime').value;
  
  evt.type = document.getElementById('editType').value;
  evt.team = document.getElementById('editTeam').value;
  evt.start_time = newStartTime;
  evt.end_time = newEndTime;
  evt.zone = document.getElementById('editZone').value;
  evt.success = document.getElementById('editSuccess').value;
  evt.strength = document.getElementById('editStrength').value;
  evt.detail1 = document.getElementById('editD1').value;
  evt.detail2 = document.getElementById('editD2').value;
  evt.isHighlight = document.getElementById('editHighlight').checked;
  let editVideoUrl = evt.isHighlight ? (document.getElementById('editVideoUrl').value.trim() || '') : '';
  
  // v23.9: If highlight but no videoUrl, use main YouTube link with start time
  if (evt.isHighlight && !editVideoUrl && S.videoTiming?.youtubeUrl) {
    const runningVideoTime = calculateRunningVideoTime(evt.period, evt.start_time);
    const startTimeSeconds = Math.max(0, runningVideoTime - 10); // 10 seconds before event
    editVideoUrl = buildYouTubeUrlWithTime(S.videoTiming.youtubeUrl, startTimeSeconds);
  }
  
  evt.videoUrl = evt.isHighlight ? (editVideoUrl || undefined) : undefined;  // v23.7: Individual highlight video URL
  
  // v23.9: Sync adjacent events when times change (if within 2 seconds)
  // If end time changed, check if next event's start time is within 2 seconds
  if (oldEndTime !== newEndTime && newEndTime) {
    const nextEvt = currentIdx < S.events.length - 1 ? S.events[currentIdx + 1] : null;
    if (nextEvt && nextEvt.period === evt.period) {
      // Only sync if they're in the same period
      const currentEndSec = parseTime(newEndTime);
      const nextStartSec = parseTime(nextEvt.start_time);
      
      if (currentEndSec !== null && nextStartSec !== null) {
        // Calculate time difference (clock counts down, so end time should be >= start time)
        // If end is 19:32 (1172 sec) and next start is 19:32 (1172 sec), diff = 0
        // If end is 19:32 (1172 sec) and next start is 19:31 (1171 sec), diff = 1
        // If end is 19:32 (1172 sec) and next start is 19:30 (1170 sec), diff = 2
        const timeDiff = Math.abs(currentEndSec - nextStartSec);
        
        if (timeDiff <= 2) {
          // Within 2 seconds - sync the next event's start time
          nextEvt.start_time = newEndTime;
          toast(`Updated event #${currentIdx + 2} start time to ${newEndTime}`, 'info');
        }
      }
    }
  }
  
  // If start time changed, check if previous event's end time is within 2 seconds
  if (oldStartTime !== newStartTime && newStartTime) {
    const prevEvt = currentIdx > 0 ? S.events[currentIdx - 1] : null;
    if (prevEvt && prevEvt.period === evt.period) {
      // Only sync if they're in the same period
      const currentStartSec = parseTime(newStartTime);
      const prevEndSec = parseTime(prevEvt.end_time);
      
      if (currentStartSec !== null && prevEndSec !== null) {
        // Calculate time difference
        const timeDiff = Math.abs(prevEndSec - currentStartSec);
        
        if (timeDiff <= 2) {
          // Within 2 seconds - sync the previous event's end time
          prevEvt.end_time = newStartTime;
          toast(`Updated event #${currentIdx} end time to ${newStartTime}`, 'info');
        }
      }
    }
  }
  
  // v23.9: Propagate XY data to all linked events when saving
  if (evt.linkedEventIdx !== null && evt.linkedEventIdx !== undefined) {
    propagateXYToLinkedEvents();
  }
  
  // Save linked event index (convert from 1-based to 0-based)
  // v24.0: Track state before propagating linked index change for undo
  const linkedIdxEl = document.getElementById('editLinkedIdx');
  if (linkedIdxEl) {
    const linkedVal = linkedIdxEl.value ? parseInt(linkedIdxEl.value) - 1 : null;
    const oldLinkedIdx = evt.linkedEventIdx;
    
    if (linkedVal !== null && linkedVal >= 0) {
      // v24.0: Track undo state before propagating linked index change
      if (oldLinkedIdx !== linkedVal) {
        // Store undo state for linked event changes
        pushUndoState('Linked event index change');
      }
      
      // Propagate the change to all events in the chain
      propagateLinkedIndexChange(evt.idx, linkedVal);
    } else {
      // v24.0: Track undo state before removing link
      if (oldLinkedIdx !== null && oldLinkedIdx !== undefined) {
        pushUndoState('Remove event link');
      }
      evt.linkedEventIdx = null;
    }
  }
  
  // v23.8: Save assist-to-goal link (convert from 1-based to 0-based)
  const assistToGoalEl = document.getElementById('editAssistToGoalIdx');
  if (assistToGoalEl && assistToGoalEl.offsetParent !== null) { // Only if visible
    const goalVal = assistToGoalEl.value ? parseInt(assistToGoalEl.value) - 1 : null;
    if (goalVal !== null && goalVal >= 0) {
      const goalEvent = S.events[goalVal];
      if (goalEvent && goalEvent.type === 'Goal' && goalEvent.detail1 === 'Goal_Scored') {
        evt.assistToGoalIdx = goalVal;
        // Also mark as assist if not already marked
        const player = evt.players?.find(p => 
          p.role === 'event_player_1' || p.role === 'event_team_player_1'
        );
        if (player) {
          const pd1 = (player.playD1 || '').toLowerCase();
          const pd2 = (player.playD2 || '').toLowerCase();
          if (!pd1.includes('assist') && !pd2.includes('assist')) {
            player.playD1 = player.playD1 ? player.playD1 + ', AssistPrimary' : 'AssistPrimary';
          }
        }
      } else {
        toast('Invalid goal event number', 'error');
        return;
      }
    } else {
      evt.assistToGoalIdx = null;
    }
  }
  
  // v23.8: Save event_id, sequence_key, and play_key (editable fields)
  const eventIdEl = document.getElementById('editEventId');
  if (eventIdEl) {
    const eventIdVal = eventIdEl.value.trim();
    evt.eventId = eventIdVal || undefined;
    evt.event_id = eventIdVal || undefined; // Support both naming conventions
  }
  
  const seqKeyEl = document.getElementById('editSeqKey');
  if (seqKeyEl) {
    const seqKeyVal = seqKeyEl.value.trim();
    if (seqKeyVal) {
      evt.sequenceIdx = seqKeyVal;
      evt.seqIdx = seqKeyVal;
      evt.sequence_key = seqKeyVal;
      evt.sequence_id = seqKeyVal; // Support sequence_id as well
    } else {
      evt.sequenceIdx = undefined;
      evt.seqIdx = undefined;
      evt.sequence_key = undefined;
      evt.sequence_id = undefined;
    }
  }
  
  const playKeyEl = document.getElementById('editPlayKey');
  if (playKeyEl) {
    const playKeyVal = playKeyEl.value.trim();
    if (playKeyVal) {
      evt.playIdx = playKeyVal;
      evt.play_key = playKeyVal;
      evt.play_id = playKeyVal; // Support play_id as well
    } else {
      evt.playIdx = undefined;
      evt.play_key = undefined;
      evt.play_id = undefined;
    }
  }
  
  // v24.0: Clean up empty XY arrays - if arrays exist but are empty, set to empty array explicitly
  if (evt.puckXY && evt.puckXY.length === 0) {
    evt.puckXY = [];
  }
  if (evt.players) {
    evt.players.forEach(p => {
      if (p.xy && p.xy.length === 0) {
        p.xy = [];
      }
    });
  }
  
  markDataChanged();
  closeEditModal();
  renderEvents(); updateScores(); updateBoxScore();
  autoSave();
  toast('Event updated', 'success');
}

function deleteEvent() {
  if (S.editingEvtIdx === null) return;
  
  // Prompt to save if there are unsaved changes
  if (hasUnsavedChanges()) {
    const shouldSave = confirm('You have unsaved changes. Save before deleting?');
    if (shouldSave) {
      try {
        saveEditEventSilent();
        toast('Changes saved', 'success');
      } catch (err) {
        console.error('Error saving event:', err);
        const proceed = confirm('Error saving event. Delete anyway?');
        if (!proceed) return;
      }
    } else {
      const proceed = confirm('Discard changes and delete event?');
      if (!proceed) return;
    }
  }
  
  if (!confirm('Delete this event?')) return;
  
  S.events.splice(S.editingEvtIdx, 1);
  markDataChanged();
  
  // Reindex linked event indexes after deletion
  reindexLinkedEventIndexes();
  
  closeEditModal();
  renderEvents(); updateScores(); updateBoxScore();
  autoSave();
  toast('Event deleted', 'success');
}

/**
 * v20.7: Insert a new event BEFORE the current one
 */
function insertEventBefore() {
  if (S.editingEvtIdx === null) return;
  
  const currentEvt = S.events[S.editingEvtIdx];
  
  // Create new blank event with same context
  const newEvt = {
    period: currentEvt.period,
    team: currentEvt.team,
    type: '',
    detail1: '',
    detail2: '',
    zone: currentEvt.zone || '',
    success: '',
    strength: currentEvt.strength || '5v5',
    start_time: currentEvt.start_time,
    end_time: '',
    players: [],
    puckXY: [],
    linkedEventIdx: null,
    assistToGoalIdx: null, // v23.8: For Pass events that assist a Goal
    isHighlight: false
  };
  
  // Insert at position
  S.events.splice(S.editingEvtIdx, 0, newEvt);
  markDataChanged();
  
  const newIdx = S.editingEvtIdx;
  S.editingEvtIdx = null;
  
  closeEditModal();
  renderEvents(); updateScores(); updateBoxScore();
  autoSave();
  toast(`Inserted event #${newIdx + 1}`, 'success');
  
  // Open the new event for editing
  setTimeout(() => editEvent(newIdx), 100);
}

/**
 * v20.7: Insert a new event AFTER the current one
 */
function insertEventAfter() {
  if (S.editingEvtIdx === null) return;
  
  const currentEvt = S.events[S.editingEvtIdx];
  
  // Create new blank event with same context
  const newEvt = {
    period: currentEvt.period,
    team: currentEvt.team,
    type: '',
    detail1: '',
    detail2: '',
    zone: currentEvt.zone || '',
    success: '',
    strength: currentEvt.strength || '5v5',
    start_time: currentEvt.start_time,
    end_time: '',
    players: [],
    puckXY: [],
    linkedEventIdx: null,
    assistToGoalIdx: null, // v23.8: For Pass events that assist a Goal
    isHighlight: false
  };
  
  // Insert after current position
  const insertIdx = S.editingEvtIdx + 1;
  S.events.splice(insertIdx, 0, newEvt);
  markDataChanged();
  
  S.editingEvtIdx = null;
  
  closeEditModal();
  renderEvents(); updateScores(); updateBoxScore();
  autoSave();
  toast(`Inserted event #${insertIdx + 1}`, 'success');
  
  // Open the new event for editing
  setTimeout(() => editEvent(insertIdx), 100);
}

/**
 * v23.9: Insert a new linked event BEFORE the current one
 * The new event will be linked to the current event and will copy XY data
 */
function insertLinkedEventBefore() {
  if (S.editingEvtIdx === null) return;
  
  // Prompt to save if there are unsaved changes
  if (!promptSaveBeforeNavigate()) {
    return; // User cancelled
  }
  
  const currentEvt = S.events[S.editingEvtIdx];
  const currentIdx = S.editingEvtIdx;
  
  // Determine linked index: use current event's linked index if it exists, otherwise create new one
  let linkedIdx;
  if (currentEvt.linkedEventIdx !== null && currentEvt.linkedEventIdx !== undefined) {
    // Current event is already in a chain - use the same linked index
    linkedIdx = currentEvt.linkedEventIdx;
  } else {
    // Current event is not linked - create a new linked index and assign it to current event
    linkedIdx = getNextLinkedEventIdx();
    // Also link the current event to this chain
    currentEvt.linkedEventIdx = linkedIdx;
  }
  
  // Create new event with same context, linked to current event
  const newEvt = {
    period: currentEvt.period,
    team: currentEvt.team,
    type: '',
    detail1: '',
    detail2: '',
    zone: currentEvt.zone || '',
    success: '',
    strength: currentEvt.strength || '5v5',
    start_time: currentEvt.start_time,
    end_time: '',
    players: [],
    puckXY: [],
    linkedEventIdx: linkedIdx, // Use proper linked index, not event index
    assistToGoalIdx: null,
    isHighlight: false
  };
  
  // Copy XY data from current event
  if (currentEvt.puckXY?.length) {
    newEvt.puckXY = JSON.parse(JSON.stringify(currentEvt.puckXY));
  }
  if (currentEvt.netXY) {
    newEvt.netXY = JSON.parse(JSON.stringify(currentEvt.netXY));
  }
  if (currentEvt.players?.length) {
    newEvt.players = JSON.parse(JSON.stringify(currentEvt.players));
  }
  
  // Insert at current position (before current event)
  S.events.splice(currentIdx, 0, newEvt);
  markDataChanged();
  
  const newIdx = currentIdx;
  S.editingEvtIdx = null;
  
  closeEditModal();
  renderEvents(); updateScores(); updateBoxScore();
  autoSave();
  toast(`Inserted linked event #${newIdx + 1} ‚Üí #${newIdx + 2}`, 'success');
  
  // Open the new event for editing
  setTimeout(() => editEvent(newIdx), 100);
}

/**
 * v23.9: Insert a new linked event AFTER the current one
 * The new event will be linked to the current event and will copy XY data
 */
function insertLinkedEventAfter() {
  if (S.editingEvtIdx === null) return;
  
  // Prompt to save if there are unsaved changes
  if (!promptSaveBeforeNavigate()) {
    return; // User cancelled
  }
  
  const currentEvt = S.events[S.editingEvtIdx];
  const currentIdx = S.editingEvtIdx;
  
  // Determine linked index: use current event's linked index if it exists, otherwise create new one
  let linkedIdx;
  if (currentEvt.linkedEventIdx !== null && currentEvt.linkedEventIdx !== undefined) {
    // Current event is already in a chain - use the same linked index
    linkedIdx = currentEvt.linkedEventIdx;
  } else {
    // Current event is not linked - create a new linked index and assign it to current event
    linkedIdx = getNextLinkedEventIdx();
    // Also link the current event to this chain
    currentEvt.linkedEventIdx = linkedIdx;
  }
  
  // Create new event with same context, linked to current event
  const newEvt = {
    period: currentEvt.period,
    team: currentEvt.team,
    type: '',
    detail1: '',
    detail2: '',
    zone: currentEvt.zone || '',
    success: '',
    strength: currentEvt.strength || '5v5',
    start_time: currentEvt.start_time,
    end_time: '',
    players: [],
    puckXY: [],
    linkedEventIdx: linkedIdx, // Use proper linked index, not event index
    assistToGoalIdx: null,
    isHighlight: false
  };
  
  // Copy XY data from current event
  if (currentEvt.puckXY?.length) {
    newEvt.puckXY = JSON.parse(JSON.stringify(currentEvt.puckXY));
  }
  if (currentEvt.netXY) {
    newEvt.netXY = JSON.parse(JSON.stringify(currentEvt.netXY));
  }
  if (currentEvt.players?.length) {
    newEvt.players = JSON.parse(JSON.stringify(currentEvt.players));
  }
  
  // Insert after current position
  const insertIdx = currentIdx + 1;
  S.events.splice(insertIdx, 0, newEvt);
  markDataChanged();
  
  S.editingEvtIdx = null;
  
  closeEditModal();
  renderEvents(); updateScores(); updateBoxScore();
  autoSave();
  toast(`Inserted linked event #${insertIdx + 1} ‚Üê #${currentIdx + 1}`, 'success');
  
  // Open the new event for editing
  setTimeout(() => editEvent(insertIdx), 100);
}

/**
 * v20.7: Duplicate the current event
 */
function duplicateEvent() {
  if (S.editingEvtIdx === null) return;
  
  const currentEvt = S.events[S.editingEvtIdx];
  
  // Deep clone the event
  const newEvt = JSON.parse(JSON.stringify(currentEvt));
  // Clear linking to avoid confusion
  newEvt.linkedEventIdx = null;
  newEvt.eventId = null;
  newEvt.event_id = null;
  
  // Insert after current position
  const insertIdx = S.editingEvtIdx + 1;
  S.events.splice(insertIdx, 0, newEvt);
  markDataChanged();
  
  S.editingEvtIdx = null;
  
  closeEditModal();
  renderEvents(); updateScores(); updateBoxScore();
  autoSave();
  toast(`Duplicated event ‚Üí #${insertIdx + 1}`, 'success');
  
  // Open the new event for editing
  setTimeout(() => editEvent(insertIdx), 100);
}

/**
 * v20.7: Add a new event at the end of the list
 */
function addNewEvent() {
  const lastEvt = S.events.length > 0 ? S.events[S.events.length - 1] : null;
  
  // Create new blank event
  const newEvt = {
    period: lastEvt ? lastEvt.period : S.period || 1,
    team: S.evtTeam || 'home',
    type: '',
    detail1: '',
    detail2: '',
    zone: '',
    success: '',
    strength: '5v5',
    start_time: lastEvt ? lastEvt.start_time : '',
    end_time: '',
    players: [],
    puckXY: [],
    linkedEventIdx: null,
    assistToGoalIdx: null, // v23.8: For Pass events that assist a Goal
    isHighlight: false
  };
  
  // Add to end
  S.events.push(newEvt);
  markDataChanged();
  const newIdx = S.events.length - 1;
  
  renderEvents(); updateScores(); updateBoxScore();
  autoSave();
  toast(`Added event #${newIdx + 1}`, 'success');
  
  // Open the new event for editing
  setTimeout(() => editEvent(newIdx), 100);
}

/**
 * v23.8: Render assists list in edit modal for Goal events
 */
function renderEditAssists(goalEvent) {
  const container = document.getElementById('editAssistsList');
  if (!container) return;
  
  // Find all Pass events that assist this goal
  const assistPasses = S.events.filter(e => {
    if (e.type !== 'Pass') return false;
    if (e.assistToGoalIdx === null || e.assistToGoalIdx === undefined) return false;
    return e.assistToGoalIdx === goalEvent.idx;
  });
  
  if (assistPasses.length === 0) {
    container.innerHTML = '<div style="font-size:9px;color:var(--muted);padding:8px;text-align:center;">No assists linked</div>';
    return;
  }
  
  // Sort by assist type (primary first) and then by event index
  assistPasses.sort((a, b) => {
    const aType = getAssistType(a);
    const bType = getAssistType(b);
    if (aType !== bType) {
      // Primary (A1) before Secondary (A2)
      if (aType === 'primary') return -1;
      if (bType === 'primary') return 1;
    }
    return a.idx - b.idx;
  });
  
  container.innerHTML = assistPasses.map(pass => {
    const player = pass.players?.find(p => 
      p.role === 'event_player_1' || p.role === 'event_team_player_1'
    );
    const playerName = player ? `#${player.num} ${player.name}` : 'Unknown';
    const assistType = getAssistType(pass);
    const assistLabel = assistType === 'primary' ? 'A1 (Primary)' : assistType === 'secondary' ? 'A2 (Secondary)' : 'Assist';
    
    return `
      <div style="background:var(--panel);padding:6px;border-radius:4px;margin-bottom:4px;border-left:3px solid var(--accent);display:flex;justify-content:space-between;align-items:center;cursor:pointer;" 
           onclick="editAssistEvent(${pass.idx})" 
           title="Click to edit this assist event">
        <div style="flex:1;">
          <div style="font-size:9px;font-weight:600;">${playerName}</div>
          <div style="font-size:8px;color:var(--muted);">Event #${pass.idx + 1} @ ${pass.start_time || ''} | ${assistLabel}</div>
        </div>
        <div style="display:flex;gap:4px;" onclick="event.stopPropagation();">
          <button class="btn-sm" onclick="changeAssistType(${pass.idx}, 'primary'); event.stopPropagation();" 
                  style="font-size:8px;${assistType === 'primary' ? 'background:var(--accent);' : ''}" 
                  title="Set as Primary (A1)">A1</button>
          <button class="btn-sm" onclick="changeAssistType(${pass.idx}, 'secondary'); event.stopPropagation();" 
                  style="font-size:8px;${assistType === 'secondary' ? 'background:var(--accent);' : ''}" 
                  title="Set as Secondary (A2)">A2</button>
          <button class="btn-sm" onclick="removeAssist(${pass.idx}); event.stopPropagation();" 
                  style="font-size:8px;background:var(--danger);" 
                  title="Remove assist">‚úï</button>
        </div>
      </div>
    `;
  }).join('');
  
  // Make all buttons work after rendering - buttons are inside editModal
  setTimeout(() => {
    const modal = document.getElementById('editModal');
    if (modal) {
      // Re-apply button fixes to ensure assist buttons work
      const assistButtons = container.querySelectorAll('button');
      assistButtons.forEach(btn => {
        const onclick = btn.getAttribute('onclick');
        if (onclick) {
          btn.onclick = function(e) {
            e.stopPropagation();
            e.preventDefault();
            try {
              eval(onclick);
            } catch (err) {
              console.error('Error executing assist button onclick:', err);
            }
          };
        }
      });
    }
  }, 100);
}

/**
 * v23.8: Get assist type (primary/secondary) from Pass event
 */
function getAssistType(passEvent) {
  const player = passEvent.players?.find(p => 
    p.role === 'event_player_1' || p.role === 'event_team_player_1'
  );
  if (!player) return null;
  
  const pd1 = (player.playD1 || '').toLowerCase();
  const pd2 = (player.playD2 || '').toLowerCase();
  
  if (pd1.includes('assistprimary') || pd2.includes('assistprimary')) return 'primary';
  if (pd1.includes('assistsecondary') || pd2.includes('assistsecondary')) return 'secondary';
  if (pd1.includes('assist')) return 'primary'; // Default to primary if just "assist"
  
  return null;
}

/**
 * v24.0: Edit assist event directly from side panel
 */
function editAssistEvent(eventIdx) {
  // Find the event index in S.events array
  const eventIndex = S.events.findIndex(e => e.idx === eventIdx);
  if (eventIndex === -1) {
    toast('Event not found', 'error');
    return;
  }
  
  // Store current goal event index before closing modal
  const currentGoalIdx = S.editingEvtIdx;
  const currentGoalEvent = currentGoalIdx !== null ? S.events[currentGoalIdx] : null;
  
  // Close current edit modal if open
  const currentModal = document.getElementById('editModal');
  if (currentModal && currentModal.classList.contains('show')) {
    // Save current goal event first if we're editing a goal
    if (currentGoalEvent && currentGoalEvent.type === 'Goal') {
      saveEditEvent();
    }
  }
  
  // Open edit modal for the assist event
  editEvent(eventIndex);
  toast(`Editing assist event #${eventIdx + 1}`, 'info');
}

/**
 * v24.0: Edit assist event directly from side panel
 */
function editAssistEvent(eventIdx) {
  // Find the event index in S.events array
  const eventIndex = S.events.findIndex(e => e.idx === eventIdx);
  if (eventIndex === -1) {
    toast('Event not found', 'error');
    return;
  }
  
  // Store current goal event index before closing modal
  const currentGoalIdx = S.editingEvtIdx;
  const currentGoalEvent = currentGoalIdx !== null ? S.events[currentGoalIdx] : null;
  
  // Close current edit modal if open
  const currentModal = document.getElementById('editModal');
  if (currentModal && currentModal.classList.contains('show')) {
    // Save current goal event first if we're editing a goal
    if (currentGoalEvent && currentGoalEvent.type === 'Goal') {
      saveEditEvent();
    }
  }
  
  // Open edit modal for the assist event
  editEvent(eventIndex);
  toast(`Editing assist event #${eventIdx + 1}`, 'info');
}

/**
 * v23.8: Change assist type (primary/secondary)
 */
function changeAssistType(passIdx, newType) {
  if (S.editingEvtIdx === null) return;
  const goalEvent = S.events[S.editingEvtIdx];
  if (goalEvent.type !== 'Goal') return;
  
  const passEvent = S.events.find(e => e.idx === passIdx);
  if (!passEvent || passEvent.assistToGoalIdx !== goalEvent.idx) {
    toast('Assist not found', 'error');
    return;
  }
  
  const player = passEvent.players?.find(p => 
    p.role === 'event_player_1' || p.role === 'event_team_player_1'
  );
  if (!player) {
    toast('Player not found in pass event', 'error');
    return;
  }
  
  // Update play_detail1 with assist type
  if (newType === 'primary') {
    player.playD1 = 'AssistPrimary';
  } else if (newType === 'secondary') {
    player.playD1 = 'AssistSecondary';
  }
  
  renderEditAssists(goalEvent);
  renderEvents();
  autoSave();
  toast(`Changed assist to ${newType === 'primary' ? 'Primary (A1)' : 'Secondary (A2)'}`, 'success');
}

/**
 * v24.0: Edit assist event directly from side panel
 */
function editAssistEvent(eventIdx) {
  // Find the event index in S.events array
  const eventIndex = S.events.findIndex(e => e.idx === eventIdx);
  if (eventIndex === -1) {
    toast('Event not found', 'error');
    return;
  }
  
  // Close current edit modal if open
  const currentModal = document.getElementById('editModal');
  if (currentModal && currentModal.classList.contains('show')) {
    // Save current goal event first
    saveEditEvent();
  }
  
  // Open edit modal for the assist event
  editEvent(eventIndex);
  toast(`Editing assist event #${eventIdx + 1}`, 'info');
}

/**
 * v23.8: Remove assist link
 */
function removeAssist(passIdx) {
  if (S.editingEvtIdx === null) return;
  const goalEvent = S.events[S.editingEvtIdx];
  if (goalEvent.type !== 'Goal') return;
  
  const passEvent = S.events.find(e => e.idx === passIdx);
  if (!passEvent || passEvent.assistToGoalIdx !== goalEvent.idx) {
    toast('Assist not found', 'error');
    return;
  }
  
  if (!confirm(`Remove assist from event #${passIdx + 1}?`)) return;
  
  // Remove assist link
  passEvent.assistToGoalIdx = null;
  
  // Remove assist markers from player
  const player = passEvent.players?.find(p => 
    p.role === 'event_player_1' || p.role === 'event_team_player_1'
  );
  if (player) {
    if (player.playD1?.toLowerCase().includes('assist')) {
      player.playD1 = '';
    }
    if (player.playD2?.toLowerCase().includes('assist')) {
      player.playD2 = '';
    }
  }
  
  renderEditAssists(goalEvent);
  renderEvents();
  updateBoxScore();
  autoSave();
  toast('Assist removed', 'success');
}

/**
 * v23.8: Open modal to add a new assist
 * v23.8: Now shows ALL events leading up to goal for context
 */
function openAddAssistModal() {
  if (S.editingEvtIdx === null) return;
  const goalEvent = S.events[S.editingEvtIdx];
  if (goalEvent.type !== 'Goal') return;
  
  // Helper to parse time to seconds
  const parseTime = (t) => {
    if (!t) return 0;
    const [min, sec] = String(t).split(':').map(Number);
    return (min || 0) * 60 + (sec || 0);
  };
  
  const goalPeriod = goalEvent.period === 'OT' ? 4 : parseInt(goalEvent.period) || 1;
  const goalTime = parseTime(goalEvent.start_time);
  
  // Get events before the goal (same team) - limit to same period or previous period, and within reasonable time
  const allEventsBeforeGoal = S.events.filter(e => {
    if (e.team !== goalEvent.team) return false;
    if (e.idx >= goalEvent.idx) return false; // Must be before the goal
    
    // Limit to same period or previous period only
    const ePeriod = e.period === 'OT' ? 4 : parseInt(e.period) || 1;
    if (ePeriod < goalPeriod - 1) return false; // Too far back (more than 1 period)
    if (ePeriod > goalPeriod) return false; // Can't be after goal period
    
    // If same period, limit to within 3 minutes of goal
    if (ePeriod === goalPeriod) {
      const eTime = parseTime(e.start_time);
      const timeDiff = goalTime - eTime;
      if (timeDiff > 180) return false; // More than 3 minutes before goal
    }
    
    // Skip if already linked to a different goal
    if (e.assistToGoalIdx !== null && e.assistToGoalIdx !== undefined) {
      if (e.assistToGoalIdx !== goalEvent.idx) return false;
    }
    return true;
  });
  
  // Sort by proximity to goal (most recent first)
  allEventsBeforeGoal.sort((a, b) => b.idx - a.idx);
  
  // Limit to last 20 events for performance and relevance
  const eventsToShow = allEventsBeforeGoal.slice(0, 20);
  
  if (eventsToShow.length === 0) {
    toast('No events found before this goal', 'info');
    return;
  }
  
  // Create modal
  const modal = document.createElement('div');
  modal.className = 'overlay show';
  modal.id = 'addAssistModal';
  modal.onclick = function(e) {
    if (e.target === modal) {
      document.getElementById('addAssistModal')?.remove();
    }
  };
  // Find all goals for navigation
  const allGoals = S.events.filter(e => e.type === 'Goal' && e.detail1 === 'Goal_Scored').sort((a, b) => a.idx - b.idx);
  const currentGoalIndex = allGoals.findIndex(g => g.idx === goalEvent.idx);
  const hasPrev = currentGoalIndex > 0;
  const hasNext = currentGoalIndex < allGoals.length - 1;
  const prevGoalIdx = hasPrev ? allGoals[currentGoalIndex - 1].idx : null;
  const nextGoalIdx = hasNext ? allGoals[currentGoalIndex + 1].idx : null;

  modal.innerHTML = `
    <div class="modal" style="min-width:700px;max-width:900px;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <h3 style="margin:0;">üéØ Add Assist to Goal #${goalEvent.idx + 1}</h3>
        <div style="display:flex;gap:4px;align-items:center;">
          <span style="font-size:9px;color:var(--muted);">Goal ${currentGoalIndex + 1} of ${allGoals.length}</span>
          <button class="btn-sm" onclick="navigateAddAssistGoal(${prevGoalIdx !== null ? prevGoalIdx : 'null'})" ${!hasPrev ? 'disabled' : ''} title="Previous goal">‚óÄ Prev</button>
          <button class="btn-sm" onclick="navigateAddAssistGoal(${nextGoalIdx !== null ? nextGoalIdx : 'null'})" ${!hasNext ? 'disabled' : ''} title="Next goal">Next ‚ñ∂</button>
        </div>
      </div>
      <p style="font-size:10px;color:var(--muted);margin-bottom:12px;">
        All events leading up to the goal. Select any event to link as an assist. Pass and Shot events are highlighted. You can set Primary (A1) or Secondary (A2) after adding.
      </p>
      <div id="addAssistPassesList" style="max-height:600px;overflow-y:auto;margin-bottom:12px;"></div>
      <div class="modal-actions">
        <button onclick="saveCurrentGoalAssists()" style="background:var(--success);color:#fff;" title="Save all assists for this goal">üíæ Save</button>
        <button onclick="document.getElementById('addAssistModal')?.remove()" title="Close without adding assist">Cancel</button>
      </div>
    </div>
  `;
  document.body.appendChild(modal);
  
  // Make ALL buttons work
  ensureModalButtonsWork(modal);
  
  // Render event list with detailed info - show events leading up to goal (limited to same/previous period and within 3 minutes)
  const list = document.getElementById('addAssistPassesList');
  list.innerHTML = eventsToShow.map(evt => {
    // Get primary player (event_player_1)
    const player1 = evt.players?.find(p => 
      p.role === 'event_player_1' || p.role === 'event_team_player_1'
    );
    const player1Name = player1 ? `#${player1.num} ${player1.name || ''}` : 'Unknown';
    
    // Get secondary player (event_player_2) - especially important for Pass events (recipient)
    const player2 = evt.players?.find(p => 
      p.role === 'event_player_2' || p.role === 'event_team_player_2'
    );
    const player2Name = player2 ? `#${player2.num} ${player2.name || ''}` : null;
    
    // Get all event players
    const eventPlayers = evt.players?.filter(p => 
      p.role?.startsWith('event') || (!p.role?.startsWith('opp') && evt.team === (p.team || evt.team))
    ) || [];
    
    // Get opp players
    const oppPlayers = evt.players?.filter(p => 
      p.role?.startsWith('opp')
    ) || [];
    
    const timeAgo = goalEvent.idx - evt.idx;
    
    // Get play details from primary player
    const pd1 = player1?.playD1 || evt.detail1 || '';
    const pd2 = player1?.playD2 || evt.detail2 || '';
    const hasAssistMarker = pd1.toLowerCase().includes('assist') || pd2.toLowerCase().includes('assist');
    const isAlreadyLinked = evt.assistToGoalIdx === goalEvent.idx;
    
    // Determine if this is a likely assist candidate (Pass or Shot)
    const isLikelyAssist = evt.type === 'Pass' || evt.type === 'Shot';
    
    // Calculate time difference
    const parseTime = (t) => {
      if (!t) return 0;
      const [min, sec] = String(t).split(':').map(Number);
      return (min || 0) * 60 + (sec || 0);
    };
    const goalTime = parseTime(goalEvent.start_time);
    const evtTime = parseTime(evt.start_time);
    const timeDiff = goalTime - evtTime;
    const timeDiffStr = timeDiff > 0 ? `${Math.floor(timeDiff / 60)}:${String(timeDiff % 60).padStart(2, '0')}` : '';
    
    // Determine border color: green for already linked, blue for likely assists, yellow for has marker, gray for others
    let borderColor = 'var(--muted)';
    if (isAlreadyLinked) {
      borderColor = 'var(--success)';
    } else if (hasAssistMarker) {
      borderColor = 'var(--accent)';
    } else if (isLikelyAssist) {
      borderColor = '#3b82f6'; // Blue for Pass/Shot
    }
    
    // Background color - slightly highlight likely assists
    const bgColor = isLikelyAssist && !isAlreadyLinked ? 'rgba(59, 130, 246, 0.05)' : 'var(--card)';
    
    // Build players info section
    let playersInfoHtml = '';
    if (evt.type === 'Pass' && player2Name) {
      // For Pass events, show passer ‚Üí recipient
      playersInfoHtml = `
        <div style="font-size:9px;color:var(--text);margin-top:4px;">
          <strong>Passer:</strong> ${player1Name}${player1?.playD1 ? ` (${player1.playD1})` : ''}${player1?.playD2 ? ` / ${player1.playD2}` : ''}
        </div>
        <div style="font-size:9px;color:var(--text);">
          <strong>Recipient:</strong> ${player2Name}${player2?.playD1 ? ` (${player2.playD1})` : ''}${player2?.playD2 ? ` / ${player2.playD2}` : ''}
        </div>
      `;
    } else if (eventPlayers.length > 1) {
      // Multiple event players
      playersInfoHtml = `
        <div style="font-size:9px;color:var(--text);margin-top:4px;">
          <strong>Event Players:</strong> ${eventPlayers.map(p => {
            const roleLabel = p.role?.replace('event_team_player_', 'P').replace('event_player_', 'P') || '';
            const details = [p.playD1, p.playD2].filter(Boolean).join(' / ');
            return `#${p.num} ${p.name || ''}${roleLabel ? ` (${roleLabel})` : ''}${details ? ` [${details}]` : ''}`;
          }).join(', ')}
        </div>
      `;
    } else if (player1) {
      // Single player with details
      playersInfoHtml = `
        <div style="font-size:9px;color:var(--text);margin-top:4px;">
          <strong>Player:</strong> ${player1Name}${player1.playD1 ? ` (${player1.playD1})` : ''}${player1.playD2 ? ` / ${player1.playD2}` : ''}
        </div>
      `;
    }
    
    // Opp players info
    let oppInfoHtml = '';
    if (oppPlayers.length > 0) {
      oppInfoHtml = `
        <div style="font-size:9px;color:var(--muted);margin-top:2px;">
          <strong>Opp:</strong> ${oppPlayers.map(p => `#${p.num} ${p.name || ''}${p.playD1 ? ` (${p.playD1})` : ''}`).join(', ')}
        </div>
      `;
    }
    
    return `
      <div style="background:${bgColor};padding:10px;border-radius:4px;margin-bottom:8px;border-left:4px solid ${borderColor};">
        <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:6px;">
          <div style="flex:1;">
            <div style="display:flex;align-items:center;gap:6px;margin-bottom:4px;">
              <div style="font-size:11px;font-weight:600;color:var(--text);">
                ${player1Name}
              </div>
              ${isLikelyAssist ? `<span style="font-size:8px;background:rgba(59, 130, 246, 0.2);color:#3b82f6;padding:2px 6px;border-radius:3px;font-weight:600;">${evt.type}</span>` : ''}
              ${hasAssistMarker ? `<span style="font-size:8px;background:var(--success);color:#fff;padding:2px 6px;border-radius:3px;">ASSIST</span>` : ''}
              ${isAlreadyLinked ? `<span style="font-size:8px;background:var(--accent);color:#fff;padding:2px 6px;border-radius:3px;">LINKED</span>` : ''}
            </div>
            <div style="font-size:9px;color:var(--muted);margin-bottom:2px;">
              <strong>Event #${evt.idx + 1}</strong> | ${evt.type || 'Unknown'} | P${evt.period || '?'} @ ${evt.start_time || '?'}
              ${timeDiffStr ? ` | ${timeDiffStr} before goal` : ''} | ${timeAgo} event${timeAgo !== 1 ? 's' : ''} before
            </div>
            ${evt.detail1 ? `<div style="font-size:9px;color:var(--text);margin-top:4px;"><strong>Event Detail1:</strong> ${evt.detail1}</div>` : ''}
            ${evt.detail2 ? `<div style="font-size:9px;color:var(--text);"><strong>Event Detail2:</strong> ${evt.detail2}</div>` : ''}
            ${evt.zone ? `<div style="font-size:9px;color:var(--text);"><strong>Zone:</strong> ${evt.zone === 'o' ? 'Offensive' : evt.zone === 'd' ? 'Defensive' : 'Neutral'}</div>` : ''}
            ${evt.success ? `<div style="font-size:9px;color:var(--text);"><strong>Success:</strong> ${evt.success === 's' ? 'Success' : evt.success === 'u' ? 'Unsuccess' : evt.success}</div>` : ''}
            ${playersInfoHtml}
            ${oppInfoHtml}
            ${hasAssistMarker ? `<div style="font-size:9px;color:var(--success);margin-top:4px;">‚úì Has assist marker</div>` : ''}
            ${isAlreadyLinked ? `<div style="font-size:9px;color:var(--accent);margin-top:4px;">‚úì Already linked to this goal</div>` : ''}
          </div>
        </div>
        <div style="display:flex;gap:6px;margin-top:8px;">
          ${!isAlreadyLinked ? `
            <button class="btn-sm btn-primary" onclick="addAssistToGoal(${evt.idx})" style="flex:1;font-size:9px;" title="Link this event as an assist to the goal">
              ${hasAssistMarker ? 'Link as Assist' : 'Add as Assist'}
            </button>
            <button class="btn-sm" onclick="editEvent(${evt.idx});document.getElementById('addAssistModal')?.remove();" style="font-size:9px;" title="Edit this event (will close this modal)">
              Edit Event
            </button>
          ` : `
            <button class="btn-sm" style="flex:1;background:var(--success);color:#fff;" disabled title="Already linked to this goal">
              ‚úì Linked
            </button>
            <button class="btn-sm" onclick="editEvent(${evt.idx});document.getElementById('addAssistModal')?.remove();" style="font-size:9px;" title="Edit this event (will close this modal)">
              Edit Event
            </button>
          `}
        </div>
      </div>
    `;
  }).join('');
}

/**
 * v23.8: Add assist to goal
 * v23.8: Now accepts any event type, not just Pass events
 */
function addAssistToGoal(eventIdx) {
  if (S.editingEvtIdx === null) return;
  const goalEvent = S.events[S.editingEvtIdx];
  if (goalEvent.type !== 'Goal') return;
  
  const assistEvent = S.events.find(e => e.idx === eventIdx);
  if (!assistEvent) {
    toast('Event not found', 'error');
    return;
  }
  
  // Check if already linked to a different goal
  if (assistEvent.assistToGoalIdx !== null && assistEvent.assistToGoalIdx !== undefined) {
    if (assistEvent.assistToGoalIdx !== goalEvent.idx) {
      toast('This event is already linked to another goal', 'error');
      return;
    }
    // Already linked to this goal - just refresh modal to show updated state
    refreshAddAssistModal();
    return;
  }
  
  // Link the assist
  assistEvent.assistToGoalIdx = goalEvent.idx;
  
  // Mark as assist in play_detail1 (default to primary, user can change)
  const player = assistEvent.players?.find(p => 
    p.role === 'event_player_1' || p.role === 'event_team_player_1'
  );
  if (player) {
    // Only add assist marker if not already present
    const pd1 = (player.playD1 || '').toLowerCase();
    const pd2 = (player.playD2 || '').toLowerCase();
    if (!pd1.includes('assist') && !pd2.includes('assist')) {
      player.playD1 = 'AssistPrimary';
    }
  }
  
  // Refresh assists list in edit modal if open
  renderEditAssists(goalEvent);
  renderEvents();
  updateBoxScore();
  autoSave();
  
  // Refresh the add assist modal to show updated state (don't close it)
  refreshAddAssistModal();
  
  toast(`Assist added (${assistEvent.type || 'Event'})`, 'success');
}

/**
 * v23.8: Save assists for the current goal being edited
 */
function saveCurrentGoalAssists() {
  if (S.editingEvtIdx === null) return;
  const goalEvent = S.events[S.editingEvtIdx];
  if (goalEvent.type !== 'Goal') return;
  
  // Refresh assists list in edit modal if open
  renderEditAssists(goalEvent);
  renderEvents();
  updateBoxScore();
  autoSave();
  
  toast('Assists saved for this goal', 'success');
}

/**
 * v23.8: Navigate to a different goal in the add assist modal
 */
function navigateAddAssistGoal(goalIdx) {
  if (goalIdx === null) return;
  
  // Save current goal's assists before navigating
  saveCurrentGoalAssists();
  
  // Find the goal event
  const goalEvent = S.events.find(e => e.idx === goalIdx);
  if (!goalEvent || goalEvent.type !== 'Goal') {
    toast('Goal not found', 'error');
    return;
  }
  
  // Update editing index to the new goal
  S.editingEvtIdx = goalIdx;
  
  // Refresh the modal with the new goal
  refreshAddAssistModal();
  
  // Also update the edit modal if it's open
  if (document.getElementById('editModal')?.classList.contains('show')) {
    editEvent(goalIdx);
  }
}

/**
 * v23.8: Refresh the add assist modal content to reflect current linking state
 */
function refreshAddAssistModal() {
  const modal = document.getElementById('addAssistModal');
  if (!modal) return;

  if (S.editingEvtIdx === null) return;
  const goalEvent = S.events[S.editingEvtIdx];
  if (goalEvent.type !== 'Goal') return;
  
  // Update navigation buttons
  const allGoals = S.events.filter(e => e.type === 'Goal' && e.detail1 === 'Goal_Scored').sort((a, b) => a.idx - b.idx);
  const currentGoalIndex = allGoals.findIndex(g => g.idx === goalEvent.idx);
  const hasPrev = currentGoalIndex > 0;
  const hasNext = currentGoalIndex < allGoals.length - 1;
  const prevGoalIdx = hasPrev ? allGoals[currentGoalIndex - 1].idx : null;
  const nextGoalIdx = hasNext ? allGoals[currentGoalIndex + 1].idx : null;
  
  // Update header with navigation
  const header = modal.querySelector('h3')?.parentElement;
  if (header) {
    header.innerHTML = `
      <h3 style="margin:0;">üéØ Add Assist to Goal #${goalEvent.idx + 1}</h3>
      <div style="display:flex;gap:4px;align-items:center;">
        <span style="font-size:9px;color:var(--muted);">Goal ${currentGoalIndex + 1} of ${allGoals.length}</span>
        <button class="btn-sm" onclick="navigateAddAssistGoal(${prevGoalIdx !== null ? prevGoalIdx : 'null'})" ${!hasPrev ? 'disabled' : ''} title="Previous goal">‚óÄ Prev</button>
        <button class="btn-sm" onclick="navigateAddAssistGoal(${nextGoalIdx !== null ? nextGoalIdx : 'null'})" ${!hasNext ? 'disabled' : ''} title="Next goal">Next ‚ñ∂</button>
      </div>
    `;
  }
  
  // Get ALL events before the goal (same team) for full context
  const allEventsBeforeGoal = S.events.filter(e => {
    if (e.team !== goalEvent.team) return false;
    if (e.idx >= goalEvent.idx) return false; // Must be before the goal
    // Skip if already linked to a different goal
    if (e.assistToGoalIdx !== null && e.assistToGoalIdx !== undefined) {
      if (e.assistToGoalIdx !== goalEvent.idx) return false;
    }
    return true;
  });
  
  // Sort by proximity to goal (most recent first)
  allEventsBeforeGoal.sort((a, b) => b.idx - a.idx);
  
  // Limit to last 50 events for performance
  const eventsToShow = allEventsBeforeGoal.slice(0, 50);
  
  // Re-render event list with detailed info
  const list = document.getElementById('addAssistPassesList');
  if (!list) return;
  
  list.innerHTML = eventsToShow.map(evt => {
    // Get primary player (event_player_1)
    const player1 = evt.players?.find(p => 
      p.role === 'event_player_1' || p.role === 'event_team_player_1'
    );
    const player1Name = player1 ? `#${player1.num} ${player1.name || ''}` : 'Unknown';
    
    // Get secondary player (event_player_2) - especially important for Pass events (recipient)
    const player2 = evt.players?.find(p => 
      p.role === 'event_player_2' || p.role === 'event_team_player_2'
    );
    const player2Name = player2 ? `#${player2.num} ${player2.name || ''}` : null;
    
    // Get all event players
    const eventPlayers = evt.players?.filter(p => 
      p.role?.startsWith('event') || (!p.role?.startsWith('opp') && evt.team === (p.team || evt.team))
    ) || [];
    
    // Get opp players
    const oppPlayers = evt.players?.filter(p => 
      p.role?.startsWith('opp')
    ) || [];
    
    const timeAgo = goalEvent.idx - evt.idx;
    
    // Get play details from primary player
    const pd1 = player1?.playD1 || evt.detail1 || '';
    const pd2 = player1?.playD2 || evt.detail2 || '';
    const hasAssistMarker = pd1.toLowerCase().includes('assist') || pd2.toLowerCase().includes('assist');
    const isAlreadyLinked = evt.assistToGoalIdx === goalEvent.idx;
    
    // Determine if this is a likely assist candidate (Pass or Shot)
    const isLikelyAssist = evt.type === 'Pass' || evt.type === 'Shot';
    
    // Calculate time difference
    const parseTime = (t) => {
      if (!t) return 0;
      const [min, sec] = String(t).split(':').map(Number);
      return (min || 0) * 60 + (sec || 0);
    };
    const goalTime = parseTime(goalEvent.start_time);
    const evtTime = parseTime(evt.start_time);
    const timeDiff = goalTime - evtTime;
    const timeDiffStr = timeDiff > 0 ? `${Math.floor(timeDiff / 60)}:${String(timeDiff % 60).padStart(2, '0')}` : '';
    
    // Determine border color: green for already linked, blue for likely assists, yellow for has marker, gray for others
    let borderColor = 'var(--muted)';
    if (isAlreadyLinked) {
      borderColor = 'var(--success)';
    } else if (hasAssistMarker) {
      borderColor = 'var(--accent)';
    } else if (isLikelyAssist) {
      borderColor = '#3b82f6'; // Blue for Pass/Shot
    }
    
    // Background color - slightly highlight likely assists
    const bgColor = isLikelyAssist && !isAlreadyLinked ? 'rgba(59, 130, 246, 0.05)' : 'var(--card)';
    
    // Build players info section
    let playersInfoHtml = '';
    if (evt.type === 'Pass' && player2Name) {
      // For Pass events, show passer ‚Üí recipient
      playersInfoHtml = `
        <div style="font-size:9px;color:var(--text);margin-top:4px;">
          <strong>Passer:</strong> ${player1Name}${player1?.playD1 ? ` (${player1.playD1})` : ''}${player1?.playD2 ? ` / ${player1.playD2}` : ''}
        </div>
        <div style="font-size:9px;color:var(--text);">
          <strong>Recipient:</strong> ${player2Name}${player2?.playD1 ? ` (${player2.playD1})` : ''}${player2?.playD2 ? ` / ${player2.playD2}` : ''}
        </div>
      `;
    } else if (eventPlayers.length > 1) {
      // Multiple event players
      playersInfoHtml = `
        <div style="font-size:9px;color:var(--text);margin-top:4px;">
          <strong>Event Players:</strong> ${eventPlayers.map(p => {
            const roleLabel = p.role?.replace('event_team_player_', 'P').replace('event_player_', 'P') || '';
            const details = [p.playD1, p.playD2].filter(Boolean).join(' / ');
            return `#${p.num} ${p.name || ''}${roleLabel ? ` (${roleLabel})` : ''}${details ? ` [${details}]` : ''}`;
          }).join(', ')}
        </div>
      `;
    } else if (player1) {
      // Single player with details
      playersInfoHtml = `
        <div style="font-size:9px;color:var(--text);margin-top:4px;">
          <strong>Player:</strong> ${player1Name}${player1.playD1 ? ` (${player1.playD1})` : ''}${player1.playD2 ? ` / ${player1.playD2}` : ''}
        </div>
      `;
    }
    
    // Opp players info
    let oppInfoHtml = '';
    if (oppPlayers.length > 0) {
      oppInfoHtml = `
        <div style="font-size:9px;color:var(--muted);margin-top:2px;">
          <strong>Opp:</strong> ${oppPlayers.map(p => `#${p.num} ${p.name || ''}${p.playD1 ? ` (${p.playD1})` : ''}`).join(', ')}
        </div>
      `;
    }
    
    return `
      <div style="background:${bgColor};padding:10px;border-radius:4px;margin-bottom:8px;border-left:4px solid ${borderColor};">
        <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:6px;">
          <div style="flex:1;">
            <div style="display:flex;align-items:center;gap:6px;margin-bottom:4px;">
              <div style="font-size:11px;font-weight:600;color:var(--text);">
                ${player1Name}
              </div>
              ${isLikelyAssist ? `<span style="font-size:8px;background:rgba(59, 130, 246, 0.2);color:#3b82f6;padding:2px 6px;border-radius:3px;font-weight:600;">${evt.type}</span>` : ''}
              ${hasAssistMarker ? `<span style="font-size:8px;background:var(--success);color:#fff;padding:2px 6px;border-radius:3px;">ASSIST</span>` : ''}
              ${isAlreadyLinked ? `<span style="font-size:8px;background:var(--accent);color:#fff;padding:2px 6px;border-radius:3px;">LINKED</span>` : ''}
            </div>
            <div style="font-size:9px;color:var(--muted);margin-bottom:2px;">
              <strong>Event #${evt.idx + 1}</strong> | ${evt.type || 'Unknown'} | P${evt.period || '?'} @ ${evt.start_time || '?'}
              ${timeDiffStr ? ` | ${timeDiffStr} before goal` : ''} | ${timeAgo} event${timeAgo !== 1 ? 's' : ''} before
            </div>
            ${evt.detail1 ? `<div style="font-size:9px;color:var(--text);margin-top:4px;"><strong>Event Detail1:</strong> ${evt.detail1}</div>` : ''}
            ${evt.detail2 ? `<div style="font-size:9px;color:var(--text);"><strong>Event Detail2:</strong> ${evt.detail2}</div>` : ''}
            ${evt.zone ? `<div style="font-size:9px;color:var(--text);"><strong>Zone:</strong> ${evt.zone === 'o' ? 'Offensive' : evt.zone === 'd' ? 'Defensive' : 'Neutral'}</div>` : ''}
            ${evt.success ? `<div style="font-size:9px;color:var(--text);"><strong>Success:</strong> ${evt.success === 's' ? 'Success' : evt.success === 'u' ? 'Unsuccess' : evt.success}</div>` : ''}
            ${playersInfoHtml}
            ${oppInfoHtml}
            ${hasAssistMarker ? `<div style="font-size:9px;color:var(--success);margin-top:4px;">‚úì Has assist marker</div>` : ''}
            ${isAlreadyLinked ? `<div style="font-size:9px;color:var(--accent);margin-top:4px;">‚úì Already linked to this goal</div>` : ''}
          </div>
        </div>
        <div style="display:flex;gap:6px;margin-top:8px;">
          ${!isAlreadyLinked ? `
            <button class="btn-sm btn-primary" onclick="addAssistToGoal(${evt.idx})" style="flex:1;font-size:9px;" title="Link this event as an assist to the goal">
              ${hasAssistMarker ? 'Link as Assist' : 'Add as Assist'}
            </button>
            <button class="btn-sm" onclick="editEvent(${evt.idx});document.getElementById('addAssistModal')?.remove();" style="font-size:9px;" title="Edit this event (will close this modal)">
              Edit Event
            </button>
          ` : `
            <button class="btn-sm" style="flex:1;background:var(--success);color:#fff;" disabled title="Already linked to this goal">
              ‚úì Linked
            </button>
            <button class="btn-sm" onclick="editEvent(${evt.idx});document.getElementById('addAssistModal')?.remove();" style="font-size:9px;" title="Edit this event (will close this modal)">
              Edit Event
            </button>
          `}
        </div>
      </div>
    `;
  }).join('');
}

/**
 * v23.8: Open modal to browse and select a goal to link assist to
 */
function openLinkAssistToGoalModal() {
  if (S.editingEvtIdx === null) return;
  const currentEvent = S.events[S.editingEvtIdx];
  
  // Find all Goal events (same team, after this event)
  const goals = S.events.filter(e => {
    if (e.type !== 'Goal' || e.detail1 !== 'Goal_Scored') return false;
    if (e.team !== currentEvent.team) return false;
    if (e.idx <= currentEvent.idx) return false; // Must be after this event
    return true;
  });
  
  if (goals.length === 0) {
    toast('No goals found after this event', 'info');
    return;
  }
  
  // Create modal
  const modal = document.createElement('div');
  modal.className = 'overlay show';
  modal.id = 'linkAssistToGoalModal';
  modal.onclick = function(e) {
    if (e.target === modal) {
      document.getElementById('linkAssistToGoalModal')?.remove();
    }
  };
  modal.innerHTML = `
    <div class="modal" style="min-width:500px;max-width:700px;">
      <h3>üéØ Link Assist to Goal</h3>
      <p style="font-size:10px;color:var(--muted);margin-bottom:12px;">
        Select a goal to link this assist to:
      </p>
      <div id="linkAssistGoalsList" style="max-height:400px;overflow-y:auto;margin-bottom:12px;"></div>
      <div class="modal-actions">
        <button onclick="document.getElementById('linkAssistToGoalModal')?.remove()" title="Close without linking">Cancel</button>
      </div>
    </div>
  `;
  document.body.appendChild(modal);
  
  // Render goals list
  const list = document.getElementById('linkAssistGoalsList');
  list.innerHTML = goals.map(goal => {
    const scorer = goal.players?.find(p => p.role === 'event_player_1');
    const scorerName = scorer ? `#${scorer.num} ${scorer.name || ''}` : 'Unknown';
    
    return `
      <div style="background:var(--card);padding:10px;border-radius:4px;margin-bottom:8px;border-left:4px solid var(--success);cursor:pointer;" 
           onclick="linkAssistToGoal(${goal.idx})">
        <div style="font-size:11px;font-weight:600;margin-bottom:4px;">
          Goal #${goal.idx + 1} - ${scorerName}
        </div>
        <div style="font-size:9px;color:var(--muted);">
          P${goal.period || '?'} @ ${goal.start_time || '?'} | ${goal.zone || '?'} zone
        </div>
        ${goal.detail1 ? `<div style="font-size:9px;color:var(--text);margin-top:4px;"><strong>Detail:</strong> ${goal.detail1}</div>` : ''}
      </div>
    `;
  }).join('');
}

/**
 * v23.8: Link current event as assist to selected goal
 */
function linkAssistToGoal(goalIdx) {
  if (S.editingEvtIdx === null) return;
  const currentEvent = S.events[S.editingEvtIdx];
  const goalEvent = S.events[goalIdx];
  
  if (!goalEvent || goalEvent.type !== 'Goal' || goalEvent.detail1 !== 'Goal_Scored') {
    toast('Invalid goal event', 'error');
    return;
  }
  
  // Set the assist link
  currentEvent.assistToGoalIdx = goalIdx;
  
  // Update the input field
  const assistToGoalEl = document.getElementById('editAssistToGoalIdx');
  if (assistToGoalEl) {
    assistToGoalEl.value = goalIdx + 1;
  }
  
  // Mark as assist if not already marked
  const player = currentEvent.players?.find(p => 
    p.role === 'event_player_1' || p.role === 'event_team_player_1'
  );
  if (player) {
    const pd1 = (player.playD1 || '').toLowerCase();
    const pd2 = (player.playD2 || '').toLowerCase();
    if (!pd1.includes('assist') && !pd2.includes('assist')) {
      player.playD1 = player.playD1 ? player.playD1 + ', AssistPrimary' : 'AssistPrimary';
    }
  }
  
  // Close modal
  document.getElementById('linkAssistToGoalModal')?.remove();
  
  toast(`Linked to Goal #${goalIdx + 1}`, 'success');
}

function closeEditModal() {
  console.log('closeEditModal() called');
  
  // Prompt to save if there are unsaved changes
  if (!promptSaveBeforeNavigate()) {
    return; // User cancelled
  }
  
  const modal = document.getElementById('editModal');
  if (modal) {
    modal.classList.remove('show');
    // Force all styles to hide - use !important via setProperty
    modal.style.setProperty('display', 'none', 'important');
    modal.style.setProperty('visibility', 'hidden', 'important');
    modal.style.setProperty('opacity', '0', 'important');
    S.editingEvtIdx = null;
    
    // v24.0: Restore zone labels to current period when closing edit modal
    S.editingPeriod = null; // Clear editing period
    updateZoneLabels();
    
    console.log('Edit modal closed');
  }
}

/**
 * v24.0: Handle team change in edit modal - update zone labels based on event's period
 */
function onEditTeamChange() {
  // Zone labels depend on period, not team, but update based on current editing period
  if (S.editingEvtIdx !== null && S.editingEvtIdx !== undefined) {
    const evt = S.events[S.editingEvtIdx];
    if (evt && evt.period) {
      const editingPeriod = evt.period === 'OT' ? 4 : parseInt(evt.period) || 1;
      S.editingPeriod = editingPeriod;
      updateZoneLabels(editingPeriod);
    }
  }
}

/**
 * v23.8: Get filtered events list (respects period filter and event filters)
 * @returns {Array} - Array of filtered events
 */
function getFilteredEvents() {
  let filteredEvents = S.events || [];
  const periodFilter = (S.eventLogFilter || 'all').toLowerCase();
  
  // Apply period filter
  if (periodFilter && periodFilter !== 'all') {
    filteredEvents = filteredEvents.filter(e => {
      const evtPeriod = String(e.period || '').toLowerCase();
      if (periodFilter === 'ot') {
        return evtPeriod === 'ot' || evtPeriod === '4' || parseInt(evtPeriod) > 3;
      }
      return evtPeriod === periodFilter;
    });
  }
  
  // Apply advanced filters
  const f = S.eventFilters || {};
  
  if (f.type) {
    filteredEvents = filteredEvents.filter(e => e.type === f.type);
  }
  if (f.detail1) {
    filteredEvents = filteredEvents.filter(e => (e.detail1 || e.detail) === f.detail1);
  }
  if (f.detail2) {
    filteredEvents = filteredEvents.filter(e => e.detail2 === f.detail2);
  }
  if (f.playDetail1) {
    filteredEvents = filteredEvents.filter(e => {
      const p1 = (e.players || []).find(p => p.role?.startsWith('event') || !p.role?.startsWith('opp'));
      return p1?.playD1 === f.playDetail1;
    });
  }
  if (f.playDetail2) {
    filteredEvents = filteredEvents.filter(e => {
      const p1 = (e.players || []).find(p => p.role?.startsWith('event') || !p.role?.startsWith('opp'));
      return p1?.playD2 === f.playDetail2;
    });
  }
  if (f.team) {
    filteredEvents = filteredEvents.filter(e => e.team === f.team);
  }
  // v23.8: Handle event index filter with "show X before/after" option
  if (f.eventIdx !== null && f.eventIdx !== undefined) {
    const targetIdx = f.eventIdx - 1; // Convert to 0-based index
    const targetEvent = S.events[targetIdx];
    if (targetEvent) {
      const eventsBefore = f.eventsBefore || 0;
      const eventsAfter = f.eventsAfter || 0;
      const startIdx = Math.max(0, targetIdx - eventsBefore);
      const endIdx = Math.min(S.events.length, targetIdx + 1 + eventsAfter);
      filteredEvents = S.events.slice(startIdx, endIdx);
    } else {
      filteredEvents = [];
    }
  }
  if (f.linkedIdx !== null && f.linkedIdx !== undefined) {
    filteredEvents = filteredEvents.filter(e => e.linkedEventIdx !== null && e.linkedEventIdx + 1 === f.linkedIdx);
  }
  if (f.shiftIdx !== null && f.shiftIdx !== undefined) {
    filteredEvents = filteredEvents.filter(e => e.shiftIdx === f.shiftIdx || e.shift_index === f.shiftIdx);
  }
  
  return filteredEvents;
}

/**
 * Check if there are unsaved changes in the edit modal
 */
function hasUnsavedChanges() {
  if (S.editingEvtIdx === null || S.editingEvtIdx === undefined) return false;
  const evt = S.events[S.editingEvtIdx];
  if (!evt) return false;
  
  // Compare current form values with event values
  const formType = document.getElementById('editType')?.value || '';
  const formTeam = document.getElementById('editTeam')?.value || '';
  const formStartTime = document.getElementById('editStartTime')?.value || '';
  const formEndTime = document.getElementById('editEndTime')?.value || '';
  const formZone = document.getElementById('editZone')?.value || '';
  const formSuccess = document.getElementById('editSuccess')?.value || '';
  const formStrength = document.getElementById('editStrength')?.value || '';
  const formD1 = document.getElementById('editD1')?.value || '';
  const formD2 = document.getElementById('editD2')?.value || '';
  const formHighlight = document.getElementById('editHighlight')?.checked || false;
  const formVideoUrl = document.getElementById('editVideoUrl')?.value || '';
  const formLinkedIdx = document.getElementById('editLinkedIdx')?.value || '';
  
  // Check if any values have changed
  if (formType !== (evt.type || '')) return true;
  if (formTeam !== (evt.team || '')) return true;
  if (formStartTime !== (evt.start_time || evt.time || '')) return true;
  if (formEndTime !== (evt.end_time || '')) return true;
  if (formZone !== (evt.zone || '')) return true;
  if (formSuccess !== (evt.success || '')) return true;
  if (formStrength !== (evt.strength || '5v5')) return true;
  if (formD1 !== (evt.detail1 || evt.detail || '')) return true;
  if (formD2 !== (evt.detail2 || '')) return true;
  if (formHighlight !== (evt.isHighlight || false)) return true;
  if (formVideoUrl !== (evt.videoUrl || '')) return true;
  
  // Check linked index
  const evtLinkedIdx = evt.linkedEventIdx !== null && evt.linkedEventIdx !== undefined ? (evt.linkedEventIdx + 1).toString() : '';
  if (formLinkedIdx !== evtLinkedIdx) return true;
  
  return false;
}

/**
 * Prompt to save before navigating away
 * @returns {boolean} true if should proceed, false if cancelled
 */
function promptSaveBeforeNavigate() {
  if (!hasUnsavedChanges()) return true;
  
  const shouldSave = confirm('You have unsaved changes. Save before navigating?');
  if (shouldSave) {
    try {
      saveEditEventSilent();
      toast('Changes saved', 'success');
      return true;
    } catch (err) {
      console.error('Error saving event:', err);
      const proceed = confirm('Error saving event. Navigate anyway?');
      return proceed;
    }
  } else {
    const proceed = confirm('Discard changes and navigate?');
    return proceed;
  }
}

// Ensure helper functions are globally accessible
if (typeof window !== 'undefined') {
  window.hasUnsavedChanges = hasUnsavedChanges;
  window.promptSaveBeforeNavigate = promptSaveBeforeNavigate;
}

/**
 * Navigate to previous/next event in edit modal
 * v23.8: Respects active filters - navigates within filtered events
 * @param {number} dir - Direction (-1 for prev, 1 for next)
 */
function navEditEvent(dir) {
  try {
    if (S.editingEvtIdx === null || S.editingEvtIdx === undefined) {
      console.error('navEditEvent: No event being edited');
      toast('No event selected for editing', 'error');
      return;
    }
    
    // Prompt to save if there are unsaved changes
    if (!promptSaveBeforeNavigate()) {
      return; // User cancelled
    }
    
    // Check if filters are active
    const periodFilter = (S.eventLogFilter || 'all').toLowerCase();
    const f = S.eventFilters || {};
    const hasFilters = (periodFilter && periodFilter !== 'all') || 
                       f.type || f.detail1 || f.detail2 || f.playDetail1 || f.playDetail2 || 
                       f.team || (f.eventIdx !== null && f.eventIdx !== undefined) ||
                       (f.linkedIdx !== null && f.linkedIdx !== undefined) ||
                       (f.shiftIdx !== null && f.shiftIdx !== undefined);
    
    if (hasFilters) {
      // Navigate within filtered events
      const filteredEvents = getFilteredEvents();
      const currentEvent = S.events[S.editingEvtIdx];
      
      if (!currentEvent) {
        console.error('navEditEvent: Current event not found at index', S.editingEvtIdx);
        toast('Current event not found', 'error');
        return;
      }
      
      // Find current event's position in filtered list
      const currentFilteredIdx = filteredEvents.findIndex(e => e === currentEvent);
      
      if (currentFilteredIdx === -1) {
        // Current event not in filtered list - go to first/last filtered event
        if (filteredEvents.length === 0) {
          toast('No events match current filters', 'info');
          return;
        }
        const targetEvent = dir < 0 ? filteredEvents[filteredEvents.length - 1] : filteredEvents[0];
        const targetIdx = S.events.indexOf(targetEvent);
        if (targetIdx !== -1) {
          editEvent(targetIdx);
        } else {
          toast('Event not found in events list', 'error');
        }
        return;
      }
      
      // Navigate within filtered list
      const newFilteredIdx = currentFilteredIdx + dir;
      if (newFilteredIdx < 0 || newFilteredIdx >= filteredEvents.length) {
        toast(dir < 0 ? 'First filtered event' : 'Last filtered event', 'info');
        return;
      }
      
      const targetEvent = filteredEvents[newFilteredIdx];
      const targetIdx = S.events.indexOf(targetEvent);
      if (targetIdx !== -1) {
        editEvent(targetIdx);
      } else {
        toast('Event not found', 'error');
      }
    } else {
      // No filters - navigate through all events (original behavior)
      const newIdx = S.editingEvtIdx + dir;
      if (newIdx < 0 || newIdx >= S.events.length) {
        toast(dir < 0 ? 'First event' : 'Last event', 'info');
        return;
      }
      editEvent(newIdx);
    }
  } catch (err) {
    console.error('Error in navEditEvent:', err);
    toast('Error navigating to event', 'error');
  }
}

// Ensure navEditEvent is globally accessible
if (typeof window !== 'undefined') {
  window.navEditEvent = navEditEvent;
}

/**
 * Navigate to previous/next shift in edit modal
 * @param {number} dir - Direction (-1 for prev, 1 for next)
 */
function navEditShift(dir) {
  if (S.editingShiftIdx === null) return;
  
  // Save current shift first
  saveEditShiftSilent();
  
  const newIdx = S.editingShiftIdx + dir;
  if (newIdx < 0 || newIdx >= S.shifts.length) {
    toast(dir < 0 ? 'First shift' : 'Last shift', 'info');
    return;
  }
  
  editShift(newIdx);
}

/**
 * Save event without closing modal or showing toast
 */
function saveEditEventSilent() {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  
  evt.type = document.getElementById('editType').value;
  evt.team = document.getElementById('editTeam').value;
  evt.start_time = document.getElementById('editStartTime').value;
  evt.end_time = document.getElementById('editEndTime').value;
  evt.zone = document.getElementById('editZone').value;
  evt.success = document.getElementById('editSuccess').value;
  evt.strength = document.getElementById('editStrength').value;
  evt.detail1 = document.getElementById('editD1').value;
  evt.detail2 = document.getElementById('editD2').value;
  evt.isHighlight = document.getElementById('editHighlight').checked;
  
  // v23.9: Handle videoUrl with fallback to main YouTube link
  let editVideoUrl = evt.isHighlight ? (document.getElementById('editVideoUrl')?.value.trim() || '') : '';
  if (evt.isHighlight && !editVideoUrl && S.videoTiming?.youtubeUrl) {
    const runningVideoTime = calculateRunningVideoTime(evt.period, evt.start_time);
    const startTimeSeconds = Math.max(0, runningVideoTime - 10); // 10 seconds before event
    editVideoUrl = buildYouTubeUrlWithTime(S.videoTiming.youtubeUrl, startTimeSeconds);
  }
  evt.videoUrl = evt.isHighlight ? (editVideoUrl || undefined) : undefined;
  
  const linkedIdxEl = document.getElementById('editLinkedIdx');
  if (linkedIdxEl) {
    const linkedVal = linkedIdxEl.value ? parseInt(linkedIdxEl.value) - 1 : null;
    if (linkedVal !== null && linkedVal >= 0) {
      // Only propagate to chain if event is already part of a chain
      // Otherwise, just set it for this event only
      const oldLinkedIdx = evt.linkedEventIdx;
      if (oldLinkedIdx !== null && oldLinkedIdx !== undefined) {
        // Event is already in a chain - propagate to all events in that chain
        propagateLinkedIndexChange(evt.idx, linkedVal);
      } else {
        // Event is not in a chain - only update this event
        evt.linkedEventIdx = linkedVal;
      }
    } else {
      // Clearing the link - only clear this event, not the whole chain
      const oldLinkedIdx = evt.linkedEventIdx;
      evt.linkedEventIdx = null;
      // If it was part of a chain, only unlink this one event
      // (Other events in the chain keep their link)
    }
  }
  
  // v23.9: Propagate XY data to all linked events when silently saving
  if (evt.linkedEventIdx !== null && evt.linkedEventIdx !== undefined) {
    propagateXYToLinkedEvents();
  }
  
  autoSave();
}

/**
 * Save shift without closing modal or showing toast
 */
function saveEditShiftSilent() {
  if (S.editingShiftIdx === null) return;
  const shift = S.shifts[S.editingShiftIdx];
  
  shift.period = document.getElementById('editShiftPeriod').value;
  shift.start_time = document.getElementById('editShiftStartTime').value;
  shift.end_time = document.getElementById('editShiftEndTime').value;
  shift.start_type = document.getElementById('editShiftStartType').value;
  shift.stop_type = document.getElementById('editShiftStopType').value;
  
  autoSave();
}

/**
 * Clear all events (keep shifts)
 */
function clearAllEvents() {
  if (!S.gameId) { toast('No game loaded', 'error'); return; }
  if (!confirm(`‚ö†Ô∏è Clear ALL ${S.events.length} events?\n\nShifts will be kept. This cannot be undone!`)) return;
  
  S.events = [];
  S.evtIdx = 0;
  
  renderAll();
  autoSave();
  toast('All events cleared', 'success');
}

/**
 * Clear all shifts (keep events)
 */
function clearAllShifts() {
  if (!S.gameId) { toast('No game loaded', 'error'); return; }
  if (!confirm(`‚ö†Ô∏è Clear ALL ${S.shifts.length} shifts?\n\nEvents will be kept. This cannot be undone!`)) return;
  
  S.shifts = [];
  S.shiftIdx = 0;
  
  renderShiftLog();
  autoSave();
  toast('All shifts cleared', 'success');
}

// ============================================================
// SHIFTS
// ============================================================

/**
 * Calculate total stoppage duration during a shift
 * Looks for Stoppage/Clockstop events within the shift time window
 * @param {object} shift - Shift object with period, start_time, end_time
 * @returns {number} - Total stoppage time in seconds
 */
function calculateShiftStoppageTime(shift) {
  if (!shift.start_time || !shift.end_time) return 0;
  
  const parseTime = (t) => {
    if (!t) return 0;
    const [min, sec] = t.split(':').map(Number);
    return (min || 0) * 60 + (sec || 0);
  };
  
  const shiftStartSec = parseTime(shift.start_time);  // Time remaining at shift start
  const shiftEndSec = parseTime(shift.end_time);      // Time remaining at shift end
  
  // Find stoppage events in this shift's period and time window
  // Note: Higher time = earlier in period (clock counts down)
  let stoppageTotal = 0;
  
  S.events.forEach(evt => {
    if (evt.period !== shift.period) return;
    // v24.0: Include DeadIce events as stoppage time (any dead ice = stoppage)
    if (evt.type !== 'Stoppage' && evt.type !== 'Clockstop' && evt.type !== 'Timeout' && evt.type !== 'DeadIce') return;
    
    const evtTimeSec = parseTime(evt.start_time);
    
    // Check if event falls within shift (between end and start because clock counts down)
    if (evtTimeSec <= shiftStartSec && evtTimeSec >= shiftEndSec) {
      // Get event duration
      let duration = 0;
      if (evt.end_time && evt.end_time !== evt.start_time) {
        const evtEndSec = parseTime(evt.end_time);
        duration = Math.abs(evtTimeSec - evtEndSec);
      }
      
      // If no end time or duration is 0, use default durations
      if (duration > 0) {
        stoppageTotal += duration;
      } else {
        // Default durations by type
        if (evt.type === 'Timeout') stoppageTotal += 60;
        else if (evt.type === 'DeadIce') {
          // v24.0: DeadIce events are stoppages - use appropriate duration based on detail
          if (evt.detail1?.includes('Icing')) stoppageTotal += 15;
          else if (evt.detail1?.includes('Offside')) stoppageTotal += 10;
          else if (evt.detail1?.includes('PuckOut')) stoppageTotal += 10;
          else stoppageTotal += 5; // Default for other dead ice
        } else if (evt.detail1?.includes('Icing')) stoppageTotal += 15;
        else if (evt.detail1?.includes('Offside')) stoppageTotal += 10;
        else if (evt.type === 'Clockstop') stoppageTotal += 30;  // Clock stops are usually longer
        else stoppageTotal += 5;  // Default 5 sec for other stoppages
      }
    }
  });
  
  return stoppageTotal;
}

/**
 * Calculate shift duration in seconds
 */
function calculateShiftDuration(shift) {
  if (!shift.start_time || !shift.end_time) return 0;
  
  const parseTime = (t) => {
    const [min, sec] = t.split(':').map(Number);
    return (min || 0) * 60 + (sec || 0);
  };
  
  // Clock counts down, so start > end
  return parseTime(shift.start_time) - parseTime(shift.end_time);
}

// Helper to check if event time falls within shift time range
// Clock counts DOWN (18:00 -> 0:00), so "between" means: start >= time >= end
function isTimeBetween(eventTime, shiftStart, shiftEnd) {
  // Debug logging disabled to prevent ERR_INSUFFICIENT_RESOURCES during export
  // (isTimeBetween is called thousands of times during buildExportWorkbook)
  // #region agent log (disabled)
  // fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'isTimeBetween:19154',message:'Function entry',data:{eventTime,shiftStart,shiftEnd},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
  // #endregion
  if (!eventTime || !shiftStart || !shiftEnd) {
    // #region agent log (disabled)
    // fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'isTimeBetween:19156',message:'Early return - missing times',data:{eventTime,shiftStart,shiftEnd},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
    // #endregion
    return false;
  }
  
  const parseTime = (t) => {
    if (!t) return 0;
    const [min, sec] = String(t).split(':').map(Number);
    return (min || 0) * 60 + (sec || 0);
  };
  
  const evt = parseTime(eventTime);
  const start = parseTime(shiftStart);
  const end = parseTime(shiftEnd);
  
  // Clock counts down, so start > end (e.g., 18:00 to 17:00)
  // Event time is "between" if: start >= eventTime >= end
  // This means: eventTime <= start AND eventTime >= end
  const result = evt <= start && evt >= end;
  
  // #region agent log (disabled)
  // fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'isTimeBetween:19175',message:'Time comparison',data:{eventTime,shiftStart,shiftEnd,evtSeconds:evt,startSeconds:start,endSeconds:end,evtLessEqualStart:evt<=start,evtGreaterEqualEnd:evt>=end,result},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
  // #endregion
  
  return result;
}

function logShift() {
  const start = document.getElementById('shiftStart').value;
  const end = document.getElementById('shiftEnd').value || document.getElementById('clock').value;
  
  const shift = {
    idx: S.shiftIdx++,
    game_id: S.gameId,
    period: S.period,
    start_time: start,
    end_time: end,
    start_type: document.getElementById('shiftStartType').value,
    stop_type: document.getElementById('shiftStopType').value,
    strength: deriveStrength(),
    home: {...S.slots.home},
    away: {...S.slots.away}
  };
  
  // Calculate stoppage time during this shift
  shift.stoppageTime = calculateShiftStoppageTime(shift);
  
  // Calculate shift duration
  shift.duration = calculateShiftDuration(shift);
  
  S.shifts.push(shift);
  markDataChanged();
  const newIdx = S.shifts.length - 1;
  
  // v23.9: Sync adjacent shift times after logging (if there's a previous shift in same period)
  if (newIdx > 0) {
    const prevShift = S.shifts[newIdx - 1];
    if (prevShift && prevShift.period === shift.period && prevShift.end_time && shift.start_time) {
      // Helper to parse time string (MM:SS) to seconds
      const parseTime = (timeStr) => {
        if (!timeStr) return null;
        const [min, sec] = timeStr.split(':').map(Number);
        return (min || 0) * 60 + (sec || 0);
      };
      
      const prevEndSec = parseTime(prevShift.end_time);
      const newStartSec = parseTime(shift.start_time);
      
      if (prevEndSec !== null && newStartSec !== null) {
        const timeDiff = Math.abs(prevEndSec - newStartSec);
        if (timeDiff <= 2) {
          // Within 2 seconds - sync the new shift's start time
          shift.start_time = prevShift.end_time;
          toast(`Synced shift #${newIdx + 1} start time to ${prevShift.end_time}`, 'info');
        }
      }
    }
  }
  
  document.getElementById('shiftStart').value = end;
  document.getElementById('shiftEnd').value = '';
  S.lastEndTime = end;
  
  renderShiftLog();
  toast(`Shift #${shift.idx + 1} logged (${shift.stoppageTime}s stoppage)`, 'success');
  autoSave();
}

// Auto-update strength when slots change
function onSlotsChanged() {
  const strength = deriveStrength();
  document.getElementById('evtStrength').value = strength;
  updateQuickStats(); // v5
}

// ============================================================
// PERIOD & CLOCK
// ============================================================
function setPeriod(p) {
  S.period = p;
  document.querySelectorAll('.period-btn').forEach(b => b.classList.remove('active'));
  document.querySelector(`.period-btn[data-p="${p}"]`)?.classList.add('active');
  
  // Set clock based on period-specific length
  const periodLen = getPeriodLength(p);
  document.getElementById('clock').value = `${periodLen}:00`;
  
  // Update period length indicator
  updatePeriodLengthIndicator();
  
  // Update zone labels (they switch each period)
  updateZoneLabels();
}

/**
 * Flip which end home team attacks in P1
 * For beer league where benches aren't fixed home/away
 */
function flipZones() {
  S.homeAttacksRightP1 = !S.homeAttacksRightP1;
  updateZoneLabels();
  
  const direction = S.homeAttacksRightP1 ? 'RIGHT' : 'LEFT';
  const homeShort = (S.homeTeam || 'HOME').toUpperCase();
  toast(`${homeShort} attacks ${direction} in P1/P3`, 'info');
  
  // Update button visual
  const btn = document.getElementById('flipZonesBtn');
  if (btn) {
    btn.style.background = S.homeAttacksRightP1 ? '#374151' : '#7c3aed';
  }
  
  autoSave();
}

function updateClock() {
  // Just store the value, could trigger other updates
}

// ============================================================
// EXPORT
// ============================================================

/**
 * Helper functions to get code and ID from name for export
 */
function getEventTypeCodeAndId(typeName) {
  if (!typeName) return { code: '', id: '' };
  const found = S.eventTypesDB?.find(e => e.name === typeName || e.code === typeName);
  return found ? { code: found.code || '', id: found.id || '' } : { code: typeName, id: '' };
}

function getEventDetailCodeAndId(detailName, eventType) {
  if (!detailName) return { code: '', id: '' };
  const found = S.eventDetails1?.find(e => 
    (e.name === detailName || e.code === detailName) && 
    (e.eventType === eventType || !eventType)
  );
  return found ? { code: found.code || '', id: found.id || '' } : { code: detailName, id: '' };
}

function getEventDetail2CodeAndId(detail2Name) {
  if (!detail2Name) return { code: '', id: '' };
  const found = S.eventDetails2?.find(e => e.name === detail2Name || e.code === detail2Name);
  return found ? { code: found.code || '', id: found.id || '' } : { code: detail2Name, id: '' };
}

// Build the export workbook (reusable for both Export and Quick Save)
function buildExportWorkbook() {
  // Build LONG format export (one row per player per event)
  // Format matches ETL expected input with underscore suffix for input columns
  const rows = [];
  
  // Helper to calculate adjusted XY (standardized: offense = +x, defense = -x, neutral = ~0)
  // This ensures all offensive plays have positive X and defensive plays have negative X,
  // regardless of which end teams attack in different periods
  const calculateAdjustedXY = (x, y, period, team, zone) => {
    if (x === null || x === undefined || isNaN(x)) return { x: null, y };
    
    // Raw XY is center-relative (-100 to +100, center is 0)
    // Adjusted XY: 
    // - Offense = positive length (distance from center toward offensive end)
    // - Defense = negative length (distance from center toward defensive end)
    // - Neutral = adjusted based on team's facing direction in this period
    const isOddPeriod = period === 1 || period === 3 || period === 'OT' || (parseInt(period) || 1) % 2 === 1;
    const homeOffensiveRight = isOddPeriod ? S.homeAttacksRightP1 : !S.homeAttacksRightP1;
    const isHome = team === 'home';
    
    // Determine which direction the team is facing in this period
    // Home team faces right if homeOffensiveRight is true, left otherwise
    // Away team faces opposite of home
    const teamFacingRight = isHome ? homeOffensiveRight : !homeOffensiveRight;
    
    // Calculate adjusted X based on zone
    let adjustedX = x;
    
    if (zone === 'o') {
      // Offensive zone: always positive (distance from center toward offensive end)
      adjustedX = Math.abs(x); // Always positive regardless of raw X sign
    } else if (zone === 'd') {
      // Defensive zone: always negative (negative distance from center toward defensive end)
      adjustedX = -Math.abs(x); // Always negative regardless of raw X sign
    } else {
      // Neutral zone or no zone specified: adjust based on team's facing direction in this period
      // Need to determine if X is on the offensive side or defensive side for this team
      if (teamFacingRight) {
        // Team facing right: positive X is toward offensive end, negative X is toward defensive end
        // Offensive end is right (+), defensive end is left (-)
        if (x > 0) {
          // On right side (offensive side) - make positive
          adjustedX = Math.abs(x);
        } else {
          // On left side (defensive side) - make negative
          adjustedX = -Math.abs(x);
        }
      } else {
        // Team facing left: negative X is toward offensive end, positive X is toward defensive end
        // Offensive end is left (-), defensive end is right (+)
        if (x < 0) {
          // On left side (offensive side) - make positive
          adjustedX = Math.abs(x);
        } else {
          // On right side (defensive side) - make negative
          adjustedX = -Math.abs(x);
        }
      }
    }
    
    // v24.0: Y also needs to be inverted when teams switch ends (even periods)
    // When teams switch ends, the entire rink is flipped, so Y should be negated
    let adjustedY = y;
    if (!isOddPeriod) {
      // Even period (teams switched ends) - invert Y coordinate
      adjustedY = y !== null && y !== undefined ? -y : y;
    }
    
    return { x: adjustedX, y: adjustedY };
  };
  
  // Track zone changes for zone_change_index
  let lastZone = null;
  let zoneChangeIdx = 0;
  
  // v24.0: Helper to calculate PIM for an event
  const calculateEventPIM = (evt) => {
    if (evt.type !== 'Penalty') return '';
    
    const penaltyLengths = {
      minor: parseInt(document.getElementById('minorPenaltyMinutes')?.value || S.penaltyLengths?.minor || 2),
      major: parseInt(document.getElementById('majorPenaltyMinutes')?.value || S.penaltyLengths?.major || 5),
      misconduct: parseInt(document.getElementById('misconductPenaltyMinutes')?.value || S.penaltyLengths?.misconduct || 10)
    };
    
    if (!evt.detail1) return '';
    
    const detail1Lower = (evt.detail1 || '').toLowerCase();
    if (detail1Lower.includes('major')) {
      return penaltyLengths.major || 5;
    } else if (detail1Lower.includes('misconduct')) {
      return penaltyLengths.misconduct || 10;
    } else if (detail1Lower.includes('minor')) {
      return penaltyLengths.minor || 2;
    }
    
    return '';
  };
  
  S.events.forEach((evt, i) => {
    const startTime = evt.start_time || evt.time || '';
    const endTime = evt.end_time || evt.start_time || evt.time || '';
    const [startMin, startSec] = (startTime || '').split(':');
    const [endMin, endSec] = (endTime || '').split(':');
    
    // Map zone to abbreviation (o/d/n)
    const zoneAbbr = evt.zone || 'n';
    
    // Track zone changes
    if (zoneAbbr !== lastZone) {
      zoneChangeIdx++;
      lastZone = zoneAbbr;
    }
    
    // Calculate time totals (clock counts down from periodLength:00 to 0:00)
    // Time elapsed = total period time - remaining time
    const period = parseInt(evt.period) || 1;
    const periodLengthMin = getPeriodLength(evt.period);
    const periodLengthSec = periodLengthMin * 60;
    const startMinInt = parseInt(startMin) || 0;
    const startSecInt = parseInt(startSec) || 0;
    const endMinInt = parseInt(endMin) || startMinInt;
    const endSecInt = parseInt(endSec) || startSecInt;
    // Remaining time in seconds: min*60 + sec
    // Elapsed time = periodLength*60 - remaining
    const startTotalSec = periodLengthSec - (startMinInt * 60 + startSecInt);
    const endTotalSec = periodLengthSec - (endMinInt * 60 + endSecInt);
    
    // Running time calculations - sum all previous periods
    let periodOffset = 0;
    for (let p = 1; p < period; p++) {
      periodOffset += getPeriodLengthSeconds(p);
    }
    const eventRunningStart = periodOffset + startTotalSec;
    const eventRunningEnd = periodOffset + endTotalSec;
    
    // Calculate running video time WITH intermissions
    const runningVideoTime = evt.videoTime || calculateRunningVideoTime(period, startTime);
    
    // Calculate intermission duration up to this point
    const int1 = S.videoTiming?.intermission1 || 0;
    const int2 = S.videoTiming?.intermission2 || 0;
    const int3 = S.videoTiming?.intermission3 || 0;
    let intermissionDuration = 0;
    if (period >= 2) intermissionDuration += int1;
    if (period >= 3) intermissionDuration += int2;
    if (period >= 4) intermissionDuration += int3;
    
    // Duration
    const duration = endTotalSec - startTotalSec;
    
    // v24.0: Find assists for goal events (primary and secondary)
    let assistPrimaryEventIndex = '';
    let assistSecondaryEventIndex = '';
    let assistPrimaryEventIndexFlag = '';
    let assistSecondaryEventIndexFlag = '';
    
    if (evt.type === 'Goal' && evt.detail1 === 'Goal_Scored') {
      // Find all Pass events that assist this goal
      const assistPasses = S.events.filter(e => 
        e.assistToGoalIdx !== null && 
        e.assistToGoalIdx !== undefined && 
        e.assistToGoalIdx === evt.idx &&
        e.type === 'Pass'
      );
      
      // Separate assists by type
      const primaryAssists = [];
      const secondaryAssists = [];
      const untypedAssists = [];
      
      assistPasses.forEach(passEvt => {
        const passIdx = S.events.indexOf(passEvt);
        if (passIdx === -1) return;
        
        const assistType = getAssistType(passEvt);
        if (assistType === 'primary') {
          primaryAssists.push(passIdx);
        } else if (assistType === 'secondary') {
          secondaryAssists.push(passIdx);
        } else {
          untypedAssists.push(passIdx);
        }
      });
      
      // Assign primary assist (first primary, or first untyped if no primary)
      if (primaryAssists.length > 0) {
        const firstPrimary = primaryAssists[0];
        assistPrimaryEventIndex = 1000 + firstPrimary;
        assistPrimaryEventIndexFlag = firstPrimary + 1;
      } else if (untypedAssists.length > 0) {
        const firstUntyped = untypedAssists[0];
        assistPrimaryEventIndex = 1000 + firstUntyped;
        assistPrimaryEventIndexFlag = firstUntyped + 1;
        // Remove from untyped list since we used it
        untypedAssists.shift();
      }
      
      // Assign secondary assist (first secondary, or second untyped if no secondary)
      if (secondaryAssists.length > 0) {
        const firstSecondary = secondaryAssists[0];
        assistSecondaryEventIndex = 1000 + firstSecondary;
        assistSecondaryEventIndexFlag = firstSecondary + 1;
      } else if (untypedAssists.length > 0) {
        const secondUntyped = untypedAssists[0];
        assistSecondaryEventIndex = 1000 + secondUntyped;
        assistSecondaryEventIndexFlag = secondUntyped + 1;
      }
    }
    
    const base = {
      // Input columns (underscore suffix for ETL)
      'event_index_flag_': i + 1,
      'sequence_index_flag_': evt.sequenceIdx || '',
      'play_index_flag_': evt.playIdx || '',
      'linked_event_index_flag_': evt.linkedEventIdx !== null ? evt.linkedEventIdx + 1 : '',
      'assist_to_goal_index_flag_': (evt.assistToGoalIdx !== null && evt.assistToGoalIdx !== undefined) ? (parseInt(evt.assistToGoalIdx, 10) + 1) : '', // v24.0: Separate column for assists (1-based)
      'assist_primary_event_index_flag_': assistPrimaryEventIndexFlag, // v24.0: Event index of primary assist (1-based)
      'assist_secondary_event_index_flag_': assistSecondaryEventIndexFlag, // v24.0: Event index of secondary assist (1-based)
      'event_start_min_': startMin || '',
      'event_start_sec_': startSec || '',
      'event_end_min_': endMin || '',
      'event_end_sec_': endSec || '',
      'event_team_zone_': zoneAbbr,
      'event_type_': evt.type,
      'event_detail_': evt.detail1 || '',
      'event_detail_2_': evt.detail2 || '',
      'event_successful_': evt.success || '',
      'team_': evt.team === 'home' ? 'h' : 'a',
      // Additional derived columns
      'period': evt.period,
      'event_index': 1000 + i,  // ETL format: 1000-based
      'tracking_event_index': 1000 + i,  // Same as event_index
      'linked_event_index': evt.linkedEventIdx !== null ? 1000 + evt.linkedEventIdx : '',
      'assist_to_goal_index': (evt.assistToGoalIdx !== null && evt.assistToGoalIdx !== undefined) ? (1000 + parseInt(evt.assistToGoalIdx, 10)) : '', // v24.0: Separate column for assists (1000-based ETL format)
      'assist_primary_event_index': assistPrimaryEventIndex, // v24.0: Event index of primary assist (1000-based ETL format)
      'assist_secondary_event_index': assistSecondaryEventIndex, // v24.0: Event index of secondary assist (1000-based ETL format)
      'game_id': S.gameId,
      'home_team': S.homeTeam,
      'away_team': S.awayTeam,
      'strength': evt.strength || '5v5',
      'event_team_zone': zoneAbbr === 'o' ? 'Offensive' : zoneAbbr === 'd' ? 'Defensive' : 'Neutral',
      // Non-underscore duplicates (ETL uses both)
      'event_start_min': startMin || '',
      'event_start_sec': startSec || '',
      'event_end_min': endMin || '',
      'event_end_sec': endSec || '',
      // Export codes and IDs instead of names
      'event_type_code': evt.typeCode || getEventTypeCodeAndId(evt.type).code,
      'event_type_id': evt.typeId || getEventTypeCodeAndId(evt.type).id,
      'event_detail_code': evt.detail1Code || getEventDetailCodeAndId(evt.detail1, evt.type).code,
      'event_detail_id': evt.detail1Id || getEventDetailCodeAndId(evt.detail1, evt.type).id,
      'event_detail_2_code': evt.detail2Code || getEventDetail2CodeAndId(evt.detail2).code,
      'event_detail_2_id': evt.detail2Id || getEventDetail2CodeAndId(evt.detail2).id,
      // Keep names for backward compatibility (but codes/IDs are primary)
      'event_detail': evt.detail1 || '',
      'event_detail_2': evt.detail2 || '',
      'event_successful': evt.success || '',
      // Calculated columns
      'time_start_total_seconds': startTotalSec,
      'time_end_total_seconds': endTotalSec,
      'duration': duration,
      'period_start_total_running_seconds': periodOffset,
      'running_video_time': runningVideoTime,
      'event_running_start': eventRunningStart,
      'event_running_end': eventRunningEnd,
      'running_intermission_duration': intermissionDuration,
      'zone_change_index': zoneChangeIdx,
      'shift_index': evt.shiftIdx || '',
      'is_highlight': evt.isHighlight ? 1 : 0,
      'video_url': evt.isHighlight && evt.videoUrl ? evt.videoUrl : '',  // v23.7: Individual highlight video URL
      'Type': evt.type,  // Legacy uppercase column
      // v24.0: PIM (Penalty minutes) calculation
      'pim': calculateEventPIM(evt)
    };
    
    // Add puck XY - only start/stop (first and last) in main events sheet (raw and adjusted)
    // v24.0: Filter out invalid/null XY items before checking length
    const puckXY = (evt.puckXY || []).filter(pt => pt && pt.x !== null && pt.x !== undefined && pt.y !== null && pt.y !== undefined);
    if (puckXY.length > 0) {
      // First XY point (start)
      const startRaw = puckXY[0];
      const startAdjusted = calculateAdjustedXY(startRaw.x, startRaw.y, evt.period, evt.team, evt.zone);
      base['puck_x_start'] = startRaw.x;
      base['puck_y_start'] = startRaw.y;
      base['puck_x_start_adjusted'] = startAdjusted.x;
      base['puck_y_start_adjusted'] = startAdjusted.y;
      
      // Last XY point (stop) - if different from first
      if (puckXY.length > 1) {
        const lastRaw = puckXY[puckXY.length - 1];
        const lastAdjusted = calculateAdjustedXY(lastRaw.x, lastRaw.y, evt.period, evt.team, evt.zone);
        base['puck_x_stop'] = lastRaw.x;
        base['puck_y_stop'] = lastRaw.y;
        base['puck_x_stop_adjusted'] = lastAdjusted.x;
        base['puck_y_stop_adjusted'] = lastAdjusted.y;
      } else {
        // Only one point - use same for start and stop
        base['puck_x_stop'] = startRaw.x;
        base['puck_y_stop'] = startRaw.y;
        base['puck_x_stop_adjusted'] = startAdjusted.x;
        base['puck_y_stop_adjusted'] = startAdjusted.y;
      }
      
      // Flag indicating adjusted XY columns are present
      base['is_xy_adjusted'] = 1;
      // v24.0: Flag indicating if XY needs adjustment (true for even periods when teams switch ends)
      const isOddPeriod = evt.period === 1 || evt.period === 3 || evt.period === 'OT' || (parseInt(evt.period) || 1) % 2 === 1;
      base['needs_xy_adjustment'] = !isOddPeriod ? 1 : 0; // 1 if even period (needs adjustment), 0 if odd period (no adjustment needed)
    }
    
    // Net XY
    if (evt.netXY && evt.netXY.x != null && evt.netXY.y != null) {
      base.net_x = evt.netXY.x;
      base.net_y = evt.netXY.y;
    }
    
    // One row per player
    if (evt.players?.length) {
      evt.players.forEach(p => {
        const row = {...base};
        row['player_game_number_'] = p.num;
        row['player_game_number'] = p.num;
        // role_abrev: e1, e2, o1, o2, etc.
        const isOpp = p.role?.includes('opp');
        const rolePrefix = isOpp ? 'o' : 'e';
        row['role_abrev'] = rolePrefix + (p.roleNum || 1);
        row['role_abrev_binary_'] = rolePrefix;  // Just 'e' or 'o'
        row.player_role = p.role;
        row.player_name = p.name;
        row['play_detail1_'] = p.playD1 || '';
        row['play_detail2_'] = p.playD2 || '';
        row['play_detail_successful_'] = p.playSuccess || '';
        row['pressured_pressurer_'] = p.pressure || '';
        row['side_of_puck_'] = p.sideOfPuck || '';  // v16
        row.play_detail1 = p.playD1 || '';
        row.play_detail_2 = p.playD2 || '';
        row.play_detail_successful = p.playSuccess || '';
        row.pressured_pressurer = p.pressure || '';
        row.side_of_puck = p.sideOfPuck || '';  // v16
        
        // Player XY - only start/stop (first and last) in main events sheet (raw and adjusted)
        // v24.0: Filter out invalid/null XY items before checking length
        const playerXY = (p.xy || []).filter(pt => pt && pt.x !== null && pt.x !== undefined && pt.y !== null && pt.y !== undefined);
        if (playerXY.length > 0) {
          // Determine player's zone context (event team's zone if player is on event team, opposite if opp player)
          const isOppPlayer = p.role?.includes('opp') || p.team !== evt.team;
          const playerZone = isOppPlayer ? (evt.zone === 'o' ? 'd' : evt.zone === 'd' ? 'o' : 'n') : evt.zone;
          
          // First XY point (start)
          const startRaw = playerXY[0];
          const startAdjusted = calculateAdjustedXY(startRaw.x, startRaw.y, evt.period, p.team || evt.team, playerZone);
          row['player_x_start'] = startRaw.x;
          row['player_y_start'] = startRaw.y;
          row['player_x_start_adjusted'] = startAdjusted.x;
          row['player_y_start_adjusted'] = startAdjusted.y;
          
          // Last XY point (stop) - if different from first
          if (playerXY.length > 1) {
            const lastRaw = playerXY[playerXY.length - 1];
            const lastAdjusted = calculateAdjustedXY(lastRaw.x, lastRaw.y, evt.period, p.team || evt.team, playerZone);
            row['player_x_stop'] = lastRaw.x;
            row['player_y_stop'] = lastRaw.y;
            row['player_x_stop_adjusted'] = lastAdjusted.x;
            row['player_y_stop_adjusted'] = lastAdjusted.y;
          } else {
            // Only one point - use same for start and stop
            row['player_x_stop'] = startRaw.x;
            row['player_y_stop'] = startRaw.y;
            row['player_x_stop_adjusted'] = startAdjusted.x;
            row['player_y_stop_adjusted'] = startAdjusted.y;
          }
        }
        
        rows.push(row);
      });
    } else {
      // Event with no players still needs a row
      base['player_game_number_'] = '';
      base['role_abrev'] = '';
      rows.push(base);
    }
  });
  
  // Create workbook
  const wb = XLSX.utils.book_new();
  
  // Metadata sheet (v19: includes zone orientation, v23.6: includes video count)
  const metadata = [{
    game_id: S.gameId,
    home_team: S.homeTeam,
    away_team: S.awayTeam,
    period_length_minutes: S.periodLength,
    home_attacks_right_p1: S.homeAttacksRightP1 ? 1 : 0,
    export_timestamp: new Date().toISOString(),
    tracker_version: 'v25.0',
    total_videos: (S.videos && S.videos.length) || 0
  }];
  const wsMeta = XLSX.utils.json_to_sheet(metadata);
  XLSX.utils.book_append_sheet(wb, wsMeta, 'metadata');
  
  // Events sheet
  if (rows.length) {
    const ws = XLSX.utils.json_to_sheet(rows);
    XLSX.utils.book_append_sheet(wb, ws, 'events');
  }
  
  // Shifts sheet
  if (S.shifts.length) {
    // Calculate running goals from events AND per-shift goals
    let homeGoals = 0;
    let awayGoals = 0;
    
    // Pre-calculate goals by shift for running totals AND per-shift plus/minus
    const goalsByShift = [];
    S.shifts.forEach((s, i) => {
      // Store running total at shift START
      const goalsAtStart = { home: homeGoals, away: awayGoals };
      
      // Find goals that occurred IN this shift
      const shiftEvents = S.events.filter(e => 
        e.shiftIdx === i || 
        (e.period === s.period && isTimeBetween(e.start_time, s.start_time, s.end_time))
      );
      
      let homePlus = 0;  // Goals FOR home during this shift (EV/SH only)
      let awayPlus = 0;  // Goals FOR away during this shift (EV/SH only)
      
      // Get shift strength for PP determination
      const shiftStrength = s.strength || '5v5';
      const [homeStr, awayStr] = shiftStrength.split('v').map(n => parseInt(n) || 5);
      const homePP = homeStr > awayStr;  // Home on power play
      const awayPP = awayStr > homeStr;  // Away on power play
      
      shiftEvents.forEach(e => {
        if (e.type === 'Goal' && e.detail1 === 'Goal_Scored') {
          // Always update running total
          if (e.team === 'home') {
            homeGoals++;
            // Plus/minus: Only count if NOT a power play goal
            if (!homePP) {
              homePlus++;
            }
          } else {
            awayGoals++;
            // Away goal on away PP = no +/- change
            if (!awayPP) {
              awayPlus++;
            }
          }
        }
      });
      
      goalsByShift.push({ 
        startHome: goalsAtStart.home, 
        startAway: goalsAtStart.away,
        homePlus: homePlus,
        homeMinus: awayPlus,
        awayPlus: awayPlus,
        awayMinus: homePlus
      });
    });
    
    // Helper to parse time string (MM:SS) to seconds
    const parseTime = (timeStr) => {
      if (!timeStr) return 0;
      const [min, sec] = timeStr.split(':').map(Number);
      return (min || 0) * 60 + (sec || 0);
    };
    
    // Helper to determine zone from X coordinate and team
    const getZoneFromX = (x, team, period) => {
      if (x === null || x === undefined || isNaN(x)) return null;
      // Rink is 200ft, center at 100
      // Blue lines at x=75 and x=125 (correct NHL dimensions)
      // 0-75 = left zone, 75-125 = neutral, 125-200 = right zone
      // Use S.homeAttacksRightP1 to determine initial orientation
      // Odd periods (1, 3, OT): Use P1 setting
      // Even periods (2): Flip from P1 setting
      const isHome = team === 'home';
      const isOddPeriod = period === 1 || period === 3 || period === 'OT' || (parseInt(period) || 1) % 2 === 1;
      
      // Determine which end is offensive for each team based on configurable setting
      const homeOffensiveRight = isOddPeriod ? S.homeAttacksRightP1 : !S.homeAttacksRightP1;
      
      if (isHome) {
        if (homeOffensiveRight) {
          if (x > 125) return 'o';      // Home offensive (right in odd periods)
          else if (x < 75) return 'd';  // Home defensive (left in odd periods)
          else return 'n';
        } else {
          if (x < 75) return 'o';       // Home offensive (left in even periods)
          else if (x > 125) return 'd'; // Home defensive (right in even periods)
          else return 'n';
        }
      } else {
        // Away team is opposite
        if (homeOffensiveRight) {
          if (x < 75) return 'o';       // Away offensive (left in odd periods)
          else if (x > 125) return 'd'; // Away defensive (right in odd periods)
          else return 'n';
        } else {
          if (x > 125) return 'o';      // Away offensive (right in even periods)
          else if (x < 75) return 'd';  // Away defensive (left in even periods)
          else return 'n';
        }
      }
    };
    
    // Helper to find closest event to a time (for puck XY lookup)
    const findClosestEvent = (targetTime, period) => {
      const targetSec = parseTime(targetTime);
      let closestEvent = null;
      let minDiff = Infinity;
      
      S.events.forEach(evt => {
        if (evt.period !== period) return;
        if (!evt.puckXY || evt.puckXY.length === 0) return;
        
        const evtSec = parseTime(evt.start_time);
        const diff = Math.abs(evtSec - targetSec);
        if (diff < minDiff && diff <= 5) { // Within 5 seconds
          minDiff = diff;
          closestEvent = evt;
        }
      });
      
      return closestEvent;
    };
    
    const shiftRows = S.shifts.map((s, i) => {
      // v24.0: DeadIce and Intermission shifts can have blank columns except period, shift_start_type, game_id, teams
      const isDeadIceOrIntermission = s.start_type === 'DeadIce' || s.start_type === 'Intermission';
      
      if (isDeadIceOrIntermission) {
        // Return minimal row with only required fields
        return {
          shift_index: i + 1,
          Period: s.period,
          shift_start_type: s.start_type || '',
          game_id: S.gameId,
          home_team: S.homeTeam,
          away_team: S.awayTeam,
          // All other fields are blank
          shift_start_min: '',
          shift_start_sec: '',
          shift_end_min: '',
          shift_end_sec: '',
          shift_stop_type: '',
          shift_duration: '',
          stoppage_time: '',
          home_forward_1: '',
          home_forward_2: '',
          home_forward_3: '',
          home_defense_1: '',
          home_defense_2: '',
          home_goalie: '',
          home_xtra: '',
          away_forward_1: '',
          away_forward_2: '',
          away_forward_3: '',
          away_defense_1: '',
          away_defense_2: '',
          away_goalie: '',
          away_xtra: '',
          strength: '',
          shift_start_total_seconds: '',
          shift_end_total_seconds: '',
          home_team_strength: '',
          away_team_strength: '',
          home_team_en: '',
          away_team_en: '',
          home_team_pk: '',
          home_team_pp: '',
          away_team_pp: '',
          away_team_pk: '',
          situation: '',
          home_goals: '',
          away_goals: '',
          home_team_plus: '',
          home_team_minus: '',
          away_team_plus: '',
          away_team_minus: '',
          home_ozone_start: '',
          home_ozone_end: '',
          home_dzone_start: '',
          home_dzone_end: '',
          home_nzone_start: '',
          home_nzone_end: '',
          away_ozone_start: '',
          away_ozone_end: '',
          away_dzone_start: '',
          away_dzone_end: '',
          away_nzone_start: '',
          away_nzone_end: '',
          puck_start_x: '',
          puck_start_y: '',
          puck_end_x: '',
          puck_end_y: '',
          needs_xy_adjustment: '',
          period_start_total_running_seconds: '',
          running_video_time: '',
          shift_start_running_time: '',
          shift_end_running_time: ''
        };
      }
      
      // Normal shift processing continues below...
      const stoppageTime = s.stoppageTime ?? calculateShiftStoppageTime(s);
      const duration = s.duration ?? calculateShiftDuration(s);
      
      const startMin = parseInt(s.start_time?.split(':')[0]) || 0;
      const startSec = parseInt(s.start_time?.split(':')[1]) || 0;
      const endMin = parseInt(s.end_time?.split(':')[0]) || startMin;
      const endSec = parseInt(s.end_time?.split(':')[1]) || startSec;
      
      const period = parseInt(s.period) || 1;
      const periodLengthSec = getPeriodLengthSeconds(s.period);
      // Time elapsed = period length - remaining time (clock counts down)
      const startTotalSec = periodLengthSec - (startMin * 60 + startSec);
      const endTotalSec = periodLengthSec - (endMin * 60 + endSec);
      
      // Running time calculations - sum all previous periods
      let periodOffset = 0;
      for (let p = 1; p < period; p++) {
        periodOffset += getPeriodLengthSeconds(p);
      }
      const startRunning = periodOffset + startTotalSec;
      const endRunning = periodOffset + endTotalSec;
      
      // Calculate running video time WITH intermissions
      const runningVideoTime = s.videoTime || calculateRunningVideoTime(period, s.start_time);
      
      // Calculate intermission duration up to this point
      const int1 = S.videoTiming?.intermission1 || 0;
      const int2 = S.videoTiming?.intermission2 || 0;
      const int3 = S.videoTiming?.intermission3 || 0;
      let shiftIntermissionDuration = 0;
      if (period >= 2) shiftIntermissionDuration += int1;
      if (period >= 3) shiftIntermissionDuration += int2;
      if (period >= 4) shiftIntermissionDuration += int3;
      
      // v23.9: Calculate puck XY and zone from events at shift start/end times
      let startPuckX = null;
      let startPuckY = null;
      let endPuckX = null;
      let endPuckY = null;
      
      // Find closest event to shift start time (within 5 seconds)
      const startEvent = findClosestEvent(s.start_time, period);
      if (startEvent && startEvent.puckXY && startEvent.puckXY.length > 0) {
        const startXY = startEvent.puckXY[0]; // Use first XY point
        startPuckX = startXY.x;
        startPuckY = startXY.y;
      } else if (s.start_xy) {
        // Fallback to stored start_xy if available
        startPuckX = s.start_xy.x;
        startPuckY = s.start_xy.y;
      }
      
      // Find closest event to shift end time (within 5 seconds)
      const endEvent = findClosestEvent(s.end_time, period);
      if (endEvent && endEvent.puckXY && endEvent.puckXY.length > 0) {
        const endXY = endEvent.puckXY[endEvent.puckXY.length - 1] || endEvent.puckXY[0]; // Use last XY point, fallback to first
        endPuckX = endXY.x;
        endPuckY = endXY.y;
      } else if (s.end_xy) {
        // Fallback to stored end_xy if available
        endPuckX = s.end_xy.x;
        endPuckY = s.end_xy.y;
      }
      
      // v23.9: Get zones from first and last events in the shift (not from puck XY)
      // Find all events that belong to this shift
      const shiftEvents = S.events.filter(evt => evt.shiftIdx === i);
      
      // Get first and last events in the shift
      let firstEvent = null;
      let lastEvent = null;
      
      if (shiftEvents.length > 0) {
        // Sort events by time within the period
        const sortedEvents = [...shiftEvents].sort((a, b) => {
          const aTime = parseTime(a.start_time || a.time || '');
          const bTime = parseTime(b.start_time || b.time || '');
          if (a.period !== b.period) return a.period - b.period;
          return aTime - bTime;
        });
        
        firstEvent = sortedEvents[0];
        lastEvent = sortedEvents[sortedEvents.length - 1];
      }
      
      // Determine zones from first and last events
      // Event zone is from the event team's perspective
      const firstEventZone = firstEvent?.zone || null;
      const lastEventZone = lastEvent?.zone || null;
      const firstEventTeam = firstEvent?.team || null;
      const lastEventTeam = lastEvent?.team || null;
      
      // Helper to convert event zone to home/away team zones
      // Event zone is from event team's perspective: 'o' = offensive, 'd' = defensive, 'n' = neutral
      const getHomeTeamZone = (eventZone, eventTeam) => {
        if (!eventZone || !eventTeam) return null;
        if (eventTeam === 'home') {
          // Event team is home, so zone is already from home perspective
          return eventZone;
        } else {
          // Event team is away, so flip the zone (away's offense = home's defense, etc.)
          if (eventZone === 'o') return 'd';
          if (eventZone === 'd') return 'o';
          return 'n'; // Neutral stays neutral
        }
      };
      
      const getAwayTeamZone = (eventZone, eventTeam) => {
        if (!eventZone || !eventTeam) return null;
        if (eventTeam === 'away') {
          // Event team is away, so zone is already from away perspective
          return eventZone;
        } else {
          // Event team is home, so flip the zone (home's offense = away's defense, etc.)
          if (eventZone === 'o') return 'd';
          if (eventZone === 'd') return 'o';
          return 'n'; // Neutral stays neutral
        }
      };
      
      // Priority: Use puck XY location at start/end of shift (as requested)
      // Fallback to event zones if puck XY not available
      const shiftTeam = s.team || 'home';
      
      // Determine zones from puck location (primary method)
      let homeTeamStartZone = null;
      let awayTeamStartZone = null;
      let homeTeamEndZone = null;
      let awayTeamEndZone = null;
      
      if (startPuckX != null) {
        // Use puck location at shift start
        homeTeamStartZone = getZoneFromX(startPuckX, 'home', period);
        awayTeamStartZone = getZoneFromX(startPuckX, 'away', period);
      } else if (firstEventZone && firstEventTeam) {
        // Fallback to first event zone if puck XY not available
        homeTeamStartZone = getHomeTeamZone(firstEventZone, firstEventTeam);
        awayTeamStartZone = getAwayTeamZone(firstEventZone, firstEventTeam);
      }
      
      if (endPuckX != null) {
        // Use puck location at shift end
        homeTeamEndZone = getZoneFromX(endPuckX, 'home', period);
        awayTeamEndZone = getZoneFromX(endPuckX, 'away', period);
      } else if (lastEventZone && lastEventTeam) {
        // Fallback to last event zone if puck XY not available
        homeTeamEndZone = getHomeTeamZone(lastEventZone, lastEventTeam);
        awayTeamEndZone = getAwayTeamZone(lastEventZone, lastEventTeam);
      }
      
      const goals = goalsByShift[i] || { startHome: 0, startAway: 0, homePlus: 0, homeMinus: 0, awayPlus: 0, awayMinus: 0 };
      
      // Calculate strength from players on ice
      const homeSkaters = ['F1','F2','F3','D1','D2','X'].filter(p => s.home?.[p]?.num).length;
      const awaySkaters = ['F1','F2','F3','D1','D2','X'].filter(p => s.away?.[p]?.num).length;
      const homeEN = s.home?.G?.num ? 0 : 1;
      const awayEN = s.away?.G?.num ? 0 : 1;
      
      // v23.8: Fix empty net detection - check for goalie before determining PP
      // If there's no goalie (empty net), it's EN situation, not PP
      const strength = (homeEN || awayEN) ? (homeEN ? 'ENA' : 'ENH') : `${homeSkaters}v${awaySkaters}`;
      
      return {
        shift_index: i + 1,
        Period: s.period,
        shift_start_min: s.start_time?.split(':')[0] || '',
        shift_start_sec: s.start_time?.split(':')[1] || '',
        shift_end_min: s.end_time?.split(':')[0] || '',
        shift_end_sec: s.end_time?.split(':')[1] || '',
        shift_start_type: s.start_type || '',
        shift_stop_type: s.stop_type || '',
        shift_duration: duration,
        stoppage_time: stoppageTime,
        // Player numbers - 6 columns for home, 6 columns for away
        home_forward_1: s.home?.F1?.num || '',
        home_forward_2: s.home?.F2?.num || '',
        home_forward_3: s.home?.F3?.num || '',
        home_defense_1: s.home?.D1?.num || '',
        home_defense_2: s.home?.D2?.num || '',
        home_goalie: s.home?.G?.num || '',
        home_xtra: s.home?.X?.num || '',
        away_forward_1: s.away?.F1?.num || '',
        away_forward_2: s.away?.F2?.num || '',
        away_forward_3: s.away?.F3?.num || '',
        away_defense_1: s.away?.D1?.num || '',
        away_defense_2: s.away?.D2?.num || '',
        away_goalie: s.away?.G?.num || '',
        away_xtra: s.away?.X?.num || '',
        game_id: S.gameId,
        home_team: S.homeTeam,
        away_team: S.awayTeam,
        strength: strength,
        // Calculated columns for ETL
        shift_start_total_seconds: startTotalSec,
        shift_end_total_seconds: endTotalSec,
        home_team_strength: homeSkaters,
        away_team_strength: awaySkaters,
        home_team_en: homeEN,
        away_team_en: awayEN,
        // v23.8: Fix PP/PK - only set if NOT empty net (if empty net, it's EN situation, not PP)
        home_team_pk: (!homeEN && !awayEN && homeSkaters < awaySkaters) ? 1 : 0,
        home_team_pp: (!homeEN && !awayEN && homeSkaters > awaySkaters) ? 1 : 0,
        away_team_pp: (!homeEN && !awayEN && awaySkaters > homeSkaters) ? 1 : 0,
        away_team_pk: (!homeEN && !awayEN && awaySkaters < homeSkaters) ? 1 : 0,
        situation: (homeEN || awayEN) ? (homeEN ? 'away_en' : 'home_en') : (homeSkaters === awaySkaters) ? 'even' : (homeSkaters > awaySkaters ? 'home_pp' : 'away_pp'),
        home_goals: goals.startHome,
        away_goals: goals.startAway,
        // Plus/minus: goals FOR and AGAINST during this shift
        home_team_plus: goals.homePlus,    // Home goals scored during shift
        home_team_minus: goals.homeMinus,  // Away goals scored during shift (against home)
        away_team_plus: goals.awayPlus,    // Away goals scored during shift
        away_team_minus: goals.awayMinus,  // Home goals scored during shift (against away)
        // Zone tracking (derived from XY or explicit)
        home_ozone_start: (homeTeamStartZone === 'o') ? 1 : 0,
        home_ozone_end: (homeTeamEndZone === 'o') ? 1 : 0,
        home_dzone_start: (homeTeamStartZone === 'd') ? 1 : 0,
        home_dzone_end: (homeTeamEndZone === 'd') ? 1 : 0,
        home_nzone_start: (homeTeamStartZone === 'n') ? 1 : 0,
        home_nzone_end: (homeTeamEndZone === 'n') ? 1 : 0,
        // Away team zones (flipped perspective)
        away_ozone_start: (awayTeamStartZone === 'o') ? 1 : 0,
        away_ozone_end: (awayTeamEndZone === 'o') ? 1 : 0,
        away_dzone_start: (awayTeamStartZone === 'd') ? 1 : 0,
        away_dzone_end: (awayTeamEndZone === 'd') ? 1 : 0,
        away_nzone_start: (awayTeamStartZone === 'n') ? 1 : 0,
        away_nzone_end: (awayTeamEndZone === 'n') ? 1 : 0,
        period_start_total_running_seconds: periodOffset,
        running_video_time: runningVideoTime,
        shift_start_running_time: startRunning,
        shift_end_running_time: endRunning
      };
    });
    const ws2 = XLSX.utils.json_to_sheet(shiftRows);
    XLSX.utils.book_append_sheet(wb, ws2, 'shifts');
  }
  
  // Videos sheet (v23.9: Game-level video metadata matching ETL expected format)
  // Calculate period start times
  const periodLengthSec = getPeriodLengthSeconds(1); // Period length in seconds
  const offset = S.videoTiming?.videoStartOffset || 0;
  const int1 = S.videoTiming?.intermission1 || 900;
  const int2 = S.videoTiming?.intermission2 || 900;
  
  const period1Start = offset; // Period 1 starts at video offset
  const period2Start = period1Start + periodLengthSec + int1;
  const period3Start = period2Start + periodLengthSec + int2;
  
  // Create video sheet with expected format (one row per video)
  // Export all videos from S.videos array if available
  const videoRows = [];
  
  if (S.videos && S.videos.length > 0) {
    // Export all videos from S.videos array (one row per video)
    S.videos.forEach(video => {
      const videoUrl = video.url || '';
      const videoType = video.type || 'Full_Ice';
      const description = video.description || video.notes || video.title || '';
      
      // Calculate duration if we have start and end times
      let durationSeconds = '';
      if (video.start_time && video.end_time) {
        const startParts = video.start_time.split(':');
        const endParts = video.end_time.split(':');
        if (startParts.length === 2 && endParts.length === 2) {
          const startMin = parseInt(startParts[0]) || 0;
          const startSec = parseInt(startParts[1]) || 0;
          const endMin = parseInt(endParts[0]) || 0;
          const endSec = parseInt(endParts[1]) || 0;
          const startTotal = (startMin * 60) + startSec;
          const endTotal = (endMin * 60) + endSec;
          durationSeconds = Math.max(0, endTotal - startTotal);
        }
      }
      
      videoRows.push({
        game_id: S.gameId,
        video_type: videoType,
        video_url: videoUrl,
        video_id: video.video_id || extractYouTubeId(videoUrl) || '',
        title: video.title || '',
        category: video.category || '',
        period: video.period || '',
        start_time: video.start_time || '',
        end_time: video.end_time || '',
        duration_seconds: durationSeconds,
        period_1_start: period1Start,
        period_2_start: period2Start,
        period_3_start: period3Start,
        description: description,
        notes: video.notes || ''
      });
    });
  } else if (S.videoTiming?.youtubeUrl) {
    // Fall back to legacy single video URL from videoTiming
    const videoUrl = S.videoTiming.youtubeUrl;
    const videoType = (videoUrl.includes('youtube') || videoUrl.includes('youtu.be')) ? 'YouTube' : 'File';
    
    videoRows.push({
      game_id: S.gameId,
      video_type: videoType,
      video_url: videoUrl,
      video_id: extractYouTubeId(videoUrl) || '',
      title: '',
      category: '',
      period: '',
      start_time: '',
      end_time: '',
      duration_seconds: '',
      period_1_start: period1Start,
      period_2_start: period2Start,
      period_3_start: period3Start,
      description: 'Game video',
      notes: ''
    });
  }
  
  // Always create video sheet (even if empty) to maintain format
  
  const wsVideos = XLSX.utils.json_to_sheet(videoRows);
  XLSX.utils.book_append_sheet(wb, wsVideos, 'video');
  
  // XY Puck sheet - all puck XY points (raw and adjusted)
  const xyPuckRows = [];
  S.events.forEach((evt, i) => {
    // Add puck XY data
    if (evt.puckXY && Array.isArray(evt.puckXY) && evt.puckXY.length > 0) {
      evt.puckXY.forEach((xy, slotIdx) => {
        // Skip null or invalid XY coordinates - check before accessing properties
        if (xy == null) return;  // Check for null/undefined first
        if (typeof xy !== 'object') return;  // Must be an object
        // Now safe to access properties
        const x = xy.x;
        const y = xy.y;
        if (x == null || y == null || typeof x !== 'number' || typeof y !== 'number') return;
        
        // Calculate adjusted XY
        const adjusted = calculateAdjustedXY(x, y, evt.period, evt.team, evt.zone);
        
        xyPuckRows.push({
          event_index: i + 1,
          game_id: S.gameId,
          period: evt.period,
          event_type: evt.type,
          event_detail: evt.detail1 || '',
          xy_slot: slotIdx + 1,
          x: x,  // Raw XY (center-relative, -100 to +100)
          y: y,  // Raw Y
          x_adjusted: adjusted.x,  // Adjusted XY (offense = +x, defense = -x)
          y_adjusted: adjusted.y,
          is_xy_adjusted: 1,  // Flag indicating adjusted columns are present
          needs_xy_adjustment: (() => { // v24.0: Flag indicating if XY needs adjustment (even periods)
            const isOddPeriod = evt.period === 1 || evt.period === 3 || evt.period === 'OT' || (parseInt(evt.period) || 1) % 2 === 1;
            return !isOddPeriod ? 1 : 0;
          })(),
          is_start: slotIdx === 0 ? 1 : 0,
          is_stop: slotIdx === evt.puckXY.length - 1 ? 1 : 0
        });
      });
    }
  });
  
  if (xyPuckRows.length > 0) {
    const wsXYPuck = XLSX.utils.json_to_sheet(xyPuckRows);
    XLSX.utils.book_append_sheet(wb, wsXYPuck, 'xy_puck');
  }
  
  // XY Player sheet - all player XY points (raw and adjusted)
  const xyPlayerRows = [];
  S.events.forEach((evt, i) => {
    // Add player XY data
    if (evt.players && evt.players.length > 0) {
      evt.players.forEach(p => {
        if (p.xy && p.xy.length > 0) {
          // Determine player's zone context (event team's zone if player is on event team, opposite if opp player)
          const isOppPlayer = p.role?.includes('opp') || p.team !== evt.team;
          const playerZone = isOppPlayer ? (evt.zone === 'o' ? 'd' : evt.zone === 'd' ? 'o' : 'n') : evt.zone;
          
          p.xy.forEach((xy, slotIdx) => {
            // Skip null or invalid XY coordinates - check before accessing properties
            if (xy == null) return;  // Check for null/undefined first
            if (typeof xy !== 'object') return;  // Must be an object
            // Now safe to access properties
            const x = xy.x;
            const y = xy.y;
            if (x == null || y == null || typeof x !== 'number' || typeof y !== 'number') return;
            
            // Calculate adjusted XY for player
            const adjusted = calculateAdjustedXY(x, y, evt.period, p.team || evt.team, playerZone);
            
            xyPlayerRows.push({
              event_index: i + 1,
              game_id: S.gameId,
              period: evt.period,
              event_type: evt.type,
              event_detail: evt.detail1 || '',
              player_number: p.num,
              player_name: p.name,
              player_role: p.role,
              xy_slot: slotIdx + 1,
              x: x,  // Raw XY (center-relative, -100 to +100)
              y: y,  // Raw Y
              x_adjusted: adjusted.x,  // Adjusted XY (offense = +x, defense = -x)
              y_adjusted: adjusted.y,
              is_xy_adjusted: 1,  // Flag indicating adjusted columns are present
              needs_xy_adjustment: (() => { // v24.0: Flag indicating if XY needs adjustment (even periods)
                const isOddPeriod = evt.period === 1 || evt.period === 3 || evt.period === 'OT' || (parseInt(evt.period) || 1) % 2 === 1;
                return !isOddPeriod ? 1 : 0;
              })(),
              is_start: slotIdx === 0 ? 1 : 0,
              is_stop: slotIdx === p.xy.length - 1 ? 1 : 0
            });
          });
        }
      });
    }
    
    // Add net XY data (if present) - include in player sheet as it's shot target
    // Net is always in offensive zone, so adjusted X should be positive
    if (evt.netXY && evt.netXY.x != null && evt.netXY.y != null) {
      const adjusted = calculateAdjustedXY(evt.netXY.x, evt.netXY.y, evt.period, evt.team, 'o');
      xyPlayerRows.push({
        event_index: i + 1,
        game_id: S.gameId,
        period: evt.period,
        event_type: evt.type,
        event_detail: evt.detail1 || '',
        player_number: '',
        player_name: '',
        player_role: 'net',
        xy_slot: 1,
        x: evt.netXY.x,  // Raw XY
        y: evt.netXY.y,
        x_adjusted: adjusted.x,  // Adjusted XY
        y_adjusted: adjusted.y,
        is_xy_adjusted: 1,
        needs_xy_adjustment: (() => { // v24.0: Flag indicating if XY needs adjustment (even periods)
          const isOddPeriod = evt.period === 1 || evt.period === 3 || evt.period === 'OT' || (parseInt(evt.period) || 1) % 2 === 1;
          return !isOddPeriod ? 1 : 0;
        })(),
        is_start: 1,
        is_stop: 1
      });
    }
  });
  
  if (xyPlayerRows.length > 0) {
    const wsXYPlayer = XLSX.utils.json_to_sheet(xyPlayerRows);
    XLSX.utils.book_append_sheet(wb, wsXYPlayer, 'xy_player');
  }
  
  // v23.6: Video Timing Configuration Sheet
  // Helper to format time (seconds to MM:SS or keep as MM:SS string)
  const formatTimeForExport = (timeValue) => {
    if (timeValue === null || timeValue === undefined || timeValue === '') return '';
    if (typeof timeValue === 'number') {
      const min = Math.floor(timeValue / 60);
      const sec = timeValue % 60;
      return `${min}:${String(sec).padStart(2, '0')}`;
    }
    return String(timeValue);
  };
  
  // Helper to parse time to seconds
  const parseTimeToSeconds = (timeStr) => {
    if (!timeStr) return 0;
    if (typeof timeStr === 'number') return timeStr;
    const parts = String(timeStr).split(':');
    if (parts.length === 2) {
      return (parseInt(parts[0]) || 0) * 60 + (parseInt(parts[1]) || 0);
    }
    return parseInt(timeStr) || 0;
  };
  
  const videoTimingConfig = [];
  
  // Basic Settings
  videoTimingConfig.push({
    category: 'Basic Settings',
    setting: 'Video Start Offset (sec)',
    value: S.videoTiming?.videoStartOffset || 0,
    description: 'Seconds to skip at video start (pre-game, warmups)'
  });
  
  // Game Start Configuration
  const gameStart = S.videoTiming?.gameStart || { period: 1, time: '18:00' };
  videoTimingConfig.push({
    category: 'Game Start',
    setting: 'Start Period',
    value: gameStart.period || 1,
    description: 'Period when video recording starts'
  });
  videoTimingConfig.push({
    category: 'Game Start',
    setting: 'Start Time (MM:SS)',
    value: gameStart.time || '18:00',
    description: 'Game clock time when video recording starts'
  });
  
  // Period Lengths
  videoTimingConfig.push({
    category: 'Period Lengths',
    setting: 'Period 1 (minutes)',
    value: S.periodLengths?.[1] || S.periodLength || 18,
    description: 'Length of period 1 in minutes'
  });
  videoTimingConfig.push({
    category: 'Period Lengths',
    setting: 'Period 2 (minutes)',
    value: S.periodLengths?.[2] || S.periodLength || 18,
    description: 'Length of period 2 in minutes'
  });
  videoTimingConfig.push({
    category: 'Period Lengths',
    setting: 'Period 3 (minutes)',
    value: S.periodLengths?.[3] || S.periodLength || 18,
    description: 'Length of period 3 in minutes'
  });
  videoTimingConfig.push({
    category: 'Period Lengths',
    setting: 'OT (minutes)',
    value: S.periodLengths?.OT || 5,
    description: 'Length of overtime in minutes'
  });
  
  // Period Start Offsets
  const offsets = S.videoTiming?.periodOffsets || {};
  videoTimingConfig.push({
    category: 'Period Start Offsets',
    setting: 'Period 1 Start (MM:SS or seconds)',
    value: offsets[1] !== null && offsets[1] !== undefined ? formatTimeForExport(offsets[1]) : '0:00',
    description: 'When period 1 starts in the video'
  });
  videoTimingConfig.push({
    category: 'Period Start Offsets',
    setting: 'Period 2 Start (MM:SS or seconds)',
    value: offsets[2] !== null && offsets[2] !== undefined ? formatTimeForExport(offsets[2]) : '',
    description: 'When period 2 starts in the video'
  });
  videoTimingConfig.push({
    category: 'Period Start Offsets',
    setting: 'Period 3 Start (MM:SS or seconds)',
    value: offsets[3] !== null && offsets[3] !== undefined ? formatTimeForExport(offsets[3]) : '',
    description: 'When period 3 starts in the video'
  });
  videoTimingConfig.push({
    category: 'Period Start Offsets',
    setting: 'OT Start (MM:SS or seconds)',
    value: offsets.OT !== null && offsets.OT !== undefined ? formatTimeForExport(offsets.OT) : '',
    description: 'When OT starts in the video'
  });
  
  // Intermission Durations
  videoTimingConfig.push({
    category: 'Intermission Durations',
    setting: 'After Period 1 (sec)',
    value: S.videoTiming?.intermission1 || 900,
    description: 'Actual video time of intermission after period 1'
  });
  videoTimingConfig.push({
    category: 'Intermission Durations',
    setting: 'After Period 2 (sec)',
    value: S.videoTiming?.intermission2 || 900,
    description: 'Actual video time of intermission after period 2'
  });
  videoTimingConfig.push({
    category: 'Intermission Durations',
    setting: 'After Period 3 / OT (sec)',
    value: S.videoTiming?.intermission3 || 300,
    description: 'Actual video time of intermission after period 3 or OT'
  });
  
  // YouTube URL
  if (S.videoTiming?.youtubeUrl) {
    videoTimingConfig.push({
      category: 'Video Management',
      setting: 'YouTube URL',
      value: S.videoTiming.youtubeUrl,
      description: 'Main game video URL'
    });
  }
  
  // Timeouts & Extended Stoppages
  const timeouts = S.videoTiming?.timeouts || [];
  timeouts.forEach((t, idx) => {
    videoTimingConfig.push({
      category: 'Timeout/Stoppage',
      setting: `Timeout ${idx + 1} - Period`,
      value: t.period || '',
      description: `Period of timeout ${idx + 1}`
    });
    videoTimingConfig.push({
      category: 'Timeout/Stoppage',
      setting: `Timeout ${idx + 1} - Game Start (MM:SS)`,
      value: t.gameStart || '',
      description: `Game clock time when timeout ${idx + 1} starts`
    });
    videoTimingConfig.push({
      category: 'Timeout/Stoppage',
      setting: `Timeout ${idx + 1} - Game Stop (MM:SS)`,
      value: t.gameStop || '',
      description: `Game clock time when timeout ${idx + 1} stops`
    });
    // Timeout video times are stored as numbers (seconds) or MM:SS strings
    const timeoutVideoStart = t.videoStart !== null && t.videoStart !== undefined
      ? (typeof t.videoStart === 'number' ? formatTimeForExport(t.videoStart) : formatTimeForExport(parseTimeToSeconds(t.videoStart)))
      : '';
    const timeoutVideoStop = t.videoStop !== null && t.videoStop !== undefined
      ? (typeof t.videoStop === 'number' ? formatTimeForExport(t.videoStop) : formatTimeForExport(parseTimeToSeconds(t.videoStop)))
      : '';
    
    videoTimingConfig.push({
      category: 'Timeout/Stoppage',
      setting: `Timeout ${idx + 1} - Video Start (MM:SS)`,
      value: timeoutVideoStart,
      description: `Video time when timeout ${idx + 1} starts`
    });
    videoTimingConfig.push({
      category: 'Timeout/Stoppage',
      setting: `Timeout ${idx + 1} - Video Stop (MM:SS)`,
      value: timeoutVideoStop,
      description: `Video time when timeout ${idx + 1} stops`
    });
    videoTimingConfig.push({
      category: 'Timeout/Stoppage',
      setting: `Timeout ${idx + 1} - Duration (sec)`,
      value: t.duration || 0,
      description: `Duration of timeout ${idx + 1} in seconds`
    });
    videoTimingConfig.push({
      category: 'Timeout/Stoppage',
      setting: `Timeout ${idx + 1} - Type`,
      value: t.type || '',
      description: `Type of timeout ${idx + 1}`
    });
    videoTimingConfig.push({
      category: 'Timeout/Stoppage',
      setting: `Timeout ${idx + 1} - Notes`,
      value: t.notes || '',
      description: `Notes for timeout ${idx + 1}`
    });
  });
  
  // Video Management - All Videos
  if (S.videos && S.videos.length > 0) {
    S.videos.forEach((video, idx) => {
      videoTimingConfig.push({
        category: 'Video Management',
        setting: `Video ${idx + 1} - URL`,
        value: video.url || '',
        description: `Video ${idx + 1} URL`
      });
      videoTimingConfig.push({
        category: 'Video Management',
        setting: `Video ${idx + 1} - Type`,
        value: video.type || '',
        description: `Video ${idx + 1} type`
      });
      videoTimingConfig.push({
        category: 'Video Management',
        setting: `Video ${idx + 1} - Category`,
        value: video.category || '',
        description: `Video ${idx + 1} category`
      });
      videoTimingConfig.push({
        category: 'Video Management',
        setting: `Video ${idx + 1} - Title`,
        value: video.title || '',
        description: `Video ${idx + 1} title`
      });
      videoTimingConfig.push({
        category: 'Video Management',
        setting: `Video ${idx + 1} - Period`,
        value: video.period || '',
        description: `Video ${idx + 1} period`
      });
      videoTimingConfig.push({
        category: 'Video Management',
        setting: `Video ${idx + 1} - Start Time`,
        value: video.start_time || '',
        description: `Video ${idx + 1} start time`
      });
      videoTimingConfig.push({
        category: 'Video Management',
        setting: `Video ${idx + 1} - End Time`,
        value: video.end_time || '',
        description: `Video ${idx + 1} end time`
      });
      videoTimingConfig.push({
        category: 'Video Management',
        setting: `Video ${idx + 1} - Description`,
        value: video.description || video.notes || '',
        description: `Video ${idx + 1} description`
      });
    });
  }
  
  // Highlight URLs
  const highlights = S.events
    .map((evt, idx) => ({ ...evt, idx }))
    .filter(evt => evt.isHighlight === true || evt.isHighlight === 1);
  
  highlights.forEach((evt, idx) => {
    const periodNum = evt.period === 'OT' ? 4 : parseInt(evt.period);
    const runningVideoTime = calculateRunningVideoTime(periodNum, evt.start_time);
    const runningVideoTimeMin = Math.floor(runningVideoTime / 60);
    const runningVideoTimeSec = runningVideoTime % 60;
    const runningVideoTimeDisplay = runningVideoTime > 0 ? `${runningVideoTimeMin}:${String(runningVideoTimeSec).padStart(2, '0')}` : '0:00';
    
    videoTimingConfig.push({
      category: 'Highlights',
      setting: `Highlight ${idx + 1} - Event #`,
      value: evt.idx + 1,
      description: `Event index for highlight ${idx + 1}`
    });
    videoTimingConfig.push({
      category: 'Highlights',
      setting: `Highlight ${idx + 1} - Period`,
      value: evt.period,
      description: `Period of highlight ${idx + 1}`
    });
    videoTimingConfig.push({
      category: 'Highlights',
      setting: `Highlight ${idx + 1} - Game Time (MM:SS)`,
      value: evt.start_time || '',
      description: `Game clock time of highlight ${idx + 1}`
    });
    videoTimingConfig.push({
      category: 'Highlights',
      setting: `Highlight ${idx + 1} - Running Video Time (MM:SS)`,
      value: runningVideoTimeDisplay,
      description: `Running video time of highlight ${idx + 1}`
    });
    videoTimingConfig.push({
      category: 'Highlights',
      setting: `Highlight ${idx + 1} - Event Type`,
      value: evt.type || '',
      description: `Event type of highlight ${idx + 1}`
    });
    videoTimingConfig.push({
      category: 'Highlights',
      setting: `Highlight ${idx + 1} - Event Detail`,
      value: evt.detail1 || '',
      description: `Event detail of highlight ${idx + 1}`
    });
    videoTimingConfig.push({
      category: 'Highlights',
      setting: `Highlight ${idx + 1} - Video URL`,
      value: evt.videoUrl || '',
      description: `Video URL for highlight ${idx + 1}`
    });
  });
  
  // Game Settings
  if (S.gameSettings) {
    videoTimingConfig.push({
      category: 'Game Settings',
      setting: 'Pressure Distribution',
      value: S.gameSettings.pressureDist || '',
      description: 'Pressure distribution setting'
    });
    videoTimingConfig.push({
      category: 'Game Settings',
      setting: 'XY History Count',
      value: S.gameSettings.xyHistCnt || 5,
      description: 'Number of past events to show XY for'
    });
    videoTimingConfig.push({
      category: 'Game Settings',
      setting: 'Penalty Length - Minor (minutes)',
      value: S.gameSettings.penaltyLengthMinor || S.penaltyLengths?.minor || 2,
      description: 'Minor penalty length in minutes'
    });
    videoTimingConfig.push({
      category: 'Game Settings',
      setting: 'Penalty Length - Major (minutes)',
      value: S.gameSettings.penaltyLengthMajor || S.penaltyLengths?.major || 5,
      description: 'Major penalty length in minutes'
    });
    videoTimingConfig.push({
      category: 'Game Settings',
      setting: 'Penalty Length - Misconduct (minutes)',
      value: S.gameSettings.penaltyLengthMisconduct || S.penaltyLengths?.misconduct || 10,
      description: 'Misconduct penalty length in minutes'
    });
  }
  
  // Running Time Preview (calculated values)
  const periodLengthSec1 = getPeriodLengthSeconds(1);
  const periodLengthSec2 = getPeriodLengthSeconds(2);
  const periodLengthSec3 = getPeriodLengthSeconds(3);
  const periodLengthSecOT = getPeriodLengthSeconds('OT');
  // Reuse offset and int values already declared above (offset declared at line 25385, int1/int2 at 25386-25387)
  const videoTimingOffset = S.videoTiming?.videoStartOffset || 0;
  const videoTimingInt1 = S.videoTiming?.intermission1 || 900;
  const videoTimingInt2 = S.videoTiming?.intermission2 || 900;
  const videoTimingInt3 = S.videoTiming?.intermission3 || 300;
  
  const p1Start = videoTimingOffset + (offsets[1] !== null && offsets[1] !== undefined ? parseTimeToSeconds(offsets[1]) : 0);
  const p1End = p1Start + periodLengthSec1;
  const p2Start = p1End + videoTimingInt1 + (offsets[2] !== null && offsets[2] !== undefined ? parseTimeToSeconds(offsets[2]) : 0);
  const p2End = p2Start + periodLengthSec2;
  const p3Start = p2End + videoTimingInt2 + (offsets[3] !== null && offsets[3] !== undefined ? parseTimeToSeconds(offsets[3]) : 0);
  const p3End = p3Start + periodLengthSec3;
  const otStart = p3End + videoTimingInt3 + (offsets.OT !== null && offsets.OT !== undefined ? parseTimeToSeconds(offsets.OT) : 0);
  const otEnd = otStart + periodLengthSecOT;
  
  videoTimingConfig.push({
    category: 'Running Time Preview',
    setting: 'Period 1 Start (MM:SS)',
    value: formatTimeForExport(p1Start),
    description: 'Calculated video time when period 1 starts'
  });
  videoTimingConfig.push({
    category: 'Running Time Preview',
    setting: 'Period 1 End (MM:SS)',
    value: formatTimeForExport(p1End),
    description: 'Calculated video time when period 1 ends'
  });
  videoTimingConfig.push({
    category: 'Running Time Preview',
    setting: 'Period 2 Start (MM:SS)',
    value: formatTimeForExport(p2Start),
    description: 'Calculated video time when period 2 starts'
  });
  videoTimingConfig.push({
    category: 'Running Time Preview',
    setting: 'Period 2 End (MM:SS)',
    value: formatTimeForExport(p2End),
    description: 'Calculated video time when period 2 ends'
  });
  videoTimingConfig.push({
    category: 'Running Time Preview',
    setting: 'Period 3 Start (MM:SS)',
    value: formatTimeForExport(p3Start),
    description: 'Calculated video time when period 3 starts'
  });
  videoTimingConfig.push({
    category: 'Running Time Preview',
    setting: 'Period 3 End (MM:SS)',
    value: formatTimeForExport(p3End),
    description: 'Calculated video time when period 3 ends'
  });
  videoTimingConfig.push({
    category: 'Running Time Preview',
    setting: 'OT Start (MM:SS)',
    value: formatTimeForExport(otStart),
    description: 'Calculated video time when OT starts'
  });
  videoTimingConfig.push({
    category: 'Running Time Preview',
    setting: 'OT End (MM:SS)',
    value: formatTimeForExport(otEnd),
    description: 'Calculated video time when OT ends'
  });
  
  // Add timeout previews (timeouts are shown in running time preview)
  timeouts.forEach((t, idx) => {
    // Timeout video times are stored as numbers (seconds) or MM:SS strings
    const timeoutVideoStart = t.videoStart !== null && t.videoStart !== undefined 
      ? (typeof t.videoStart === 'number' ? t.videoStart : parseTimeToSeconds(t.videoStart))
      : null;
    const timeoutVideoStop = t.videoStop !== null && t.videoStop !== undefined
      ? (typeof t.videoStop === 'number' ? t.videoStop : parseTimeToSeconds(t.videoStop))
      : null;
    
    if (timeoutVideoStart !== null) {
      videoTimingConfig.push({
        category: 'Running Time Preview',
        setting: `Timeout ${idx + 1} Start (MM:SS)`,
        value: formatTimeForExport(timeoutVideoStart),
        description: `Video time when timeout ${idx + 1} starts`
      });
    }
    if (timeoutVideoStop !== null) {
      videoTimingConfig.push({
        category: 'Running Time Preview',
        setting: `Timeout ${idx + 1} End (MM:SS)`,
        value: formatTimeForExport(timeoutVideoStop),
        description: `Video time when timeout ${idx + 1} ends`
      });
    }
  });
  
  // Create video timing configuration sheet
  const wsVideoTiming = XLSX.utils.json_to_sheet(videoTimingConfig);
  XLSX.utils.book_append_sheet(wb, wsVideoTiming, 'video_timing');
  
  return wb;
}

/**
 * v23.9: Validate export data against Supabase dim tables
 * Returns {hasErrors, hasWarnings, errors, warnings, totalIssues}
 */
async function validateExportData() {
  // Load dim values if not already loaded
  await loadDimValuesForValidation();
  
  const issues = [];
  
  // Validate events - check against exported _code columns (event_type_code, event_detail_code, etc.)
  // IMPORTANT: We validate the CODE columns that are exported, NOT the underscore input columns
  // S.dimValues.event_type contains CODES loaded from dim_event_type.event_type_code column
  // We compare exported codes (event_type_code) against dim table codes (event_type_code)
  S.events.forEach((evt, idx) => {
    // Validate event_type_code column (exported code)
    if (evt.type) {
      // Get event type code - this is what gets exported as 'event_type_code' column
      const typeCodeAndId = getEventTypeCodeAndId(evt.type);
      const typeCode = evt.typeCode || typeCodeAndId.code;
      
      // Compare against dim_event_type.event_type_code values (codes, not names)
      // S.dimValues.event_type contains codes from dim_event_type.event_type_code column
      if (typeCode && (!S.dimValues.event_type || !S.dimValues.event_type.includes(typeCode))) {
        issues.push({
          type: 'warning', // All validations are warnings - export always allowed
          category: 'event_type_code',
          field: 'Event Type Code',
          value: typeCode,
          eventIndex: idx + 1,
          eventId: evt.idx !== undefined ? evt.idx + 1 : idx + 1,
          period: evt.period,
          time: evt.start_time
        });
      }
    }
    
    // Validate event_detail_code column (exported code)
    if (evt.detail1) {
      // Get event detail code - this is what gets exported as 'event_detail_code' column
      const detailCodeAndId = getEventDetailCodeAndId(evt.detail1, evt.type);
      const detailCode = evt.detail1Code || detailCodeAndId.code;
      
      // Compare against dim_event_detail.event_detail_code values (codes, not names)
      // S.dimValues.event_detail contains codes from dim_event_detail.event_detail_code column
      if (detailCode && (!S.dimValues.event_detail || !S.dimValues.event_detail.includes(detailCode))) {
        issues.push({
          type: 'warning',
          category: 'event_detail_code',
          field: 'Event Detail 1 Code',
          value: detailCode,
          eventIndex: idx + 1,
          eventId: evt.idx !== undefined ? evt.idx + 1 : idx + 1,
          eventType: evt.type,
          period: evt.period,
          time: evt.start_time
        });
      }
    }
    
    // Validate event_detail_2_code column (exported code)
    if (evt.detail2) {
      // Get event detail 2 code - this is what gets exported as 'event_detail_2_code' column
      const detail2CodeAndId = getEventDetail2CodeAndId(evt.detail2);
      const detail2Code = evt.detail2Code || detail2CodeAndId.code;
      
      // Compare against dim_event_detail_2.event_detail_2_code values (codes, not names)
      // S.dimValues.event_detail_2 contains codes from dim_event_detail_2.event_detail_2_code column
      if (detail2Code && (!S.dimValues.event_detail_2 || !S.dimValues.event_detail_2.includes(detail2Code))) {
        issues.push({
          type: 'warning',
          category: 'event_detail_2_code',
          field: 'Event Detail 2 Code',
          value: detail2Code,
          eventIndex: idx + 1,
          eventId: evt.idx !== undefined ? evt.idx + 1 : idx + 1,
          eventType: evt.type,
          period: evt.period,
          time: evt.start_time
        });
      }
    }
    
    // Validate player play details - check play_detail_code and play_detail_2_code columns
    if (evt.players && evt.players.length > 0) {
      evt.players.forEach((player, pIdx) => {
        // Validate play_detail_code column (exported code)
        if (player.playD1) {
          // Handle comma-separated values (e.g., "AssistPrimary, Shot")
          // Note: playD1 values are already codes, exported as 'play_detail_code' column
          const playDetails1 = player.playD1.split(',').map(s => s.trim()).filter(Boolean);
          playDetails1.forEach(pd1 => {
            // Compare against dim_play_detail.play_detail_code values (codes, not names)
            // S.dimValues.play_detail contains codes from dim_play_detail.play_detail_code column
            if (!S.dimValues.play_detail || !S.dimValues.play_detail.includes(pd1)) {
              issues.push({
                type: 'warning',
                category: 'play_detail_code',
                field: 'Play Detail 1 Code',
                value: pd1,
                eventIndex: idx + 1,
                eventId: evt.idx !== undefined ? evt.idx + 1 : idx + 1,
                playerNumber: player.num,
                playerName: player.name,
                eventType: evt.type,
                period: evt.period,
                time: evt.start_time
              });
            }
          });
        }
        
        // Validate play_detail_2_code column (exported code)
        if (player.playD2) {
          // Note: playD2 values are already codes, exported as 'play_detail_2_code' column
          const playDetails2 = player.playD2.split(',').map(s => s.trim()).filter(Boolean);
          playDetails2.forEach(pd2 => {
            // Compare against dim_play_detail_2.play_detail_2_code values (codes, not names)
            // S.dimValues.play_detail_2 contains codes from dim_play_detail_2.play_detail_2_code column
            if (!S.dimValues.play_detail_2 || !S.dimValues.play_detail_2.includes(pd2)) {
              issues.push({
                type: 'warning',
                category: 'play_detail_2_code',
                field: 'Play Detail 2 Code',
                value: pd2,
                eventIndex: idx + 1,
                eventId: evt.idx !== undefined ? evt.idx + 1 : idx + 1,
                playerNumber: player.num,
                playerName: player.name,
                eventType: evt.type,
                period: evt.period,
                time: evt.start_time
              });
            }
          });
        }
      });
    }
  });
  
  // v23.6: Check goals for missing highlights or XY data
  const goals = S.events.filter(e => e.type === 'Goal' && e.detail1 === 'Goal_Scored');
  goals.forEach(goal => {
    const hasHighlight = goal.isHighlight === true || goal.isHighlight === 1 || goal.videoUrl;
    const hasXY = (goal.puckXY && goal.puckXY.length > 0) || (goal.players && goal.players.some(p => p.xy && p.xy.length > 0));
    
    if (!hasHighlight && !hasXY) {
      issues.push({
        type: 'warning',
        category: 'goal_data',
        field: 'Goal Missing Highlight/XY',
        value: 'Goal has no highlight or XY data',
        eventIndex: goal.idx !== undefined ? goal.idx + 1 : S.events.indexOf(goal) + 1,
        eventId: goal.idx !== undefined ? goal.idx + 1 : S.events.indexOf(goal) + 1,
        period: goal.period,
        time: goal.start_time,
        team: goal.team
      });
    }
  });
  
  // v23.6: Validate shifts - check for teams with fewer than 4 players
  // (Don't flag missing slots - penalties, goalie pulls, and empty X slot are normal)
  if (S.shifts && S.shifts.length > 0) {
    S.shifts.forEach((shift, idx) => {
      // Count skaters (F1, F2, F3, D1, D2, X) - exclude goalie
      const homeSkaters = ['F1', 'F2', 'F3', 'D1', 'D2', 'X'].filter(slot => shift.home?.[slot]?.num).length;
      const awaySkaters = ['F1', 'F2', 'F3', 'D1', 'D2', 'X'].filter(slot => shift.away?.[slot]?.num).length;
      
      // Only flag if a team has fewer than 4 skaters
      if (homeSkaters < 4) {
        issues.push({
          type: 'warning',
          category: 'shift_players',
          field: 'Shift Players',
          value: `Home team has only ${homeSkaters} skaters`,
          shiftIndex: idx + 1,
          period: shift.period,
          time: shift.start_time,
          team: 'home',
          skaterCount: homeSkaters
        });
      }
      
      if (awaySkaters < 4) {
        issues.push({
          type: 'warning',
          category: 'shift_players',
          field: 'Shift Players',
          value: `Away team has only ${awaySkaters} skaters`,
          shiftIndex: idx + 1,
          period: shift.period,
          time: shift.start_time,
          team: 'away',
          skaterCount: awaySkaters
        });
      }
    });
  }
  
  // Separate errors and warnings
  const errors = issues.filter(i => i.type === 'error');
  const warnings = issues.filter(i => i.type === 'warning');
  
  return {
    hasErrors: errors.length > 0,
    hasWarnings: warnings.length > 0,
    errors: errors,
    warnings: warnings,
    totalIssues: issues.length
  };
}

/**
 * v23.9: Show export validation modal with errors/warnings
 */
function showExportValidationModal(validationResult, allowProceed = false) {
  return new Promise((resolve) => {
    // Add timeout to prevent hanging
    const timeout = setTimeout(() => {
      console.warn('Validation modal timeout, auto-proceeding with export');
      const existingModal = document.getElementById('exportValidationModal');
      if (existingModal) existingModal.remove();
      resolve(true); // Auto-proceed after timeout
    }, 30000); // 30 second timeout
    
    // Remove existing modal if present
    const existingModal = document.getElementById('exportValidationModal');
    if (existingModal) existingModal.remove();
    
    const modal = document.createElement('div');
    modal.id = 'exportValidationModal';
    modal.className = 'overlay';
    modal.style.zIndex = '10001'; // Higher than other modals
    modal.innerHTML = `
      <div class="modal" style="min-width:600px;max-width:800px;max-height:80vh;overflow-y:auto;">
        <h3>${validationResult.hasErrors ? '‚ùå Export Validation Errors' : '‚ö†Ô∏è Export Validation Warnings'}</h3>
        <p style="font-size:10px;color:var(--muted);margin-bottom:12px;">
          ${validationResult.hasErrors 
            ? 'The following values do not conform to Supabase dim tables. Please fix these before exporting.'
            : 'The following values may not conform to Supabase dim tables. You can proceed, but data may fail ETL validation.'}
        </p>
        
        <div style="max-height:400px;overflow-y:auto;border:1px solid var(--border);border-radius:4px;padding:8px;background:var(--card);">
          <table style="width:100%;font-size:9px;border-collapse:collapse;">
            <thead style="position:sticky;top:0;background:var(--panel);">
              <tr>
                <th style="text-align:left;padding:4px;border-bottom:1px solid var(--border);">#</th>
                <th style="text-align:left;padding:4px;border-bottom:1px solid var(--border);">Field</th>
                <th style="text-align:left;padding:4px;border-bottom:1px solid var(--border);">Invalid Value</th>
                <th style="text-align:left;padding:4px;border-bottom:1px solid var(--border);">Player</th>
                <th style="text-align:left;padding:4px;border-bottom:1px solid var(--border);">Time</th>
              </tr>
            </thead>
            <tbody>
              ${validationResult.errors.map(issue => `
                <tr style="border-bottom:1px solid var(--border);">
                  <td style="padding:4px;">${issue.shiftIndex ? `Shift #${issue.shiftIndex}` : `Event #${issue.eventId || issue.eventIndex || '--'}`}</td>
                  <td style="padding:4px;color:var(--danger);">${issue.field}</td>
                  <td style="padding:4px;"><code style="font-size:8px;">${issue.value}</code></td>
                  <td style="padding:4px;">${issue.playerNumber ? `#${issue.playerNumber} ${issue.playerName || ''}` : '--'}</td>
                  <td style="padding:4px;">P${issue.period || '--'} ${issue.time || ''}</td>
                </tr>
              `).join('')}
              ${validationResult.warnings.map(issue => `
                <tr style="border-bottom:1px solid var(--border);background:rgba(245,158,11,0.1);">
                  <td style="padding:4px;">${issue.shiftIndex ? `Shift #${issue.shiftIndex}` : `Event #${issue.eventId || issue.eventIndex || '--'}`}</td>
                  <td style="padding:4px;color:var(--warn);">${issue.field}</td>
                  <td style="padding:4px;"><code style="font-size:8px;">${issue.value}</code></td>
                  <td style="padding:4px;">${issue.playerNumber ? `#${issue.playerNumber} ${issue.playerName || ''}` : '--'}</td>
                  <td style="padding:4px;">P${issue.period || '--'} ${issue.time || ''}</td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        </div>
        
        <div style="margin-top:12px;font-size:9px;color:var(--muted);">
          <strong>Total:</strong> ${validationResult.errors.length} error(s), ${validationResult.warnings.length} warning(s)
        </div>
        
        <div class="modal-actions" style="margin-top:16px;">
          <button class="btn-primary" onclick="document.getElementById('exportValidationModal').remove(); window._exportValidationResolve(true);">Proceed with Export</button>
          <button onclick="document.getElementById('exportValidationModal').remove(); window._exportValidationResolve(false);">Cancel</button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    modal.classList.add('show');
    modal.style.display = 'flex';
    modal.style.zIndex = '10001';
    
    // Store resolve function globally so modal buttons can call it
    // Wrap resolve to clear timeout
    window._exportValidationResolve = (value) => {
      clearTimeout(timeout);
      resolve(value);
    };
  });
}

async function exportData() {
  console.log('exportData called');
  try {
    // Verify S object is available
    if (typeof S === 'undefined' || !S) {
      console.error('S object not defined!');
      toast('Application not initialized. Please refresh the page.', 'error');
      return;
    }
    
    // Verify XLSX library is loaded
    if (typeof XLSX === 'undefined') {
      console.error('XLSX library not loaded!');
      toast('Export library not loaded. Please refresh the page.', 'error');
      return;
    }
    
    if (!S.gameId) { 
      toast('No game loaded', 'error'); 
      return; 
    }
    
    // v23.9: Validate data against Supabase dim tables before exporting
    // Only validate non-underscore columns (event_type_code, event_detail_code, etc.)
    // Wrap in try-catch so validation errors don't block export
    let validationResult = { hasErrors: false, hasWarnings: false, errors: [], warnings: [] };
    try {
      validationResult = await validateExportData();
    } catch (validationError) {
      console.warn('Validation failed, proceeding with export anyway:', validationError);
      // Continue with export even if validation fails
    }
    
    // Always allow export - warnings don't block, only show modal if there are issues
    if (validationResult.hasErrors || validationResult.hasWarnings) {
      try {
      // Show validation modal (user can proceed or cancel)
      const proceed = await showExportValidationModal(validationResult, true); // true = allow proceed
        if (!proceed) {
          console.log('User cancelled export');
          return; // User cancelled
        }
      } catch (modalError) {
        console.warn('Validation modal failed, proceeding with export:', modalError);
        // Continue with export if modal fails
      }
    }
    
    console.log('Building export workbook...');
    const wb = buildExportWorkbook();
    if (!wb) {
      throw new Error('Failed to build export workbook');
    }
    console.log('Export workbook built successfully');
  // Save to game folder if available, otherwise download
  if (S.gameFolderHandle) {
    try {
      const fileName = `${S.gameId}_tracking.xlsx`;
      const fileHandle = await S.gameFolderHandle.getFileHandle(fileName, { create: true });
      const writable = await fileHandle.createWritable();
      
      // Convert workbook to array buffer, then to blob
      const arrayBuffer = XLSX.write(wb, { type: 'array', bookType: 'xlsx' });
      const blob = new Blob([arrayBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
      
      await writable.write(blob);
      await writable.close();
      toast(`Exported to game folder: ${fileName}`, 'success');
    } catch (e) {
      console.error('Error saving to game folder:', e);
      // Fall back to download
      XLSX.writeFile(wb, `${S.gameId}_tracking.xlsx`);
      toast('Exported! (saved to downloads)', 'success');
    }
  } else {
    XLSX.writeFile(wb, `${S.gameId}_tracking.xlsx`);
    toast('Exported!', 'success');
  }
  } catch (error) {
    console.error('Export error:', error);
    toast(`Export failed: ${error.message}`, 'error');
    throw error; // Re-throw so browser console shows full stack trace
  }
}

// ============================================================
// EXPORT TO CSV (Multiple files to avoid memory issues)
// ============================================================
async function exportToCSV() {
  console.log('exportToCSV called');
  try {
    // Verify S object is available
    if (typeof S === 'undefined' || !S) {
      console.error('S object not defined!');
      toast('Application not initialized. Please refresh the page.', 'error');
      return;
    }
    
    if (!S.gameId) { 
      toast('No game loaded', 'error'); 
      return; 
    }
    
    // Verify XLSX library is loaded (needed for buildExportWorkbook)
    if (typeof XLSX === 'undefined') {
      console.error('XLSX library not loaded!');
      toast('Export library not loaded. Please refresh the page.', 'error');
      return; 
    }
    
    console.log('=== CSV EXPORT START ===');
    const startTime = performance.now();
    // Validate required data
    if (!S.homeTeam || !S.awayTeam) {
      toast('Team names missing. Please load game from Supabase first.', 'error');
      return;
    }
    
    // Validate events array
    if (!Array.isArray(S.events)) {
      console.error('S.events is not an array:', S.events);
      toast('Invalid events data. Please reload the game.', 'error');
      return;
    }
    
    // Helper to convert object to CSV row
    const objectToCSV = (obj, headers) => {
      return headers.map(h => {
        const val = obj[h];
        if (val === null || val === undefined) return '';
        // Escape quotes and wrap in quotes if contains comma, quote, or newline
        const str = String(val);
        if (str.includes(',') || str.includes('"') || str.includes('\n')) {
          return `"${str.replace(/"/g, '""')}"`;
        }
        return str;
      }).join(',');
    };
    
    // Helper to download CSV
    const downloadCSV = (filename, headers, rows) => {
      console.log(`downloadCSV called: ${filename}, ${headers.length} headers, ${rows.length} rows`);
      try {
        if (!headers || headers.length === 0) {
          console.error('No headers provided for CSV');
          toast(`No headers for ${filename}`, 'error');
          return;
        }
        if (!rows || rows.length === 0) {
          console.warn(`No rows for ${filename}, creating empty CSV with headers only`);
        }
        
        const csv = [
          headers.join(','),
          ...rows.map(r => objectToCSV(r, headers))
        ].join('\n');
        
        console.log(`CSV content length: ${csv.length} characters`);
        
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        link.setAttribute('download', filename);
        link.style.visibility = 'hidden';
        link.style.display = 'none';
        document.body.appendChild(link);
        
        console.log(`Triggering download for ${filename}`);
        link.click();
        
        // Clean up after a short delay
        setTimeout(() => {
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
          console.log(`Download completed for ${filename}`);
        }, 100);
      } catch (e) {
        console.error(`Error downloading ${filename}:`, e);
        toast(`Failed to download ${filename}: ${e.message}`, 'error');
      }
    };
    
    // Export metadata
    const metadata = [{
      game_id: S.gameId,
      home_team: S.homeTeam || '',
      away_team: S.awayTeam || '',
      period_length_minutes: S.periodLength || 18,
      home_attacks_right_p1: S.homeAttacksRightP1 ? 1 : 0,
      export_timestamp: new Date().toISOString(),
      tracker_version: 'v23.5'
    }];
    const metaHeaders = Object.keys(metadata[0]);
    downloadCSV(`${S.gameId}_metadata.csv`, metaHeaders, metadata);
    
    // Wait a bit before next download to avoid browser blocking
    await new Promise(resolve => setTimeout(resolve, 300));
    
    // Export events and shifts - build workbook once and extract both sheets
    console.log(`Building export workbook with ${S.events.length} events and ${S.shifts.length} shifts...`);
    let wb;
    try {
      wb = buildExportWorkbook();
      console.log('Workbook created successfully. Sheets:', wb.SheetNames);
    } catch (e) {
      console.error('Error building export workbook:', e);
      toast('Failed to build export workbook: ' + e.message, 'error');
      throw e;
    }
    
    // Export events
    if (S.events.length > 0) {
      const eventsSheet = wb.Sheets['events'];
      if (eventsSheet) {
        try {
          const eventData = XLSX.utils.sheet_to_json(eventsSheet);
          console.log(`Extracted ${eventData.length} event rows from sheet`);
          if (eventData.length > 0) {
            const eventHeaders = Object.keys(eventData[0]);
            downloadCSV(`${S.gameId}_events.csv`, eventHeaders, eventData);
            console.log(`‚úì Exported ${eventData.length} event rows to CSV`);
            // Wait before next download
            await new Promise(resolve => setTimeout(resolve, 300));
          } else {
            console.warn('Events sheet exists but has no data');
            toast('Events sheet is empty', 'warning');
          }
        } catch (e) {
          console.error('Error converting events sheet to JSON:', e);
          toast('Failed to export events: ' + e.message, 'error');
        }
      } else {
        console.error('Events sheet not found in workbook. Available sheets:', wb.SheetNames);
        toast('Events sheet not found in export', 'error');
      }
    } else {
      console.log('No events to export');
    }
    
    // Export shifts
    if (Array.isArray(S.shifts) && S.shifts.length > 0) {
      const shiftsSheet = wb.Sheets['shifts'];
      if (shiftsSheet) {
        try {
          const shiftData = XLSX.utils.sheet_to_json(shiftsSheet);
          console.log(`Extracted ${shiftData.length} shift rows from sheet`);
          if (shiftData.length > 0) {
            const shiftHeaders = Object.keys(shiftData[0]);
            downloadCSV(`${S.gameId}_shifts.csv`, shiftHeaders, shiftData);
            console.log(`‚úì Exported ${shiftData.length} shift rows to CSV`);
            // Wait before completion
            await new Promise(resolve => setTimeout(resolve, 300));
          } else {
            console.warn('Shifts sheet exists but has no data');
            toast('Shifts sheet is empty', 'warning');
          }
        } catch (e) {
          console.error('Error converting shifts sheet to JSON:', e);
          toast('Failed to export shifts: ' + e.message, 'error');
        }
      } else {
        console.error('Shifts sheet not found in workbook. Available sheets:', wb.SheetNames);
        toast('Shifts sheet not found in export', 'error');
      }
    } else {
      console.log('No shifts to export');
    }
    
    const endTime = performance.now();
    const duration = ((endTime - startTime) / 1000).toFixed(2);
    console.log(`=== CSV EXPORT COMPLETE ===`);
    console.log(`Duration: ${duration}s`);
    
    // Add a small delay to ensure all downloads complete
    setTimeout(() => {
      toast('CSV files exported! Check your downloads folder.', 'success');
    }, 500);
  } catch (err) {
    console.error('CSV export error:', err);
    console.error('Error stack:', err.stack);
    toast('CSV export failed: ' + (err.message || String(err)), 'error');
    throw err; // Re-throw so it shows in console
  }
}

// ============================================================
// IMPORT EXCEL
// ============================================================
async function importExcel(file) {
  if (!file) return;
  
  try {
    const data = await file.arrayBuffer();
    const wb = XLSX.read(data, { type: 'array' });
    
    console.log('Import: Sheets found:', wb.SheetNames);
    
    // Check for required sheets
    const hasEvents = wb.SheetNames.includes('events');
    const hasShifts = wb.SheetNames.includes('shifts');
    const hasMetadata = wb.SheetNames.includes('metadata');
    
    if (!hasEvents && !hasShifts) {
      toast('No events or shifts sheet found', 'error');
      return;
    }
    
    // Read videos sheet if present (v23.6)
    const hasVideos = wb.SheetNames.includes('videos');
    if (hasVideos) {
      const videosSheet = XLSX.utils.sheet_to_json(wb.Sheets['videos']);
      if (videosSheet && videosSheet.length > 0) {
        S.videos = videosSheet.map(v => ({
          id: Date.now().toString() + Math.random(),
          url: v.video_url || '',
          type: v.video_type || 'Full_Ice',
          video_id: v.video_id || '',
          title: v.title || undefined,
          description: v.description || undefined,
          start_time: v.start_time || undefined,
          end_time: v.end_time || undefined,
          period: v.period ? parseInt(v.period) : undefined,
          notes: v.notes || undefined
        }));
        toast(`Loaded ${S.videos.length} video(s)`, 'success');
      }
    }
    
    // Read metadata sheet if present (v19: includes zone orientation)
    if (hasMetadata) {
      const metaSheet = XLSX.utils.sheet_to_json(wb.Sheets['metadata']);
      if (metaSheet.length > 0) {
        const meta = metaSheet[0];
        if (meta.home_attacks_right_p1 !== undefined) {
          S.homeAttacksRightP1 = meta.home_attacks_right_p1 === 1 || meta.home_attacks_right_p1 === true;
          updateZoneLabels();
          const btn = document.getElementById('flipZonesBtn');
          if (btn) btn.style.background = S.homeAttacksRightP1 ? '#374151' : '#7c3aed';
        }
        if (meta.period_length_minutes) {
          S.periodLength = meta.period_length_minutes;
        }
        console.log('Import: Loaded metadata - homeAttacksRightP1:', S.homeAttacksRightP1);
      }
    }
    
    // Parse events sheet
    let importedEvents = [];
    let gameId = null;
    let homeTeam = null;
    let awayTeam = null;
    
    if (hasEvents) {
      const eventsSheet = XLSX.utils.sheet_to_json(wb.Sheets['events']);
      console.log('Import: Raw events rows:', eventsSheet.length);
      
      // Get game info from first row
      if (eventsSheet.length > 0) {
        gameId = eventsSheet[0].game_id;
        homeTeam = eventsSheet[0].home_team;
        awayTeam = eventsSheet[0].away_team;
      }
      
      // Group rows by event_index to reconstruct events with multiple players
      // The Excel is in LONG format (one row per player per event)
      const eventGroups = {};
      
      eventsSheet.forEach(row => {
        // Get event index - try multiple column names
        const eventIdx = row.event_index || row['event_index_flag_'] || row.event_index_ || row.tracking_event_index || 0;
        if (!eventIdx) return;
        
        // Get event type - prefer event_type_ over Type (Type is often sparse/calculated)
        const eventType = row.event_type_ || row['event_type_'] || row.Type || '';
        if (!eventType) return; // Skip rows without event type
        
        // Get times - check non-underscore columns first (they have actual data), then underscore versions
        const startMin = row.event_start_min ?? row['event_start_min_'] ?? '';
        const startSec = row.event_start_sec ?? row['event_start_sec_'] ?? '';
        const endMin = row.event_end_min ?? row['event_end_min_'] ?? '';
        const endSec = row.event_end_sec ?? row['event_end_sec_'] ?? '';
        
        if (!eventGroups[eventIdx]) {
          eventGroups[eventIdx] = {
            rows: [],
            period: row.period,
            type: eventType,
            team: parseTeam(row.team_ || row['team_'] || row.team_venue || row.team_venue_abv),
            zone: parseZone(row.event_team_zone_ || row['event_team_zone_'] || row.event_team_zone),
            success: parseSuccess(row.event_successful_ || row['event_successful_'] || row.event_successful),
            detail1: row.event_detail_ || row['event_detail_'] || row.event_detail || '',
            detail2: row.event_detail_2_ || row['event_detail_2_'] || row.event_detail_2 || '',
            start_time: formatTime(startMin, startSec),
            end_time: formatTime(endMin, endSec),
            strength: row.strength || '5v5',
            // v23.8: Prioritize linked_event_index (no underscore) over flag versions
            // Check all possible column name variations
            linkedEventIdx: (() => {
              // Try linked_event_index (no underscore) first - this is the ETL format
              let val = row.linked_event_index;
              if (val === undefined || val === null || val === '') {
                val = row['linked_event_index'];
              }
              if (val === undefined || val === null || val === '') {
                val = row.linked_event_index_ || row['linked_event_index_'];
              }
              if (val === undefined || val === null || val === '') {
                val = row.linked_event_index_flag_ || row['linked_event_index_flag_'];
              }
              return val !== undefined && val !== null && val !== '' ? val : null;
            })(),
            assistToGoalIdx: row.assist_to_goal_index_ || row['assist_to_goal_index_'] || row.assist_to_goal_index ? (parseInt(row.assist_to_goal_index_ || row['assist_to_goal_index_'] || row.assist_to_goal_index) - 1000) : (row.assist_to_goal_index_flag_ ? parseInt(row.assist_to_goal_index_flag_) - 1 : null), // v23.8: Separate column for assists
            sequenceIdx: row.sequence_index_ || row['sequence_index_'] || row.sequence_index || null,
            playIdx: row.play_index_ || row['play_index_'] || row.play_index || null,
            isHighlight: row.is_highlight === 1 || row.is_highlight === true || false,  // v23.7: Import highlight flag
            videoUrl: row.video_url || ''  // v23.7: Import individual highlight video URL
          };
        }
        eventGroups[eventIdx].rows.push(row);
      });
      
      // Convert groups to events
      Object.keys(eventGroups).sort((a, b) => parseInt(a) - parseInt(b)).forEach((idx, i) => {
        const group = eventGroups[idx];
        const evt = {
          idx: i,
          period: parseInt(group.period) || 1,
          type: group.type || 'Unknown',
          team: group.team,
          zone: group.zone,
          success: group.success,
          detail1: group.detail1,
          detail2: group.detail2,
          start_time: group.start_time,
          end_time: group.end_time || group.start_time,
          strength: group.strength,
          // v23.8: Handle linked_event_index - could be 1-based, 1000-based, or already 0-based
          linkedEventIdx: (() => {
            const linkedVal = group.linkedEventIdx;
            // Check for null, undefined, or empty string (but allow 0)
            if (linkedVal === null || linkedVal === undefined || linkedVal === '') {
              return null;
            }
            
            // Try parsing as number
            const parsed = parseInt(linkedVal);
            if (isNaN(parsed)) {
              console.warn(`Import: Invalid linked_event_index value: ${linkedVal}, treating as null`);
              return null;
            }
            
            // If it's 1000-based (ETL format: event_index = 1000 + actual_index), convert to 0-based index
            if (parsed >= 1000) {
              const converted = parsed - 1000;
              console.log(`Import: Converted linked_event_index from ETL format ${parsed} to 0-based ${converted}`);
              return converted;
            }
            // If it's 1-based (user-friendly format), convert to 0-based
            if (parsed > 0) {
              const converted = parsed - 1;
              console.log(`Import: Converted linked_event_index from 1-based ${parsed} to 0-based ${converted}`);
              return converted;
            }
            // Already 0-based or 0
            console.log(`Import: Using linked_event_index as-is (0-based): ${parsed}`);
            return parsed;
          })(),
          assistToGoalIdx: group.assistToGoalIdx ? (group.assistToGoalIdx >= 1000 ? parseInt(group.assistToGoalIdx) - 1000 : parseInt(group.assistToGoalIdx) - 1) : null, // v23.8: Separate column for assists
          sequenceIdx: group.sequenceIdx,
          playIdx: group.playIdx,
          players: [],
          puckXY: [],
          netXY: null,  // v23.5: Import net target location
          isHighlight: group.isHighlight || false,  // v23.7: Import highlight flag
          videoUrl: group.isHighlight && group.videoUrl ? group.videoUrl : undefined  // v23.7: Import individual highlight video URL
        };
        
        // Add players from rows
        group.rows.forEach(row => {
          const playerNum = row.player_game_number_ || row['player_game_number_'] || row.player_game_number;
          if (playerNum && !isNaN(parseInt(playerNum))) {
            const roleAbrev = row.role_abrev || '';
            const playerRoleRaw = row.player_role || '';
            const playerRole = parseRoleFromRaw(playerRoleRaw, roleAbrev);
            const numInt = parseInt(playerNum);
            
            // Determine player team based on role
            // event_team_player = same team as event
            // opp_team_player = opposite team
            const isOppPlayer = playerRoleRaw.includes('opp') || roleAbrev.toLowerCase().startsWith('o');
            let playerTeam = isOppPlayer 
              ? (group.team === 'home' ? 'away' : 'home')
              : group.team;
            
            // Try to get name from roster - check both teams to find the player
            let roster = S.rosters?.[playerTeam] || [];
            let rosterPlayer = roster.find(p => parseInt(p.num) === numInt);
            
            // If not found on expected team, check the other team
            if (!rosterPlayer) {
              const otherTeam = playerTeam === 'home' ? 'away' : 'home';
              const otherRoster = S.rosters?.[otherTeam] || [];
              const otherTeamPlayer = otherRoster.find(p => parseInt(p.num) === numInt);
              
              if (otherTeamPlayer) {
                // Player is on the other team - this will be flagged in validation
                // Keep the role-based assignment but validation will catch it
                console.warn(`Import: Player #${numInt} is on ${otherTeam} roster but role suggests ${playerTeam} team`);
              }
            }
            
            const playerName = rosterPlayer?.name || row.player_name || `#${numInt}`;
            
            evt.players.push({
              num: numInt,
              name: playerName,
              team: playerTeam,
              role: playerRole,
              roleNum: parseRoleNum(roleAbrev),
              playD1: row.play_detail1_ || row['play_detail1_'] || row.play_detail1 || '',
              playD2: row.play_detail2_ || row['play_detail2_'] || row.play_detail_2 || '',
              playSuccess: row.play_detail_successful_ || row['play_detail_successful_'] || row.play_detail_successful || '',
              pressure: row.pressured_pressurer_ || row['pressured_pressurer_'] || row.pressured_pressurer || '',
              sideOfPuck: row.side_of_puck_ || row['side_of_puck_'] || row.side_of_puck || '',
              xy: []
            });
            
            // v23.5: Extract player XY coordinates for this player
            const lastPlayer = evt.players[evt.players.length - 1];
            for (let k = 1; k <= 10; k++) {
              const plx = row[`player_x_${k}`];
              const ply = row[`player_y_${k}`];
              if (plx !== undefined && ply !== undefined && !isNaN(plx) && !isNaN(ply)) {
                lastPlayer.xy.push({ x: parseFloat(plx), y: parseFloat(ply), seq: k });
              }
            }
          }
          
          // Extract puck XY coordinates
          for (let j = 1; j <= 10; j++) {
            const px = row[`puck_x_${j}`];
            const py = row[`puck_y_${j}`];
            if (px !== undefined && py !== undefined && !isNaN(px) && !isNaN(py)) {
              // Only add if not already present (since it's repeated per player row)
              if (!evt.puckXY.find(p => p.x === px && p.y === py)) {
                evt.puckXY.push({ x: parseFloat(px), y: parseFloat(py) });
              }
            }
          }
          
          // v23.5: Extract net XY coordinates (shot target)
          if (!evt.netXY) {
            const nx = row.net_x ?? row['net_x'];
            const ny = row.net_y ?? row['net_y'];
            if (nx !== undefined && ny !== undefined && !isNaN(nx) && !isNaN(ny)) {
              evt.netXY = { x: parseFloat(nx), y: parseFloat(ny) };
            }
          }
        });
        
        importedEvents.push(evt);
      });
      
      console.log('Import: Parsed events:', importedEvents.length);
    }
    
    // Parse shifts sheet
    let importedShifts = [];
    
    if (hasShifts) {
      const shiftsSheet = XLSX.utils.sheet_to_json(wb.Sheets['shifts']);
      console.log('Import: Raw shifts rows:', shiftsSheet.length);
      
      // Get game info if not already set
      if (!gameId && shiftsSheet.length > 0) {
        gameId = shiftsSheet[0].game_id;
        homeTeam = shiftsSheet[0].home_team;
        awayTeam = shiftsSheet[0].away_team;
      }
      
      shiftsSheet.forEach((row, i) => {
        // Handle NaN values for stop_type
        let stopType = row.shift_stop_type;
        if (stopType === null || stopType === undefined || (typeof stopType === 'number' && isNaN(stopType)) || stopType === 'nan') {
          stopType = '';
        }
        
        const shift = {
          period: parseInt(row.Period) || 1,
          start_time: formatTime(row.shift_start_min, row.shift_start_sec),
          end_time: formatTime(row.shift_end_min, row.shift_end_sec),
          start_type: row.shift_start_type || 'OnTheFly',
          stop_type: stopType,
          strength: row.strength || '5v5',
          duration: row.shift_duration || null,
          stoppageTime: row.stoppage_time || 0,
          home: {
            F1: parsePlayer(row.home_forward_1, 'home'),
            F2: parsePlayer(row.home_forward_2, 'home'),
            F3: parsePlayer(row.home_forward_3, 'home'),
            D1: parsePlayer(row.home_defense_1, 'home'),
            D2: parsePlayer(row.home_defense_2, 'home'),
            G: parsePlayer(row.home_goalie, 'home'),
            X: parsePlayer(row.home_xtra, 'home')
          },
          away: {
            F1: parsePlayer(row.away_forward_1, 'away'),
            F2: parsePlayer(row.away_forward_2, 'away'),
            F3: parsePlayer(row.away_forward_3, 'away'),
            D1: parsePlayer(row.away_defense_1, 'away'),
            D2: parsePlayer(row.away_defense_2, 'away'),
            G: parsePlayer(row.away_goalie, 'away'),
            X: parsePlayer(row.away_xtra, 'away')
          }
        };
        importedShifts.push(shift);
      });
      
      console.log('Import: Parsed shifts:', importedShifts.length);
    }
    
    // Confirm import
    const evtCount = importedEvents.length;
    const shiftCount = importedShifts.length;
    const msg = `Import ${evtCount} events and ${shiftCount} shifts from game ${gameId}?\n\nThis will REPLACE current data.\n\nNote: Select the game in dropdown FIRST to load rosters for player name lookup.`;
    
    if (!confirm(msg)) {
      toast('Import cancelled', 'info');
      document.getElementById('importFileInput').value = '';
      return;
    }
    
    // Try to select the game if we have a gameId
    if (gameId) {
      S.gameId = parseInt(gameId);
      S.homeTeam = homeTeam;
      S.awayTeam = awayTeam;
      
      // Try to select the game in dropdown and load roster
      const gameSelect = document.getElementById('gameSelect');
      if (gameSelect && gameSelect.querySelector(`option[value="${gameId}"]`)) {
        gameSelect.value = gameId;
        // Try to load roster for this game
        try {
          await selectGame(gameId);
          // Re-process players with loaded roster
          importedShifts = importedShifts.map(shift => ({
            ...shift,
            home: {
              F1: shift.home.F1 ? parsePlayer(shift.home.F1.num, 'home') : null,
              F2: shift.home.F2 ? parsePlayer(shift.home.F2.num, 'home') : null,
              F3: shift.home.F3 ? parsePlayer(shift.home.F3.num, 'home') : null,
              D1: shift.home.D1 ? parsePlayer(shift.home.D1.num, 'home') : null,
              D2: shift.home.D2 ? parsePlayer(shift.home.D2.num, 'home') : null,
              G: shift.home.G ? parsePlayer(shift.home.G.num, 'home') : null,
              X: shift.home.X ? parsePlayer(shift.home.X.num, 'home') : null
            },
            away: {
              F1: shift.away.F1 ? parsePlayer(shift.away.F1.num, 'away') : null,
              F2: shift.away.F2 ? parsePlayer(shift.away.F2.num, 'away') : null,
              F3: shift.away.F3 ? parsePlayer(shift.away.F3.num, 'away') : null,
              D1: shift.away.D1 ? parsePlayer(shift.away.D1.num, 'away') : null,
              D2: shift.away.D2 ? parsePlayer(shift.away.D2.num, 'away') : null,
              G: shift.away.G ? parsePlayer(shift.away.G.num, 'away') : null,
              X: shift.away.X ? parsePlayer(shift.away.X.num, 'away') : null
            }
          }));
        } catch (e) {
          console.log('Could not load game roster:', e);
        }
      }
    }
    
    // v23.9: Validate and fix team designations against schedule
    const correctedData = await validateAndFixTeamDesignations(gameId, homeTeam, awayTeam, importedEvents, importedShifts);
    importedEvents = correctedData.events;
    importedShifts = correctedData.shifts;
    const teamCorrectionApplied = correctedData.correctionApplied;
    const scheduleHomeTeam = correctedData.scheduleHomeTeam;
    const scheduleAwayTeam = correctedData.scheduleAwayTeam;
    
    // Update S.homeTeam and S.awayTeam to schedule values (correct)
    if (scheduleHomeTeam && scheduleAwayTeam) {
      S.homeTeam = scheduleHomeTeam;
      S.awayTeam = scheduleAwayTeam;
      // Update UI
      document.getElementById('homeLbl').textContent = S.homeTeam;
      document.getElementById('awayLbl').textContent = S.awayTeam;
      document.getElementById('evtHomeLbl').textContent = S.homeTeam;
      document.getElementById('evtAwayLbl').textContent = S.awayTeam;
    }
    
    // v20.5: Load dim values and check for mapping needs
    await loadDimValuesForValidation();
    const mappingsNeeded = analyzeImportMappings(importedEvents);
    
    // Function to complete import (called after mappings are applied or skipped)
    const completeImport = (events, shifts) => {
      S.events = events;
      S.shifts = shifts;
      S.evtIdx = events.length;
      S.shiftIdx = shifts.length;
      
      // POST-IMPORT: Propagate XY data to linked events missing it
      propagateXYToLinkedEvents();
      
      // v23.8: Process all goals to detect and link assists
      processAllGoalsForAssists();
      
      // v23.8: Auto-mark all Goal events as highlights
      const goals = S.events.filter(e => e.type === 'Goal' && e.detail1 === 'Goal_Scored');
      goals.forEach(goal => {
        goal.isHighlight = true;
      });
      
      // Render
      renderAll();
      autoSave();
      
      toast(`Imported ${events.length} events, ${shifts.length} shifts`, 'success');
      console.log('Import complete:', { events: S.events.length, shifts: S.shifts.length });
      
      // v23.8: Show video URL entry modal for goals if any exist
      if (goals.length > 0) {
        setTimeout(() => {
          showGoalVideoUrlsModal(goals);
        }, 500);
      } else {
        // If no goals, just show verification
        setTimeout(() => {
          openVerifyModal();
        }, 500);
      }
    };
    
    // If mappings needed, show modal
    if (mappingsNeeded.length > 0) {
      console.log('Import: Found', mappingsNeeded.length, 'values needing mapping review');
      showMappingModal(
        mappingsNeeded,
        // onAccept - apply mappings then validate teams and show warning
        (finalMappings) => {
          const mappedEvents = applyMappingsToEvents(importedEvents, finalMappings);
          // Validate player teams and show warning if needed
          validatePlayerTeams(mappedEvents, () => {
            completeImport(mappedEvents, importedShifts);
          });
        },
        // onSkip - validate teams and show warning, then complete
        () => {
          toast('Skipped value mapping - using original values', 'info');
          validatePlayerTeams(importedEvents, () => {
            completeImport(importedEvents, importedShifts);
          });
        }
      );
    } else {
      // No mappings needed - validate teams and show warning
      console.log('Import: All values match dim tables');
      validatePlayerTeams(importedEvents, () => {
        completeImport(importedEvents, importedShifts);
      });
    }
    
  } catch (e) {
    console.error('Import error:', e);
    toast('Import failed: ' + e.message, 'error');
  }
  
  // Reset file input
  document.getElementById('importFileInput').value = '';
}

/**
 * v23.9: Propagate XY data to ALL linked events (puck and player)
 * When an event is saved with linkedEventIdx, propagates XY to all events in that link chain
 * Also runs after import to fill in missing XY data
 */
function propagateXYToLinkedEvents() {
  if (!S.events?.length) return;
  
  let propagatedCount = 0;
  
  // Group events by linkedEventIdx (all events with same linkedEventIdx are linked together)
  const linkedGroups = {};
  S.events.forEach((evt, idx) => {
    if (evt.linkedEventIdx !== null && evt.linkedEventIdx !== undefined) {
      const key = evt.linkedEventIdx;
      if (!linkedGroups[key]) linkedGroups[key] = [];
      linkedGroups[key].push({ evt, idx });
    }
  });
  
  // For each linked group, find the event with the most complete XY data and propagate to all others
  Object.values(linkedGroups).forEach(group => {
    if (group.length < 2) return; // Need at least 2 events to propagate
    
    // Find the best source event (one with most complete XY data)
    // Score: puckXY.length + playerCount * 2 (prioritize events with more XY data)
    const scored = group.map(({ evt, idx }) => {
      const puckXYCount = evt.puckXY?.length || 0;
      const playerXYCount = (evt.players || []).filter(p => p.xy?.length > 0).length;
      const score = puckXYCount + (playerXYCount * 2);
      return { evt, idx, score };
    }).sort((a, b) => b.score - a.score);
    
    if (scored[0].score === 0) return; // No XY data to propagate
    
    const source = scored[0].evt;
    const sourceIdx = scored[0].idx;
    
    // Propagate to all other events in the group
    group.forEach(({ evt, idx }) => {
      if (idx === sourceIdx) return; // Skip source event
      
      let updated = false;
      
      // Copy puck XY if missing or incomplete
      if (source.puckXY?.length > 0) {
        if (!evt.puckXY?.length || evt.puckXY.length < source.puckXY.length) {
          S.events[idx].puckXY = JSON.parse(JSON.stringify(source.puckXY));
          updated = true;
        }
      }
      
      // Copy net XY if missing
      if (source.netXY && !evt.netXY) {
        S.events[idx].netXY = JSON.parse(JSON.stringify(source.netXY));
        updated = true;
      }
      
      // Copy player XY - ensure ALL players from source are copied/merged
      if (source.players?.length > 0) {
        if (!S.events[idx].players) S.events[idx].players = [];
        
        source.players.forEach(srcPlayer => {
          if (!srcPlayer.xy?.length) return;
          
          // Find matching player by number and team
          const existingIdx = S.events[idx].players.findIndex(p => 
            String(p.num) === String(srcPlayer.num) && p.team === srcPlayer.team
          );
          
          if (existingIdx >= 0) {
            // Merge: update XY if source has more points
            if (!S.events[idx].players[existingIdx].xy?.length || 
                srcPlayer.xy.length > S.events[idx].players[existingIdx].xy.length) {
              S.events[idx].players[existingIdx].xy = JSON.parse(JSON.stringify(srcPlayer.xy));
              updated = true;
            }
          } else {
            // Add player with XY (deep copy to preserve all properties)
            S.events[idx].players.push(JSON.parse(JSON.stringify(srcPlayer)));
            updated = true;
          }
        });
      }
      
      if (updated) propagatedCount++;
    });
  });
  
  if (propagatedCount > 0) {
    console.log(`Propagated XY data to ${propagatedCount} linked events`);
    // Don't show toast during normal operation (only during import)
    if (propagatedCount > 5) { // Only show for bulk operations
      toast(`Filled XY for ${propagatedCount} linked events`, 'info');
    }
  }
}

// Helper functions for import
function parseTeam(value) {
  if (!value) return 'home';
  const v = String(value).toLowerCase().trim();
  if (v === 'h' || v === 'home' || v.includes('home')) return 'home';
  if (v === 'a' || v === 'away' || v.includes('away')) return 'away';
  return 'home';
}

function parseZone(value) {
  if (!value) return 'n';
  const v = String(value).toLowerCase().trim();
  if (v === 'o' || v === 'off' || v.includes('offensive')) return 'o';
  if (v === 'd' || v === 'def' || v.includes('defensive')) return 'd';
  if (v === 'n' || v === 'neu' || v.includes('neutral')) return 'n';
  return 'n';
}

function parseSuccess(value) {
  if (value === null || value === undefined || value === '') return null;
  const v = String(value).toLowerCase().trim();
  if (v === 's' || v === 'y' || v === 'yes' || v === 'true' || v === '1') return true;
  if (v === 'u' || v === 'n' || v === 'no' || v === 'false' || v === '0') return false;
  return null;
}

function formatTime(min, sec) {
  if (min === null || min === undefined || min === '') return '';
  const m = String(min).padStart(2, '0');
  const s = String(sec || 0).padStart(2, '0');
  return `${m}:${s}`;
}

function parsePlayer(num, team) {
  if (!num || isNaN(parseInt(num))) return null;
  const numInt = parseInt(num);
  
  // Try to find player name from roster
  const roster = S.rosters?.[team] || [];
  const rosterPlayer = roster.find(p => parseInt(p.num) === numInt);
  
  return { 
    num: numInt, 
    name: rosterPlayer?.name || `#${numInt}` 
  };
}

function parseRoleFromRaw(rawRole, abrev) {
  // Convert Excel role format to tracker format
  // Excel: event_team_player_1, opp_team_player_1
  // Tracker: event_player_1, opp_player_1
  if (rawRole) {
    // Replace event_team_player with event_player
    if (rawRole.includes('event_team_player')) {
      return rawRole.replace('event_team_player', 'event_player');
    }
    // Replace opp_team_player with opp_player
    if (rawRole.includes('opp_team_player')) {
      return rawRole.replace('opp_team_player', 'opp_player');
    }
    // Already in correct format
    if (rawRole.includes('event_player') || rawRole.includes('opp_player')) {
      return rawRole;
    }
  }
  
  // Fall back to parsing from abbreviation
  return parseRoleFromAbrev(abrev);
}

function parseRoleFromAbrev(abrev) {
  if (!abrev) return 'event_player_1';
  const a = String(abrev).toLowerCase().trim();
  
  // e, e1, e2 -> event_player_X
  if (a === 'e' || a.startsWith('e')) {
    const num = parseInt(a.substring(1)) || 1;
    return `event_player_${num}`;
  }
  // o, o1, o2 -> opp_player_X
  if (a === 'o' || a.startsWith('o')) {
    const num = parseInt(a.substring(1)) || 1;
    return `opp_player_${num}`;
  }
  // h1, h2 -> event_player (home)
  if (a.startsWith('h')) {
    const num = parseInt(a.substring(1)) || 1;
    return `event_player_${num}`;
  }
  // a1, a2 -> could be either depending on context
  if (a.startsWith('a')) {
    const num = parseInt(a.substring(1)) || 1;
    return `event_player_${num}`;
  }
  
  return 'event_player_1';
}

function parseRoleNum(abrev) {
  if (!abrev) return 1;
  const match = String(abrev).match(/\d+/);
  return match ? parseInt(match[0]) : 1;
}

// ============================================================
// KEYBOARD
// ============================================================
function setupKeys() {
  document.addEventListener('keydown', e => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
    
    const key = e.key.toUpperCase();
    
    // Event type hotkeys - flash indicator on activation (v5)
    const typeMap = { F:'Faceoff', S:'Shot', P:'Pass', G:'Goal', T:'Turnover', Z:'Zone_Entry_Exit', N:'Penalty', X:'Stoppage', O:'Possession', V:'Save', R:'Rebound', D:'DeadIce', Y:'Play' };
    if (typeMap[key]) { 
      setEvtType(typeMap[key]); 
      flashHotkeyIndicator(key);
      return; 
    }
    
    // Enter = log event (with confirmation), Shift+Enter = quick log (no confirmation)
    // Ctrl+L or Cmd+L = log event and auto-create next linked event
    if (e.key === 'Enter') { 
      e.preventDefault(); // Prevent form submission and other default behaviors
      
      // Check if confirmation modal is open - if so, Ctrl+L = log & next
      const confirmModal = document.getElementById('confirmEventModal');
      if ((e.ctrlKey || e.metaKey) && confirmModal && confirmModal.classList.contains('show')) {
        confirmAndLogWithNext();
        return;
      }
      
      if (e.shiftKey) {
        logEventDirect(); // Quick log without confirmation
      } else {
        logEvent(); // Normal log (shows confirmation if not skipped)
      }
      return; 
    }
    
    // Ctrl+L or Cmd+L = log and auto-create next linked event (when confirmation modal is open)
    if ((e.ctrlKey || e.metaKey) && key === 'L') {
      const confirmModal = document.getElementById('confirmEventModal');
      if (confirmModal && confirmModal.classList.contains('show')) {
        e.preventDefault();
        confirmAndLogWithNext();
        return;
      }
    }
    
    // Escape = clear or close modals
    if (e.key === 'Escape') { 
      // Close any open modals first
      const modals = document.querySelectorAll('.overlay.show');
      if (modals.length > 0) {
        modals.forEach(m => m.classList.remove('show'));
        return;
      }
      clearEvent(); 
      return; 
    }
    
    // L = log shift
    if (key === 'L') { logShift(); return; }
    
    // E = end shift (v5)
    if (key === 'E') { endShift(); return; }
    
    // Tab = switch XY mode
    if (e.key === 'Tab') { e.preventDefault(); setXYMode(S.xyMode === 'puck' ? 'player' : 'puck'); return; }
    
    // M = toggle XY mode (puck/player)
    if (key === 'M' && !e.ctrlKey && !e.altKey && !e.shiftKey) {
      e.preventDefault();
      const newMode = S.xyMode === 'puck' ? 'player' : 'puck';
      setXYMode(newMode);
      toast(newMode === 'puck' ? 'üèí Puck XY mode' : 'üë§ Player XY mode', 'info');
      return;
    }
    
    // v16.06: P = switch to puck XY mode
    if (key === 'P' && !e.ctrlKey && !e.altKey) { setXYMode('puck'); toast('üèí Puck XY mode', 'info'); return; }
    
    // [ and ] to cycle through players in XY dropdown (when in player mode or when players exist)
    if (e.key === '[' && S.curr.players.length > 0) {
      e.preventDefault();
      cycleXYPlayer(-1); // Previous player
      return;
    }
    if (e.key === ']' && S.curr.players.length > 0) {
      e.preventDefault();
      cycleXYPlayer(1); // Next player
      return;
    }
    
    // H/A = set team
    if (key === 'H') { setEvtTeam('home'); return; }
    if (key === 'A') { setEvtTeam('away'); return; }
    
    // Shift+S = swap event/opp teams (v23.3)
    if (e.shiftKey && key === 'S') { swapEvtTeam(); return; }
    
    // ` (backtick) = switch to puck XY mode (v16.06)
    if (e.key === '`') { 
      setXYMode('puck'); 
      toast('Switched to Puck XY mode', 'info'); 
      return; 
    }
    
    // v23.9: K = quickly link to last event (if current type can link to last event type)
    if (key === 'K' && !e.ctrlKey && !e.altKey && !e.shiftKey && S.events.length > 0) {
      e.preventDefault();
      const lastEvt = S.events[S.events.length - 1];
      const canLink = LISTS.linkedEvents[S.curr.type];
      
      if (canLink && canLink.includes(lastEvt.type)) {
        S.linkedEventIdx = lastEvt.idx;
        const linkedSel = document.getElementById('linkedEvtSelect');
        if (linkedSel) {
          linkedSel.value = lastEvt.idx;
          updateLinkedEventsDropdown();
        }
        applyLinkedEventData();
        toast(`Linked to #${lastEvt.idx + 1} ${lastEvt.type}`, 'success');
      } else {
        // Still link even if not in auto-link list (user wants manual link)
        S.linkedEventIdx = lastEvt.idx;
        const linkedSel = document.getElementById('linkedEvtSelect');
        if (linkedSel) {
          linkedSel.value = lastEvt.idx;
        }
        applyLinkedEventData();
        toast(`Linked to #${lastEvt.idx + 1} ${lastEvt.type}`, 'info');
      }
      return;
    }
    
    // v6: 1-6 = select event player slot (not period anymore)
    // Use Alt+1-6 for opponent players (Ctrl+1-6 conflicts with browser tab switching)
    // v23.3: If player is selected, reassign their role instead of adding new
    if (['1','2','3','4','5','6'].includes(e.key)) {
      e.preventDefault();
      const num = parseInt(e.key);
      
      // If Shift is held, force ADD new player (bypass role reassignment)
      if (e.shiftKey) {
        selectEventPlayerSlot(e.altKey ? 'opp' : 'evt', num);
        return;
      }
      
      // If a player is selected, reassign their role
      if (S.selectedPlayer) {
        const newRole = e.altKey ? 'opp_team_player_' + num : 'event_team_player_' + num;
        const oldRole = S.selectedPlayer.role;
        
        // Check if another player already has this role
        const existing = S.curr.players.find(p => p !== S.selectedPlayer && 
          (p.role === newRole || p.role === newRole.replace('_team', '') || p.roleNum === num));
        
        if (existing) {
          // Swap roles with existing player
          existing.role = oldRole;
          existing.roleNum = S.selectedPlayer.roleNum;
        }
        
        S.selectedPlayer.role = newRole;
        S.selectedPlayer.roleNum = num;
        renumberPlayers();
        renderQuickAdd();
        toast(`Reassigned #${S.selectedPlayer.num} to ${e.altKey ? 'O' : 'E'}${num}`, 'success');
        return;
      }
      
      // No player selected - use slot-based add/select
      if (e.altKey || e.ctrlKey) {
        selectEventPlayerSlot('opp', num);
      } else {
        selectEventPlayerSlot('evt', num);
      }
      return;
    }
    
    // Q = quick line change (v6)
    if (key === 'Q') { quickLineChange(); return; }
    
    // W = cycle forward presets, Shift+W = cycle D presets (v6)
    if (key === 'W') {
      if (e.shiftKey) {
        cyclePreset(S.evtTeam, 'D');
      } else {
        cyclePreset(S.evtTeam, 'F');
      }
      return;
    }
    
    // * = toggle highlight (v5)
    if (e.key === '*' || (e.shiftKey && e.key === '8')) {
      const hl = document.getElementById('isHighlight');
      if (hl) { hl.checked = !hl.checked; toast(hl.checked ? '‚≠ê Highlight ON' : 'Highlight OFF', 'info'); }
      return;
    }
    
    // Ctrl+Z = smart undo (XY if points exist, otherwise events)
    if (e.ctrlKey && key === 'Z' && !e.shiftKey) { 
      e.preventDefault(); 
      // If there are XY points to undo, undo those first
      if (S.curr && S.curr.puckXY && S.curr.puckXY.length > 0) {
        undoLastXY();
      } else if (undoStack && undoStack.length > 0) {
        undo();
      } else {
        undoLastXY(); // Fallback
      }
      return; 
    }
    
    // Ctrl+Shift+Z = force undo event (v23.5)
    if (e.ctrlKey && e.shiftKey && key === 'Z') { e.preventDefault(); undo(); return; }
    
    // Arrow keys in edit modals (v5) - prioritize over video controls
    if (S.editingEvtIdx !== null) {
      if (e.key === 'ArrowLeft') { e.preventDefault(); navEditEvent(-1); return; }
      if (e.key === 'ArrowRight') { e.preventDefault(); navEditEvent(1); return; }
    }
    if (S.editingShiftIdx !== null) {
      if (e.key === 'ArrowLeft') { e.preventDefault(); navEditShift(-1); return; }
      if (e.key === 'ArrowRight') { e.preventDefault(); navEditShift(1); return; }
    }
    
    // ? = open help
    if (e.key === '?') { openHelp(); return; }
  });
}

/**
 * Flash hotkey indicator for visual feedback (v5)
 */
function flashHotkeyIndicator(key) {
  const btn = document.querySelector(`.evt-btn[data-hotkey="${key}"]`);
  if (btn) {
    btn.classList.add('hotkey-flash');
    setTimeout(() => btn.classList.remove('hotkey-flash'), 300);
  }
}

/**
 * End current shift with current clock time (v5)
 */
function endShift() {
  const clock = document.getElementById('clock').value;
  document.getElementById('shiftEnd').value = clock;
  toast(`Shift end set to ${clock}`, 'info');
}

// ============================================================
// V6 FEATURES: LINE PRESETS, PERIOD FILTERS, COMPACT MODE
// ============================================================

// Line preset storage
S.linePresets = JSON.parse(localStorage.getItem('bs_line_presets') || '{}');
S.shiftLogFilter = 'all';
S.eventLogFilter = 'all';
// v20.4: Advanced event filters
S.eventFilters = {
  type: '',
  detail1: '',
  detail2: '',
  playDetail1: '',
  playDetail2: '',
  team: '',
  eventIdx: null,
  eventsBefore: 0, // v23.8: Show X events before found event
  eventsAfter: 0, // v23.8: Show X events after found event
  linkedIdx: null,
  shiftIdx: null,
  playerSearch: '' // v23.8: Search by player number or name
};
S.shiftLogPlayerFilter = ''; // v23.8: Search shifts by player number or name
// S.saveDirectoryHandle and S.maxBackups are now initialized in S object definition above
S.selectedPlayerSlot = null;
S.compactMode = false;

// v20.5: Dim table value cache for import validation
S.dimValues = {
  event_type: [],
  event_detail: [],
  event_detail_2: [],
  play_detail: [],
  play_detail_2: [],
  loaded: false
};
S.pendingMappings = null; // Holds mappings during modal review

/**
 * v20.5: Load dim table values from Supabase for import validation
 * v22.1: Fixed to load ALL values and better fallback
 */
async function loadDimValuesForValidation() {
  if (S.dimValues.loaded) return true;
  
  try {
    // Try Supabase first
    if (typeof supabase !== 'undefined' && S.sb) {
      const tables = [
        { name: 'dim_event_type', field: 'event_type', col: 'event_type_code' },
        { name: 'dim_event_detail', field: 'event_detail', col: 'event_detail_code' },
        { name: 'dim_event_detail_2', field: 'event_detail_2', col: 'event_detail_2_code' },
        { name: 'dim_play_detail', field: 'play_detail', col: 'play_detail_code' },
        { name: 'dim_play_detail_2', field: 'play_detail_2', col: 'play_detail_2_code' }
      ];
      
      let loadedCount = 0;
      for (const t of tables) {
        // v22.1: Load ALL rows (up to 1000) - use .limit(1000) to ensure we get everything
        const { data, error } = await S.sb.from(t.name).select(t.col).limit(1000);
        if (!error && data && data.length > 0) {
          S.dimValues[t.field] = data.map(r => r[t.col]).filter(Boolean);
          loadedCount++;
          console.log(`Loaded ${S.dimValues[t.field].length} values from ${t.name}`);
        } else {
          console.warn(`Failed to load ${t.name}:`, error || 'no data');
        }
      }
      
      if (loadedCount >= 3) {
        S.dimValues.loaded = true;
        console.log('Loaded dim values from Supabase:', Object.keys(S.dimValues).map(k => `${k}: ${S.dimValues[k]?.length || 0}`).join(', '));
        return true;
      }
    }
  } catch (e) {
    console.warn('Supabase dim load failed, using fallback:', e);
  }
  
  // v22.1: Comprehensive fallback values (if Supabase load fails)
  S.dimValues.event_type = ['Shot', 'Save', 'Pass', 'Faceoff', 'Turnover', 'Zone_Entry_Exit', 'Possession', 'Penalty', 'Hit', 'Block', 'Stoppage', 'Goal', 'GameStart', 'GameEnd', 'PeriodStart', 'PeriodEnd', 'Rebound', 'DeadIce', 'Play', 'Intermission', 'Clockstop', 'Timeout', 'LoosePuck', 'PenaltyShot_Shootout', 'Penalty_Delayed'];
  
  S.dimValues.event_detail = ['Shot_OnNetSaved', 'Shot_Goal', 'Goal_Scored', 'Shot_Missed', 'Shot_MissedWide', 'Shot_MissedHigh', 'Shot_HitPost', 'Shot_Blocked', 'Shot_TippedOnNetSaved', 'Shot_OnNetGoal', 'Shot_BlockedSameTeam', 'Shot_Deflected', 'Pass_Completed', 'Pass_Missed', 'Pass_Intercepted', 'Pass_Deflected', 'Turnover_Giveaway', 'Turnover_Takeaway', 'Zone_Entry', 'Zone_Exit', 'Zone_Keepin', 'Zone_EntryFailed', 'Zone_ExitFailed', 'Faceoff_Won', 'Faceoff_Lost', 'Faceoff_PeriodStart', 'Faceoff_GameStart', 'Faceoff_AfterGoal', 'Faceoff_AfterPenalty', 'Faceoff_AfterStoppage', 'Save_Rebound', 'Save_Freeze', 'Save_Played', 'Stoppage_PeriodEnd', 'Stoppage_Play', 'Stoppage_Other', 'Stoppage_GameEnd', 'Penalty_Minor', 'Penalty_Major', 'Penalty_Misconduct', 'Goal_Shootout', 'Goal_PenaltyShot', 'Rebound_TeamRecovered', 'Rebound_OppRecovered', 'Rebound_ShotGenerated', 'DeadIce_Icing', 'DeadIce_Offside', 'DeadIce_PuckOut', 'Play_Offensive', 'Play_Defensive', 'Breakaway', 'PuckRetrieval', 'PuckRecovery', 'Regroup', 'LoosePuck'];
  
  // v22.1: Full list of event_detail_2 values
  S.dimValues.event_detail_2 = [
    // Pass modifiers
    'Pass_Forehand', 'Pass_Backhand', 'Pass_Bank', 'Pass_Stretch', 'Pass_Rim/Wrap', 'Pass_Drop', 'Pass_Dump', 'Pass_OneTouch', 'Pass_Lob', 'Pass_Reverse', 'Pass_QuickUp', 'Pass_GiveAndGo', 'Pass_SecondTouch', 'Pass_Tipped', 'Pass_Deflected/TippedShot', 'Pass_ReceiverMissed', 'Pass_Other',
    // Shot modifiers
    'Shot_Wrist', 'Shot_Slap', 'Shot_Backhand', 'Shot_Snap', 'Shot_WrapAround', 'Shot_Bat', 'Shot_Poke', 'Shot_OneTime', 'Shot_Tip', 'Shot_Deflection', 'Shot_Other', 'Shot_BetweenLegs', 'Shot_Cradle',
    // Goal modifiers
    'Goal_Wrist', 'Goal_Slap', 'Goal_Backhand', 'Goal_Snap', 'Goal_WrapAround', 'Goal_Bat', 'Goal_Poke', 'Goal_OneTime', 'Goal_Tip', 'Goal_Deflection', 'Goal_Dumpin', 'Goal_Other', 'Goal_BetweenLegs', 'Goal_Cradle',
    // Save modifiers
    'Save_Glove', 'Save_Blocker', 'Save_Pad', 'Save_Stick', 'Save_Butterfly', 'Save_Other',
    // Zone entry modifiers
    'ZoneEntry_Rush', 'ZoneEntry_Carry', 'ZoneEntry_Pass', 'ZoneEntry_DumpIn', 'ZoneEntry_Chip', 'ZoneEntry_OppTeam', 'ZoneEntry_PassMiss/Misplay',
    // Zone exit modifiers  
    'ZoneExit_Rush', 'ZoneExit_Carry', 'ZoneExit_Pass', 'ZoneExit_Clear', 'ZoneExit_Chip', 'ZoneExit_PassMiss/Misplay',
    // Giveaway modifiers
    'Giveaway_Misplayed', 'Giveaway_BattleLost', 'Giveaway_PassIntercepted', 'Giveaway_PassMissed', 'Giveaway_PassBlocked', 'Giveaway_PassReceiverMissed', 'Giveaway_ShotBlocked', 'Giveaway_ShotMissed', 'Giveaway_DumpInZone', 'Giveaway_ZoneClear/Dump', 'Giveaway_ZoneEntry/ExitMisplay', 'Giveaway_AttemptedZoneClear/Dump', 'Giveaway_Other',
    // Takeaway modifiers
    'Takeaway_BattleWon', 'Takeaway_PokeCheck', 'Takeaway_PassIntercepted', 'Takeaway_PassBlocked', 'Takeaway_Other',
    // Stoppage modifiers
    'Stoppage_Icing', 'Stoppage_Offsides', 'Stoppage_GoalieStoppage', 'Stoppage_PuckOut', 'Stoppage_Penalty', 'Stoppage_Goal', 'Stoppage_HandPass', 'Stoppage_NetOff', 'Stoppage_Injury',
    // Penalty modifiers
    'Penalty_Tripping', 'Penalty_Hooking', 'Penalty_Slashing', 'Penalty_Interference', 'Penalty_Holding', 'Penalty_Roughing', 'Penalty_HighSticking', 'Penalty_CrossChecking', 'Penalty_Boarding', 'Penalty_Other',
    // Play context modifiers
    'Deke', 'DriveMiddle', 'DriveWide', 'DumpChase', 'Rush', 'Cycle', 'Rebound', 'OneTimer', 'Tip', 'Deflection', 'Breakaway', 'OddManRush', 'CrashNet', 'Forecheck', 'Backcheck', 'NetFront', 'PointShot', 'Screen',
    // Zone keep-in
    'Zone_KeepIn', 'ZoneEntry_KeepIn'
  ];
  
  // v22.1: Comprehensive play_detail fallback (111 values from dim_play_detail)
  S.dimValues.play_detail = ['AssistPrimary','AssistSecondary','AssistTertiary','AttemptedBlockedShot','AttemptedBreakOutClear','AttemptedBreakOutPass','AttemptedBreakOutRush','AttemptedEntryDumpIn','AttemptedEntryPass','AttemptedEntryRush','AttemptedKeepin','AttemptedPass','AttemptedShot','AttemptedTip/Deflection','Backcheck','BeatDeke','BeatFake','BeatMiddle','BeatSpeed','BeatWide','BlockedShot','BoxOut','Breakout','CededZoneEntry','CededZoneExit','Chip','ClearingAttempt','Contain','CrashNet','CutBack','Cycle','DeflectedShot','Deke','Delay','DelayedOffside','DriveCorner','DriveMiddle','DriveNetMiddle','DriveNetWide','DriveWide','Dump/RimInZone','DumpChase','DumpInAttempt','EndToEndRush','FakeShot','ForcedDumpin/Clear','ForcedLostPossession','ForcedMissedPass','ForcedMissedShot','ForcedTurnover','ForceWide','ForecedOutside','Forecheck','FrontofNet','GapControl','GiveAndGo','InShotPassLane','LoosePuckBattleLost','LoosePuckBattleWon','LostPuck','ManOnMan','MisplayedPuck','OpenIceDeke','Other','PassDeflected','PassForTip','PassIntercepted','PenaltyKillClear','PokeCheck','Pressure','PuckRecoveryRetreivalAttemptedClear','PuckRecoveryRetreivalClear','PuckRecoveryRetreivalDumpIn','PuckRecoveryRetreivalFaceoff','PuckRecoveryRetreivalLoosePuckBattle','PuckRecoveryRetreivalOther','PuckRecoveryRetreivalPass','PuckRecoveryRetreivalRebound','PuckRecoveryRetreivalShot','PuckRecoveryRetreivalTurnover','PuckRetrievalDumpIn','PuckRetrievalRebound','PuckRetrievalShot','QuickUp','ReceiverMissed','RecoveryRetreivalDumpIn','RecoveryRetreivalFaceoff','RecoveryRetreivalOther','RecoveryRetreivalPass','RecoveryRetreivalRebound','RecoveryRetreivalShot','RecoveryRetreivalTurnover','RecoveryRetrievalDumpIn','RecoveryRetrievalShot','Regroup','RegroupClear','RegroupDumpin','Reverse','Screen','SecondTouch','SeperateFromPuck','Speed','StickCheck','StoppedDeke','Surf','Tracker','Wheel','Zone','ZoneEntryDenial','ZoneExitDenial','ZoneKeepin'];
  
  // v22.1: Comprehensive play_detail_2 fallback (111 values from dim_play_detail_2)
  S.dimValues.play_detail_2 = ['AssistPrimary','AssistSecondary','AssistTertiary','AttemptedBlockedShot','AttemptedBreakOutClear','AttemptedBreakOutPass','AttemptedBreakOutRush','AttemptedEntryDumpIn','AttemptedEntryPass','AttemptedEntryRush','AttemptedKeepin','AttemptedPass','AttemptedShot','AttemptedTip/Deflection','Backcheck','BeatDeke','BeatFake','BeatMiddle','BeatSpeed','BeatWide','BlockedShot','BoxOut','Breakout','CededZoneEntry','CededZoneExit','Chip','ClearingAttempt','Contain','CrashNet','CutBack','Cycle','DeflectedShot','Deke','Delay','DelayedOffside','DriveCorner','DriveMiddle','DriveNetMiddle','DriveNetWide','DriveWide','Dump/RimInZone','DumpChase','DumpInAttempt','EndToEndRush','FakeShot','ForcedDumpin/Clear','ForcedLostPossession','ForcedMissedPass','ForcedMissedShot','ForcedTurnover','ForceWide','ForecedOutside','Forecheck','FrontofNet','GapControl','GiveAndGo','InShotPassLane','LoosePuckBattleLost','LoosePuckBattleWon','LostPuck','ManOnMan','MisplayedPuck','OpenIceDeke','Other','PassDeflected','PassForTip','PassIntercepted','PenaltyKillClear','PokeCheck','Pressure','PuckRecoveryRetreivalAttemptedClear','PuckRecoveryRetreivalClear','PuckRecoveryRetreivalDumpIn','PuckRecoveryRetreivalFaceoff','PuckRecoveryRetreivalLoosePuckBattle','PuckRecoveryRetreivalOther','PuckRecoveryRetreivalPass','PuckRecoveryRetreivalRebound','PuckRecoveryRetreivalShot','PuckRecoveryRetreivalTurnover','PuckRetrievalDumpIn','PuckRetrievalRebound','PuckRetrievalShot','QuickUp','ReceiverMissed','RecoveryRetreivalDumpIn','RecoveryRetreivalFaceoff','RecoveryRetreivalOther','RecoveryRetreivalPass','RecoveryRetreivalRebound','RecoveryRetreivalShot','RecoveryRetreivalTurnover','RecoveryRetrievalDumpIn','RecoveryRetrievalShot','Regroup','RegroupClear','RegroupDumpin','Reverse','Screen','SecondTouch','SeperateFromPuck','Speed','StickCheck','StoppedDeke','Surf','Tracker','Wheel','Zone','ZoneEntryDenial','ZoneExitDenial','ZoneKeepin'];
  
  S.dimValues.loaded = true;
  console.log('Loaded fallback dim values (Supabase unavailable)');
  return true;
}

/**
 * v20.5: Normalize string for fuzzy matching
 * Handles: case, underscores vs hyphens vs spaces, common prefixes
 */
function normalizeForMatch(str) {
  if (!str) return '';
  let normalized = str
    .toLowerCase()
    .replace(/[-_ ]/g, '')  // Remove separators
    .replace(/^(play|shot|pass|zone|turnover|giveaway|takeaway|save|faceoff|goal)[_-]?/i, '')  // Remove common prefixes for matching
    .trim();
  
  // Apply synonym mappings
  // "rush" in zone entry/exit context means "carried"
  if (normalized.includes('rush')) {
    normalized = normalized.replace(/rush/g, 'carried');
  }
  
  return normalized;
}

/**
 * v23.5: Synonym map for fuzzy matching old data formats
 * Maps old terminology to current terminology (from Supabase dim tables)
 */
const VALUE_SYNONYMS = {
  // Zone Entry/Exit Rush = Carried (with puck control)
  'ZoneEntry_Rush': 'ZoneEntry_Carried',
  'ZoneEntry-Rush': 'ZoneEntry-Carried',
  'ZoneEntry Rush': 'ZoneEntry Carried',
  'Entry_Rush': 'Entry_Carried',
  'Entry-Rush': 'Entry-Carried',
  'Rush': 'Carried',
  
  'ZoneExit_Rush': 'ZoneExit_Carried', 
  'ZoneExit-Rush': 'ZoneExit-Carried',
  'ZoneExit Rush': 'ZoneExit Carried',
  'Exit_Rush': 'Exit_Carried',
  'Exit-Rush': 'Exit-Carried',
  
  // Other common mappings
  'Shot_OnNet': 'Shot_OnNetSaved',
  'Shot On Net': 'Shot_OnNetSaved',
  'Blocked': 'Shot_Blocked',
  'Missed': 'Shot_Missed'
};

/**
 * v23.5: Apply synonyms before fuzzy matching
 */
function applySynonyms(value) {
  if (!value) return value;
  
  // Check exact synonym match
  if (VALUE_SYNONYMS[value]) {
    return VALUE_SYNONYMS[value];
  }
  
  // Check case-insensitive
  const lower = value.toLowerCase();
  for (const [key, replacement] of Object.entries(VALUE_SYNONYMS)) {
    if (key.toLowerCase() === lower) {
      return replacement;
    }
  }
  
  // Check if value contains Rush (for zone entries/exits)
  if (value.toLowerCase().includes('rush') && 
      (value.toLowerCase().includes('entry') || value.toLowerCase().includes('exit') || value.toLowerCase().includes('zone'))) {
    return value.replace(/rush/gi, 'Carried');
  }
  
  return value;
}

/**
 * v20.5: Calculate match score between two strings (0-100)
 * v23.8: Improved to prevent incorrect matches (zone_exit vs zone_entry, shot_ vs goal_)
 */
function matchScore(a, b) {
  if (!a || !b) return 0;
  
  // v23.5: Apply synonyms first
  const aSyn = applySynonyms(a);
  const bSyn = applySynonyms(b);
  
  const na = normalizeForMatch(aSyn);
  const nb = normalizeForMatch(bSyn);
  
  // Exact match (normalized)
  if (na === nb) return 100;
  
  // v23.8: Check for conflicting prefixes - heavily penalize these
  const conflictingPrefixes = [
    ['zone_exit', 'zone_entry'], ['zone_entry', 'zone_exit'],
    ['exit', 'entry'], ['entry', 'exit'],
    ['shot_', 'goal_'], ['goal_', 'shot_'],
    ['pass_', 'goal_'], ['goal_', 'pass_'],
    ['shot', 'goal'], ['goal', 'shot']
  ];
  
  for (const [prefix1, prefix2] of conflictingPrefixes) {
    if ((na.startsWith(prefix1) && nb.startsWith(prefix2)) ||
        (nb.startsWith(prefix1) && na.startsWith(prefix2))) {
      // Conflicting prefixes - return very low score
      return 10;
    }
  }
  
  // v23.8: Check for similar but different event categories
  // If one is clearly a different category, reduce score
  const eventCategories = {
    zone: ['zone_entry', 'zone_exit'],
    shot: ['shot_', 'shot'],
    goal: ['goal_', 'goal'],
    pass: ['pass_', 'pass'],
    penalty: ['penalty_', 'penalty']
  };
  
  let categoryPenalty = 0;
  for (const [category, prefixes] of Object.entries(eventCategories)) {
    const aInCategory = prefixes.some(p => na.includes(p));
    const bInCategory = prefixes.some(p => nb.includes(p));
    
    if (aInCategory && !bInCategory) {
      // Check if b is in a different category
      for (const [otherCategory, otherPrefixes] of Object.entries(eventCategories)) {
        if (otherCategory !== category && otherPrefixes.some(p => nb.includes(p))) {
          categoryPenalty = 30; // Penalize cross-category matches
          break;
        }
      }
    }
  }
  
  // One contains the other (but only if no category conflict)
  if (categoryPenalty === 0 && (na.includes(nb) || nb.includes(na))) {
    return 85;
  }
  
  // Levenshtein-ish: count common chars
  const setA = new Set(na.split(''));
  const setB = new Set(nb.split(''));
  const intersection = [...setA].filter(c => setB.has(c)).length;
  const union = new Set([...setA, ...setB]).size;
  const similarity = union > 0 ? (intersection / union) * 100 : 0;
  
  const finalScore = Math.round(similarity) - categoryPenalty;
  return Math.max(0, finalScore);
}

/**
 * v20.5: Find best match from valid values
 * v23.5: Added synonym support for old data formats
 * v23.8: Added context-aware matching and stricter threshold for fuzzy matches
 */
function findBestMatch(value, validValues, threshold = 70, context = null) {
  if (!value || !validValues?.length) return { match: null, score: 0, type: 'none' };
  
  // v23.5: Apply synonyms first (e.g., Rush -> Carry)
  const synonymValue = applySynonyms(value);
  
  // Check exact match first (case-insensitive) - with synonym applied
  const exactMatch = validValues.find(v => 
    v.toLowerCase() === value.toLowerCase() || 
    v.toLowerCase() === synonymValue.toLowerCase()
  );
  if (exactMatch) return { match: exactMatch, score: 100, type: 'exact' };
  
  // v23.8: Context-aware matching - if context provided, prefer matches that make sense
  // For example, if event type is "ZoneEntry", prefer detail1 values that start with "ZoneEntry"
  let contextBoost = 0;
  if (context && context.eventType) {
    const eventTypeLower = context.eventType.toLowerCase();
    // Boost matches that share the same prefix as the event type
    if (synonymValue.toLowerCase().includes(eventTypeLower) || 
        eventTypeLower.includes(synonymValue.toLowerCase().split('_')[0])) {
      contextBoost = 5; // Small boost for context matches
    }
  }
  
  // Fuzzy match using synonym-applied value
  let best = { match: null, score: 0 };
  for (const candidate of validValues) {
    let score = matchScore(synonymValue, candidate);
    
    // v23.8: Apply context boost
    if (context && context.eventType) {
      const candidateLower = candidate.toLowerCase();
      const eventTypeLower = context.eventType.toLowerCase();
      if (candidateLower.includes(eventTypeLower) || 
          eventTypeLower.includes(candidateLower.split('_')[0])) {
        score += contextBoost;
      }
    }
    
    if (score > best.score) {
      best = { match: candidate, score };
    }
  }
  
  // v23.8: Stricter threshold - require higher confidence for fuzzy matches
  // Also require at least 50% similarity even if above threshold
  if (best.score >= threshold && best.score >= 50) {
    return { ...best, type: 'fuzzy' };
  }
  
  return { match: null, score: best.score, type: 'none' };
}

/**
 * v20.5: Analyze imported events and find mappings needed
 * v23.8: Added context-aware matching (event type context for details)
 */
function analyzeImportMappings(events) {
  const fields = [
    { key: 'type', dimKey: 'event_type', label: 'Event Type' },
    { key: 'detail1', dimKey: 'event_detail', label: 'Event Detail' },
    { key: 'detail', dimKey: 'event_detail', label: 'Event Detail' },  // Alias
    { key: 'detail2', dimKey: 'event_detail_2', label: 'Event Detail 2' }
  ];
  
  // Also check player play details
  const playerFields = [
    { key: 'playD1', dimKey: 'play_detail', label: 'Play Detail 1' },
    { key: 'playD2', dimKey: 'play_detail_2', label: 'Play Detail 2' }
  ];
  
  const mappings = [];
  const seenValues = new Set();
  
  // v23.8: Load custom mappings from localStorage
  const customMappings = loadCustomMappings();
  
  // Collect unique values from events
  for (const evt of events) {
    // v23.8: Get event type for context-aware matching
    const eventType = evt.type || evt.eventType;
    const context = eventType ? { eventType } : null;
    
    for (const f of fields) {
      const val = evt[f.key];
      if (val && !seenValues.has(`${f.dimKey}:${val}`)) {
        seenValues.add(`${f.dimKey}:${val}`);
        
        // v23.8: Check custom mappings first
        const customKey = `${f.dimKey}:${val}`;
        let result;
        if (customMappings[customKey]) {
          // Use custom mapping
          const mappedValue = customMappings[customKey];
          const isValid = S.dimValues[f.dimKey]?.includes(mappedValue);
          if (isValid) {
            result = { match: mappedValue, score: 100, type: 'custom' };
          } else {
            // Custom mapping is invalid, fall back to fuzzy match
            result = findBestMatch(val, S.dimValues[f.dimKey], 70, 
              f.key === 'detail1' || f.key === 'detail2' ? context : null);
          }
        } else {
          // Use fuzzy matching with context for detail fields
          result = findBestMatch(val, S.dimValues[f.dimKey], 70, 
            f.key === 'detail1' || f.key === 'detail2' ? context : null);
        }
        
        if (result.type !== 'exact') {
          mappings.push({
            field: f.label,
            dimKey: f.dimKey,
            eventKey: f.key,
            original: val,
            eventType: eventType, // v23.8: Store event type for filtering
            ...result
          });
        }
      }
    }
    
    // Check player play details
    for (const player of (evt.players || [])) {
      for (const f of playerFields) {
        const val = player[f.key];
        if (val && !seenValues.has(`${f.dimKey}:${val}`)) {
          seenValues.add(`${f.dimKey}:${val}`);
          
          // v23.8: Check custom mappings for player fields too
          const customKey = `${f.dimKey}:${val}`;
          let result;
          if (customMappings[customKey]) {
            const mappedValue = customMappings[customKey];
            const isValid = S.dimValues[f.dimKey]?.includes(mappedValue);
            if (isValid) {
              result = { match: mappedValue, score: 100, type: 'custom' };
            } else {
              result = findBestMatch(val, S.dimValues[f.dimKey], 70, context);
            }
          } else {
            result = findBestMatch(val, S.dimValues[f.dimKey], 70, context);
          }
          
          if (result.type !== 'exact') {
            mappings.push({
              field: f.label,
              dimKey: f.dimKey,
              eventKey: f.key,
              isPlayerField: true,
              original: val,
              eventType: eventType,
              ...result
            });
          }
        }
      }
    }
  }
  
  return mappings;
}

/**
 * v23.8: Load custom mappings from localStorage
 */
function loadCustomMappings() {
  try {
    const stored = localStorage.getItem('benchsight_custom_mappings');
    return stored ? JSON.parse(stored) : {};
  } catch (e) {
    console.warn('Failed to load custom mappings:', e);
    return {};
  }
}

/**
 * v23.8: Save custom mapping to localStorage
 */
function saveCustomMapping(dimKey, originalValue, mappedValue) {
  try {
    const mappings = loadCustomMappings();
    const key = `${dimKey}:${originalValue}`;
    mappings[key] = mappedValue;
    localStorage.setItem('benchsight_custom_mappings', JSON.stringify(mappings));
    console.log('Saved custom mapping:', key, '->', mappedValue);
  } catch (e) {
    console.error('Failed to save custom mapping:', e);
  }
}

/**
 * v20.5: Show mapping modal for user review
 * v22.1: Added "Show More" functionality and ensured correct dim table per field
 * v23.8: Added batch processing, filtering, and custom mappings
 */
function showMappingModal(mappings, onAccept, onSkip) {
  // v23.8: Get unique event types and fields for filtering
  const eventTypes = [...new Set(mappings.map(m => m.eventType).filter(Boolean))].sort();
  const fields = [...new Set(mappings.map(m => m.field))].sort();
  const dimKeys = [...new Set(mappings.map(m => m.dimKey))].sort();
  
  // Create modal HTML
  const fuzzyCount = mappings.filter(m => m.type === 'fuzzy').length;
  const noMatchCount = mappings.filter(m => m.type === 'none').length;
  const customCount = mappings.filter(m => m.type === 'custom').length;
  
  let tableRows = mappings.map((m, i) => {
    // v22.1: Get options ONLY from the correct dim table for this field
    const allOptions = S.dimValues[m.dimKey] || [];
    const dimTableName = m.dimKey; // e.g., "event_detail_2"
    
    // v22.1: Sort options by relevance to the original value
    const scoredOptions = allOptions.map(o => ({
      value: o,
      score: matchScore(m.original, o)
    })).sort((a, b) => b.score - a.score);
    
    // v22.1: Show top 8 matches initially, with "Show More" to expand
    const topOptions = scoredOptions.slice(0, 8);
    const hasMore = scoredOptions.length > 8;
    
    // Build select HTML with top matches first
    let selectHtml = '<select id="mapping_' + i + '" class="mapping-select" onchange="handleMappingSelect(this, ' + i + ', \'' + m.dimKey + '\')">';
    selectHtml += '<option value="">-- No mapping --</option>';
    
    // Add suggested match first if it exists and not in top options
    if (m.match && !topOptions.find(o => o.value === m.match)) {
      const mScore = scoredOptions.find(o => o.value === m.match)?.score || m.score;
      selectHtml += '<option value="' + m.match + '" selected>‚úì ' + m.match + ' (' + mScore + '%)</option>';
    }
    
    // Add top scored options
    for (const opt of topOptions) {
      const selected = opt.value === m.match ? 'selected' : '';
      const scoreLabel = opt.score > 0 ? ' (' + opt.score + '%)' : '';
      selectHtml += '<option value="' + opt.value + '" ' + selected + '>' + opt.value + scoreLabel + '</option>';
    }
    
    // Add "Show More" option if there are more values
    if (hasMore) {
      selectHtml += '<option value="__SHOW_MORE__">‚ñº Show all ' + allOptions.length + ' from ' + dimTableName + '...</option>';
    }
    
    selectHtml += '</select>';
    
    const typeIcon = m.type === 'fuzzy' ? '‚âà' : (m.type === 'custom' ? '‚òÖ' : '?');
    const eventTypeDisplay = m.eventType ? `<span style="font-size:9px;color:var(--muted);">[${m.eventType}]</span>` : '';
    
    return '<tr data-mapping-index="' + i + '" data-dimkey="' + m.dimKey + '" data-field="' + m.field + '" data-eventtype="' + (m.eventType || '') + '" data-original="' + m.original.toLowerCase() + '">' +
      '<td><input type="checkbox" class="mapping-checkbox" data-index="' + i + '" onchange="updateMappingSelection()"></td>' +
      '<td class="field">' + m.field + '</td>' +
      '<td class="original">' + m.original + ' ' + eventTypeDisplay + '</td>' +
      '<td>' + typeIcon + '</td>' +
      '<td>' + selectHtml + '</td>' +
      '<td class="score">' + m.score + '%</td>' +
    '</tr>';
  }).join('');
  
  // v23.8: Build filter dropdowns
  const eventTypeFilter = eventTypes.length > 0 ? 
    '<select id="mappingEventTypeFilter" onchange="filterMappingTable()" style="min-width:120px;"><option value="">All Event Types</option>' +
    eventTypes.map(et => `<option value="${et}">${et}</option>`).join('') + '</select>' : '';
  
  const fieldFilter = fields.length > 0 ?
    '<select id="mappingFieldFilter" onchange="filterMappingTable()" style="min-width:120px;"><option value="">All Fields</option>' +
    fields.map(f => `<option value="${f}">${f}</option>`).join('') + '</select>' : '';
  
  const modalHtml = 
    '<div class="modal mapping-modal" id="mappingModal" style="max-width: 1000px; max-height: 90vh; overflow-y: auto;">' +
      '<h3>üìã Import Value Mapping</h3>' +
      '<p class="summary">' +
        'Found <strong>' + mappings.length + '</strong> values needing review: ' +
        '<span style="color:var(--accent)">' + fuzzyCount + ' fuzzy</span>, ' +
        '<span style="color:var(--danger)">' + noMatchCount + ' no match</span>' +
        (customCount > 0 ? ', <span style="color:var(--warn)">' + customCount + ' custom</span>' : '') +
      '</p>' +
      '<div class="mapping-filters">' +
        '<input type="text" id="mappingSearchFilter" placeholder="Search original values..." onkeyup="filterMappingTable()" style="flex:1;min-width:200px;">' +
        eventTypeFilter +
        fieldFilter +
        '<button onclick="selectAllMappings()" style="font-size:10px;padding:4px 8px;">Select All</button>' +
        '<button onclick="deselectAllMappings()" style="font-size:10px;padding:4px 8px;">Deselect All</button>' +
      '</div>' +
      '<div class="mapping-batch-actions" id="mappingBatchActions" style="display:none;">' +
        '<span id="mappingSelectedCount">0 selected</span>' +
        '<button onclick="batchApplyMapping()" class="btn-success" style="font-size:10px;padding:4px 8px;">Apply Same Mapping to Selected</button>' +
        '<button onclick="batchSaveAsCustom()" class="btn-accent" style="font-size:10px;padding:4px 8px;">Save Selected as Custom Mappings</button>' +
      '</div>' +
      '<p style="font-size:10px;color:var(--muted);">Each dropdown shows top matches from its correct dim table. Click "Show all" to see all options. Select rows to batch process.</p>' +
      '<div class="mapping-legend">' +
        '<span><span class="dot exact"></span> Exact (auto-mapped)</span>' +
        '<span><span class="dot fuzzy"></span> Fuzzy (suggested)</span>' +
        '<span><span class="dot custom"></span> Custom mapping</span>' +
        '<span><span class="dot none"></span> No match (select manually)</span>' +
      '</div>' +
      '<table class="mapping-table">' +
        '<thead>' +
          '<tr><th style="width:30px;">‚òë</th><th>Field</th><th>Original Value</th><th>Type</th><th>Map To</th><th>Score</th></tr>' +
        '</thead>' +
        '<tbody id="mappingTableBody">' + tableRows + '</tbody>' +
      '</table>' +
      '<div class="modal-actions">' +
        '<button class="btn-cancel" onclick="closeMappingModal(false)">Skip (Keep Original)</button>' +
        '<button class="btn-success" onclick="closeMappingModal(true)">Apply Mappings</button>' +
      '</div>' +
    '</div>' +
    '<div class="modal-overlay" onclick="closeMappingModal(false)"></div>';
  
  // Store callbacks
  S.pendingMappings = { mappings, onAccept, onSkip };
  
  // Show modal
  const container = document.createElement('div');
  container.id = 'mappingModalContainer';
  container.className = 'overlay show';
  container.innerHTML = modalHtml;
  document.body.appendChild(container);
  
  // v23.8: Initialize filter
  filterMappingTable();
}

/**
 * v22.1: Handle mapping select change - expand to show all options when "Show More" selected
 */
function handleMappingSelect(select, idx, dimKey) {
  if (select.value === '__SHOW_MORE__') {
    // Get all options from the correct dim table
    const allOptions = S.dimValues[dimKey] || [];
    const original = S.pendingMappings?.mappings[idx]?.original || '';
    
    // Sort alphabetically first
    const sortedOptions = [...allOptions].sort((a, b) => a.localeCompare(b));
    
    // Then calculate match scores
    const scoredOptions = sortedOptions.map(o => ({
      value: o,
      score: matchScore(original, o)
    }));
    
    // Create a searchable modal instead of just expanding the dropdown
    const row = select.closest('tr');
    const fieldName = row?.querySelector('.field')?.textContent || 'Field';
    
    // Create modal HTML with search input
    const modalHtml = `
      <div class="modal mapping-modal" id="showMoreModal_${idx}" style="max-width: 600px; max-height: 80vh;">
        <h3>Select Value for ${fieldName}</h3>
        <p style="font-size: 10px; color: var(--muted); margin-bottom: 8px;">
          Search and select from ${allOptions.length} options (sorted alphabetically)
        </p>
        <input 
          type="text" 
          id="showMoreSearch_${idx}" 
          placeholder="Search options..." 
          style="width: 100%; padding: 8px; margin-bottom: 10px; background: var(--card); border: 1px solid var(--border); color: var(--text); font-size: 11px;"
          onkeyup="filterShowMoreOptions(${idx}, '${dimKey}')"
        />
        <div id="showMoreOptions_${idx}" style="max-height: 400px; overflow-y: auto; border: 1px solid var(--border);">
          ${scoredOptions.map(opt => {
            const scoreLabel = opt.score > 0 ? ` <span style="color: var(--muted); font-size: 9px;">(${opt.score}%)</span>` : '';
            const selected = opt.value === original ? ' style="background: rgba(0,212,255,0.2);"' : '';
            return `<div class="show-more-option" data-value="${opt.value}" onclick="selectShowMoreOption(${idx}, '${opt.value}', '${dimKey}')"${selected} style="padding: 6px 8px; cursor: pointer; border-bottom: 1px solid var(--border); font-size: 10px;" onmouseover="this.style.background='rgba(0,212,255,0.1)'" onmouseout="this.style.background=''">${opt.value}${scoreLabel}</div>`;
          }).join('')}
        </div>
        <div class="modal-actions" style="margin-top: 10px;">
          <button class="btn-cancel" onclick="closeShowMoreModal(${idx})">Cancel</button>
        </div>
      </div>
      <div class="modal-overlay" onclick="closeShowMoreModal(${idx})"></div>
    `;
    
    // Remove existing modal if any
    const existing = document.getElementById(`showMoreModal_${idx}`);
    if (existing) existing.remove();
    
    // Create and show modal
    const container = document.createElement('div');
    container.id = `showMoreContainer_${idx}`;
    container.innerHTML = modalHtml;
    document.body.appendChild(container);
    
    // Focus search input
    setTimeout(() => {
      const searchInput = document.getElementById(`showMoreSearch_${idx}`);
      if (searchInput) searchInput.focus();
    }, 100);
    
    return;
  }
}

/**
 * v23.8: Filter mapping table based on search and filters
 */
function filterMappingTable() {
  const searchTerm = (document.getElementById('mappingSearchFilter')?.value || '').toLowerCase();
  const eventTypeFilter = document.getElementById('mappingEventTypeFilter')?.value || '';
  const fieldFilter = document.getElementById('mappingFieldFilter')?.value || '';
  const rows = document.querySelectorAll('#mappingTableBody tr');
  
  let visibleCount = 0;
  rows.forEach(row => {
    const original = row.getAttribute('data-original') || '';
    const eventType = row.getAttribute('data-eventtype') || '';
    const field = row.getAttribute('data-field') || '';
    
    const matchesSearch = !searchTerm || original.includes(searchTerm);
    const matchesEventType = !eventTypeFilter || eventType === eventTypeFilter;
    const matchesField = !fieldFilter || field === fieldFilter;
    
    if (matchesSearch && matchesEventType && matchesField) {
      row.style.display = '';
      visibleCount++;
    } else {
      row.style.display = 'none';
    }
  });
  
  // Update count display
  const countDisplay = document.querySelector('.summary strong');
  if (countDisplay) {
    const total = S.pendingMappings?.mappings?.length || 0;
    countDisplay.textContent = `${visibleCount} of ${total}`;
  }
}

/**
 * v23.8: Select all visible mappings
 */
function selectAllMappings() {
  const visibleRows = document.querySelectorAll('#mappingTableBody tr[style=""]');
  visibleRows.forEach(row => {
    const checkbox = row.querySelector('.mapping-checkbox');
    if (checkbox) checkbox.checked = true;
  });
  updateMappingSelection();
}

/**
 * v23.8: Deselect all mappings
 */
function deselectAllMappings() {
  document.querySelectorAll('.mapping-checkbox').forEach(cb => cb.checked = false);
  updateMappingSelection();
}

/**
 * v23.8: Update selection count and show/hide batch actions
 */
function updateMappingSelection() {
  const checked = document.querySelectorAll('.mapping-checkbox:checked');
  const count = checked.length;
  const batchActions = document.getElementById('mappingBatchActions');
  const countDisplay = document.getElementById('mappingSelectedCount');
  
  if (batchActions) {
    batchActions.style.display = count > 0 ? 'flex' : 'none';
  }
  if (countDisplay) {
    countDisplay.textContent = `${count} selected`;
  }
  
  // Update row highlighting
  document.querySelectorAll('#mappingTableBody tr').forEach(row => {
    const checkbox = row.querySelector('.mapping-checkbox');
    if (checkbox && checkbox.checked) {
      row.classList.add('selected');
    } else {
      row.classList.remove('selected');
    }
  });
}

/**
 * v23.8: Batch apply the same mapping to selected rows
 */
function batchApplyMapping() {
  const checked = document.querySelectorAll('.mapping-checkbox:checked');
  if (checked.length === 0) {
    toast('No rows selected', 'warning');
    return;
  }
  
  // Get mapping value from first selected row
  const firstRow = checked[0].closest('tr');
  const firstSelect = firstRow?.querySelector('.mapping-select');
  const mappingValue = firstSelect?.value;
  
  if (!mappingValue) {
    toast('Please select a mapping value for the first row first', 'warning');
    return;
  }
  
  // Apply to all selected rows
  let applied = 0;
  checked.forEach(checkbox => {
    const row = checkbox.closest('tr');
    const select = row?.querySelector('.mapping-select');
    if (select && select.value !== mappingValue) {
      select.value = mappingValue;
      select.dispatchEvent(new Event('change'));
      applied++;
    }
  });
  
  toast(`Applied mapping to ${applied} rows`, 'success');
  updateMappingSelection();
}

/**
 * v23.8: Save selected mappings as custom mappings
 */
function batchSaveAsCustom() {
  const checked = document.querySelectorAll('.mapping-checkbox:checked');
  if (checked.length === 0) {
    toast('No rows selected', 'warning');
    return;
  }
  
  let saved = 0;
  checked.forEach(checkbox => {
    const row = checkbox.closest('tr');
    const index = parseInt(checkbox.getAttribute('data-index'));
    const mapping = S.pendingMappings?.mappings[index];
    const select = row?.querySelector('.mapping-select');
    const mappedValue = select?.value;
    
    if (mapping && mappedValue) {
      saveCustomMapping(mapping.dimKey, mapping.original, mappedValue);
      saved++;
    }
  });
  
  toast(`Saved ${saved} custom mappings. They will be used in future imports.`, 'success');
  updateMappingSelection();
}

function closeMappingModal(apply) {
  const container = document.getElementById('mappingModalContainer');
  if (!container) {
    console.warn('mappingModalContainer not found');
    return;
  }
  
  try {
    if (apply && S.pendingMappings) {
      // Read user selections
      const finalMappings = S.pendingMappings.mappings.map((m, i) => {
        const select = document.getElementById(`mapping_${i}`);
        if (select && select.value) {
          // v23.8: Save as custom mapping if user wants
          const row = select.closest('tr');
          const checkbox = row?.querySelector('.mapping-checkbox');
          if (checkbox && checkbox.checked) {
            // Optionally save as custom - user can use batch action for this
          }
          
          return {
            ...m,
            mappedTo: select.value
          };
        }
        return null;
      }).filter(m => m && m.mappedTo); // Only include ones with a mapping
      
      if (S.pendingMappings.onAccept && typeof S.pendingMappings.onAccept === 'function') {
        S.pendingMappings.onAccept(finalMappings);
      }
    } else {
      if (S.pendingMappings && S.pendingMappings.onSkip && typeof S.pendingMappings.onSkip === 'function') {
        S.pendingMappings.onSkip();
      }
    }
  } catch(e) {
    console.error('Error in closeMappingModal:', e);
  }
  
  // Close modal with animation
  container.classList.remove('show');
  setTimeout(() => {
    if (container && container.parentNode) {
      container.remove();
    }
    S.pendingMappings = null;
  }, 300);
}

/**
 * Validate that event players and opp players are on the correct teams
 * @param {Array} events - Events to validate
 * @param {Function} onComplete - Callback when validation is done (or user dismisses warning)
 */
/**
 * v23.9: Validate and fix team designations against schedule
 * @param {string|number} gameId - Game identifier
 * @param {string} excelHomeTeam - Home team from Excel
 * @param {string} excelAwayTeam - Away team from Excel
 * @param {Array} events - Imported events
 * @param {Array} shifts - Imported shifts
 * @returns {Promise<{events, shifts, correctionApplied, scheduleHomeTeam, scheduleAwayTeam}>}
 */
async function validateAndFixTeamDesignations(gameId, excelHomeTeam, excelAwayTeam, events, shifts) {
  if (!gameId || !S.connected) {
    // No game ID or not connected - skip validation
    return { events, shifts, correctionApplied: false, scheduleHomeTeam: excelHomeTeam, scheduleAwayTeam: excelAwayTeam };
  }
  
  try {
    // Fetch schedule teams for this game
    const { data: scheduleData, error } = await S.sb.from('dim_schedule')
      .select('home_team_name,away_team_name')
      .eq('game_id', gameId)
      .single();
    
    if (error || !scheduleData) {
      console.log('Could not fetch schedule teams for game', gameId, error);
      return { events, shifts, correctionApplied: false, scheduleHomeTeam: excelHomeTeam, scheduleAwayTeam: excelAwayTeam };
    }
    
    const scheduleHomeTeam = scheduleData.home_team_name;
    const scheduleAwayTeam = scheduleData.away_team_name;
    
    // Normalize team names for comparison (case-insensitive, trim)
    const normalizeTeam = (name) => (name || '').trim().toLowerCase();
    const excelHomeNorm = normalizeTeam(excelHomeTeam);
    const excelAwayNorm = normalizeTeam(excelAwayTeam);
    const scheduleHomeNorm = normalizeTeam(scheduleHomeTeam);
    const scheduleAwayNorm = normalizeTeam(scheduleAwayTeam);
    
    // Check if teams match (exact or swapped)
    const teamsMatch = (excelHomeNorm === scheduleHomeNorm && excelAwayNorm === scheduleAwayNorm);
    const teamsSwapped = (excelHomeNorm === scheduleAwayNorm && excelAwayNorm === scheduleHomeNorm);
    
    if (teamsMatch) {
      // Teams match - no correction needed
      return { events, shifts, correctionApplied: false, scheduleHomeTeam, scheduleAwayTeam };
    }
    
    if (teamsSwapped) {
      // Teams are swapped - need to fix
      console.log('Import: Teams are swapped - fixing designations');
      
      // Fix events: swap 'home' and 'away' team designations
      const fixedEvents = events.map(evt => ({
        ...evt,
        team: evt.team === 'home' ? 'away' : (evt.team === 'away' ? 'home' : evt.team)
      }));
      
      // Fix shifts: swap 'home' and 'away' objects
      const fixedShifts = shifts.map(shift => ({
        ...shift,
        home: shift.away,  // Swap: Excel "home" becomes schedule "away"
        away: shift.home   // Swap: Excel "away" becomes schedule "home"
      }));
      
      // Show notification
      toast(`‚ö†Ô∏è Team designations corrected:\nExcel had teams swapped.\nFixed ${fixedEvents.length} events and ${fixedShifts.length} shifts.`, 'info', 8000);
      
      return { 
        events: fixedEvents, 
        shifts: fixedShifts, 
        correctionApplied: true, 
        scheduleHomeTeam, 
        scheduleAwayTeam 
      };
    }
    
    // Teams don't match and aren't swapped - may be different names or missing
    console.warn('Import: Team names do not match schedule', {
      excel: { home: excelHomeTeam, away: excelAwayTeam },
      schedule: { home: scheduleHomeTeam, away: scheduleAwayTeam }
    });
    
    // Show warning but don't auto-correct (could be intentional)
    toast(`‚ö†Ô∏è Team names don't match schedule:\nExcel: ${excelHomeTeam} vs ${excelAwayTeam}\nSchedule: ${scheduleHomeTeam} vs ${scheduleAwayTeam}\nUsing schedule teams.`, 'warning', 8000);
    
    return { events, shifts, correctionApplied: false, scheduleHomeTeam, scheduleAwayTeam };
    
  } catch (e) {
    console.error('Error validating team designations:', e);
    return { events, shifts, correctionApplied: false, scheduleHomeTeam: excelHomeTeam, scheduleAwayTeam: excelAwayTeam };
  }
}

function validatePlayerTeams(events, onComplete) {
  if (!events || events.length === 0) {
    if (onComplete) onComplete();
    return;
  }
  
  const issues = [];
  
  events.forEach((evt, evtIdx) => {
    if (!evt.players || evt.players.length === 0) return;
    
    const eventTeam = evt.team; // 'home' or 'away'
    const oppTeam = eventTeam === 'home' ? 'away' : 'home';
    
    evt.players.forEach((player, playerIdx) => {
      const isEventPlayer = player.role?.startsWith('event') || player.role?.includes('event');
      const isOppPlayer = player.role?.startsWith('opp') || player.role?.includes('opp');
      
      // Check if player is actually on the roster for their assigned team
      const assignedTeam = player.team;
      const roster = S.rosters?.[assignedTeam] || [];
      const playerOnRoster = roster.find(p => String(p.num) === String(player.num));
      
      // Check if player should be on event team or opp team based on role
      let expectedTeam = null;
      if (isEventPlayer) {
        expectedTeam = eventTeam;
      } else if (isOppPlayer) {
        expectedTeam = oppTeam;
      }
      
      // Issue 1: Player not on roster for assigned team
      if (!playerOnRoster && assignedTeam) {
        // Check if they're on the other team's roster
        const otherTeam = assignedTeam === 'home' ? 'away' : 'home';
        const otherRoster = S.rosters?.[otherTeam] || [];
        const onOtherTeam = otherRoster.find(p => String(p.num) === String(player.num));
        
        if (onOtherTeam) {
          issues.push({
            eventIdx: evtIdx,
            eventNum: evtIdx + 1,
            eventType: evt.type,
            eventTime: evt.start_time,
            playerNum: player.num,
            playerName: player.name,
            assignedTeam: assignedTeam,
            correctTeam: otherTeam,
            role: player.role,
            issue: 'wrong_team',
            message: `Event #${evtIdx + 1} (${evt.type} @ ${evt.start_time}): Player #${player.num} ${player.name} is assigned to ${assignedTeam} team but is on ${otherTeam} roster`
          });
        }
      }
      
      // Issue 2: Player role doesn't match expected team
      if (expectedTeam && assignedTeam !== expectedTeam) {
        issues.push({
          eventIdx: evtIdx,
          eventNum: evtIdx + 1,
          eventType: evt.type,
          eventTime: evt.start_time,
          playerNum: player.num,
          playerName: player.name,
          assignedTeam: assignedTeam,
          expectedTeam: expectedTeam,
          role: player.role,
          issue: 'role_team_mismatch',
          message: `Event #${evtIdx + 1} (${evt.type} @ ${evt.start_time}): Player #${player.num} ${player.name} has role "${player.role}" but is assigned to ${assignedTeam} team (should be ${expectedTeam})`
        });
      }
    });
  });
  
  if (issues.length > 0) {
    // Store issues globally so we can mark events in the event log
    S.teamValidationIssues = issues;
    showTeamValidationWarning(issues, onComplete);
  } else {
    S.teamValidationIssues = []; // Clear issues if none found
    if (onComplete) onComplete();
  }
}

/**
 * Show warning modal for team validation issues
 */
function showTeamValidationWarning(issues, onComplete) {
  const wrongTeamIssues = issues.filter(i => i.issue === 'wrong_team');
  const roleMismatchIssues = issues.filter(i => i.issue === 'role_team_mismatch');
  
  const modalHtml = 
    '<div class="modal" id="teamValidationWarningModal" style="max-width:800px;max-height:80vh;overflow-y:auto;">' +
      '<h3>‚ö†Ô∏è Player Team Validation Warning</h3>' +
      '<p style="font-size:11px;color:var(--muted);margin-bottom:12px;">' +
        `Found <strong>${issues.length}</strong> player team issues. Please review and correct if needed.` +
      '</p>' +
      '<div style="margin-bottom:12px;">' +
        (wrongTeamIssues.length > 0 ? 
          `<div style="background:rgba(239,68,68,0.1);padding:8px;border-radius:4px;margin-bottom:8px;border-left:3px solid var(--danger);">
            <strong style="color:var(--danger);">${wrongTeamIssues.length} players on wrong team roster:</strong>
            <ul style="margin:4px 0;padding-left:20px;font-size:10px;">
              ${wrongTeamIssues.slice(0, 50).map(i => `<li style="cursor:pointer;padding:2px 0;" onclick="closeTeamValidationWarningAndEdit(${i.eventIdx});" onmouseover="this.style.background='rgba(0,212,255,0.2)'" onmouseout="this.style.background='transparent'">${i.message} <span style="color:var(--accent);font-weight:bold;">[Click to edit]</span></li>`).join('')}
              ${wrongTeamIssues.length > 50 ? `<li><em>...and ${wrongTeamIssues.length - 50} more</em></li>` : ''}
            </ul>
          </div>` : '') +
        (roleMismatchIssues.length > 0 ?
          `<div style="background:rgba(251,191,36,0.1);padding:8px;border-radius:4px;border-left:3px solid var(--warn);">
            <strong style="color:var(--warn);">${roleMismatchIssues.length} role/team mismatches:</strong>
            <ul style="margin:4px 0;padding-left:20px;font-size:10px;">
              ${roleMismatchIssues.slice(0, 50).map(i => `<li style="cursor:pointer;padding:2px 0;" onclick="closeTeamValidationWarningAndEdit(${i.eventIdx});" onmouseover="this.style.background='rgba(0,212,255,0.2)'" onmouseout="this.style.background='transparent'">${i.message} <span style="color:var(--accent);font-weight:bold;">[Click to edit]</span></li>`).join('')}
              ${roleMismatchIssues.length > 50 ? `<li><em>...and ${roleMismatchIssues.length - 50} more</em></li>` : ''}
            </ul>
          </div>` : '') +
      '</div>' +
      '<p style="font-size:10px;color:var(--muted);">' +
        'Click on any issue above to edit that event. Events with team warnings are marked with ‚ö†Ô∏è in the event log.' +
      '</p>' +
      '<div class="modal-actions">' +
        '<button class="btn-primary" onclick="closeTeamValidationWarning()">Continue with Import</button>' +
      '</div>' +
    '</div>' +
    '<div class="modal-overlay" onclick="closeTeamValidationWarning()"></div>';
  
  const container = document.createElement('div');
  container.id = 'teamValidationWarningContainer';
  container.className = 'overlay show';
  container.innerHTML = modalHtml;
  document.body.appendChild(container);
  
  // Store callback
  window.teamValidationCallback = onComplete;
}

function closeTeamValidationWarning() {
  const container = document.getElementById('teamValidationWarningContainer');
  if (container) {
    container.classList.remove('show');
    setTimeout(() => {
      if (container && container.parentNode) {
        container.remove();
      }
      if (window.teamValidationCallback) {
        window.teamValidationCallback();
        window.teamValidationCallback = null;
      }
    }, 300);
  }
}

/**
 * Close team validation warning modal and open edit event modal
 */
function closeTeamValidationWarningAndEdit(eventIdx) {
  console.log('closeTeamValidationWarningAndEdit called for event', eventIdx);
  const container = document.getElementById('teamValidationWarningContainer');
  if (container) {
    // Remove immediately so editEvent modal can show
    container.classList.remove('show');
    if (container.parentNode) {
      container.remove();
    }
  }
  // Small delay to ensure DOM is updated, then open edit modal
  setTimeout(() => {
    console.log('Opening editEvent for', eventIdx);
    try {
      editEvent(eventIdx);
    } catch (e) {
      console.error('Error opening editEvent:', e);
      toast('Error opening edit modal: ' + e.message, 'error');
    }
  }, 100);
}

/**
 * v20.5: Apply mappings to events array
 */
function applyMappingsToEvents(events, mappings) {
  if (!mappings?.length) return events;
  
  // Build lookup: original -> mapped
  const lookup = {};
  for (const m of mappings) {
    const key = `${m.eventKey}:${m.original}`;
    lookup[key] = m.mappedTo;
  }
  
  // Apply to events
  let changeCount = 0;
  for (const evt of events) {
    // Event-level fields
    for (const field of ['type', 'detail', 'detail1', 'detail2']) {
      const key = `${field}:${evt[field]}`;
      if (lookup[key]) {
        console.log(`Mapping ${field}: ${evt[field]} ‚Üí ${lookup[key]}`);
        evt[field] = lookup[key];
        changeCount++;
      }
    }
    
    // Player-level fields
    for (const player of (evt.players || [])) {
      for (const field of ['playD1', 'playD2']) {
        const key = `${field}:${player[field]}`;
        if (lookup[key]) {
          console.log(`Mapping player ${field}: ${player[field]} ‚Üí ${lookup[key]}`);
          player[field] = lookup[key];
          changeCount++;
        }
      }
    }
  }
  
  toast(`Applied ${changeCount} value mappings`, 'success');
  return events;
}

/**
 * Load a line preset into slots
 */
function loadPreset(team, preset) {
  const key = `${team}_${preset}`;
  const presetData = S.linePresets[key];
  if (!presetData || !presetData.players || presetData.players.length === 0) {
    toast(`No ${preset} preset saved for ${team}`, 'info');
    return;
  }
  
  // Determine which slots to fill based on preset type
  const isForward = preset.startsWith('F');
  const slots = isForward ? ['F1','F2','F3'] : ['D1','D2'];
  
  // Clear relevant slots first
  slots.forEach(slot => { S.slots[team][slot] = null; });
  
  // Fill slots with preset players
  presetData.players.forEach((num, i) => {
    if (i < slots.length) {
      const player = S.rosters[team].find(p => String(p.num) === String(num));
      if (player) {
        S.slots[team][slots[i]] = player;
      }
    }
  });
  
  renderSlots();
  renderRosters();
  onSlotsChanged();
  toast(`Loaded ${team} ${preset}: ${presetData.players.join(', ')}`, 'success');
}

/**
 * Save current slots as a preset
 */
function savePreset(team, preset) {
  const isForward = preset.startsWith('F');
  const slots = isForward ? ['F1','F2','F3'] : ['D1','D2'];
  
  const players = slots
    .map(slot => S.slots[team]?.[slot]?.num)
    .filter(num => num);
  
  if (players.length === 0) {
    toast(`No players in ${preset} slots`, 'warning');
    return;
  }
  
  const key = `${team}_${preset}`;
  S.linePresets[key] = { name: preset, players };
  localStorage.setItem('bs_line_presets', JSON.stringify(S.linePresets));
  toast(`Saved ${team} ${preset}: ${players.join(', ')}`, 'success');
}

/**
 * Cycle through forward or defense presets
 */
function cyclePreset(team, type) {
  const presets = type === 'F' ? ['F1','F2','F3'] : ['D1','D2'];
  const currentIdx = S.cycleIdx?.[team]?.[type] || 0;
  const nextIdx = (currentIdx + 1) % presets.length;
  
  if (!S.cycleIdx) S.cycleIdx = {};
  if (!S.cycleIdx[team]) S.cycleIdx[team] = {};
  S.cycleIdx[team][type] = nextIdx;
  
  loadPreset(team, presets[nextIdx]);
}

/**
 * Open line preset configuration modal
 */
function openLinePresetModal() {
  // Build modal content showing current presets
  let html = '<div style="max-height:400px;overflow-y:auto;">';
  
  ['home', 'away'].forEach(team => {
    html += `<h4 style="color:var(--accent);margin:8px 0 4px;">${team.toUpperCase()} PRESETS</h4>`;
    
    // Forward lines
    ['F1','F2','F3'].forEach(preset => {
      const key = `${team}_${preset}`;
      const data = S.linePresets[key];
      const players = data?.players?.join(', ') || 'Not set';
      html += `
        <div style="display:flex;gap:8px;align-items:center;margin:4px 0;">
          <span style="width:30px;font-weight:bold;">${preset}:</span>
          <span style="flex:1;color:var(--muted);">${players}</span>
          <button class="btn-sm" onclick="savePreset('${team}','${preset}')">Save Current</button>
          <button class="btn-sm" onclick="clearPreset('${team}','${preset}')">Clear</button>
        </div>`;
    });
    
    // Defense pairs
    ['D1','D2'].forEach(preset => {
      const key = `${team}_${preset}`;
      const data = S.linePresets[key];
      const players = data?.players?.join(', ') || 'Not set';
      html += `
        <div style="display:flex;gap:8px;align-items:center;margin:4px 0;">
          <span style="width:30px;font-weight:bold;">${preset}:</span>
          <span style="flex:1;color:var(--muted);">${players}</span>
          <button class="btn-sm" onclick="savePreset('${team}','${preset}')">Save Current</button>
          <button class="btn-sm" onclick="clearPreset('${team}','${preset}')">Clear</button>
        </div>`;
    });
  });
  
  html += '</div>';
  
  // Use a simple alert-style modal
  const modal = document.createElement('div');
  modal.className = 'overlay show';
  modal.id = 'linePresetModal';
  modal.innerHTML = `
    <div class="modal" style="min-width:400px;">
      <h3>‚öôÔ∏è Line Presets Configuration</h3>
      ${html}
      <p style="font-size:9px;color:var(--muted);margin-top:8px;">
        Fill slots with players, then click "Save Current" to save as a preset.
        Use preset buttons or W/Shift+W to cycle presets.
      </p>
      <div class="modal-actions" style="margin-top:16px;">
        <button class="btn-primary" onclick="closeLinePresetModal()">Close</button>
      </div>
    </div>`;
  document.body.appendChild(modal);
}

function closeLinePresetModal() {
  const modal = document.getElementById('linePresetModal');
  if (modal) modal.remove();
}

function clearPreset(team, preset) {
  const key = `${team}_${preset}`;
  delete S.linePresets[key];
  localStorage.setItem('bs_line_presets', JSON.stringify(S.linePresets));
  closeLinePresetModal();
  openLinePresetModal();
  toast(`Cleared ${team} ${preset}`, 'info');
}

/**
 * Filter shift log by period
 */
function filterShiftLog(period) {
  S.shiftLogFilter = period;

  // Update tab styles
  document.querySelectorAll('#leftPanel .period-filter-tab').forEach(tab => {
    tab.classList.toggle('active', tab.dataset.filter === period);
  });

  renderShiftLog();
}

/**
 * v23.8: Filter event log by player number or name
 */
function filterEventLogByPlayer(searchTerm) {
  if (!searchTerm || searchTerm.trim() === '') {
    // Clear player filter
    if (S.eventFilters) {
      S.eventFilters.playerSearch = '';
    }
    renderEvents();
    return;
  }
  
  const search = searchTerm.trim().toLowerCase();
  
  // Initialize eventFilters if needed
  if (!S.eventFilters) {
    S.eventFilters = {
      type: '', detail1: '', detail2: '', playDetail1: '', playDetail2: '',
      team: '', eventIdx: null, eventsBefore: 0, eventsAfter: 0,
      linkedIdx: null, shiftIdx: null, playerSearch: ''
    };
  }
  
  // Store search term
  S.eventFilters.playerSearch = search;
  
  // Re-render events with player filter
  renderEvents();
}

/**
 * Helper function to ensure all buttons in a modal work properly
 */
function ensureModalButtonsWork(modal) {
  if (!modal) {
    console.error('ensureModalButtonsWork: modal is null');
    return;
  }
  
  // Look for buttons in both modal and .modal content - try multiple selectors
  const modalContent = modal.querySelector('.modal');
  console.log('Modal content element:', modalContent);
  let buttons = [];
  
  if (modalContent) {
    buttons = modalContent.querySelectorAll('button');
    console.log('Found', buttons.length, 'buttons in .modal content');
  }
  
  // If no buttons in .modal, try direct children
  if (buttons.length === 0) {
    buttons = modal.querySelectorAll('button');
    console.log('Found', buttons.length, 'buttons directly in modal');
  }
  
  // Also try finding by class or in modal-actions
  if (buttons.length === 0) {
    const modalActions = modal.querySelector('.modal-actions');
    if (modalActions) {
      buttons = modalActions.querySelectorAll('button');
      console.log('Found', buttons.length, 'buttons in .modal-actions');
    }
  }
  
  console.log('ensureModalButtonsWork: found', buttons.length, 'buttons in modal:', modal.id);
  
  buttons.forEach((btn, idx) => {
    // Get onclick BEFORE removing it
    const originalOnclick = btn.getAttribute('onclick');
    const text = btn.textContent.trim();
    
    console.log(`Button ${idx}: "${text}", onclick: "${originalOnclick}"`);
    
    // Clear any existing handlers
    btn.onclick = null;
    btn.removeAttribute('onclick');
    
    if (!originalOnclick) {
      console.log('No onclick for button:', text);
      return;
    }
    
    // Extract function name and call it directly
    const match = originalOnclick.match(/(\w+)\s*\(/);
    if (match) {
      const funcName = match[1];
      console.log(`Extracted function name: "${funcName}", type on window:`, typeof window[funcName]);
      
      if (typeof window[funcName] === 'function') {
        // Use both onclick and addEventListener in capture phase to ensure it fires
        btn.onclick = function(e) {
          if (e) {
            e.stopPropagation();
            e.preventDefault();
            e.stopImmediatePropagation();
          }
          console.log('Button onclick fired:', text, 'calling:', funcName);
          const func = window[funcName];
          if (typeof func === 'function') {
            func();
          } else {
            console.error('Function not found on window:', funcName);
          }
          return false;
        };
        
        // Also add capture phase listener as backup
        btn.addEventListener('click', function(e) {
          e.stopPropagation();
          e.preventDefault();
          e.stopImmediatePropagation();
          console.log('Button addEventListener fired:', text, 'calling:', funcName);
          const func = window[funcName];
          if (typeof func === 'function') {
            func();
          } else {
            console.error('Function not found on window in listener:', funcName);
          }
        }, true); // Capture phase
        // Also add mousedown as backup
        btn.onmousedown = btn.onclick;
        // Ensure it's clickable
        btn.style.cursor = 'pointer';
        btn.style.pointerEvents = 'auto';
        console.log(`Button "${text}" setup complete`);
      } else {
        console.error(`Function "${funcName}" not found on window! Available functions:`, Object.keys(window).filter(k => k.includes('confirm') || k.includes('close')));
        // Fallback: try eval
        btn.onclick = function(e) {
          e.stopPropagation();
          e.preventDefault();
          console.log('Button clicked (eval fallback):', text);
          try {
            eval(originalOnclick);
          } catch (err) {
            console.error('Error executing onclick:', err, originalOnclick);
          }
          return false;
        };
        btn.onmousedown = btn.onclick;
        btn.style.cursor = 'pointer';
        btn.style.pointerEvents = 'auto';
      }
    } else {
      // For complex onclick like document.getElementById(...).click(), use eval
      console.warn('Complex onclick detected, using eval:', originalOnclick);
      btn.onclick = function(e) {
        e.stopPropagation();
        e.preventDefault();
        console.log('Button clicked (complex onclick):', text);
        try {
          eval(originalOnclick);
        } catch (err) {
          console.error('Error executing complex onclick:', err, originalOnclick);
        }
        return false;
      };
      btn.onmousedown = btn.onclick;
      btn.style.cursor = 'pointer';
      btn.style.pointerEvents = 'auto';
    }
  });
  
  console.log('ensureModalButtonsWork: completed for modal:', modal.id);
}

/**
 * v23.8: Filter shift log by player number or name
 */
function filterShiftLogByPlayer(searchTerm) {
  if (!searchTerm || searchTerm.trim() === '') {
    // Clear player filter
    if (S.shiftLogPlayerFilter) {
      S.shiftLogPlayerFilter = '';
    }
    renderShiftLog();
    return;
  }
  
  const search = searchTerm.trim().toLowerCase();
  S.shiftLogPlayerFilter = search;
  
  // Re-render shift log with player filter
  renderShiftLog();
}

/**
 * Filter event log by period
 */
function filterEventLog(period) {
  S.eventLogFilter = period;
  
  // Clear goal selection when switching away from goals_context
  if (period !== 'goals_context') {
    S.selectedGoalIdx = null;
  }
  
  // v24.0: Handle chain filter - opens modal, don't change filter
  if (period === 'chains') {
    openEventChainStats();
    return;
  }
  
  // v23.8: Show/hide event type context filter
  const eventTypeContextContainer = document.getElementById('eventTypeContextContainer');
  const issueTypeFilterContainer = document.getElementById('issueTypeFilterContainer');
  
  if (period === 'event_type_context') {
    if (eventTypeContextContainer) eventTypeContextContainer.style.display = 'block';
    if (issueTypeFilterContainer) issueTypeFilterContainer.style.display = 'none';
  } else if (period === 'issues') {
    if (eventTypeContextContainer) eventTypeContextContainer.style.display = 'none';
    if (issueTypeFilterContainer) issueTypeFilterContainer.style.display = 'block';
  } else {
    if (eventTypeContextContainer) eventTypeContextContainer.style.display = 'none';
    if (issueTypeFilterContainer) issueTypeFilterContainer.style.display = 'none';
  }
  
  // Update tab styles
  document.querySelectorAll('.evt-list .period-filter-tab').forEach(tab => {
    tab.classList.toggle('active', tab.dataset.filter === period);
  });
  
  renderEvents();
}

/**
 * v24.0: Open event chain statistics modal
 */
function openEventChainStats() {
  const modal = document.getElementById('eventChainStatsModal');
  if (!modal) return;
  
  const chains = analyzeEventChains();
  
  // Build HTML for chain statistics
  let chainsHTML = '';
  if (chains.length === 0) {
    chainsHTML = '<p style="color:var(--muted);font-size:10px;text-align:center;padding:20px;">No event chains found. Chains require events with linkedEventIdx.</p>';
  } else {
    chainsHTML = chains.map(([chainStr, stats]) => {
      const examplesText = stats.examples.length > 0 ? ` (e.g., events #${stats.examples.join(', ')})` : '';
      return `
        <div style="border:1px solid var(--border);border-radius:4px;padding:8px;margin-bottom:4px;background:var(--card);cursor:pointer;" 
             onclick="filterEventLogByChain('${chainStr.replace(/'/g, "\\'")}');closeEventChainStats();" 
             title="Click to filter event log by this chain">
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <div style="flex:1;">
              <strong style="font-size:10px;color:var(--accent);">${chainStr}</strong>
              <div style="font-size:8px;color:var(--muted);margin-top:2px;">
                ${stats.count} instance(s)${examplesText}
              </div>
            </div>
            <div style="font-size:9px;color:var(--success);">‚Üí</div>
          </div>
        </div>
      `;
    }).join('');
  }
  
  const html = `
    <div class="modal" style="min-width:600px;max-width:800px;max-height:80vh;overflow-y:auto;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
        <h3 style="margin:0;">üîó Event Chain Statistics</h3>
        <button onclick="closeEventChainStats();return false;" style="background:none;border:none;font-size:18px;cursor:pointer;color:var(--muted);padding:0;width:24px;height:24px;line-height:1;" title="Close">√ó</button>
      </div>
      <p style="font-size:10px;color:var(--muted);margin:8px 0;">Click on any chain to filter the event log by that pattern.</p>
      <div style="margin-top:16px;max-height:60vh;overflow-y:auto;">
        ${chainsHTML}
      </div>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:16px;padding-top:16px;border-top:1px solid var(--border);">
        <button class="btn-sm" onclick="closeEventChainStats()">Close</button>
      </div>
    </div>
  `;
  
  modal.innerHTML = html;
  modal.onclick = function(e) {
    if (e.target === modal) closeEventChainStats();
  };
  modal.classList.add('show');
  modal.style.display = 'flex';
}

/**
 * v24.0: Close event chain statistics modal
 */
function closeEventChainStats() {
  const modal = document.getElementById('eventChainStatsModal');
  if (modal) {
    modal.classList.remove('show');
    modal.style.display = 'none';
  }
}

/**
 * v24.0: Filter event log by chain pattern
 */
function filterEventLogByChain(chainPattern) {
  S.eventChainFilter = chainPattern;
  S.eventLogFilter = 'chain_pattern';
  
  // Update tab styles
  document.querySelectorAll('.evt-list .period-filter-tab').forEach(tab => {
    tab.classList.toggle('active', tab.dataset.filter === 'chains');
  });
  
  renderEvents();
  toast(`Filtered by chain: ${chainPattern}`, 'info');
}

/**
 * v23.6: Select a specific goal to view with context
 */
function selectGoalForContext(goalIdxStr) {
  if (!goalIdxStr || goalIdxStr === '') {
    S.selectedGoalIdx = null;
  } else {
    S.selectedGoalIdx = parseInt(goalIdxStr);
  }
  renderEvents();
}

/**
 * v23.6: Navigate between goals in goals_context filter
 */
function navigateGoalContext(direction) {
  const goals = S.events.filter(e => e.type === 'Goal' && e.detail1 === 'Goal_Scored');
  if (goals.length === 0) return;
  
  const goalIndices = goals.map(g => S.events.indexOf(g)).filter(idx => idx !== -1).sort((a, b) => a - b);
  
  if (goalIndices.length === 0) return;
  
  // Get current selection or default to first goal
  let currentIdx = S.selectedGoalIdx !== null && S.selectedGoalIdx !== undefined 
    ? goalIndices.indexOf(S.selectedGoalIdx)
    : -1;
  
  // Navigate
  if (direction < 0) {
    // Previous
    if (currentIdx <= 0) {
      currentIdx = goalIndices.length - 1; // Wrap to last
    } else {
      currentIdx--;
    }
  } else {
    // Next
    if (currentIdx >= goalIndices.length - 1) {
      currentIdx = 0; // Wrap to first
    } else {
      currentIdx++;
    }
  }
  
  S.selectedGoalIdx = goalIndices[currentIdx];
  
  // Update selector
  const goalSelector = document.getElementById('goalSelector');
  if (goalSelector) {
    goalSelector.value = S.selectedGoalIdx;
  }
  
  renderEvents();
}

/**
 * v23.8: Update event type context filter dropdowns
 */
function updateEventTypeContextFilter() {
  const typeSelect = document.getElementById('eventTypeContextFilter');
  const detail1Select = document.getElementById('eventDetail1ContextFilter');
  
  if (!typeSelect || !detail1Select) return;
  
  const eventType = typeSelect.value;
  const detail1 = detail1Select.value;
  
  // Update detail1 options based on selected type
  if (eventType) {
    const matchingEvents = S.events.filter(e => e.type === eventType);
    const detail1s = new Set();
    matchingEvents.forEach(e => {
      if (e.detail1) detail1s.add(e.detail1);
      if (e.detail) detail1s.add(e.detail);
    });
    
    detail1Select.innerHTML = '<option value="">All</option>';
    Array.from(detail1s).sort().forEach(d => {
      detail1Select.innerHTML += `<option value="${d}">${d}</option>`;
    });
  } else {
    detail1Select.innerHTML = '<option value="">All</option>';
  }
  
  // Store selected context
  S.selectedEventTypeContext = { type: eventType || null, detail1: detail1 || null };
  S.selectedEventIdxContext = null; // Clear event selection
  
  // Update event selector
  const eventTypeSelector = document.getElementById('eventTypeSelector');
  if (eventTypeSelector) {
    eventTypeSelector.innerHTML = '<option value="">All Events</option>';
  }
  
  filterEventLog('event_type_context');
}

/**
 * v23.8: Select a specific event for context filter
 */
function selectEventForContext(eventIdxStr) {
  if (!eventIdxStr || eventIdxStr === '') {
    S.selectedEventIdxContext = null;
  } else {
    S.selectedEventIdxContext = parseInt(eventIdxStr);
  }
  renderEvents();
}

/**
 * v23.8: Navigate between events in event type context filter
 */
function navigateEventContext(direction) {
  const eventType = S.selectedEventTypeContext?.type || null;
  const detail1 = S.selectedEventTypeContext?.detail1 || null;
  
  if (!eventType && !detail1) return;
  
  const matchingEvents = S.events.filter(e => {
    if (eventType && e.type !== eventType) return false;
    if (detail1 && e.detail1 !== detail1 && e.detail !== detail1) return false;
    return true;
  });
  
  if (matchingEvents.length === 0) return;
  
  const eventIndices = matchingEvents.map(e => S.events.indexOf(e)).filter(idx => idx !== -1).sort((a, b) => a - b);
  
  if (eventIndices.length === 0) return;
  
  // Get current selection or default to first event
  let currentIdx = S.selectedEventIdxContext !== null && S.selectedEventIdxContext !== undefined 
    ? eventIndices.indexOf(S.selectedEventIdxContext)
    : -1;
  
  // Navigate
  if (direction < 0) {
    // Previous
    if (currentIdx <= 0) {
      currentIdx = eventIndices.length - 1; // Wrap to last
    } else {
      currentIdx--;
    }
  } else {
    // Next
    if (currentIdx >= eventIndices.length - 1) {
      currentIdx = 0; // Wrap to first
    } else {
      currentIdx++;
    }
  }
  
  S.selectedEventIdxContext = eventIndices[currentIdx];
  
  // Update selector
  const eventTypeSelector = document.getElementById('eventTypeSelector');
  if (eventTypeSelector) {
    eventTypeSelector.value = S.selectedEventIdxContext;
  }
  
  renderEvents();
}

/**
 * v23.8: Apply issue type filter
 */
function applyIssueTypeFilter() {
  const issueTypeSelect = document.getElementById('issueTypeFilter');
  if (!issueTypeSelect) return;
  
  S.issueTypeFilter = issueTypeSelect.value || null;
  renderEvents();
}

/**
 * v23.8: Handle version selector change
 */
function handleVersionChange(version) {
  const versionSelector = document.getElementById('versionSelector');
  if (!versionSelector) return;
  
  const latestVersion = 'v25.0';
  const isLatest = version === latestVersion;
  
  // Update text color based on whether it's the latest version
  if (isLatest) {
    versionSelector.style.color = 'var(--accent)';
    versionSelector.style.borderColor = 'var(--border)';
  } else {
    versionSelector.style.color = '#ef4444'; // Red warning
    versionSelector.style.borderColor = '#ef4444';
    
    // Show warning toast
    if (confirm(`‚ö†Ô∏è WARNING: You are switching to an older version (${version}). This version may have missing features or bugs. Continue?`)) {
      // Navigate to the version file
      const versionFile = `tracker_index_${version}.html`;
      window.location.href = versionFile;
    } else {
      // Reset to current version
      versionSelector.value = 'v25.0';
      versionSelector.style.color = 'var(--accent)';
      versionSelector.style.borderColor = 'var(--border)';
    }
  }
}

/**
 * v23.8: Initialize version selector styling
 */
function initVersionSelector() {
  const versionSelector = document.getElementById('versionSelector');
  if (versionSelector) {
    const currentVersion = versionSelector.value;
    const latestVersion = 'v24.0';
    if (currentVersion !== latestVersion) {
      versionSelector.style.color = '#ef4444';
      versionSelector.style.borderColor = '#ef4444';
    } else {
      versionSelector.style.color = 'var(--accent)';
      versionSelector.style.borderColor = 'var(--border)';
    }
  }
}

/**
 * v23.8: Mass swap start/end times for events where start > end
 */
function massSwapInvalidTimes() {
  if (!confirm('Swap start and end times for all events where start > end?')) return;
  
  let swappedCount = 0;
  
  S.events.forEach((evt, idx) => {
    if (!evt.start_time || !evt.end_time) return;
    
    const parseTime = (t) => {
      if (!t) return null;
      const parts = String(t).split(':');
      if (parts.length !== 2) return null;
      const min = parseInt(parts[0]);
      const sec = parseInt(parts[1]);
      if (isNaN(min) || isNaN(sec)) return null;
      return min * 60 + sec;
    };
    
    const startSec = parseTime(evt.start_time);
    const endSec = parseTime(evt.end_time);
    
    if (startSec !== null && endSec !== null && endSec < startSec) {
      // Swap times
      const temp = evt.start_time;
      evt.start_time = evt.end_time;
      evt.end_time = temp;
      swappedCount++;
    }
  });
  
  if (swappedCount > 0) {
    toast(`Swapped times for ${swappedCount} event(s)`, 'success');
    renderEvents();
    saveGame();
  } else {
    toast('No events found with invalid time ranges', 'info');
  }
}

/**
 * v23.8: Copy all XY data (puck and all players) for current event
 */
function copyAllXYData() {
  if (!S.curr) {
    toast('No current event to copy from', 'warning');
    return;
  }
  
  const xyData = {
    puckXY: S.curr.puckXY ? JSON.parse(JSON.stringify(S.curr.puckXY)) : null,
    players: (S.curr.players || []).map(p => ({
      num: p.num,
      role: p.role,
      xy: p.xy ? JSON.parse(JSON.stringify(p.xy)) : null
    }))
  };
  
  S.copiedXYData = xyData;
  toast(`Copied XY data (${xyData.puckXY?.length || 0} puck points, ${xyData.players.filter(p => p.xy?.length > 0).length} players with XY)`, 'success');
}

/**
 * v23.8: Paste all XY data (puck and all players) to current event
 */
function pasteAllXYData() {
  if (!S.copiedXYData) {
    toast('No XY data copied. Copy XY data from an event first.', 'warning');
    return;
  }
  
  if (!S.curr) {
    toast('No current event to paste to', 'warning');
    return;
  }
  
  // Paste puck XY
  if (S.copiedXYData.puckXY && S.copiedXYData.puckXY.length > 0) {
    S.curr.puckXY = JSON.parse(JSON.stringify(S.copiedXYData.puckXY));
  }
  
  // Paste player XY - match by role or number
  if (S.copiedXYData.players && S.copiedXYData.players.length > 0) {
    S.copiedXYData.players.forEach(copiedPlayer => {
      if (!copiedPlayer.xy || copiedPlayer.xy.length === 0) return;
      
      // Find matching player in current event
      let targetPlayer = S.curr.players.find(p => p.role === copiedPlayer.role);
      if (!targetPlayer) {
        targetPlayer = S.curr.players.find(p => p.num === copiedPlayer.num);
      }
      
      if (targetPlayer) {
        targetPlayer.xy = JSON.parse(JSON.stringify(copiedPlayer.xy));
      }
    });
  }
  
  toast('Pasted XY data', 'success');
  renderMarkers();
  renderXYSlots();
}

/**
 * v20.4: Populate filter dropdowns with unique values from events
 */
function populateEventFilterDropdowns() {
  if (!S.events?.length) return;
  
  // Collect unique values
  const types = new Set();
  const detail1s = new Set();
  const detail2s = new Set();
  const pd1s = new Set();
  const pd2s = new Set();
  
  S.events.forEach(e => {
    if (e.type) types.add(e.type);
    if (e.detail1 || e.detail) detail1s.add(e.detail1 || e.detail);
    if (e.detail2) detail2s.add(e.detail2);
    
    // Get play details from primary player
    const primaryPlayer = (e.players || []).find(p => p.role?.startsWith('event') || !p.role?.startsWith('opp'));
    if (primaryPlayer?.playD1) pd1s.add(primaryPlayer.playD1);
    if (primaryPlayer?.playD2) pd2s.add(primaryPlayer.playD2);
  });
  
  // v23.8: Populate event type context filter dropdown
  const eventTypeContextFilter = document.getElementById('eventTypeContextFilter');
  if (eventTypeContextFilter) {
    const currentValue = eventTypeContextFilter.value;
    eventTypeContextFilter.innerHTML = '<option value="">Select Type...</option>';
    Array.from(types).sort().forEach(t => {
      eventTypeContextFilter.innerHTML += `<option value="${t}">${t}</option>`;
    });
    if (currentValue) eventTypeContextFilter.value = currentValue;
  }
  
  // Helper to populate a select
  const populateSelect = (id, values) => {
    const sel = document.getElementById(id);
    if (!sel) return;
    const current = sel.value;
    sel.innerHTML = '<option value="">All</option>' + 
      [...values].sort().map(v => `<option value="${v}">${v.substring(0,15)}</option>`).join('');
    sel.value = current; // Restore selection
  };
  
  populateSelect('filterEvtType', types);
  populateSelect('filterEvtDetail1', detail1s);
  populateSelect('filterEvtDetail2', detail2s);
  populateSelect('filterPlayDetail1', pd1s);
  populateSelect('filterPlayDetail2', pd2s);
}

/**
 * v20.4: Apply event filters from UI
 */
function applyEventFilters() {
  S.eventFilters.type = document.getElementById('filterEvtType')?.value || '';
  S.eventFilters.detail1 = document.getElementById('filterEvtDetail1')?.value || '';
  S.eventFilters.detail2 = document.getElementById('filterEvtDetail2')?.value || '';
  S.eventFilters.playDetail1 = document.getElementById('filterPlayDetail1')?.value || '';
  S.eventFilters.playDetail2 = document.getElementById('filterPlayDetail2')?.value || '';
  S.eventFilters.team = document.getElementById('filterEvtTeam')?.value || '';
  
  // v23.8: Read player search from input
  const playerSearchEl = document.getElementById('eventLogPlayerSearch');
  if (playerSearchEl) {
    S.eventFilters.playerSearch = playerSearchEl.value.trim() || '';
  }
  
  const evtIdxVal = document.getElementById('filterEvtIdx')?.value;
  S.eventFilters.eventIdx = evtIdxVal ? parseInt(evtIdxVal) : null;
  
  // v23.8: Read "show X events before/after" values
  const eventsBeforeVal = document.getElementById('filterEventsBefore')?.value;
  S.eventFilters.eventsBefore = eventsBeforeVal ? parseInt(eventsBeforeVal) : 0;
  
  const eventsAfterVal = document.getElementById('filterEventsAfter')?.value;
  S.eventFilters.eventsAfter = eventsAfterVal ? parseInt(eventsAfterVal) : 0;
  
  const linkIdxVal = document.getElementById('filterLinkIdx')?.value;
  S.eventFilters.linkedIdx = linkIdxVal ? parseInt(linkIdxVal) : null;
  
  const shiftIdxVal = document.getElementById('filterShiftIdx')?.value;
  S.eventFilters.shiftIdx = shiftIdxVal ? parseInt(shiftIdxVal) : null;
  
  renderEvents();
}

/**
 * v20.4: Clear all event filters
 */
function clearEventFilters() {
  S.eventFilters = {
    type: '',
    detail1: '',
    detail2: '',
    playDetail1: '',
    playDetail2: '',
    team: '',
    eventIdx: null,
    eventsBefore: 0, // v23.8: Show X events before
    eventsAfter: 0, // v23.8: Show X events after
    linkedIdx: null,
    shiftIdx: null,
    playerSearch: '' // v23.8: Player search
  };

  // Clear UI elements
  ['filterEvtType', 'filterEvtDetail1', 'filterEvtDetail2', 'filterPlayDetail1',
   'filterPlayDetail2', 'filterEvtTeam'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.value = '';
  });
  ['filterEvtIdx', 'filterEventsBefore', 'filterEventsAfter', 'filterLinkIdx', 'filterShiftIdx'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.value = (id === 'filterEventsBefore' || id === 'filterEventsAfter') ? '0' : '';
  });
  
  // Clear player search
  const playerSearchEl = document.getElementById('eventLogPlayerSearch');
  if (playerSearchEl) playerSearchEl.value = '';

  renderEvents();
  toast('Filters cleared', 'info');
}

/**
 * Toggle compact mode
 */
function toggleCompactMode() {
  S.compactMode = !S.compactMode;
  document.body.classList.toggle('compact-mode', S.compactMode);
  toast(S.compactMode ? 'Compact mode ON' : 'Compact mode OFF', 'info');
}

/**
 * Toggle event log visibility (v17)
 */
function toggleEventLog() {
  const section = document.getElementById('eventLogSection');
  const body = document.getElementById('evtListBody');
  const tabs = section?.querySelector('.period-filter-tabs');
  
  if (body) {
    const isHidden = body.style.display === 'none';
    body.style.display = isHidden ? 'block' : 'none';
    if (tabs) tabs.style.display = isHidden ? 'flex' : 'none';
    toast(isHidden ? 'Event log shown' : 'Event log hidden', 'info');
  }
}

/**
 * Select event player slot for XY/details editing (v6)
 */
function selectEventPlayerSlot(type, num) {
  const rolePrefix1 = type === 'evt' ? 'event_team_player_' : 'opp_team_player_';
  const rolePrefix2 = type === 'evt' ? 'event_player_' : 'opp_player_';
  
  // Check if player with this role already exists (check both role formats)
  let player = S.curr.players.find(p => 
    p.role === rolePrefix1 + num || 
    p.role === rolePrefix2 + num ||
    (p.roleNum === num && p.role?.startsWith(type === 'evt' ? 'event' : 'opp'))
  );
  
  if (player) {
    // Player exists - just SELECT them (don't add duplicate)
    S.selectedPlayer = player;
    setXYMode('player');
    S.xySlot = (player.xy?.length || 0) + 1; // Start at next XY slot
    renderXYSlots();
    renderQuickAdd(); // Highlight selected player
    toast(`Selected ${type === 'evt' ? 'E' : 'O'}${num}: #${player.num}`, 'info');
    return;
  }
  
  // Player doesn't exist - try to add from slots
  const team = type === 'evt' ? S.evtTeam : (S.evtTeam === 'home' ? 'away' : 'home');
  const slots = S.slots[team];
  
  // Map slot positions to player numbers (F1, F2, F3, D1, D2)
  const slotMap = { 1: 'F1', 2: 'F2', 3: 'F3', 4: 'D1', 5: 'D2', 6: 'G' };
  const slotKey = slotMap[num];
  const slotPlayer = slots[slotKey];
  
  if (slotPlayer) {
    // Add player to current event
    player = {
      num: slotPlayer.num,
      name: slotPlayer.name,
      team: team,
      role: rolePrefix1 + num,
      roleNum: num,
      xy: [],
      playD1: '',
      playD2: '',
      playSuccess: '',
      pressuredBy: '',
      sideOfPuck: ''
    };
    S.curr.players.push(player);
    S.selectedPlayer = player;
    setXYMode('player');
    S.xySlot = 1;
    renderXYSlots();
    renderQuickAdd();
    toast(`Added ${type === 'evt' ? 'E' : 'O'}${num}: #${slotPlayer.num} ${slotPlayer.name}`, 'success');
  } else {
    toast(`${type === 'evt' ? 'Event' : 'Opp'} Player ${num} - No player in slot ${slotKey}`, 'warning');
    return;
  }
}

/**
 * Filter options in "Show More" modal based on search input
 */
function filterShowMoreOptions(idx, dimKey) {
  const searchInput = document.getElementById(`showMoreSearch_${idx}`);
  const optionsContainer = document.getElementById(`showMoreOptions_${idx}`);
  if (!searchInput || !optionsContainer) return;
  
  const searchTerm = searchInput.value.toLowerCase().trim();
  const allOptions = optionsContainer.querySelectorAll('.show-more-option');
  
  allOptions.forEach(opt => {
    const text = opt.textContent.toLowerCase();
    if (searchTerm === '' || text.includes(searchTerm)) {
      opt.style.display = '';
    } else {
      opt.style.display = 'none';
    }
  });
}

/**
 * Select an option from "Show More" modal and update the mapping select
 */
function selectShowMoreOption(idx, value, dimKey) {
  console.log('selectShowMoreOption called:', idx, value, dimKey);
  
  // Find the original select element
  const select = document.querySelector(`#mapping_${idx}`);
  if (!select) {
    console.error('Select element not found:', `#mapping_${idx}`);
    closeShowMoreModal(idx);
    return;
  }
  
  // Update the mapping in pendingMappings FIRST
  if (S.pendingMappings && S.pendingMappings.mappings && S.pendingMappings.mappings[idx]) {
    S.pendingMappings.mappings[idx].mapped = value;
    console.log('Updated mapping:', S.pendingMappings.mappings[idx]);
  }
  
  // Update the select element - need to add option if it doesn't exist
  if (!select.querySelector(`option[value="${value}"]`)) {
    const option = document.createElement('option');
    option.value = value;
    option.textContent = value;
    select.appendChild(option);
  }
  
  // Set the select value
  select.value = value;
  
  // Update visual styling
  select.style.backgroundColor = value ? 'rgba(0,212,255,0.1)' : '';
  
  // Close the modal
  closeShowMoreModal(idx);
  
  console.log('Mapping selected:', value);
  
  // Trigger a visual update of the select to show the selected value
  select.dispatchEvent(new Event('change', { bubbles: true }));
}

/**
 * Close the "Show More" modal
 */
function closeShowMoreModal(idx) {
  const container = document.getElementById(`showMoreContainer_${idx}`);
  if (container) container.remove();
}

/**
 * Quick line change - ends all current shifts and starts new ones (v6)
 */
function quickLineChange() {
  const clock = document.getElementById('clock').value;
  
  // Log current shift with end time
  document.getElementById('shiftEnd').value = clock;
  logShift();
  
  // Start new shift immediately
  document.getElementById('shiftStart').value = clock;
  document.getElementById('shiftEnd').value = '';
  
  toast('Quick line change recorded', 'success');
}

// ============================================================
// RESIZE PANELS
// ============================================================
// v23.8: Enhanced resize system for modular layout
let resizing = null;
let savedPanelWidths = JSON.parse(localStorage.getItem('bs_panel_widths') || '{}');

function startResize(e, panel) {
  e.preventDefault();
  e.stopPropagation();
  const panelEl = document.getElementById(panel + 'Panel');
  resizing = { 
    panel, 
    startX: e.clientX, 
    startWidth: panelEl.offsetWidth,
    minWidth: 150,
    maxWidth: window.innerWidth * 0.5 // Max 50% of screen width
  };
  document.body.style.cursor = 'ew-resize';
  document.body.style.userSelect = 'none';
  document.addEventListener('mousemove', doResize);
  document.addEventListener('mouseup', stopResize);
  // Add active class to handle
  const handle = e.target;
  if (handle) handle.classList.add('active');
}

function doResize(e) {
  if (!resizing) return;
  e.preventDefault();
  const diff = e.clientX - resizing.startX;
  let newWidth;
  
  if (resizing.panel === 'left') {
    newWidth = resizing.startWidth + diff;
  } else if (resizing.panel === 'right') {
    newWidth = resizing.startWidth - diff;
  } else {
    return;
  }
  
  // Clamp to min/max
  newWidth = Math.max(resizing.minWidth, Math.min(resizing.maxWidth, newWidth));
  
  const panelEl = document.getElementById(resizing.panel + 'Panel');
  if (panelEl) {
    panelEl.style.width = newWidth + 'px';
    panelEl.style.flexShrink = '0';
    panelEl.style.flexGrow = '0';
    
    // Save to localStorage
    savedPanelWidths[resizing.panel] = newWidth;
    localStorage.setItem('bs_panel_widths', JSON.stringify(savedPanelWidths));
    
    // Update CSS variable for responsive layout
    if (resizing.panel === 'left') {
      document.documentElement.style.setProperty('--left-panel-width', newWidth + 'px');
    } else if (resizing.panel === 'right') {
      document.documentElement.style.setProperty('--right-panel-width', newWidth + 'px');
    }
  }
}

function stopResize() { 
  resizing = null; 
  document.body.style.cursor = '';
  document.body.style.userSelect = '';
  document.removeEventListener('mousemove', doResize); 
  document.removeEventListener('mouseup', stopResize);
  // Remove active class from all handles
  document.querySelectorAll('.resize-handle.active').forEach(h => h.classList.remove('active'));
}

// v23.8: Restore saved panel widths on load
function restorePanelWidths() {
  if (savedPanelWidths.left) {
    const leftPanel = document.getElementById('leftPanel');
    if (leftPanel) {
      leftPanel.style.width = savedPanelWidths.left + 'px';
      leftPanel.style.flexShrink = '0';
      leftPanel.style.flexGrow = '0';
      document.documentElement.style.setProperty('--left-panel-width', savedPanelWidths.left + 'px');
    }
  }
  if (savedPanelWidths.right) {
    const rightPanel = document.getElementById('rightPanel');
    if (rightPanel) {
      rightPanel.style.width = savedPanelWidths.right + 'px';
      rightPanel.style.flexShrink = '0';
      rightPanel.style.flexGrow = '0';
      document.documentElement.style.setProperty('--right-panel-width', savedPanelWidths.right + 'px');
    }
  }
}

// v23.8: Responsive layout adjustments
function adjustLayoutForScreenSize() {
  const width = window.innerWidth;
  const height = window.innerHeight;
  
  // On smaller screens, make panels more compact
  if (width < 1200) {
    // Reduce font sizes slightly
    document.documentElement.style.setProperty('--base-font-size', '10px');
    
    // Adjust panel min widths
    const leftPanel = document.getElementById('leftPanel');
    const rightPanel = document.getElementById('rightPanel');
    if (leftPanel && !savedPanelWidths.left) {
      leftPanel.style.width = '180px';
      document.documentElement.style.setProperty('--left-panel-width', '180px');
    }
    if (rightPanel && !savedPanelWidths.right) {
      rightPanel.style.width = '280px';
      document.documentElement.style.setProperty('--right-panel-width', '280px');
    }
  } else {
    document.documentElement.style.setProperty('--base-font-size', '11px');
  }
  
  // Adjust for height
  if (height < 700) {
    // Reduce max heights of scrollable areas
    document.querySelectorAll('.panel-body').forEach(el => {
      if (!el.style.maxHeight) {
        el.style.maxHeight = (height - 100) + 'px';
      }
    });
  }
}

// Listen for window resize
window.addEventListener('resize', adjustLayoutForScreenSize);

// ============================================================
// v23.4: GENERIC MODAL
// ============================================================

/**
 * Show generic modal with HTML content
 */
function showModal(html) {
  const overlay = document.getElementById('genericModal');
  const content = document.getElementById('genericModalContent');
  if (!overlay || !content) return;
  
  content.innerHTML = html;
  overlay.classList.add('show');
  overlay.style.display = 'flex';
  
  // Update overlay click handler to use appropriate close function
  overlay.onclick = function(e) {
    if (e.target === overlay) {
      // Check if we're in template edit mode
      if (window.editingTemplateIdx !== null && window.editingTemplateIdx !== undefined) {
        closeEditTemplateModal();
      } else {
        closeModal();
      }
    }
  };
}

/**
 * Close generic modal
 */
function closeModal() {
  const overlay = document.getElementById('genericModal');
  if (overlay) {
    overlay.classList.remove('show');
    overlay.style.display = 'none';
  }
}

// ============================================================
// TOAST
// ============================================================
function toast(msg, type = '') {
  const el = document.getElementById('toast');
  el.textContent = msg;
  el.className = 'toast show ' + type;
  setTimeout(() => el.classList.remove('show'), 2000);
}

// ============================================================
// START
// ============================================================

// Debug helpers - define early so they're always available
window.testModal = function(modalId) {
  const modal = document.getElementById(modalId);
  if (!modal) {
    console.error('Modal not found:', modalId);
    return false;
  }
  console.log('Testing modal:', modalId);
  modal.classList.add('show');
  modal.style.display = 'flex';
  modal.style.zIndex = '10000';
  modal.style.position = 'fixed';
  console.log('Modal classes:', modal.className);
  console.log('Modal style.display:', modal.style.display);
  console.log('Modal computed display:', window.getComputedStyle(modal).display);
  return true;
};

window.debugModals = function() {
  console.log('Testing modal functions...');
  console.log('editEvent exists:', typeof editEvent);
  console.log('editShift exists:', typeof editShift);
  console.log('showAllShifts exists:', typeof showAllShifts);
  console.log('showAllEvents exists:', typeof showAllEvents);
  console.log('editModal element:', document.getElementById('editModal'));
  console.log('editShiftModal element:', document.getElementById('editShiftModal'));
  console.log('allShiftsModal element:', document.getElementById('allShiftsModal'));
  console.log('allEventsModal element:', document.getElementById('allEventsModal'));
};

document.addEventListener('DOMContentLoaded', () => {
  console.log('DOMContentLoaded - starting init');
  init().catch(e => {
    console.error('Init error:', e);
    // Even if init fails, try to build UI
    setTimeout(() => {
      console.log('Retrying buildUI after init error');
      buildUI();
    }, 500);
  });
});

// Also try to build buttons immediately if DOM is already ready
if (document.readyState === 'loading') {
  // DOM is still loading, wait for DOMContentLoaded
} else {
  // DOM is already ready, build buttons now as backup
  console.log('DOM already ready, building buttons as backup');
  setTimeout(buildEventTypeButtons, 100);
}

// Ensure critical functions are accessible globally after script loads
// This runs after all functions are defined
setTimeout(() => {
  try {
    // Verify and expose critical functions to window object
    if (typeof exportData === 'function') {
      window.exportData = exportData;
      console.log('exportData function verified');
    } else {
      console.error('exportData function not found!');
    }
    if (typeof exportToCSV === 'function') {
      window.exportToCSV = exportToCSV;
      console.log('exportToCSV function verified');
    } else {
      console.error('exportToCSV function not found!');
    }
    if (typeof editEvent === 'function') {
      window.editEvent = editEvent;
      console.log('editEvent function verified');
    } else {
      console.error('editEvent function not found!');
    }
    if (typeof editShift === 'function') {
      window.editShift = editShift;
      console.log('editShift function verified');
    } else {
      console.error('editShift function not found!');
    }
    if (typeof showAddVideoModal === 'function') {
      window.showAddVideoModal = showAddVideoModal;
      console.log('showAddVideoModal function verified');
    } else {
      console.error('showAddVideoModal function not found!');
    }
    if (typeof showAllShifts === 'function') {
      window.showAllShifts = showAllShifts;
      console.log('showAllShifts function verified');
    } else {
      console.error('showAllShifts function not found!');
    }
    if (typeof showAllEvents === 'function') {
      window.showAllEvents = showAllEvents;
      console.log('showAllEvents function verified');
    } else {
      console.error('showAllEvents function not found!');
    }
    // logEvent is already defined on window at function definition, just verify
    if (typeof window.logEvent === 'function') {
      console.log('logEvent function verified on window');
    } else {
      console.error('logEvent function not found on window!');
      // Try to assign if regular function exists
      if (typeof logEvent === 'function') {
        window.logEvent = logEvent;
        console.log('Assigned logEvent to window from regular function');
      }
    }
    if (typeof logEventDirect === 'function') {
      window.logEventDirect = logEventDirect;
      console.log('logEventDirect function verified');
    } else {
      console.error('logEventDirect function not found!');
    }
    if (typeof clearEvent === 'function') {
      window.clearEvent = clearEvent;
      console.log('clearEvent function verified');
    } else {
      console.error('clearEvent function not found!');
    }
    
    // v25.0: After verifying functions, setup Log Event button
    setupLogEventButton();
  } catch (e) {
    console.error('Error verifying functions:', e);
  }
}, 2000);

</script>
</body>
</html>
