<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BenchSight Tracker v22.1</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<style>
:root {
  --bg: #0a0e14; --panel: #131920; --card: #1a222c; --input: #0d1117;
  --border: #2a3441; --accent: #00d4aa; --accent2: #00b4d8;
  --success: #10b981; --warn: #f59e0b; --danger: #ef4444;
  --text: #e2e8f0; --muted: #64748b; --home: #3b82f6; --away: #ef4444;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: 'SF Mono', monospace; background: var(--bg); color: var(--text); font-size: 11px; overflow: hidden; height: 100vh; }
.app { display: grid; grid-template-rows: 36px 1fr; height: 100vh; }
.header { background: var(--panel); border-bottom: 1px solid var(--border); padding: 0 8px; display: flex; align-items: center; gap: 8px; }
.header h1 { font-size: 12px; background: linear-gradient(135deg, var(--accent), var(--accent2)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
.main { display: grid; grid-template-columns: 220px 1fr 320px; height: 100%; }
.panel { background: var(--panel); border-right: 1px solid var(--border); display: flex; flex-direction: column; overflow: hidden; position: relative; }
.panel:last-child { border-right: none; border-left: 1px solid var(--border); }
.panel-header { background: var(--card); padding: 4px 8px; font-size: 9px; font-weight: 600; text-transform: uppercase; color: var(--accent); border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; }
.panel-body { flex: 1; overflow-y: auto; padding: 6px; }
select, input, button { font-family: inherit; font-size: 10px; background: var(--input); border: 1px solid var(--border); color: var(--text); padding: 4px 6px; border-radius: 3px; }
select:focus, input:focus { border-color: var(--accent); outline: none; }
button { cursor: pointer; } button:hover { background: var(--card); border-color: var(--accent); }
.btn-sm { padding: 2px 5px; font-size: 9px; }
.btn-primary { background: var(--accent); color: #000; border-color: var(--accent); }
.btn-success { background: var(--success); color: #fff; }
.btn-danger { background: var(--danger); color: #fff; }
kbd { background: var(--bg); border: 1px solid var(--border); padding: 0 3px; border-radius: 2px; font-size: 8px; color: var(--muted); }
.form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 4px; }
.form-row.tri { grid-template-columns: 1fr 1fr 1fr; }
.form-group { display: flex; flex-direction: column; gap: 1px; }
.form-group label { font-size: 7px; color: var(--muted); text-transform: uppercase; }
.form-group select, .form-group input { width: 100%; }

/* Resize handles */
.resize-handle { position: absolute; background: transparent; z-index: 10; }
.resize-handle:hover { background: var(--accent); opacity: 0.5; }
.resize-handle.right { right: 0; top: 0; width: 4px; height: 100%; cursor: ew-resize; }

/* Header */
.game-select { width: 200px; }
.game-search { background: var(--input); border: 1px solid var(--border); color: var(--text); padding: 4px 8px; border-radius: 3px; width: 150px; font-size: 10px; }
.clock { font-size: 16px; font-weight: 700; color: var(--accent); background: var(--bg); padding: 2px 8px; border-radius: 3px; border: 1px solid var(--border); }
.score { font-size: 14px; font-weight: 700; }
.score-h { color: var(--home); } .score-a { color: var(--away); }
.period-btns { display: flex; gap: 2px; }
.period-btn { padding: 2px 6px; } .period-btn.active { background: var(--accent); color: #000; }
.header-right { margin-left: auto; display: flex; gap: 6px; align-items: center; }
.status { font-size: 8px; color: var(--muted); }
.save-ind { font-size: 7px; padding: 1px 4px; border-radius: 4px; background: var(--card); }
.save-ind.saving { background: var(--warn); color: #000; }
.save-ind.saved { background: var(--success); color: #fff; }
.conn { font-size: 7px; padding: 1px 4px; border-radius: 8px; }
.conn.on { background: var(--success); color: #fff; } .conn.off { background: var(--muted); color: #fff; }

/* Shift Panel */
.team-sec { margin-bottom: 8px; }
.team-hdr { display: flex; justify-content: space-between; align-items: center; padding: 3px 6px; background: var(--card); border-radius: 3px; margin-bottom: 3px; }
.team-hdr h4 { font-size: 9px; display: flex; align-items: center; gap: 4px; }
.team-dot { width: 8px; height: 8px; border-radius: 50%; }
.slots { display: grid; grid-template-columns: 20px 1fr; gap: 2px; margin-bottom: 2px; }
.slot-lbl { font-size: 7px; color: var(--muted); display: flex; align-items: center; }
.slot-row { display: flex; gap: 2px; }
.slot { flex: 1; min-height: 24px; border-radius: 3px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; border: 2px solid var(--border); background: var(--input); font-size: 10px; }
.slot .num { font-weight: 700; } .slot .name { font-size: 6px; color: var(--muted); max-width: 40px; overflow: hidden; text-overflow: ellipsis; }
.slot.filled { border-color: var(--success); background: var(--card); }
.slot.selected { box-shadow: 0 0 0 2px var(--accent); }
.roster { background: var(--card); border-radius: 3px; padding: 3px; max-height: 100px; overflow-y: auto; }
.roster-group { margin-bottom: 4px; }
.roster-group-label { font-size: 7px; color: var(--accent); text-transform: uppercase; display: block; margin-bottom: 2px; }
.roster-btn { padding: 2px 4px; font-size: 8px; border-radius: 2px; cursor: pointer; border: 1px solid var(--border); background: var(--input); display: inline-flex; flex-direction: column; align-items: center; min-width: 36px; margin: 1px; }
.roster-btn .num { font-weight: 700; } .roster-btn .name { font-size: 6px; color: var(--muted); }
.roster-btn .rating { font-size: 6px; color: var(--accent); background: var(--bg); padding: 0 2px; border-radius: 2px; margin-top: 1px; }
.roster-btn:hover { background: var(--accent); color: #000; }
.roster-btn.on-ice { opacity: 0.3; }
.shift-times { display: grid; grid-template-columns: 1fr 1fr; gap: 3px; margin-top: 4px; padding: 4px; background: var(--card); border-radius: 3px; }
.shift-times label { font-size: 6px; color: var(--muted); }
.shift-actions { display: flex; gap: 3px; margin-top: 4px; }
.shift-actions button { flex: 1; padding: 6px; font-size: 9px; }

/* Center - Rink */
.center { display: flex; flex-direction: column; background: var(--panel); overflow-y: auto; }
.video-section { border-bottom: 2px solid var(--accent); }
.video-section .speed-btn.active { background: var(--accent); color: #000; }
.video-toggle-bar:hover { background: var(--panel); }
.rink-wrap { flex: 1; display: flex; align-items: center; justify-content: center; padding: 8px; position: relative; min-height: 300px; max-height: 450px; }
#rinkSvg { max-width: 100%; max-height: 100%; cursor: crosshair; }
.mode-ind { position: absolute; top: 6px; left: 50%; transform: translateX(-50%); padding: 3px 10px; border-radius: 12px; font-size: 9px; font-weight: 600; border: 2px solid; }
.mode-ind.puck { background: #000; color: #fff; border-color: #fff; }
.mode-ind.player { background: var(--accent); color: #000; border-color: var(--accent); }
.xy-controls { display: flex; gap: 4px; padding: 4px 8px; background: var(--card); border-top: 1px solid var(--border); align-items: center; flex-wrap: wrap; justify-content: center; }
.xy-btn { padding: 2px 6px; font-size: 9px; } .xy-btn.active { background: var(--accent); color: #000; }
.xy-slots { display: flex; gap: 1px; }
.xy-slot { width: 18px; height: 18px; border-radius: 2px; display: flex; align-items: center; justify-content: center; font-size: 8px; cursor: pointer; border: 1px solid var(--border); background: var(--input); }
.xy-slot.has { background: var(--success); color: #fff; } .xy-slot.active { box-shadow: 0 0 0 2px var(--accent); }
.xy-player-sel { min-width: 80px; font-size: 9px; }

/* Event List */
.evt-list { border-top: 1px solid var(--border); flex: 0 0 auto; min-height: 120px; max-height: 280px; overflow-y: auto; background: var(--card); }
.evt-header { display: grid; grid-template-columns: 35px 45px 100px 1fr 20px; gap: 2px; padding: 2px 6px; background: var(--card); font-size: 7px; color: var(--muted); position: sticky; top: 0; }
/* v20.4: Expanded columns - #, Sh, Lnk, Time, T, Type, Detail1, Detail2, Z, S, EvtP, OppP, PD1, PD2, PS, XY, ‚≠ê */
.evt-item { display: grid; grid-template-columns: 22px 22px 20px 48px 14px 46px 58px 58px 14px 12px 30px 30px 46px 46px 12px 12px 12px; gap: 1px; padding: 2px 3px; border-bottom: 1px solid var(--border); font-size: 7px; cursor: pointer; align-items: center; }
/* v20.4: Event log filter row */
.evt-filter-row { display: flex; flex-wrap: wrap; gap: 4px; padding: 4px 6px; background: var(--panel); border-bottom: 1px solid var(--border); align-items: center; }
.evt-filter-row select, .evt-filter-row input { font-size: 8px; padding: 2px 4px; background: var(--card); border: 1px solid var(--border); color: var(--text); border-radius: 3px; }
.evt-filter-row select { max-width: 80px; }
.evt-filter-row input { width: 40px; }
.evt-filter-row label { font-size: 7px; color: var(--muted); margin-right: 2px; }
.evt-filter-row .filter-group { display: flex; align-items: center; gap: 2px; }
.evt-filter-row .btn-clear { font-size: 8px; padding: 2px 6px; background: var(--danger); color: white; border: none; border-radius: 3px; cursor: pointer; }
.evt-item:hover { background: var(--panel); }
.evt-item.active { background: rgba(0,212,170,0.1); }
.evt-item .idx { color: var(--accent); font-family: monospace; font-size: 7px; }
.evt-item .seq { color: var(--accent2); font-family: monospace; font-size: 6px; }
.evt-item .link { color: var(--warn); font-family: monospace; font-size: 6px; }
.evt-item .time { color: var(--muted); font-size: 7px; }
.evt-item .team { font-weight: bold; font-size: 7px; }
.evt-item .type { font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 7px; }
.evt-item .detail { color: var(--muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 6px; }
.evt-item .zone { color: var(--accent2); font-size: 6px; }
.evt-item .success { color: var(--success); font-size: 7px; }
.evt-item .evtp { font-size: 6px; color: var(--accent); font-family: monospace; }
.evt-item .oppp { font-size: 6px; color: var(--muted); font-family: monospace; }
.evt-item .pd1 { font-size: 5px; color: var(--muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.evt-item .psucc { font-size: 6px; color: var(--success); }
.evt-item .xy-dot { color: var(--accent); font-size: 8px; }
.evt-item .hl { color: var(--warn); }

/* Right Panel - Event Entry */
.team-toggle { display: flex; gap: 2px; margin-bottom: 4px; }
.team-toggle button { flex: 1; padding: 5px; font-size: 9px; }
.team-toggle .home.active { background: var(--home); color: #fff; }
.team-toggle .away.active { background: var(--away); color: #fff; }
.evt-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 2px; margin-bottom: 6px; }
.evt-btn { padding: 4px 2px; display: flex; flex-direction: column; align-items: center; font-size: 8px; border-radius: 3px; }
.evt-btn kbd { font-size: 7px; } .evt-btn.active { background: var(--accent); color: #000; }
.section { margin-bottom: 6px; }
.section-title { font-size: 8px; color: var(--muted); margin-bottom: 2px; display: flex; justify-content: space-between; }
.player-list { background: var(--card); border-radius: 3px; padding: 3px; min-height: 28px; }
.player-chip { display: inline-flex; align-items: center; gap: 2px; padding: 2px 5px; margin: 1px; border-radius: 3px; font-size: 9px; cursor: pointer; border: 1px solid var(--border); background: var(--input); }
.player-chip.evt { border-color: var(--accent); background: rgba(0,212,170,0.1); }
.player-chip.opp { border-color: var(--danger); background: rgba(239,68,68,0.1); }
.player-chip.selected { box-shadow: 0 0 0 2px var(--warn); }
.player-chip .num { font-weight: 700; }
.player-chip .su { font-size: 7px; padding: 0 2px; border-radius: 2px; margin-left: 2px; }
.player-chip .su.s { background: var(--success); color: #fff; }
.player-chip .su.u { background: var(--danger); color: #fff; }
.player-chip .remove { color: var(--muted); margin-left: 2px; } .player-chip .remove:hover { color: var(--danger); }
.quick-add { display: flex; flex-wrap: wrap; gap: 2px; padding: 3px; background: var(--card); border-radius: 3px; }
.quick-add button { padding: 2px 4px; font-size: 8px; min-width: 24px; }
.quick-add button.in-evt { background: var(--accent); color: #000; }
.player-details { background: var(--card); border-radius: 3px; padding: 4px; margin-top: 4px; font-size: 8px; }
.player-details h5 { color: var(--accent); margin-bottom: 3px; font-size: 9px; }
.log-actions { display: flex; gap: 3px; margin-top: 6px; }
.log-actions button { flex: 1; padding: 8px; font-size: 10px; }

/* Zone indicator */
.zone-ind { display: inline-block; padding: 2px 6px; border-radius: 3px; font-size: 8px; font-weight: bold; margin-left: 4px; }
.zone-ind.o { background: var(--success); color: #fff; }
.zone-ind.d { background: var(--danger); color: #fff; }
.zone-ind.n { background: var(--warn); color: #000; }

/* Modals */
.overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.85); display: none; align-items: center; justify-content: center; z-index: 100; }
.overlay.show { display: flex; }
.modal { background: var(--panel); border: 1px solid var(--border); border-radius: 6px; padding: 12px; min-width: 400px; max-width: 600px; max-height: 80vh; overflow-y: auto; }
.modal h3 { font-size: 12px; color: var(--accent); margin-bottom: 8px; }
.modal-actions { display: flex; gap: 4px; margin-top: 10px; }
.modal-actions button { flex: 1; }
/* v20.5: Mapping modal for import validation */
.mapping-modal { min-width: 700px; max-width: 900px; }
.mapping-modal h3 { font-size: 14px; margin-bottom: 12px; }
.mapping-modal .summary { font-size: 11px; color: var(--muted); margin-bottom: 10px; }
.mapping-table { width: 100%; border-collapse: collapse; font-size: 10px; margin: 10px 0; }
.mapping-table th { background: var(--card); color: var(--accent); padding: 6px 8px; text-align: left; border: 1px solid var(--border); }
.mapping-table td { padding: 6px 8px; border: 1px solid var(--border); }
.mapping-table tr:hover { background: rgba(0,212,255,0.1); }
.mapping-table .field { color: var(--muted); font-size: 9px; }
.mapping-table .original { color: var(--warn); font-family: monospace; }
.mapping-table .matched { color: var(--success); font-family: monospace; }
.mapping-table .no-match { color: var(--danger); }
.mapping-table select { font-size: 9px; padding: 2px 4px; max-width: 180px; background: var(--card); border: 1px solid var(--border); color: var(--text); }
.mapping-table .score { font-size: 9px; color: var(--muted); }
.mapping-legend { display: flex; gap: 15px; font-size: 9px; margin: 8px 0; }
.mapping-legend span { display: flex; align-items: center; gap: 4px; }
.mapping-legend .dot { width: 8px; height: 8px; border-radius: 50%; }
.mapping-legend .dot.exact { background: var(--success); }
.mapping-legend .dot.fuzzy { background: var(--accent); }
.mapping-legend .dot.none { background: var(--danger); }
.modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 999; }
.mapping-modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1000; }

/* Edit Modal Specific */
.edit-player-row { display: flex; gap: 4px; align-items: center; padding: 4px; background: var(--input); border-radius: 3px; margin-bottom: 4px; }
.edit-player-row .pnum { font-weight: bold; min-width: 50px; }
.edit-player-row select, .edit-player-row input { flex: 1; }
.edit-xy-grid { display: flex; gap: 2px; flex-wrap: wrap; margin-top: 4px; }
.edit-xy-btn { width: 24px; height: 24px; border-radius: 3px; display: flex; align-items: center; justify-content: center; font-size: 8px; cursor: pointer; }
.edit-xy-btn.has { background: var(--success); color: #fff; }

/* Toast */
.toast { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); background: var(--card); border: 1px solid var(--border); padding: 6px 14px; border-radius: 4px; font-size: 10px; z-index: 200; opacity: 0; transition: opacity 0.2s; }
.toast.show { opacity: 1; }
.toast.success { border-color: var(--success); color: var(--success); }
.toast.error { border-color: var(--danger); color: var(--danger); }

/* XY Tooltip v5 */
.xy-tooltip { position: absolute; background: rgba(0,0,0,0.9); color: #fff; padding: 6px 10px; border-radius: 4px; font-size: 10px; pointer-events: none; z-index: 100; white-space: nowrap; transform: translate(-50%, -100%); margin-top: -8px; }
.xy-tooltip::after { content: ''; position: absolute; bottom: -4px; left: 50%; transform: translateX(-50%); border-left: 5px solid transparent; border-right: 5px solid transparent; border-top: 5px solid rgba(0,0,0,0.9); }

/* Clear All Buttons v5 */
.clear-all-btn { padding: 4px 8px; font-size: 8px; background: var(--danger); color: #fff; border: none; border-radius: 3px; cursor: pointer; margin-left: 4px; }
.clear-all-btn:hover { background: #dc2626; }

/* Auto-popup checkbox v5 */
.auto-popup-row { display: flex; align-items: center; gap: 8px; margin: 8px 0; padding: 6px; background: var(--card); border-radius: 4px; font-size: 9px; }
.auto-popup-row input[type="checkbox"] { margin: 0; }

/* Enhanced player chip inline edit v5 */
.player-chip { position: relative; }
.player-chip .inline-edit { position: absolute; top: 100%; left: 0; background: var(--panel); border: 1px solid var(--accent); border-radius: 4px; padding: 4px; z-index: 50; min-width: 150px; display: none; }
.player-chip:hover .inline-edit.active { display: block; }

/* Hotkey indicator flash v5 */
.hotkey-flash { animation: hotkey-pulse 0.3s ease-out; }
@keyframes hotkey-pulse { 0% { box-shadow: 0 0 0 0 rgba(0,212,170,0.5); } 100% { box-shadow: 0 0 0 10px rgba(0,212,170,0); } }

/* Event type colors v5 */
.evt-btn[data-type="Goal"] { border-color: #22c55e !important; }
.evt-btn[data-type="Goal"].active { background: #22c55e !important; }
.evt-btn[data-type="Shot"] { border-color: #3b82f6 !important; }
.evt-btn[data-type="Shot"].active { background: #3b82f6 !important; }
.evt-btn[data-type="Penalty"] { border-color: #ef4444 !important; }
.evt-btn[data-type="Penalty"].active { background: #ef4444 !important; }
.evt-btn[data-type="Turnover"] { border-color: #f59e0b !important; }
.evt-btn[data-type="Turnover"].active { background: #f59e0b !important; }

/* Quick stats bar v5 */
.quick-stats { display: flex; gap: 8px; padding: 4px 8px; background: var(--card); font-size: 9px; border-bottom: 1px solid var(--border); }
.quick-stat { display: flex; align-items: center; gap: 4px; }
.quick-stat .label { color: var(--muted); }
.quick-stat .value { font-weight: bold; color: var(--accent); }

/* Period indicator enhanced v5 */
.period-btn.active { background: var(--accent); color: #000; font-weight: bold; }

/* Shift strength indicator v5 */
.strength-indicator { padding: 2px 6px; border-radius: 3px; font-size: 9px; font-weight: bold; }
.strength-indicator.pp { background: rgba(34,197,94,0.2); color: #22c55e; }
.strength-indicator.pk { background: rgba(239,68,68,0.2); color: #ef4444; }
.strength-indicator.even { background: rgba(100,116,139,0.2); color: #94a3b8; }

/* v6: Period filter tabs */
.period-filter-tabs { display: flex; gap: 2px; padding: 4px 8px; background: var(--bg); border-bottom: 1px solid var(--border); }
.period-filter-tab { padding: 2px 8px; font-size: 8px; border: 1px solid var(--border); border-radius: 3px; cursor: pointer; background: var(--input); color: var(--muted); }
.period-filter-tab.active { background: var(--accent); color: #000; border-color: var(--accent); }

/* v6: Line presets */
.line-presets { padding: 4px 8px; background: var(--card); border-bottom: 1px solid var(--border); font-size: 8px; }
.preset-row { display: flex; gap: 4px; align-items: center; margin-bottom: 2px; }
.preset-btn { padding: 2px 6px; font-size: 8px; border-radius: 3px; cursor: pointer; border: 1px solid var(--border); background: var(--input); }
.preset-btn:hover { background: var(--accent); color: #000; }
.preset-btn.active { border-color: var(--success); }

/* v6: Compact mode */
.compact-mode .panel-body { padding: 4px; }
.compact-mode .team-sec { margin-bottom: 4px; }
.compact-mode .team-hdr { padding: 2px 4px; margin-bottom: 2px; }
.compact-mode .slots { margin-bottom: 1px; }
.compact-mode .slot { min-height: 20px; font-size: 9px; }
.compact-mode .roster { max-height: 60px; padding: 2px; }
.compact-mode .roster-btn { padding: 1px 2px; font-size: 7px; min-width: 28px; }
.compact-mode .quick-stats { padding: 2px 8px; }

/* v6: Selected player indicator */
.selected-player-slot { box-shadow: 0 0 0 2px var(--accent), 0 0 8px var(--accent); }
.player-selector { display: inline-flex; align-items: center; gap: 2px; padding: 1px 4px; border-radius: 3px; font-size: 8px; cursor: pointer; border: 1px solid var(--border); }
.player-selector.selected { background: var(--accent); color: #000; border-color: var(--accent); }
</style>
</head>
<body>
<div class="app">
  <!-- Header -->
  <header class="header">
    <h1>üèí BenchSight v16.08</h1>
    <div style="display:flex;gap:4px;align-items:center;">
      <input type="text" id="gameSearch" class="game-search" placeholder="üîç Search games..." oninput="filterGames(this.value)">
      <select id="gameSelect" class="game-select" onchange="selectGame(this.value)"></select>
      <button class="btn-sm" onclick="loadGames()" title="Reload Games">üîÑ</button>
    </div>
    <div class="period-btns">
      <button class="period-btn active" data-p="1" onclick="setPeriod(1)">P1</button>
      <button class="period-btn" data-p="2" onclick="setPeriod(2)">P2</button>
      <button class="period-btn" data-p="3" onclick="setPeriod(3)">P3</button>
      <button class="period-btn" data-p="OT" onclick="setPeriod('OT')">OT</button>
      <button id="flipZonesBtn" onclick="flipZones()" title="Flip which end home attacks in P1 (for beer league variable benches)" style="margin-left:8px;padding:2px 6px;font-size:10px;background:#374151;">‚ü∑ Flip</button>
    </div>
    <span class="score"><span class="score-h" id="scoreH">0</span> - <span class="score-a" id="scoreA">0</span></span>
    <input type="text" class="clock" id="clock" value="18:00" style="width:60px;text-align:center;" onchange="updateClock()">
    <div class="header-right">
      <span class="save-ind" id="saveInd">--</span>
      <button class="btn-sm" onclick="manualSave()" title="Save Now">üíæ</button>
      <button class="btn-sm" onclick="openLoadGameModal()" title="Load Existing Game">üìÇ</button>
      <button class="btn-sm" onclick="openVerifyModal()" title="Verify Goals">‚úÖ</button>
      <button class="btn-sm" onclick="openVideoTimingModal()" title="Video Timing">üé¨</button>
      <span class="conn off" id="connStatus">OFFLINE</span>
      <button class="btn-sm" onclick="openSettings()">‚öôÔ∏è</button>
      <button class="btn-sm" onclick="openHelp()">‚ùì</button>
      <button class="btn-sm btn-success" onclick="exportData()">üì• Export</button>
      <button class="btn-sm" style="background:#6366f1;" onclick="document.getElementById('importFileInput').click()">üì§ Import</button>
      <input type="file" id="importFileInput" accept=".xlsx,.xls" style="display:none" onchange="importExcel(this.files[0])">
    </div>
  </header>
  
  <!-- Quick Stats Bar (v5) -->
  <div class="quick-stats" id="quickStatsBar">
    <div class="quick-stat"><span class="label">Events:</span><span class="value" id="qsEvents">0</span></div>
    <div class="quick-stat"><span class="label">Shifts:</span><span class="value" id="qsShifts">0</span></div>
    <div class="quick-stat"><span class="label">SOG:</span><span class="value" id="qsSOG">0-0</span></div>
    <div class="quick-stat"><span class="label">FO:</span><span class="value" id="qsFO">0-0</span></div>
    <div class="quick-stat"><span class="label">PEN:</span><span class="value" id="qsPEN">0-0</span></div>
    <div class="quick-stat" style="margin-left:auto;"><span class="label">Strength:</span><span class="value strength-indicator even" id="qsStrength">5v5</span></div>
  </div>

  <!-- Main -->
  <div class="main">
    <!-- Left: Shifts -->
    <div class="panel" id="leftPanel">
      <div class="resize-handle right" onmousedown="startResize(event, 'left')"></div>
      <div class="panel-header">
        <span>Shift Tracking</span>
        <button class="btn-sm" onclick="toggleCompactMode()" title="Toggle Compact Mode">‚äü</button>
      </div>
      <!-- v6: Line Presets -->
      <div class="line-presets" id="linePresetsBar">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:2px;">
          <span style="color:var(--muted);">LINE PRESETS</span>
          <button class="btn-sm" onclick="openLinePresetModal()">‚öôÔ∏è</button>
        </div>
        <div class="preset-row">
          <button class="preset-btn" onclick="loadPreset('home','F1')">F1</button>
          <button class="preset-btn" onclick="loadPreset('home','F2')">F2</button>
          <button class="preset-btn" onclick="loadPreset('home','F3')">F3</button>
          <button class="preset-btn" onclick="loadPreset('home','D1')">D1</button>
          <button class="preset-btn" onclick="loadPreset('home','D2')">D2</button>
          <span style="color:var(--muted);font-size:7px;">Home</span>
        </div>
        <div class="preset-row">
          <button class="preset-btn" onclick="loadPreset('away','F1')">F1</button>
          <button class="preset-btn" onclick="loadPreset('away','F2')">F2</button>
          <button class="preset-btn" onclick="loadPreset('away','F3')">F3</button>
          <button class="preset-btn" onclick="loadPreset('away','D1')">D1</button>
          <button class="preset-btn" onclick="loadPreset('away','D2')">D2</button>
          <span style="color:var(--muted);font-size:7px;">Away</span>
        </div>
      </div>
      <div class="panel-body">
        <!-- Home Team -->
        <div class="team-sec">
          <div class="team-hdr">
            <h4><img id="homeLogoImg" src="" alt="" style="height:20px;width:auto;margin-right:4px;display:none;vertical-align:middle;" onerror="this.style.display='none'" onload="this.style.display='inline'"><span class="team-dot" id="homeDot" style="background:var(--home)"></span><span id="homeLbl">Home</span></h4>
            <button class="btn-sm" onclick="clearSlots('home')">Clear</button>
          </div>
          <div class="slots"><span class="slot-lbl">F</span><div class="slot-row" id="homeF"></div></div>
          <div class="slots"><span class="slot-lbl">D</span><div class="slot-row" id="homeD"></div></div>
          <div class="slots"><span class="slot-lbl">G</span><div class="slot-row" id="homeG"></div></div>
          <div class="roster" id="homeRoster"></div>
        </div>
        <!-- Away Team -->
        <div class="team-sec">
          <div class="team-hdr">
            <h4><img id="awayLogoImg" src="" alt="" style="height:20px;width:auto;margin-right:4px;display:none;vertical-align:middle;" onerror="this.style.display='none'" onload="this.style.display='inline'"><span class="team-dot" id="awayDot" style="background:var(--away)"></span><span id="awayLbl">Away</span></h4>
            <button class="btn-sm" onclick="clearSlots('away')">Clear</button>
          </div>
          <div class="slots"><span class="slot-lbl">F</span><div class="slot-row" id="awayF"></div></div>
          <div class="slots"><span class="slot-lbl">D</span><div class="slot-row" id="awayD"></div></div>
          <div class="slots"><span class="slot-lbl">G</span><div class="slot-row" id="awayG"></div></div>
          <div class="roster" id="awayRoster"></div>
        </div>
        <!-- Shift Times -->
        <div class="shift-times">
          <div class="form-group"><label>Start Type</label><select id="shiftStartType"></select></div>
          <div class="form-group"><label>Stop Type</label><select id="shiftStopType"></select></div>
          <div class="form-group"><label>Start</label><input type="text" id="shiftStart" value="18:00"></div>
          <div class="form-group"><label>End</label><input type="text" id="shiftEnd" value=""></div>
        </div>
        <div class="shift-actions">
          <button class="btn-success" onclick="logShift()">Log Shift <kbd>L</kbd></button>
        </div>
        <!-- Shift Log -->
        <div class="log-container" style="margin-top:8px;">
          <div class="panel-header" style="font-size:8px;display:flex;justify-content:space-between;">
            <span>Shift Log</span>
            <span>
              <button class="btn-sm" onclick="addNewShift()" title="Add New Shift" style="background:var(--success);">‚ûï</button>
              <button class="clear-all-btn" onclick="clearAllShifts()" title="Clear All Shifts">üóëÔ∏è All</button>
              <button class="btn-sm" onclick="showAllShifts()">View All</button>
            </span>
          </div>
          <!-- v6: Period filter tabs -->
          <div class="period-filter-tabs">
            <button class="period-filter-tab active" data-filter="all" onclick="filterShiftLog('all')">ALL</button>
            <button class="period-filter-tab" data-filter="1" onclick="filterShiftLog('1')">P1</button>
            <button class="period-filter-tab" data-filter="2" onclick="filterShiftLog('2')">P2</button>
            <button class="period-filter-tab" data-filter="3" onclick="filterShiftLog('3')">P3</button>
            <button class="period-filter-tab" data-filter="OT" onclick="filterShiftLog('OT')">OT</button>
          </div>
          <div class="log-header" style="grid-template-columns: 25px 25px 40px 40px 60px;">
            <span>#</span><span>P</span><span>Start</span><span>End</span><span>Type</span>
          </div>
          <div id="shiftLogBody" style="max-height:200px;overflow-y:auto;"></div>
        </div>
        <!-- Player Box Score -->
        <div class="box-score" style="margin-top:8px;background:var(--card);border-radius:4px;padding:6px;">
          <div style="font-size:8px;color:var(--muted);margin-bottom:4px;display:flex;justify-content:space-between;">
            <span>PLAYER STATS</span>
            <button class="btn-sm" onclick="showFullBoxScore()">üìä</button>
          </div>
          <div id="playerBoxScore" style="max-height:120px;overflow-y:auto;">
            <table style="width:100%;font-size:8px;border-collapse:collapse;">
              <thead>
                <tr style="color:var(--muted);">
                  <td>#</td><td>Name</td><td>G</td><td>A</td><td>SOG</td><td>TOI</td>
                </tr>
              </thead>
              <tbody id="playerBoxBody"></tbody>
            </table>
          </div>
        </div>
        <!-- Team Summary -->
        <div class="team-summary" style="margin-top:4px;background:var(--card);border-radius:4px;padding:4px;font-size:8px;">
          <div style="display:flex;justify-content:space-between;">
            <span><span id="teamSumHome">HOME</span>: <strong id="teamSumHomeScore">0</strong></span>
            <span><span id="teamSumAway">AWAY</span>: <strong id="teamSumAwayScore">0</strong></span>
          </div>
          <div style="display:flex;justify-content:space-between;color:var(--muted);margin-top:2px;">
            <span>SOG: <span id="teamSumHomeSOG">0</span></span>
            <span>SOG: <span id="teamSumAwaySOG">0</span></span>
          </div>
        </div>
      </div>
    </div>

    <!-- Center: Rink -->
    <div class="center">
      <!-- v15.01: VIDEO PLAYER SECTION -->
      <div class="video-section" id="videoSection" style="display:none;">
        <div class="video-header" style="display:flex;justify-content:space-between;align-items:center;padding:4px 8px;background:var(--card);border-bottom:1px solid var(--border);">
          <div style="display:flex;align-items:center;gap:8px;">
            <span style="font-size:10px;font-weight:600;color:var(--accent);">üé¨ VIDEO</span>
            <select id="videoSourceSelect" onchange="switchVideoSource()" style="font-size:9px;width:150px;">
              <option value="">-- Select Video --</option>
            </select>
            <button class="btn-sm" onclick="addVideoSource()" title="Add Video Source">+</button>
          </div>
          <div style="display:flex;align-items:center;gap:4px;">
            <span id="videoTimeDisplay" style="font-size:12px;font-family:monospace;color:var(--accent);background:var(--bg);padding:2px 6px;border-radius:3px;">00:00:00</span>
            <span style="color:var(--muted);font-size:8px;">‚Üí</span>
            <span id="gameTimeFromVideo" style="font-size:10px;font-family:monospace;color:var(--warn);">P1 20:00</span>
            <button class="btn-sm" onclick="toggleVideoSection()" title="Minimize">‚ñº</button>
          </div>
        </div>
        <div id="videoPlayerContainer" style="position:relative;width:100%;height:200px;background:#000;">
          <!-- YouTube or HTML5 video will be inserted here -->
          <div id="videoPlaceholder" style="display:flex;align-items:center;justify-content:center;height:100%;color:var(--muted);font-size:11px;">
            No video loaded. Click + to add a video source.
          </div>
          <div id="youtubePlayer" style="display:none;width:100%;height:100%;"></div>
          <video id="localVideoPlayer" style="display:none;width:100%;height:100%;" controls></video>
        </div>
        <div class="video-controls" style="display:flex;gap:4px;padding:4px 8px;background:var(--card);border-top:1px solid var(--border);align-items:center;flex-wrap:wrap;">
          <!-- Playback controls -->
          <button class="btn-sm" onclick="videoSeek(-10)" title="Back 10s">‚è™10</button>
          <button class="btn-sm" onclick="videoSeek(-1)" title="Back 1s">‚óÄ1</button>
          <button class="btn-sm" onclick="videoFrameStep(-1)" title="Back 1 frame">|‚óÄ</button>
          <button class="btn-sm btn-primary" onclick="videoPlayPause()" id="videoPlayBtn" title="Play/Pause (Space)">‚ñ∂</button>
          <button class="btn-sm" onclick="videoFrameStep(1)" title="Forward 1 frame">‚ñ∂|</button>
          <button class="btn-sm" onclick="videoSeek(1)" title="Forward 1s">1‚ñ∂</button>
          <button class="btn-sm" onclick="videoSeek(10)" title="Forward 10s">10‚è©</button>
          
          <span style="color:var(--border);">|</span>
          
          <!-- Speed controls -->
          <span style="font-size:8px;color:var(--muted);">Speed:</span>
          <button class="btn-sm speed-btn" onclick="setVideoSpeed(0.25)" data-speed="0.25">0.25x</button>
          <button class="btn-sm speed-btn" onclick="setVideoSpeed(0.5)" data-speed="0.5">0.5x</button>
          <button class="btn-sm speed-btn active" onclick="setVideoSpeed(1)" data-speed="1">1x</button>
          <button class="btn-sm speed-btn" onclick="setVideoSpeed(1.5)" data-speed="1.5">1.5x</button>
          <button class="btn-sm speed-btn" onclick="setVideoSpeed(2)" data-speed="2">2x</button>
          
          <span style="color:var(--border);">|</span>
          
          <!-- Time sync controls -->
          <label style="font-size:8px;color:var(--muted);display:flex;align-items:center;gap:2px;">
            <input type="checkbox" id="videoAutoSync" checked onchange="toggleVideoAutoSync()"> Auto-sync times
          </label>
          <button class="btn-sm" onclick="captureStartTime()" title="Set event/shift START to current video time">üìç Start</button>
          <button class="btn-sm" onclick="captureEndTime()" title="Set event/shift END to current video time">üìç End</button>
          
          <span style="color:var(--border);">|</span>
          
          <!-- Hotkeys -->
          <span style="font-size:7px;color:var(--muted);">Hotkeys: <kbd>1-5</kbd>=vid <kbd>Space</kbd>=play <kbd>‚Üê‚Üí</kbd>=¬±1s <kbd>.</kbd>,<kbd>,</kbd>=frame</span>
        </div>
        <!-- Game Markers -->
        <div class="video-markers" style="display:flex;gap:4px;padding:4px 8px;background:var(--panel);border-top:1px solid var(--border);align-items:center;">
          <span style="font-size:8px;color:var(--muted);">Game Markers:</span>
          <button class="btn-sm" onclick="setGameMarker('P1Start')" title="Mark P1 puck drop">P1üèí</button>
          <button class="btn-sm" onclick="setGameMarker('P1End')" title="Mark P1 end">P1üõë</button>
          <button class="btn-sm" onclick="setGameMarker('P2Start')" title="Mark P2 puck drop">P2üèí</button>
          <button class="btn-sm" onclick="setGameMarker('P2End')" title="Mark P2 end">P2üõë</button>
          <button class="btn-sm" onclick="setGameMarker('P3Start')" title="Mark P3 puck drop">P3üèí</button>
          <button class="btn-sm" onclick="setGameMarker('P3End')" title="Mark P3 end">P3üõë</button>
          <button class="btn-sm" onclick="setGameMarker('OTStart')" title="Mark OT puck drop">OTüèí</button>
          <button class="btn-sm" onclick="addStoppageMarker()" title="Add stoppage (timeout, injury, etc)">‚è∏Ô∏è+</button>
          <span style="margin-left:auto;font-size:8px;color:var(--muted);" id="markerStatus">No markers set</span>
        </div>
      </div>
      <!-- Video Toggle Bar (shown when minimized) -->
      <div class="video-toggle-bar" id="videoToggleBar" style="display:flex;justify-content:space-between;align-items:center;padding:2px 8px;background:var(--card);border-bottom:1px solid var(--border);cursor:pointer;" onclick="toggleVideoSection()">
        <span style="font-size:9px;color:var(--accent);">üé¨ VIDEO</span>
        <span id="videoMiniTime" style="font-size:10px;font-family:monospace;color:var(--muted);">--:--:--</span>
        <span style="font-size:8px;color:var(--muted);">‚ñ≤ Expand</span>
      </div>
      
      <div class="rink-wrap">
        <div class="mode-ind puck" id="modeInd">üèí PUCK</div>
        <div class="xy-tooltip" id="xyTooltip" style="display:none;"></div>
        <svg id="rinkSvg" viewBox="0 0 200 85" onclick="handleRinkClick(event)" onmousemove="handleRinkHover(event)" onmouseleave="hideXYTooltip()">
          <defs>
            <linearGradient id="iceGrad" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" style="stop-color:#f0f9ff;stop-opacity:1"/>
              <stop offset="50%" style="stop-color:#e0f2fe;stop-opacity:1"/>
              <stop offset="100%" style="stop-color:#f0f9ff;stop-opacity:1"/>
            </linearGradient>
            <pattern id="iceTexture" patternUnits="userSpaceOnUse" width="4" height="4">
              <rect width="4" height="4" fill="#e0f2fe" opacity="0.3"/>
              <circle cx="1" cy="1" r="0.3" fill="#fff" opacity="0.4"/>
            </pattern>
          </defs>
          
          <!-- Ice surface -->
          <rect x="0" y="0" width="200" height="85" fill="url(#iceGrad)" rx="14" ry="14"/>
          <rect x="0" y="0" width="200" height="85" fill="url(#iceTexture)" rx="14" ry="14"/>
          <!-- Boards -->
          <rect x="0" y="0" width="200" height="85" fill="none" rx="14" ry="14" stroke="#1f2937" stroke-width="2"/>
          
          <!-- Blue lines -->
          <rect x="74" y="0" width="2" height="85" fill="#1e40af"/>
          <rect x="124" y="0" width="2" height="85" fill="#1e40af"/>
          
          <!-- Red center line (dashed) -->
          <line x1="100" y1="0" x2="100" y2="85" stroke="#dc2626" stroke-width="1.5" stroke-dasharray="4,2"/>
          
          <!-- Goal lines -->
          <line x1="11" y1="0" x2="11" y2="85" stroke="#dc2626" stroke-width="1"/>
          <line x1="189" y1="0" x2="189" y2="85" stroke="#dc2626" stroke-width="1"/>
          
          <!-- Center ice logo -->
          <circle cx="100" cy="42.5" r="10" fill="rgba(30,58,138,0.08)" stroke="none"/>
          <image href="https://www.noradhockey.com/wp-content/uploads/2022/05/New-NORAD-Logo-White.png" x="88" y="31" width="24" height="23" preserveAspectRatio="xMidYMid meet"/>
          
          <!-- Center circle -->
          <circle cx="100" cy="42.5" r="15" fill="none" stroke="#1e40af" stroke-width="1"/>
          <circle cx="100" cy="42.5" r="1" fill="#1e40af"/>
          
          <!-- Left zone circles -->
          <circle cx="31" cy="22" r="15" fill="none" stroke="#dc2626" stroke-width="0.8"/>
          <circle cx="31" cy="22" r="1" fill="#dc2626"/>
          <circle cx="31" cy="63" r="15" fill="none" stroke="#dc2626" stroke-width="0.8"/>
          <circle cx="31" cy="63" r="1" fill="#dc2626"/>
          
          <!-- Right zone circles -->
          <circle cx="169" cy="22" r="15" fill="none" stroke="#dc2626" stroke-width="0.8"/>
          <circle cx="169" cy="22" r="1" fill="#dc2626"/>
          <circle cx="169" cy="63" r="15" fill="none" stroke="#dc2626" stroke-width="0.8"/>
          <circle cx="169" cy="63" r="1" fill="#dc2626"/>
          
          <!-- Neutral zone dots -->
          <circle cx="80" cy="22" r="1" fill="#dc2626"/>
          <circle cx="80" cy="63" r="1" fill="#dc2626"/>
          <circle cx="120" cy="22" r="1" fill="#dc2626"/>
          <circle cx="120" cy="63" r="1" fill="#dc2626"/>
          
          <!-- Creases - NHL standard: 8ft wide, 4.5ft deep (scaled: 4 wide, 2.25 deep) -->
          <path d="M 11 38.5 L 15 38.5 A 4 4 0 0 1 15 46.5 L 11 46.5 Z" fill="rgba(59,130,246,0.25)" stroke="#3b82f6" stroke-width="0.8"/>
          <path d="M 189 38.5 L 185 38.5 A 4 4 0 0 0 185 46.5 L 189 46.5 Z" fill="rgba(59,130,246,0.25)" stroke="#3b82f6" stroke-width="0.8"/>
          
          <!-- Left goal -->
          <rect x="7" y="39" width="4" height="7" fill="#111827" stroke="#f8fafc" stroke-width="0.5"/>
          <line x1="7" y1="40" x2="10" y2="42.5" stroke="#374151" stroke-width="0.3"/>
          <line x1="7" y1="45" x2="10" y2="42.5" stroke="#374151" stroke-width="0.3"/>
          
          <!-- Right goal -->
          <rect x="189" y="39" width="4" height="7" fill="#111827" stroke="#f8fafc" stroke-width="0.5"/>
          <line x1="193" y1="40" x2="190" y2="42.5" stroke="#374151" stroke-width="0.3"/>
          <line x1="193" y1="45" x2="190" y2="42.5" stroke="#374151" stroke-width="0.3"/>
          
          <!-- Trapezoids -->
          <path d="M 0 28 L 11 34 L 11 51 L 0 57" fill="none" stroke="#dc2626" stroke-width="0.5"/>
          <path d="M 200 28 L 189 34 L 189 51 L 200 57" fill="none" stroke="#dc2626" stroke-width="0.5"/>
          
          <!-- Zone labels -->
          <text x="43" y="81" font-size="3.5" fill="#64748b" text-anchor="middle" id="leftZoneLbl">AWAY OFF</text>
          <text x="100" y="81" font-size="3.5" fill="#64748b" text-anchor="middle">NEUTRAL</text>
          <text x="157" y="81" font-size="3.5" fill="#64748b" text-anchor="middle" id="rightZoneLbl">HOME OFF</text>
          
          <!-- Markers -->
          <g id="markers"></g>
        </svg>
      </div>
      <div class="xy-controls">
        <button class="xy-btn active" id="puckModeBtn" onclick="setXYMode('puck')">üèí Puck</button>
        <button class="xy-btn" id="playerModeBtn" onclick="setXYMode('player')">üë§ Player</button>
        <select class="xy-player-sel" id="xyPlayerSel" onchange="selectXYPlayer(this.value)" style="display:none;"></select>
        <span style="color:var(--muted);font-size:8px;">Slot:</span>
        <div class="xy-slots" id="xySlots"></div>
        <button class="btn-sm" onclick="undoLastXY()">‚Ü© Undo</button>
        <button class="btn-sm btn-danger" onclick="clearCurrentXY()">Clear</button>
        <button class="btn-sm" onclick="clearRink()">Clear Rink</button>
        <span style="margin-left:8px;font-size:8px;color:var(--muted);">History:</span>
        <input type="number" id="xyHistCnt" value="5" min="0" max="20" style="width:35px;" onchange="renderMarkers()">
      </div>
      <!-- Event List -->
      <div class="evt-list" id="eventLogSection">
        <div class="evt-header" style="display:flex;justify-content:space-between;align-items:center;">
          <!-- v20.4: Header columns now match expanded body columns -->
          <span style="display:flex;align-items:center;gap:4px;">
            <button class="btn-sm" onclick="toggleEventLog()" title="Toggle Event Log">üìù</button>
            <span id="evtLogHeader" style="display:grid;grid-template-columns:22px 22px 20px 48px 14px 46px 58px 58px 14px 12px 30px 30px 46px 46px 12px 12px 12px;gap:1px;flex:1;font-size:6px;">
              <span>#</span><span>Sh</span><span>Lnk</span><span>Time</span><span>T</span><span>Type</span><span>Detail1</span><span>Detail2</span><span>Z</span><span>S</span><span>EvtP</span><span>OppP</span><span>PD1</span><span>PD2</span><span>PS</span><span>XY</span><span>‚≠ê</span>
            </span>
          </span>
          <span>
            <button class="btn-sm" onclick="addNewEvent()" title="Add New Event" style="background:var(--success);">‚ûï</button>
            <button class="clear-all-btn" onclick="clearAllEvents()" title="Clear All Events">üóëÔ∏è All</button>
            <button class="btn-sm" onclick="showAllEvents()" style="margin-left:4px;">All</button>
          </span>
        </div>
        <!-- v6: Period filter tabs for events -->
        <div class="period-filter-tabs">
          <button class="period-filter-tab active" data-filter="all" onclick="filterEventLog('all')">ALL</button>
          <button class="period-filter-tab" data-filter="1" onclick="filterEventLog('1')">P1</button>
          <button class="period-filter-tab" data-filter="2" onclick="filterEventLog('2')">P2</button>
          <button class="period-filter-tab" data-filter="3" onclick="filterEventLog('3')">P3</button>
          <button class="period-filter-tab" data-filter="OT" onclick="filterEventLog('OT')">OT</button>
        </div>
        <!-- v20.4: Advanced filter row -->
        <div class="evt-filter-row" id="evtFilterRow">
          <div class="filter-group">
            <label>Type:</label>
            <select id="filterEvtType" onchange="applyEventFilters()">
              <option value="">All</option>
            </select>
          </div>
          <div class="filter-group">
            <label>Detail1:</label>
            <select id="filterEvtDetail1" onchange="applyEventFilters()">
              <option value="">All</option>
            </select>
          </div>
          <div class="filter-group">
            <label>Detail2:</label>
            <select id="filterEvtDetail2" onchange="applyEventFilters()">
              <option value="">All</option>
            </select>
          </div>
          <div class="filter-group">
            <label>PD1:</label>
            <select id="filterPlayDetail1" onchange="applyEventFilters()">
              <option value="">All</option>
            </select>
          </div>
          <div class="filter-group">
            <label>PD2:</label>
            <select id="filterPlayDetail2" onchange="applyEventFilters()">
              <option value="">All</option>
            </select>
          </div>
          <div class="filter-group">
            <label>Team:</label>
            <select id="filterEvtTeam" onchange="applyEventFilters()">
              <option value="">All</option>
              <option value="home">Home</option>
              <option value="away">Away</option>
            </select>
          </div>
          <div class="filter-group">
            <label>Evt#:</label>
            <input type="number" id="filterEvtIdx" min="1" placeholder="#" onchange="applyEventFilters()">
          </div>
          <div class="filter-group">
            <label>Link#:</label>
            <input type="number" id="filterLinkIdx" min="1" placeholder="#" onchange="applyEventFilters()">
          </div>
          <div class="filter-group">
            <label>Shift#:</label>
            <input type="number" id="filterShiftIdx" min="1" placeholder="#" onchange="applyEventFilters()">
          </div>
          <button class="btn-clear" onclick="clearEventFilters()">Clear</button>
        </div>
        <div id="evtListBody" style="max-height:300px;overflow-y:auto;"></div>
      </div>
      <!-- Next Play Suggestions -->
      <div class="next-play-bar" style="background:var(--card);padding:4px 8px;border-top:1px solid var(--border);">
        <span style="font-size:8px;color:var(--muted);">NEXT:</span>
        <span id="nextPlaySuggestions" style="font-size:9px;"></span>
      </div>
      <!-- v16.02: Box Score moved here - more visible below events -->
      <div class="center-box-score" style="background:var(--card);padding:6px;border-top:1px solid var(--border);">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
          <span style="font-size:9px;color:var(--accent);font-weight:bold;">üìä BOX SCORE</span>
          <button class="btn-sm" onclick="showFullBoxScore()">Full</button>
        </div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;font-size:10px;">
          <div style="text-align:center;">
            <span id="centerBoxHome" style="font-weight:bold;color:var(--home);">HOME</span>
            <span style="font-size:20px;font-weight:bold;display:block;" id="centerBoxHomeScore">0</span>
            <span style="font-size:8px;color:var(--muted);">SOG: <span id="centerBoxHomeSOG">0</span></span>
          </div>
          <div style="text-align:center;">
            <span id="centerBoxAway" style="font-weight:bold;color:var(--away);">AWAY</span>
            <span style="font-size:20px;font-weight:bold;display:block;" id="centerBoxAwayScore">0</span>
            <span style="font-size:8px;color:var(--muted);">SOG: <span id="centerBoxAwaySOG">0</span></span>
          </div>
        </div>
      </div>
    </div>

    <!-- Right: Event Entry -->
    <div class="panel" id="rightPanel">
      <div class="resize-handle right" style="left:0;right:auto;" onmousedown="startResize(event, 'right')"></div>
      <div class="panel-header"><span>Event Entry</span><span id="zoneDisplay"></span></div>
      <div class="panel-body">
        <!-- Team Toggle -->
        <div class="team-toggle">
          <button class="home active" id="evtHomeLbl" onclick="setEvtTeam('home')">Home</button>
          <button class="away" id="evtAwayLbl" onclick="setEvtTeam('away')">Away</button>
        </div>
        <!-- Event Types -->
        <div class="evt-grid" id="evtTypeGrid"></div>
        <!-- Event Details -->
        <div class="form-row">
          <div class="form-group"><label>Detail 1</label><select id="evtD1" onchange="onD1Change()"></select></div>
          <div class="form-group"><label>Detail 2</label><select id="evtD2"></select></div>
        </div>
        <div class="form-row tri">
          <div class="form-group">
            <label>Zone <button class="btn-sm" onclick="autoZone()" title="Auto-detect from XY">‚ö°</button></label>
            <select id="evtZone"><option value="">--</option><option value="o">Offensive</option><option value="d">Defensive</option><option value="n">Neutral</option></select>
          </div>
          <div class="form-group">
            <label>Success <button class="btn-sm" onclick="autoSuccess()" title="Auto-detect from detail">‚ö°</button></label>
            <select id="evtSuccess"><option value="">--</option><option value="s">Success</option><option value="u">Unsuccess</option></select>
          </div>
          <div class="form-group">
            <label>Strength <button class="btn-sm" onclick="autoStrength()" title="Auto-detect from slots">‚ö°</button></label>
            <select id="evtStrength"><option value="5v5">5v5</option><option value="5v4">5v4 PP</option><option value="4v5">4v5 PK</option><option value="4v4">4v4</option><option value="3v3">3v3</option><option value="ENG">ENG</option><option value="ENA">ENA</option></select>
          </div>
        </div>
        <div class="form-row">
          <div class="form-group"><label>Start Time</label><input type="text" id="evtStartTime" placeholder="MM:SS"></div>
          <div class="form-group"><label>End Time</label><input type="text" id="evtEndTime" placeholder="MM:SS (auto)"></div>
        </div>
        <!-- Event Players -->
        <div class="section">
          <div class="section-title"><span>Event Players (on puck)</span></div>
          <div class="player-list" id="evtPlayers"></div>
          <div class="quick-add" id="evtQuickAdd"></div>
        </div>
        <div class="section">
          <div class="section-title"><span>Opposing Players</span></div>
          <div class="player-list" id="oppPlayers"></div>
          <div class="quick-add" id="oppQuickAdd"></div>
        </div>
        <!-- Player Details -->
        <div class="player-details" id="playerDetails" style="display:none;">
          <h5 id="pdPlayerNum">#0 Player</h5>
          <div class="form-row">
            <!-- v16.02: Searchable play detail dropdowns using input with datalist -->
            <div class="form-group">
              <label>Play Detail 1</label>
              <input list="pdPlayD1List" id="pdPlayD1" style="width:100%;" onchange="updatePlayerDetail('playD1', this.value); updatePlayD2()" placeholder="Type to search...">
              <datalist id="pdPlayD1List"></datalist>
            </div>
            <div class="form-group">
              <label>Play Detail 2</label>
              <input list="pdPlayD2List" id="pdPlayD2" style="width:100%;" onchange="updatePlayerDetail('playD2', this.value)" placeholder="Type to search...">
              <datalist id="pdPlayD2List"></datalist>
            </div>
          </div>
          <div class="form-row">
            <div class="form-group"><label>Success <button class="btn-sm" onclick="derivePlayerSuccess()" title="Auto from event">‚ö°</button></label><select id="pdPlaySuccess" onchange="updatePlayerDetail('playSuccess', this.value)"><option value="">--</option><option value="s">S</option><option value="u">U</option></select></div>
            <div class="form-group"><label>Pressured By <button class="btn-sm" onclick="autoCalcPressure()" title="Auto from XY">‚ö°</button></label><select id="pdPressure" onchange="updatePlayerDetail('pressure', this.value)"><option value="">--</option></select></div>
          </div>
          <!-- v16: Side of Puck -->
          <div class="form-row">
            <div class="form-group">
              <label>Side of Puck <button class="btn-sm" onclick="autoSideOfPuck()" title="Auto-detect from zone">‚ö°</button></label>
              <select id="pdSideOfPuck" onchange="updatePlayerDetail('sideOfPuck', this.value)">
                <option value="">--</option>
                <option value="Offensive">Offensive</option>
                <option value="Defensive">Defensive</option>
              </select>
            </div>
            <div class="form-group"><label>&nbsp;</label><span style="font-size:8px;color:var(--muted);line-height:26px;">Relative to player's team</span></div>
          </div>
        </div>
        <!-- Linked Event & Highlight -->
        <div class="linked-event-bar" style="background:var(--card);padding:4px 8px;border-radius:4px;margin-top:6px;font-size:9px;display:flex;align-items:center;gap:8px;">
          <span style="color:var(--muted);">Link:</span>
          <select id="linkedEvtSelect" style="flex:1;" onchange="onLinkedEvtChange()">
            <option value="">-- None --</option>
          </select>
          <span id="linkedEvtInfo" style="color:var(--accent);font-size:8px;"></span>
          <label style="display:flex;align-items:center;gap:4px;cursor:pointer;margin-left:auto;">
            <input type="checkbox" id="isHighlight"> ‚≠ê Highlight
          </label>
        </div>
        <!-- Quick Time Buttons (v5) + Time Nudge (v6) -->
        <div style="display:flex;gap:4px;margin-top:4px;align-items:center;flex-wrap:wrap;">
          <button class="btn-sm" onclick="copyClockToStart()" title="Copy clock to start time">‚è±Ô∏è‚ÜíStart</button>
          <button class="btn-sm" onclick="copyClockToEnd()" title="Copy clock to end time">‚è±Ô∏è‚ÜíEnd</button>
          <button class="btn-sm" onclick="copyLastEventTime()" title="Copy last event's end time">üìã Last</button>
          <!-- v6: Time nudge buttons with variable increment -->
          <span style="color:var(--muted);font-size:8px;margin-left:4px;">¬±</span>
          <input type="number" id="timeNudgeAmount" value="5" min="1" max="60" style="width:30px;font-size:9px;padding:2px;" title="Nudge seconds">
          <button class="btn-sm" onclick="nudgeStartTime(-1)" title="Subtract from start time">-S</button>
          <button class="btn-sm" onclick="nudgeStartTime(1)" title="Add to start time">+S</button>
          <button class="btn-sm" onclick="nudgeEndTime(-1)" title="Subtract from end time">-E</button>
          <button class="btn-sm" onclick="nudgeEndTime(1)" title="Add to end time">+E</button>
          <label style="display:flex;align-items:center;gap:4px;font-size:8px;margin-left:auto;cursor:pointer;">
            <input type="checkbox" id="autoEditNext"> Auto-edit next
          </label>
        </div>
        <!-- Actions -->
        <div class="log-actions">
          <button class="btn-success" onclick="logEvent()">Log Event <kbd>Enter</kbd></button>
          <button onclick="clearEvent()">Clear <kbd>Esc</kbd></button>
          <button class="btn-sm" onclick="duplicateLastEvent()" title="Duplicate last event">üìã Dup</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Settings Modal -->
<div class="overlay" id="settingsModal">
  <div class="modal">
    <h3>‚öôÔ∏è Settings</h3>
    <div class="form-group" style="margin-bottom:8px;">
      <label>Supabase URL</label>
      <input type="text" id="sbUrl" placeholder="https://xxx.supabase.co" style="width:100%;">
    </div>
    <div class="form-group" style="margin-bottom:8px;">
      <label>Supabase Anon Key</label>
      <input type="password" id="sbKey" placeholder="eyJ..." style="width:100%;">
    </div>
    <div class="form-row">
      <div class="form-group"><label>Auto-save (sec)</label><input type="number" id="autoSaveInt" value="30"></div>
      <div class="form-group"><label>Pressure Distance (ft)</label><input type="number" id="pressureDist" value="10"></div>
    </div>
    <div class="form-row">
      <div class="form-group"><label>Period Length (min)</label><input type="number" id="periodLength" value="18" min="5" max="20"></div>
      <div class="form-group"><label>OT Length (min)</label><input type="number" id="otLength" value="5" min="3" max="20"></div>
    </div>
    <div class="form-group" style="margin-bottom:8px;">
      <label>Backup Storage Path</label>
      <div style="display:flex;gap:4px;">
        <select id="backupPathPreset" onchange="setBackupPath(this.value)" style="flex:1;">
          <option value="">Custom path...</option>
          <option value="C:\BenchSight\backups\">C:\BenchSight\backups\</option>
          <option value="C:\Users\Public\BenchSight\">C:\Users\Public\BenchSight\</option>
          <option value="D:\BenchSight\">D:\BenchSight\</option>
          <option value="~/BenchSight/backups/">~/BenchSight/backups/ (Mac/Linux)</option>
          <option value="./exports/">./exports/ (relative)</option>
        </select>
      </div>
      <input type="text" id="backupPath" placeholder="Or type custom path..." style="width:100%;margin-top:4px;">
      <p style="font-size:8px;color:var(--muted);margin-top:2px;">Path where exported files will be saved</p>
    </div>
    <div style="margin-top:12px;padding-top:8px;border-top:1px solid var(--border);">
      <button class="btn-danger" onclick="clearAllData()" style="width:100%;">üóëÔ∏è Clear All Game Data</button>
      <p style="font-size:8px;color:var(--muted);margin-top:4px;">Removes all events, shifts, and saved data for current game</p>
    </div>
    <div class="modal-actions">
      <button onclick="testConn()">Test Connection</button>
      <button class="btn-primary" onclick="saveSettings()">Save</button>
      <button onclick="closeSettings()">Cancel</button>
    </div>
  </div>
</div>

<!-- Help/Instructions Modal -->
<div class="overlay" id="helpModal">
  <div class="modal" style="min-width:600px;max-height:80vh;overflow-y:auto;">
    <h3>‚ùì Instructions & Hotkeys (v15)</h3>
    
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;">
      <!-- Keyboard Shortcuts -->
      <div>
        <h4 style="color:var(--accent);margin-bottom:8px;font-size:12px;">‚å®Ô∏è Keyboard Shortcuts</h4>
        <table style="font-size:10px;width:100%;">
          <tr><td style="padding:2px 8px;"><kbd>Enter</kbd></td><td>Save current event</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Escape</kbd></td><td>Cancel / Close modals</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>L</kbd></td><td>Log shift</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>E</kbd></td><td>End shift (set end time)</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Q</kbd></td><td>Quick line change (v6)</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Tab</kbd></td><td>Toggle Puck/Player mode</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>`</kbd></td><td>Switch to Puck XY mode (v16.06)</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>H</kbd></td><td>Set team to Home</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>A</kbd></td><td>Set team to Away</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>1-6</kbd></td><td>Select Event Player 1-6 (v6)</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Alt+1-6</kbd></td><td>Select Opp Player 1-6 (v17)</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>W</kbd></td><td>Cycle Forward presets (v6)</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Shift+W</kbd></td><td>Cycle Defense presets (v6)</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>*</kbd></td><td>Toggle highlight ‚≠ê</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Ctrl+Z</kbd></td><td>Undo last XY point</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>‚Üê/‚Üí</kbd></td><td>Navigate events in edit modal</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>?</kbd></td><td>Open this help</td></tr>
        </table>
        <h5 style="color:var(--accent);margin:8px 0 4px;font-size:10px;">Event Type Hotkeys:</h5>
        <div style="font-size:9px;color:var(--muted);">F=Faceoff, S=Shot, P=Pass, G=Goal, T=Turnover, Z=Zone, N=Penalty, X=Stoppage, O=Possession, V=Save, R=Rebound, D=DeadIce, Y=Play</div>
      </div>
      
      <!-- Quick Guide -->
      <div>
        <h4 style="color:var(--accent);margin-bottom:8px;font-size:12px;">üìã Quick Guide</h4>
        <div style="font-size:10px;line-height:1.6;">
          <p><strong>1. Connect:</strong> Click ‚öôÔ∏è Settings, enter Supabase credentials</p>
          <p><strong>2. Select Game:</strong> Choose from dropdown (only tracked games)</p>
          <p><strong>3. Track Events:</strong></p>
          <ul style="margin:4px 0 4px 16px;">
            <li>Click rink to place puck/players</li>
            <li>Select event type (or press hotkey)</li>
            <li>Add players from shift panel</li>
            <li>Press Enter or click Log Event</li>
          </ul>
          <p><strong>4. Track Shifts:</strong> Press L to log, E to set end time, Q for quick line change</p>
          <p><strong>5. Export:</strong> Click Export to download Excel file</p>
          <p><strong>6. Import:</strong> Click Import to load a half-tracked Excel file</p>
        </div>
        <h4 style="color:var(--accent);margin:12px 0 8px;font-size:12px;">üÜï v17+ Features</h4>
        <div style="font-size:9px;line-height:1.5;color:var(--muted);">
          <p>‚Ä¢ <strong>Excel Import</strong> - Load half-tracked games to continue tracking</p>
          <p>‚Ä¢ <strong>Line Presets</strong> - Save/load F-lines & D-pairs with W/Shift+W</p>
          <p>‚Ä¢ <strong>Period Filtering</strong> - P1/P2/P3/OT tabs in event & shift logs</p>
          <p>‚Ä¢ <strong>Player Selection</strong> - 1-6 for event players, Alt+1-6 for opponents</p>
          <p>‚Ä¢ <strong>Quick Line Change</strong> - Press Q to end shift and start new</p>
          <p>‚Ä¢ <strong>Compact Mode</strong> - Toggle ‚äü button for smaller UI</p>
          <p>‚Ä¢ <strong>Better Shift Types</strong> - Null defaults to "OnTheFly"</p>
          <p>‚Ä¢ <strong>More Visible Logs</strong> - 50 items in scroll view</p>
        </div>
      </div>
    </div>
    
    <hr style="margin:12px 0;border-color:var(--border);">
    
    <!-- Video Timing -->
    <div>
      <h4 style="color:var(--accent);margin-bottom:8px;font-size:12px;">üé¨ Video & Time Sync</h4>
      <div style="font-size:10px;line-height:1.6;">
        <p><strong>Video Time Calculation:</strong></p>
        <ul style="margin:4px 0 4px 16px;">
          <li><strong>event_running_start</strong> = (period-1) √ó period_seconds + (period_seconds - time_remaining)</li>
          <li><strong>running_video_time</strong> = event_running_start + intermission_offset</li>
          <li>Period seconds = periodLength √ó 60 (default 18 min = 1080 sec for NORAD)</li>
        </ul>
        <p><strong>Stoppages:</strong> Stoppage events are tracked with duration. You do NOT need to cut 
           stoppages from video - the tracker calculates running time including them.</p>
        <p><strong>Shift Stoppage Time:</strong> Each shift automatically calculates total stoppage duration 
           from Stoppage/Clockstop events that occur within the shift time window.</p>
      </div>
    </div>
    
    <hr style="margin:12px 0;border-color:var(--border);">
    
    <!-- Highlights -->
    <div>
      <h4 style="color:var(--accent);margin-bottom:8px;font-size:12px;">‚≠ê Highlights & Video Clips</h4>
      <div style="font-size:10px;line-height:1.6;">
        <p><strong>Marking Highlights:</strong></p>
        <ul style="margin:4px 0 4px 16px;">
          <li>Press <kbd>H</kbd> while recording to mark as highlight</li>
          <li>Goals are automatically marked as highlights</li>
          <li>Double-click event ‚Üí Edit Highlight field</li>
        </ul>
        <p><strong>ETL Export:</strong></p>
        <ul style="margin:4px 0 4px 16px;">
          <li><code>is_highlight</code> column = 1 for highlights, 0 otherwise</li>
          <li>Use <code>running_video_time</code> to find clip start in video</li>
          <li>Clip duration = event duration or default (10 sec for goals)</li>
        </ul>
        <p><strong>Creating Highlight Reels:</strong></p>
        <ul style="margin:4px 0 4px 16px;">
          <li>Query: <code>SELECT * FROM fact_events WHERE is_highlight = 1 ORDER BY running_video_time</code></li>
          <li>Use video editor to extract clips at running_video_time timestamps</li>
        </ul>
      </div>
    </div>
    
    <hr style="margin:12px 0;border-color:var(--border);">
    
    <!-- Event Log -->
    <div>
      <h4 style="color:var(--accent);margin-bottom:8px;font-size:12px;">üìù Event Log Columns</h4>
      <div style="font-size:10px;display:grid;grid-template-columns:repeat(3,1fr);gap:4px;">
        <span><strong>Idx:</strong> Event index (1-based)</span>
        <span><strong>Link:</strong> Linked event index</span>
        <span><strong>Seq/Play:</strong> Sequence/Play index</span>
        <span><strong>Time:</strong> Period + game time</span>
        <span><strong>Type:</strong> Event type</span>
        <span><strong>Detail:</strong> Event detail 1</span>
        <span><strong>Zone:</strong> Off/Neu/Def</span>
        <span><strong>‚úì/‚úó:</strong> Success flag</span>
        <span><strong>Players:</strong> Player numbers</span>
        <span><strong>‚óè:</strong> Has XY data</span>
        <span><strong>‚≠ê:</strong> Highlight</span>
      </div>
      <p style="font-size:9px;color:var(--muted);margin-top:4px;">Double-click any event to quick edit (Type, Detail, Zone, Success, Linked, Highlight, Time)</p>
    </div>
    
    <div class="modal-actions">
      <button class="btn-primary" onclick="closeHelp()">Close</button>
    </div>
  </div>
</div>

<!-- Player Picker Modal -->
<div class="overlay" id="playerPickerModal">
  <div class="modal" style="min-width:400px;">
    <h3>üë§ Select Player</h3>
    <div class="form-row">
      <div class="form-group">
        <label>Team</label>
        <select id="pickerTeam" onchange="renderPlayerPicker()">
          <option value="home">Home</option>
          <option value="away">Away</option>
        </select>
      </div>
      <div class="form-group">
        <label>Role</label>
        <select id="pickerRole">
          <option value="event_team_player">Event Team</option>
          <option value="opp_team_player">Opposing Team</option>
        </select>
      </div>
    </div>
    <div id="playerPickerList" style="max-height:250px;overflow-y:auto;margin:8px 0;"></div>
    <div class="modal-actions">
      <button onclick="closePlayerPicker()">Cancel</button>
    </div>
  </div>
</div>

<!-- Verification Panel Modal -->
<div class="overlay" id="verifyModal">
  <div class="modal" style="min-width:600px;max-height:90vh;overflow-y:auto;">
    <h3>‚úÖ Verification Panel</h3>
    
    <!-- Tracked Goals (Blue) -->
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:12px;">
      <div style="background:rgba(59,130,246,0.2);border:2px solid var(--home);padding:12px;border-radius:4px;text-align:center;">
        <div style="font-size:24px;font-weight:bold;color:var(--home);" id="verifyHomeGoals">0</div>
        <div style="font-size:10px;color:var(--muted);">Tracked Home Goals</div>
        <div style="font-size:9px;color:var(--accent);margin-top:4px;" id="verifyHomeByPeriod">P1: 0 | P2: 0 | P3: 0</div>
      </div>
      <div style="background:rgba(239,68,68,0.2);border:2px solid var(--away);padding:12px;border-radius:4px;text-align:center;">
        <div style="font-size:24px;font-weight:bold;color:var(--away);" id="verifyAwayGoals">0</div>
        <div style="font-size:10px;color:var(--muted);">Tracked Away Goals</div>
        <div style="font-size:9px;color:var(--accent);margin-top:4px;" id="verifyAwayByPeriod">P1: 0 | P2: 0 | P3: 0</div>
      </div>
    </div>
    
    <!-- Official Score (Purple - Auto from dim_schedule) -->
    <div style="background:rgba(168,85,247,0.15);border:2px solid #a855f7;padding:12px;border-radius:4px;margin-bottom:12px;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <span style="font-size:11px;color:#a855f7;font-weight:bold;">üìä OFFICIAL SCORE (from dim_schedule)</span>
        <a id="noradGameLink" href="#" target="_blank" style="font-size:9px;color:var(--accent);">View on noradhockey.com ‚Üó</a>
      </div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;">
        <div style="text-align:center;">
          <div style="font-size:24px;font-weight:bold;color:#a855f7;" id="officialHomeGoalsDisplay">-</div>
          <div style="font-size:9px;color:var(--muted);" id="officialHomeByPeriod">P1: - | P2: - | P3: -</div>
        </div>
        <div style="text-align:center;">
          <div style="font-size:24px;font-weight:bold;color:#a855f7;" id="officialAwayGoalsDisplay">-</div>
          <div style="font-size:9px;color:var(--muted);" id="officialAwayByPeriod">P1: - | P2: - | P3: -</div>
        </div>
      </div>
      <input type="hidden" id="officialHomeGoals" value="0">
      <input type="hidden" id="officialAwayGoals" value="0">
    </div>
    
    <!-- Verification Result -->
    <div id="verifyResult" style="padding:12px;border-radius:4px;text-align:center;font-weight:bold;font-size:14px;margin-bottom:12px;"></div>
    
    <!-- Warnings -->
    <div id="verifyWarnings" style="display:none;background:rgba(245,158,11,0.2);border:1px solid var(--warn);padding:8px;border-radius:4px;margin-bottom:12px;font-size:10px;">
      <div style="font-weight:bold;color:var(--warn);margin-bottom:4px;">‚ö†Ô∏è WARNINGS</div>
      <div id="verifyWarningsList"></div>
    </div>
    
    <!-- Goal Breakdown -->
    <div style="margin-bottom:12px;">
      <div style="font-size:9px;color:var(--muted);margin-bottom:4px;">GOAL BREAKDOWN (Scorer #, Assist # from play_details)</div>
      <table style="width:100%;font-size:10px;border-collapse:collapse;">
        <thead><tr style="background:var(--card);">
          <th style="text-align:left;padding:4px;">P</th>
          <th style="text-align:left;padding:4px;">Time</th>
          <th style="text-align:left;padding:4px;">Team</th>
          <th style="text-align:left;padding:4px;">Scorer</th>
          <th style="text-align:left;padding:4px;">Assists</th>
          <th style="text-align:left;padding:4px;">‚úì</th>
        </tr></thead>
        <tbody id="verifyGoalsList"></tbody>
      </table>
    </div>
    
    <div class="modal-actions">
      <button onclick="runVerification()">üîÑ Verify</button>
      <button onclick="closeVerifyModal()">Close</button>
    </div>
  </div>
</div>

<!-- Video Timing Modal -->
<div class="overlay" id="videoTimingModal">
  <div class="modal" style="min-width:500px;max-height:80vh;overflow-y:auto;">
    <h3>üé¨ Video Timing Setup</h3>
    <p style="font-size:10px;color:var(--muted);margin-bottom:12px;">Configure video offsets for accurate timestamp calculations</p>
    
    <!-- Basic Settings -->
    <div style="background:var(--card);padding:12px;border-radius:4px;margin-bottom:12px;">
      <h4 style="font-size:11px;color:var(--accent);margin-bottom:8px;">Basic Settings</h4>
      <div class="form-row">
        <div class="form-group">
          <label>Video Start Offset (sec)</label>
          <input type="number" id="vtVideoStartOffset" value="0" min="0" placeholder="Skip warmups etc" oninput="updateVideoTimingPreview()">
        </div>
        <div class="form-group">
          <label>Period Length (min)</label>
          <input type="number" id="vtPeriodLength" value="20" min="10" max="30" oninput="updateVideoTimingPreview()">
        </div>
      </div>
      <div class="form-group">
        <label>YouTube URL (optional)</label>
        <input type="text" id="vtYoutubeUrl" placeholder="https://youtube.com/watch?v=...">
      </div>
    </div>
    
    <!-- Intermissions -->
    <div style="background:var(--card);padding:12px;border-radius:4px;margin-bottom:12px;">
      <h4 style="font-size:11px;color:var(--accent);margin-bottom:8px;">Intermission Durations</h4>
      <p style="font-size:9px;color:var(--muted);margin-bottom:8px;">Enter actual video time of intermissions (not game clock)</p>
      <div class="form-row">
        <div class="form-group">
          <label>After Period 1 (sec)</label>
          <input type="number" id="vtIntermission1" value="900" min="0" placeholder="900 = 15 min" oninput="updateVideoTimingPreview()">
        </div>
        <div class="form-group">
          <label>After Period 2 (sec)</label>
          <input type="number" id="vtIntermission2" value="900" min="0" placeholder="900 = 15 min" oninput="updateVideoTimingPreview()">
        </div>
        <div class="form-group">
          <label>After Period 3 / OT (sec)</label>
          <input type="number" id="vtIntermission3" value="300" min="0" placeholder="300 = 5 min" oninput="updateVideoTimingPreview()">
        </div>
      </div>
    </div>
    
    <!-- Timeouts/Stoppages -->
    <div style="background:var(--card);padding:12px;border-radius:4px;margin-bottom:12px;">
      <h4 style="font-size:11px;color:var(--accent);margin-bottom:8px;">Timeouts & Extended Stoppages</h4>
      <p style="font-size:9px;color:var(--muted);margin-bottom:8px;">Add stoppages that add extra video time (injuries, TV timeouts, etc)</p>
      <div id="vtTimeoutsList" style="margin-bottom:8px;max-height:150px;overflow-y:auto;"></div>
      <div class="form-row" style="align-items:flex-end;">
        <div class="form-group" style="flex:0.5;">
          <label>Period</label>
          <select id="vtNewTimeoutPeriod"><option>1</option><option>2</option><option>3</option><option>OT</option></select>
        </div>
        <div class="form-group" style="flex:1;">
          <label>Game Time</label>
          <input type="text" id="vtNewTimeoutTime" placeholder="15:30">
        </div>
        <div class="form-group" style="flex:1;">
          <label>Duration (sec)</label>
          <input type="number" id="vtNewTimeoutDuration" value="60" min="1">
        </div>
        <button class="btn-sm btn-success" onclick="addVideoTimeout()" style="margin-bottom:4px;">+ Add</button>
      </div>
    </div>
    
    <!-- Running Time Preview -->
    <div style="background:var(--panel);padding:12px;border-radius:4px;margin-bottom:12px;border:1px solid var(--accent);">
      <h4 style="font-size:11px;color:var(--accent);margin-bottom:8px;">‚è±Ô∏è Running Time Preview</h4>
      <div style="font-size:10px;display:grid;grid-template-columns:1fr 1fr;gap:4px;">
        <span>Period 1 Start:</span><span id="vtPreviewP1Start">0:00</span>
        <span>Period 1 End:</span><span id="vtPreviewP1End">20:00</span>
        <span>Period 2 Start:</span><span id="vtPreviewP2Start">35:00</span>
        <span>Period 2 End:</span><span id="vtPreviewP2End">55:00</span>
        <span>Period 3 Start:</span><span id="vtPreviewP3Start">70:00</span>
        <span>Period 3 End:</span><span id="vtPreviewP3End">90:00</span>
        <span>OT Start:</span><span id="vtPreviewOTStart">95:00</span>
        <span>OT End:</span><span id="vtPreviewOTEnd">100:00</span>
      </div>
    </div>
    
    <div class="modal-actions">
      <button class="btn-primary" onclick="saveVideoTiming()">üíæ Save</button>
      <button onclick="closeVideoTimingModal()">Cancel</button>
    </div>
  </div>
</div>

<!-- Load Existing Game Modal -->
<div class="overlay" id="loadGameModal">
  <div class="modal" style="min-width:500px;">
    <h3>üìÇ Load Existing Game</h3>
    <p style="font-size:10px;color:var(--muted);margin-bottom:12px;">Load tracked events from Supabase for editing</p>
    <div class="form-group" style="margin-bottom:8px;">
      <label>Select Game</label>
      <select id="loadGameSelect" style="width:100%;" onchange="previewLoadGame()"></select>
    </div>
    <div id="loadGamePreview" style="background:var(--card);padding:8px;border-radius:4px;font-size:10px;margin-bottom:8px;">
      <div>Events: <span id="loadPreviewEvents">--</span></div>
      <div>Shifts: <span id="loadPreviewShifts">--</span></div>
    </div>
    <div class="modal-actions">
      <button class="btn-primary" onclick="confirmLoadGame()">Load Game</button>
      <button onclick="closeLoadGameModal()">Cancel</button>
    </div>
  </div>
</div>
<div class="overlay" id="editModal">
  <div class="modal" style="min-width:650px;max-height:90vh;overflow-y:auto;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
      <button class="btn-sm" onclick="navEditEvent(-1)" title="Previous Event (‚Üê)">‚óÄ Prev</button>
      <h3 style="margin:0;">‚úèÔ∏è Event #<span id="editEvtIdx"></span> <span id="editHighlightBadge" style="color:gold;"></span></h3>
      <button class="btn-sm" onclick="navEditEvent(1)" title="Next Event (‚Üí)">Next ‚ñ∂</button>
    </div>
    <div class="form-row">
      <div class="form-group"><label>Event Type</label><select id="editType" onchange="onEditTypeChange()"></select></div>
      <div class="form-group"><label>Team</label><select id="editTeam"><option value="home">Home</option><option value="away">Away</option></select></div>
    </div>
    <div class="form-row">
      <div class="form-group"><label>Detail 1</label><select id="editD1" onchange="onEditD1Change()"></select></div>
      <div class="form-group"><label>Detail 2</label><select id="editD2"></select></div>
    </div>
    <div class="form-row tri">
      <div class="form-group"><label>Zone</label><select id="editZone"><option value="">--</option><option value="o">O</option><option value="d">D</option><option value="n">N</option></select></div>
      <div class="form-group"><label>Success</label><select id="editSuccess"><option value="">--</option><option value="s">S</option><option value="u">U</option></select></div>
      <div class="form-group"><label>Strength</label><select id="editStrength"><option value="5v5">5v5</option><option value="5v4">5v4</option><option value="4v5">4v5</option><option value="4v4">4v4</option><option value="3v3">3v3</option><option value="ENG">ENG</option></select></div>
    </div>
    <div class="form-row">
      <div class="form-group"><label>Start Time</label><input type="text" id="editStartTime"></div>
      <div class="form-group"><label>End Time</label><input type="text" id="editEndTime"></div>
    </div>
    <div class="form-row">
      <div class="form-group">
        <label style="display:flex;align-items:center;gap:4px;">
          <input type="checkbox" id="editHighlight"> ‚≠ê Highlight (for video)
        </label>
      </div>
      <div class="form-group">
        <label>Linked Event #</label>
        <input type="number" id="editLinkedIdx" style="width:60px;" placeholder="--" title="Enter event # to link to">
      </div>
    </div>
    <div class="form-row" style="background:var(--panel);padding:4px 8px;border-radius:4px;margin-bottom:8px;">
      <!-- v15: Added event_id and event_index info -->
      <div class="form-group" style="margin-bottom:0;">
        <label style="font-size:8px;color:var(--muted);">Event ID</label>
        <span id="editEventId" style="font-size:9px;color:var(--accent);font-family:monospace;">--</span>
      </div>
      <div class="form-group" style="margin-bottom:0;">
        <label style="font-size:8px;color:var(--muted);">Event Index</label>
        <span id="editEventIndex" style="font-size:10px;color:var(--accent);">--</span>
      </div>
      <div class="form-group" style="margin-bottom:0;">
        <label style="font-size:8px;color:var(--muted);">Sequence Key</label>
        <span id="editSeqKey" style="font-size:10px;color:var(--accent);">--</span>
      </div>
      <div class="form-group" style="margin-bottom:0;">
        <label style="font-size:8px;color:var(--muted);">Play Key</label>
        <span id="editPlayKey" style="font-size:10px;color:var(--accent);">--</span>
      </div>
      <div class="form-group" style="margin-bottom:0;">
        <label style="font-size:8px;color:var(--muted);">Linked Chain</label>
        <span id="editLinkedChain" style="font-size:9px;color:var(--warn);">--</span>
      </div>
    </div>
    <div class="section-title" style="margin-top:8px;"><span>Players</span><button class="btn-sm" onclick="addPlayerToEdit()">+ Add</button></div>
    <div id="editPlayersContainer" style="max-height:200px;overflow-y:auto;"></div>
    <div class="section-title" style="margin-top:8px;"><span>Puck XY</span></div>
    <div id="editPuckXY" style="display:flex;flex-wrap:wrap;gap:4px;"></div>
    <div class="section-title" style="margin-top:8px;"><span>Edit XY on Rink</span></div>
    <svg id="editRinkSvg" viewBox="0 0 200 85" width="100%" style="cursor:crosshair;background:var(--card);border-radius:4px;max-height:150px;" onclick="handleEditRinkClick(event)">
      <!-- Ice surface -->
      <rect x="0" y="0" width="200" height="85" fill="#f0f9ff" rx="14" ry="14" stroke="#1e293b" stroke-width="0.5"/>
      
      <!-- Blue lines -->
      <line x1="75" y1="0" x2="75" y2="85" stroke="#1d4ed8" stroke-width="1.5"/>
      <line x1="125" y1="0" x2="125" y2="85" stroke="#1d4ed8" stroke-width="1.5"/>
      
      <!-- Red center line (dashed) -->
      <line x1="100" y1="0" x2="100" y2="85" stroke="#dc2626" stroke-width="0.8" stroke-dasharray="3,2"/>
      
      <!-- Goal lines -->
      <line x1="11" y1="0" x2="11" y2="85" stroke="#dc2626" stroke-width="0.5"/>
      <line x1="189" y1="0" x2="189" y2="85" stroke="#dc2626" stroke-width="0.5"/>
      
      <!-- Center circle -->
      <circle cx="100" cy="42.5" r="15" fill="none" stroke="#1d4ed8" stroke-width="0.5"/>
      <circle cx="100" cy="42.5" r="1" fill="#1d4ed8"/>
      
      <!-- Offensive zone faceoff circles (left) -->
      <circle cx="31" cy="22" r="15" fill="none" stroke="#dc2626" stroke-width="0.4"/>
      <circle cx="31" cy="22" r="1" fill="#dc2626"/>
      <circle cx="31" cy="63" r="15" fill="none" stroke="#dc2626" stroke-width="0.4"/>
      <circle cx="31" cy="63" r="1" fill="#dc2626"/>
      
      <!-- Offensive zone faceoff circles (right) -->
      <circle cx="169" cy="22" r="15" fill="none" stroke="#dc2626" stroke-width="0.4"/>
      <circle cx="169" cy="22" r="1" fill="#dc2626"/>
      <circle cx="169" cy="63" r="15" fill="none" stroke="#dc2626" stroke-width="0.4"/>
      <circle cx="169" cy="63" r="1" fill="#dc2626"/>
      
      <!-- Neutral zone dots -->
      <circle cx="80" cy="22" r="0.8" fill="#dc2626"/>
      <circle cx="80" cy="63" r="0.8" fill="#dc2626"/>
      <circle cx="120" cy="22" r="0.8" fill="#dc2626"/>
      <circle cx="120" cy="63" r="0.8" fill="#dc2626"/>
      
      <!-- Creases (simplified) -->
      <path d="M 11 38.5 L 15 38.5 A 4 4 0 0 1 15 46.5 L 11 46.5" fill="rgba(59,130,246,0.15)" stroke="#3b82f6" stroke-width="0.4"/>
      <path d="M 189 38.5 L 185 38.5 A 4 4 0 0 0 185 46.5 L 189 46.5" fill="rgba(59,130,246,0.15)" stroke="#3b82f6" stroke-width="0.4"/>
      
      <!-- Goals -->
      <rect x="7" y="39" width="4" height="7" fill="#222" stroke="#fff" stroke-width="0.3"/>
      <rect x="189" y="39" width="4" height="7" fill="#222" stroke="#fff" stroke-width="0.3"/>
      
      <!-- High danger zone (slot area) -->
      <path d="M 11 30 L 45 30 L 45 55 L 11 55 Z" fill="rgba(239,68,68,0.08)" stroke="none"/>
      <path d="M 189 30 L 155 30 L 155 55 L 189 55 Z" fill="rgba(239,68,68,0.08)" stroke="none"/>
      
      <!-- Zone labels -->
      <text x="43" y="82" font-size="3" fill="#64748b" text-anchor="middle">OFF</text>
      <text x="100" y="82" font-size="3" fill="#64748b" text-anchor="middle">NEU</text>
      <text x="157" y="82" font-size="3" fill="#64748b" text-anchor="middle">OFF</text>
      
      <g id="editRinkMarkers"></g>
    </svg>
    <div id="editXYControls" style="font-size:9px;color:var(--muted);margin-top:4px;">
      Editing: <select id="editXYTarget" onchange="renderEditRinkMarkers()" style="font-size:9px;"></select>
      <button class="btn-sm" onclick="addEditXYPoint()">+ Add Point</button>
    </div>
    <!-- Net Location for Shots/Goals -->
    <div id="editNetSection" style="display:none;margin-top:8px;">
      <div class="section-title"><span>Net Location (Shot/Goal)</span></div>
      <div style="display:flex;gap:16px;align-items:center;">
        <svg id="editNetSvg" viewBox="0 0 72 48" width="160" style="cursor:crosshair;background:#1f2937;border-radius:4px;" onclick="handleEditNetClick(event)">
          <rect x="1" y="1" width="70" height="46" fill="#111" stroke="#fff" stroke-width="1"/>
          <line x1="1" y1="1" x2="71" y2="47" stroke="#444" stroke-width="0.5"/>
          <line x1="71" y1="1" x2="1" y2="47" stroke="#444" stroke-width="0.5"/>
          <line x1="36" y1="1" x2="36" y2="47" stroke="#444" stroke-width="0.5"/>
          <line x1="1" y1="24" x2="71" y2="24" stroke="#444" stroke-width="0.5"/>
          <text x="12" y="12" font-size="5" fill="#666">Top L</text>
          <text x="50" y="12" font-size="5" fill="#666">Top R</text>
          <text x="12" y="42" font-size="5" fill="#666">Low L</text>
          <text x="50" y="42" font-size="5" fill="#666">Low R</text>
          <text x="26" y="26" font-size="5" fill="#666">5-Hole</text>
          <g id="editNetMarker"></g>
        </svg>
        <div style="font-size:10px;">
          <div style="color:var(--muted);margin-bottom:4px;">Click to set location</div>
          <div>Current: <span id="editNetLocation" style="color:var(--accent);">--</span></div>
          <button class="btn-sm" onclick="clearEditNetXY()" style="margin-top:4px;">Clear</button>
        </div>
      </div>
    </div>
    <!-- v20.7: Insert/Delete actions -->
    <div style="display:flex;gap:4px;margin-top:8px;padding-top:8px;border-top:1px solid var(--border);">
      <button class="btn-sm" onclick="insertEventBefore()" title="Insert new event before this one" style="flex:1;background:var(--accent2);">‚ûï Insert Before</button>
      <button class="btn-sm" onclick="insertEventAfter()" title="Insert new event after this one" style="flex:1;background:var(--accent2);">‚ûï Insert After</button>
      <button class="btn-sm" onclick="duplicateEvent()" title="Duplicate this event" style="flex:1;">üìã Duplicate</button>
    </div>
    <div class="modal-actions">
      <button class="btn-danger" onclick="deleteEvent()">Delete</button>
      <button class="btn-primary" onclick="saveEditEvent()">Save</button>
      <button onclick="closeEditModal()">Cancel</button>
    </div>
  </div>
</div>

<!-- Net Location Modal -->
<div class="overlay" id="netModal">
  <div class="modal" style="min-width:200px;">
    <h3>ü•Ö Net Location</h3>
    <p style="font-size:9px;color:var(--muted);margin-bottom:8px;">Click where puck entered net</p>
    <svg id="netSvg" viewBox="0 0 72 48" width="200" style="cursor:crosshair;background:#222;border-radius:4px;" onclick="handleNetClick(event)">
      <!-- Net frame -->
      <rect x="1" y="1" width="70" height="46" fill="none" stroke="#fff" stroke-width="1"/>
      <!-- Net mesh -->
      <line x1="1" y1="1" x2="71" y2="47" stroke="#666" stroke-width="0.3"/>
      <line x1="71" y1="1" x2="1" y2="47" stroke="#666" stroke-width="0.3"/>
      <line x1="36" y1="1" x2="36" y2="47" stroke="#666" stroke-width="0.3"/>
      <line x1="1" y1="24" x2="71" y2="24" stroke="#666" stroke-width="0.3"/>
      <!-- Zones -->
      <text x="18" y="14" font-size="6" fill="#888">Top L</text>
      <text x="46" y="14" font-size="6" fill="#888">Top R</text>
      <text x="18" y="38" font-size="6" fill="#888">Low L</text>
      <text x="46" y="38" font-size="6" fill="#888">Low R</text>
      <text x="28" y="26" font-size="6" fill="#888">5-Hole</text>
      <!-- Marker layer -->
      <g id="netMarker"></g>
    </svg>
    <div class="modal-actions">
      <button onclick="clearNetXY()">Clear</button>
      <button class="btn-primary" onclick="closeNetModal()">Done</button>
    </div>
  </div>
</div>

<!-- Edit Shift Modal -->
<div class="overlay" id="editShiftModal">
  <div class="modal" style="min-width:500px;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
      <button class="btn-sm" onclick="navEditShift(-1)" title="Previous Shift (‚Üê)">‚óÄ Prev</button>
      <h3 style="margin:0;">‚úèÔ∏è Shift #<span id="editShiftIdx"></span></h3>
      <button class="btn-sm" onclick="navEditShift(1)" title="Next Shift (‚Üí)">Next ‚ñ∂</button>
    </div>
    <div class="form-row">
      <div class="form-group"><label>Period</label><select id="editShiftPeriod"><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="OT">OT</option></select></div>
      <div class="form-group"><label>Strength</label><input type="text" id="editShiftStrength" readonly></div>
    </div>
    <div class="form-row">
      <div class="form-group"><label>Start Time</label><input type="text" id="editShiftStartTime"></div>
      <div class="form-group"><label>End Time</label><input type="text" id="editShiftEndTime"></div>
    </div>
    <div class="form-row">
      <div class="form-group"><label>Start Type</label><select id="editShiftStartType"></select></div>
      <div class="form-group"><label>Stop Type</label><select id="editShiftStopType"></select></div>
    </div>
    <div class="section-title" style="margin-top:8px;"><span>Players on Ice</span></div>
    <div id="editShiftPlayersContainer" style="background:var(--card);padding:8px;border-radius:4px;"></div>
    <!-- v20.6: Insert/Delete actions -->
    <div style="display:flex;gap:4px;margin-top:8px;padding-top:8px;border-top:1px solid var(--border);">
      <button class="btn-sm" onclick="insertShiftBefore()" title="Insert new shift before this one" style="flex:1;background:var(--accent2);">‚ûï Insert Before</button>
      <button class="btn-sm" onclick="insertShiftAfter()" title="Insert new shift after this one" style="flex:1;background:var(--accent2);">‚ûï Insert After</button>
      <button class="btn-sm" onclick="duplicateShift()" title="Duplicate this shift" style="flex:1;">üìã Duplicate</button>
    </div>
    <div class="modal-actions">
      <button class="btn-danger" onclick="deleteShift()">Delete</button>
      <button class="btn-primary" onclick="saveEditShift()">Save</button>
      <button onclick="closeEditShiftModal()">Cancel</button>
    </div>
  </div>
</div>

<!-- XY Edit Modal -->
<div class="overlay" id="xyEditModal">
  <div class="modal" style="min-width:400px;">
    <h3>üìç Edit XY Position</h3>
    <p style="font-size:9px;color:var(--muted);margin-bottom:8px;">Click on rink to set position</p>
    <svg id="xyEditSvg" viewBox="0 0 200 85" width="350" style="cursor:crosshair;background:var(--card);border-radius:4px;" onclick="handleXYEditClick(event)">
      <rect x="0" y="0" width="200" height="85" fill="#f8fafc" rx="14" ry="14" stroke="#1e293b" stroke-width="1"/>
      <line x1="75" y1="0" x2="75" y2="85" stroke="#1d4ed8" stroke-width="1.5"/>
      <line x1="125" y1="0" x2="125" y2="85" stroke="#1d4ed8" stroke-width="1.5"/>
      <line x1="100" y1="0" x2="100" y2="85" stroke="#dc2626" stroke-width="1" stroke-dasharray="3,2"/>
      <line x1="11" y1="0" x2="11" y2="85" stroke="#dc2626" stroke-width="0.8"/>
      <line x1="189" y1="0" x2="189" y2="85" stroke="#dc2626" stroke-width="0.8"/>
      <circle cx="100" cy="42.5" r="15" fill="none" stroke="#1d4ed8" stroke-width="0.8"/>
      <circle cx="31" cy="22" r="15" fill="none" stroke="#dc2626" stroke-width="0.5"/>
      <circle cx="31" cy="63" r="15" fill="none" stroke="#dc2626" stroke-width="0.5"/>
      <circle cx="169" cy="22" r="15" fill="none" stroke="#dc2626" stroke-width="0.5"/>
      <circle cx="169" cy="63" r="15" fill="none" stroke="#dc2626" stroke-width="0.5"/>
      <g id="xyEditMarker"></g>
    </svg>
    <div class="modal-actions">
      <button class="btn-primary" onclick="closeXYEditModal()">Done</button>
    </div>
  </div>
</div>

<!-- All Shifts Modal -->
<div class="overlay" id="allShiftsModal">
  <div class="modal" style="min-width:600px;max-width:800px;">
    <h3>üìã All Shifts (<span id="allShiftsCount">0</span>)</h3>
    <div class="table-wrap" style="max-height:400px;overflow-y:auto;">
      <table style="width:100%;font-size:10px;border-collapse:collapse;">
        <thead style="position:sticky;top:0;background:var(--card);">
          <tr><th>#</th><th>Period</th><th>Start</th><th>End</th><th>Start Type</th><th>Stop Type</th><th>Strength</th></tr>
        </thead>
        <tbody id="allShiftsBody"></tbody>
      </table>
    </div>
    <div class="modal-actions">
      <button onclick="document.getElementById('allShiftsModal').classList.remove('show')">Close</button>
    </div>
  </div>
</div>

<!-- All Events Modal -->
<div class="overlay" id="allEventsModal">
  <div class="modal" style="min-width:700px;max-width:900px;">
    <h3>üìã All Events (<span id="allEventsCount">0</span>)</h3>
    <div class="table-wrap" style="max-height:400px;overflow-y:auto;">
      <table style="width:100%;font-size:10px;border-collapse:collapse;">
        <thead style="position:sticky;top:0;background:var(--card);">
          <tr><th>#</th><th>Period</th><th>Time</th><th>Team</th><th>Type</th><th>Detail</th><th>Players</th></tr>
        </thead>
        <tbody id="allEventsBody"></tbody>
      </table>
    </div>
    <div class="modal-actions">
      <button onclick="document.getElementById('allEventsModal').classList.remove('show')">Close</button>
    </div>
  </div>
</div>

<!-- Full Box Score Modal -->
<div class="overlay" id="boxScoreModal">
  <div class="modal" style="min-width:700px;max-width:900px;">
    <h3>üìä Full Box Score</h3>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-bottom:16px;">
      <div style="background:var(--card);padding:12px;border-radius:6px;text-align:center;">
        <div style="font-size:12px;color:var(--muted);" id="boxModalHome">HOME</div>
        <div style="font-size:32px;font-weight:bold;" id="boxModalHomeScore">0</div>
        <div style="font-size:10px;color:var(--muted);">SOG: <span id="boxModalHomeSOG">0</span> | FO: <span id="boxModalHomeFO">0</span></div>
      </div>
      <div style="background:var(--card);padding:12px;border-radius:6px;text-align:center;">
        <div style="font-size:12px;color:var(--muted);" id="boxModalAway">AWAY</div>
        <div style="font-size:32px;font-weight:bold;" id="boxModalAwayScore">0</div>
        <div style="font-size:10px;color:var(--muted);">SOG: <span id="boxModalAwaySOG">0</span> | FO: <span id="boxModalAwayFO">0</span></div>
      </div>
    </div>
    <div class="table-wrap" style="max-height:300px;overflow-y:auto;">
      <table style="width:100%;font-size:11px;border-collapse:collapse;">
        <thead style="position:sticky;top:0;background:var(--card);">
          <tr><th>#</th><th>Player</th><th>Team</th><th>G</th><th>A</th><th>PTS</th><th>SOG</th><th>FO%</th><th>TOI</th></tr>
        </thead>
        <tbody id="boxModalBody"></tbody>
      </table>
    </div>
    <div class="modal-actions">
      <button onclick="document.getElementById('boxScoreModal').classList.remove('show')">Close</button>
    </div>
  </div>
</div>

<!-- Player Detail Modal -->
<div class="overlay" id="playerDetailModal">
  <div class="modal" style="min-width:400px;">
    <h3>üë§ <span id="playerDetailName">Player</span></h3>
    <div style="display:grid;grid-template-columns:repeat(4, 1fr);gap:8px;margin-bottom:16px;">
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:20px;font-weight:bold;" id="pdGoals">0</div>
        <div style="font-size:9px;color:var(--muted);">Goals</div>
      </div>
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:20px;font-weight:bold;" id="pdAssists">0</div>
        <div style="font-size:9px;color:var(--muted);">Assists</div>
      </div>
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:20px;font-weight:bold;" id="pdShots">0</div>
        <div style="font-size:9px;color:var(--muted);">SOG</div>
      </div>
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:20px;font-weight:bold;" id="pdFO">0%</div>
        <div style="font-size:9px;color:var(--muted);">FO%</div>
      </div>
    </div>
    <div style="display:grid;grid-template-columns:repeat(3, 1fr);gap:8px;margin-bottom:16px;">
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:16px;font-weight:bold;" id="pdTOI">--:--</div>
        <div style="font-size:9px;color:var(--muted);">TOI</div>
      </div>
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:16px;font-weight:bold;" id="pdHits">0</div>
        <div style="font-size:9px;color:var(--muted);">Hits</div>
      </div>
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:16px;font-weight:bold;" id="pdBlocks">0</div>
        <div style="font-size:9px;color:var(--muted);">Blocks</div>
      </div>
    </div>
    <div style="font-size:10px;color:var(--muted);margin-bottom:8px;">Recent Events:</div>
    <div id="pdRecentEvents" style="max-height:150px;overflow-y:auto;background:var(--card);border-radius:4px;padding:8px;font-size:9px;"></div>
    <div class="modal-actions">
      <button onclick="document.getElementById('playerDetailModal').classList.remove('show')">Close</button>
    </div>
  </div>
</div>

<!-- Toast -->
<div class="toast" id="toast"></div>

<script>
// ============================================================
// STATE
// ============================================================
const S = {
  sb: null, connected: false,
  gameId: null, games: [], rosters: { home: [], away: [] },
  homeTeam: 'Home', awayTeam: 'Away', homeColor: '#3b82f6', awayColor: '#ef4444',
  homeLogo: null, awayLogo: null,
  teams: {},  // v15.01: Team data from dim_team
  // Reference data from Supabase
  playDetails1: [],  // dim_play_detail
  playDetails2: [],  // dim_play_detail_2
  eventDetails1: [], // dim_event_detail (v16.06)
  eventDetails2: [], // dim_event_detail_2 (v16.06)
  eventTypesDB: [],  // dim_event_type (v22.1)
  showAllEventTypes: false, // v22.1: Toggle for showing all event types
  playerRoles: [],   // dim_player_role
  period: 1, evtTeam: 'home', periodLength: 18, // Variable period length (NORAD default: 18 min)
  homeAttacksRightP1: true, // v19: Configurable per game - which end home attacks in P1
  slots: { home: {F1:null,F2:null,F3:null,D1:null,D2:null,G:null,X:null}, away: {F1:null,F2:null,F3:null,D1:null,D2:null,G:null,X:null} },
  selectedSlot: null, events: [], shifts: [], evtIdx: 0, shiftIdx: 0,
  curr: { type: null, players: [], puckXY: [], netXY: null },
  selectedPlayer: null, xyMode: 'puck', xySlot: 1,
  editingEvtIdx: null, editingShiftIdx: null, lastEndTime: '18:00',
  editingXYType: null, editingXYIdx: null, // For XY editing in modal
  xyHistory: [], // For undo
  lastSave: null, saveTimer: null,
  linkedEventIdx: null, // For linked plays
  // Video timing - variable intermissions and stoppages
  videoTiming: {
    videoStartOffset: 0,        // Seconds to skip at video start (pre-game, warmups)
    intermission1: 900,         // Seconds after P1 (default 15 min)
    intermission2: 900,         // Seconds after P2 (default 15 min)
    intermission3: 300,         // Seconds after P3 if OT (default 5 min)
    timeouts: [],               // Array of {period, gameTime, duration} objects
    youtubeUrl: ''              // Optional YouTube link for this game
  },
  // v15.01: Video player state
  videoPlayer: {
    sources: [],                // Array of {id, name, type:'youtube'|'file', url, hotkey}
    currentSourceIdx: 0,
    isPlaying: false,
    currentTime: 0,
    speed: 1,
    autoSync: true,             // Auto-populate start/end times from video
    ytPlayer: null,             // YouTube IFrame API player instance
    gameMarkers: {              // Video timestamps for game events (in seconds)
      P1Start: null, P1End: null,
      P2Start: null, P2End: null,
      P3Start: null, P3End: null,
      OTStart: null, OTEnd: null,
      stoppages: []             // Array of {startTime, endTime, type, note}
    }
  }
};

// ============================================================
// DROPDOWN OPTIONS
// ============================================================
const LISTS = {
  eventTypes: ['Faceoff','Shot','Pass','Goal','Turnover','Zone_Entry_Exit','Penalty','Stoppage','Possession','Save','Rebound','DeadIce','Play','Intermission','Clockstop','Timeout'],
  hotkeys: { Faceoff:'F', Shot:'S', Pass:'P', Goal:'G', Turnover:'T', Zone_Entry_Exit:'Z', Penalty:'N', Stoppage:'X', Possession:'O', Save:'V', Rebound:'R', DeadIce:'D', Play:'Y', Intermission:'I', Clockstop:'C' },
  details: {
    Shot: { d1: ['Shot_OnNetSaved','Shot_Missed','Shot_Blocked','Shot_BlockedSameTeam','Shot_Deflected','Shot_OnNetGoal'], d2: ['Shot-Wrist','Shot-Slap','Shot-Backhand','Shot-Snap','Shot-WrapAround','Shot-Bat','Shot-Poke','Shot-OneTime','Shot-Tip','Shot-Deflection','Shot-Other'] },
    Pass: { d1: ['Pass_Completed','Pass_Missed','Pass_Deflected','Pass_Intercepted'], d2: ['Pass-Stretch','Pass-Rim/Wrap','Pass-Backhand','Pass-Forehand','Pass-Bank','Pass-Dump','Pass-Drop','Pass-OneTouch','Pass-Other'] },
    Goal: { d1: ['Goal_Scored','Goal_Shootout','Goal_PenaltyShot'], d2: ['Goal-Wrist','Goal-Slap','Goal-Backhand','Goal-Tip','Goal-Snap','Goal-WrapAround','Goal-Deflection','Goal-OneTime','Goal-Other'] },
    Faceoff: { d1: ['Faceoff_PeriodStart','Faceoff_GameStart','Faceoff_AfterGoal','Faceoff_AfterPenalty','Faceoff_AfterStoppage'], d2: [] },
    Turnover: { d1: ['Turnover_Giveaway','Turnover_Takeaway'], d2_Giveaway: ['Giveaway-Misplayed','Giveaway-BattleLost','Giveaway-PassIntercepted','Giveaway-Other'], d2_Takeaway: ['Takeaway-BattleWon','Takeaway-PokeCheck','Takeaway-PassIntercepted','Takeaway-Other'] },
    Zone_Entry_Exit: { d1: ['Zone_Entry','Zone_Exit','Zone_Keepin','Zone_EntryFailed','Zone_ExitFailed'], d2_Entry: ['ZoneEntry-Rush','ZoneEntry-Pass','ZoneEntry-DumpIn','ZoneEntry-Chip'], d2_Exit: ['ZoneExit-Rush','ZoneExit-Pass','ZoneExit-Clear','ZoneExit-Chip'] },
    Save: { d1: ['Save_Rebound','Save_Freeze','Save_Played'], d2: ['Save-Glove','Save-Blocker','Save-Pad','Save-Stick','Save-Butterfly','Save-Other'] },
    Stoppage: { d1: ['Stoppage_PeriodEnd','Stoppage_Play','Stoppage_Other','Stoppage_GameEnd'], d2_Play: ['Stoppage-Icing','Stoppage-Offsides','Stoppage-GoalieStoppage','Stoppage-PuckOut','Stoppage-Penalty','Stoppage-Goal'] },
    Penalty: { d1: ['Penalty_Minor','Penalty_Major','Penalty_Misconduct'], d2: ['Penalty-Tripping','Penalty-Hooking','Penalty-Slashing','Penalty-Interference','Penalty-Holding','Penalty-Roughing','Penalty-HighSticking','Penalty-CrossChecking','Penalty-Boarding','Penalty-Other'] },
    Possession: { d1: ['Breakaway','PuckRetrieval','PuckRecovery','Regroup','LoosePuck'], d2: [] },
    Rebound: { d1: ['Rebound_TeamRecovered','Rebound_OppRecovered','Rebound_ShotGenerated'], d2: [] },
    DeadIce: { d1: ['DeadIce_Icing','DeadIce_Offside','DeadIce_PuckOut','DeadIce_NetOff','DeadIce_Other'], d2: [] },
    Play: { d1: ['Play_Offensive','Play_Defensive'], d2_Offensive: ['Play-DriveMiddle','Play-DriveWide','Play-CrashNet','Play-Deke','Play-DumpChase','Play-Forecheck'], d2_Defensive: ['Play-PokeCheck','Play-Backcheck','Play-Contain','Play-BoxOut'] },
    Intermission: { d1: ['Intermission_Period1','Intermission_Period2','Intermission_Period3','Intermission_OT'], d2: [] },
    Clockstop: { d1: ['Clockstop_Injury','Clockstop_Equipment','Clockstop_IceRepair','Clockstop_Other'], d2: [] },
    Timeout: { d1: ['Timeout_Home','Timeout_Away'], d2: [] }
  },
  shiftStart: ['GameStart','PeriodStart','FaceoffAfterGoal','FaceoffAfterPenalty','OtherFaceoff','Stoppage','Intermission','OnTheFly'],
  shiftStop: ['','OnTheFly','PeriodEnd','Period End','GoalScored','Home Goal','Away Goal','Penalty','Stoppage','OtherFaceoff','Intermission','GameEnd','High Stick','Away Icing','Home Icing','Away Offside','Home Offside','Puck Out of Play','Away Goalie Stopped (after Home SOG)','Home Goalie Stopped (after Away SOG)'],
  playOffensive: ['Play-DriveMiddle','Play-DriveWide','Play-CrashNet','Play-Delay','Play-Deke','Play-DumpChase','Play-Forecheck','Play-Other'],
  playDefensive: ['Play-PokeCheck','Play-Backcheck','Play-Contain','Play-BoxOut','Play-Other'],
  // Events where puck XY = event_player_1 XY
  possessionEvents: ['Possession','Zone_Entry_Exit'],
  possessionDetails: ['ZoneEntry-Rush','ZoneExit-Rush','Breakaway','PuckRetrieval','PuckRecovery','Regroup'],
  // Suggested next events based on current event
  nextEventSuggestions: {
    'Faceoff': ['Pass', 'Possession', 'Turnover'],
    'Pass': ['Shot', 'Pass', 'Turnover', 'Zone_Entry_Exit'],
    'Shot': ['Save', 'Goal', 'Rebound'],
    'Save': ['Rebound', 'Pass', 'Stoppage'],
    'Goal': ['Faceoff', 'Stoppage'],
    'Rebound': ['Shot', 'Possession', 'Turnover'],
    'Zone_Entry_Exit': ['Pass', 'Shot', 'Possession'],
    'Turnover': ['Pass', 'Shot', 'Zone_Entry_Exit'],
    'Possession': ['Pass', 'Shot', 'Zone_Entry_Exit'],
    'Penalty': ['Faceoff', 'Stoppage'],
    'Stoppage': ['Faceoff', 'Intermission']
  },
  // Events that can be linked (sequence)
  linkedEvents: {
    'Shot': ['Pass', 'Rebound'], // Shot can link to preceding Pass or following Rebound
    'Goal': ['Shot', 'Pass'], // Goal links to Shot (the goal shot) or Pass (assist)
    'Save': ['Shot'], // Save links to Shot
    'Rebound': ['Shot', 'Save'] // Rebound links to Shot or Save
  }
};

// ============================================================
// INIT
// ============================================================
async function init() {
  console.log('BenchSight v16 initializing...');
  loadSettings();
  await tryConnect();
  buildUI();
  loadFromStorage();
  setupKeys();
  setupTimeInputs(); // v5: Auto-format time inputs
  startAutoSave();
  await loadGames();
  if (S.gameId) await selectGame(S.gameId);
  updateSaveIndicator();
  updateNextPlaySuggestions();
  updateZoneLabels();
  console.log('Ready:', S.events.length, 'events,', S.shifts.length, 'shifts');
}

function loadSettings() {
  try {
    const s = JSON.parse(localStorage.getItem('bs_settings') || '{}');
    if (s.sbUrl) document.getElementById('sbUrl').value = s.sbUrl;
    if (s.sbKey) document.getElementById('sbKey').value = s.sbKey;
    if (s.autoSaveInt) document.getElementById('autoSaveInt').value = s.autoSaveInt;
    if (s.pressureDist) document.getElementById('pressureDist').value = s.pressureDist;
    if (s.xyHistCnt) document.getElementById('xyHistCnt').value = s.xyHistCnt;
    if (s.periodLength) {
      document.getElementById('periodLength').value = s.periodLength;
      S.periodLength = parseInt(s.periodLength);
    }
    if (s.otLength) document.getElementById('otLength').value = s.otLength;
    if (s.backupPath) document.getElementById('backupPath').value = s.backupPath;
  } catch(e) {}
}

function saveSettings() {
  const s = {
    sbUrl: document.getElementById('sbUrl').value,
    sbKey: document.getElementById('sbKey').value,
    autoSaveInt: document.getElementById('autoSaveInt').value,
    pressureDist: document.getElementById('pressureDist').value,
    xyHistCnt: document.getElementById('xyHistCnt').value,
    periodLength: document.getElementById('periodLength').value,
    otLength: document.getElementById('otLength').value,
    backupPath: document.getElementById('backupPath').value
  };
  localStorage.setItem('bs_settings', JSON.stringify(s));
  S.periodLength = parseInt(s.periodLength) || 18;
  
  // Update clock to match period length
  if (S.period !== 'OT') {
    document.getElementById('clock').value = S.periodLength + ':00';
  }
  
  closeSettings();
  toast('Settings saved', 'success');
  tryConnect();
  startAutoSave();
}

async function tryConnect() {
  const url = document.getElementById('sbUrl').value;
  const key = document.getElementById('sbKey').value;
  if (!url || !key) { 
    updateConn(false); 
    return; 
  }
  try {
    S.sb = supabase.createClient(url, key);
    // Try to query a table that exists
    const { data, error } = await S.sb.from('dim_schedule').select('game_id').limit(1);
    if (error) {
      console.error('Supabase query error:', error);
      // Provide helpful error messages
      if (error.message?.includes('permission denied') || error.code === '42501') {
        toast('RLS is blocking queries. Disable RLS in Supabase SQL Editor.', 'error');
      } else if (error.message?.includes('does not exist') || error.code === '42P01') {
        toast('Tables not found. Run upload.py --schema then upload.py', 'error');
      } else {
        toast('Connection error: ' + (error.message || error.code), 'error');
      }
      throw error;
    }
    S.connected = true;
    updateConn(true);
    
    // Load reference data (play details, player roles)
    await loadReferenceData();
  } catch(e) { 
    console.error('Connection failed:', e);
    S.sb = null; S.connected = false; updateConn(false); 
  }
}

/**
 * Load reference data from Supabase (dim tables)
 */
async function loadReferenceData() {
  if (!S.connected) return;
  
  try {
    // Load dim_play_detail
    const { data: pd1, error: e1 } = await S.sb.from('dim_play_detail')
      .select('play_detail_id,play_detail_name,play_category')
      .order('play_detail_name');
    
    if (!e1 && pd1) {
      S.playDetails1 = pd1.map(p => ({
        id: p.play_detail_id,
        name: p.play_detail_name,
        category: p.play_category
      }));
      console.log('Loaded', S.playDetails1.length, 'play details 1');
    }
    
    // Load dim_play_detail_2
    const { data: pd2, error: e2 } = await S.sb.from('dim_play_detail_2')
      .select('play_detail_2_id,play_detail_2_name,play_category')
      .order('play_detail_2_name');
    
    if (!e2 && pd2) {
      S.playDetails2 = pd2.map(p => ({
        id: p.play_detail_2_id,
        name: p.play_detail_2_name,
        category: p.play_category
      }));
      console.log('Loaded', S.playDetails2.length, 'play details 2');
    }
    
    // v16.06: Load dim_event_detail for event detail 1 dropdown
    const { data: ed1, error: e2a } = await S.sb.from('dim_event_detail')
      .select('event_detail_id,event_detail_name,event_type')
      .order('event_type,event_detail_name');
    
    if (!e2a && ed1) {
      S.eventDetails1 = ed1.map(e => ({
        id: e.event_detail_id,
        name: e.event_detail_name,
        eventType: e.event_type
      }));
      console.log('Loaded', S.eventDetails1.length, 'event details 1');
    }
    
    // v16.08: Load dim_event_detail_2 for event detail 2 dropdown
    // Note: category is "other" for most entries, so we filter by code prefix
    const { data: ed2, error: e2b } = await S.sb.from('dim_event_detail_2')
      .select('event_detail_2_id,event_detail_2_code,event_detail_2_name,category')
      .order('event_detail_2_code');
    
    if (!e2b && ed2) {
      S.eventDetails2 = ed2.map(e => ({
        id: e.event_detail_2_id,
        code: e.event_detail_2_code,  // e.g., "ZoneEntry_Rush"
        name: e.event_detail_2_name,   // e.g., "ZoneEntry Rush"
        category: e.category
      }));
      console.log('Loaded', S.eventDetails2.length, 'event details 2');
    }
    
    // v22.1: Load dim_event_type for event type buttons
    const { data: et, error: etErr } = await S.sb.from('dim_event_type')
      .select('event_type_id,event_type_code,event_type_name,event_category')
      .order('event_type_code');
    
    if (!etErr && et) {
      S.eventTypesDB = et.map(e => ({
        id: e.event_type_id,
        code: e.event_type_code,
        name: e.event_type_name,
        category: e.event_category
      }));
      console.log('Loaded', S.eventTypesDB.length, 'event types from dim_event_type');
      // Rebuild UI to use dynamic event types
      buildEventTypeButtons();
    }
    
    // Load dim_player_role
    const { data: roles, error: e3 } = await S.sb.from('dim_player_role')
      .select('role_id,role_code,role_name,role_type,sort_order')
      .order('sort_order');
    
    if (!e3 && roles) {
      S.playerRoles = roles.map(r => ({
        id: r.role_id,
        code: r.role_code,
        name: r.role_name,
        type: r.role_type,
        order: r.sort_order
      }));
      console.log('Loaded', S.playerRoles.length, 'player roles');
    }
    
    // v15.01: Load dim_team for colors and logos
    const { data: teams, error: e4 } = await S.sb.from('dim_team')
      .select('team_id,team_name,team_color1,team_color2,team_logo');
    
    if (!e4 && teams) {
      S.teams = {};
      teams.forEach(t => {
        S.teams[t.team_name] = {
          id: t.team_id,
          name: t.team_name,
          color1: t.team_color1 || '#3b82f6',
          color2: t.team_color2 || '#1e40af',
          logo: t.team_logo || null
        };
      });
      console.log('Loaded', Object.keys(S.teams).length, 'teams');
    }
    
  } catch(e) {
    console.error('Error loading reference data:', e);
  }
}

async function testConn() {
  await tryConnect();
  toast(S.connected ? '‚úÖ Connected to Supabase!' : '‚ùå Connection failed', S.connected ? 'success' : 'error');
}

function updateConn(on) {
  const el = document.getElementById('connStatus');
  el.textContent = on ? 'ONLINE' : 'OFFLINE';
  el.className = 'conn ' + (on ? 'on' : 'off');
}

function openSettings() { document.getElementById('settingsModal').classList.add('show'); }
function closeSettings() { document.getElementById('settingsModal').classList.remove('show'); }
function openHelp() { document.getElementById('helpModal').classList.add('show'); }
function closeHelp() { document.getElementById('helpModal').classList.remove('show'); }

// ============================================================
// VIDEO TIMING FUNCTIONS
// ============================================================
function openVideoTimingModal() {
  // Populate fields from S.videoTiming
  document.getElementById('vtVideoStartOffset').value = S.videoTiming.videoStartOffset || 0;
  document.getElementById('vtPeriodLength').value = S.periodLength || 18;
  document.getElementById('vtIntermission1').value = S.videoTiming.intermission1 || 900;
  document.getElementById('vtIntermission2').value = S.videoTiming.intermission2 || 900;
  document.getElementById('vtIntermission3').value = S.videoTiming.intermission3 || 300;
  document.getElementById('vtYoutubeUrl').value = S.videoTiming.youtubeUrl || '';
  
  renderVideoTimeouts();
  updateVideoTimingPreview();
  document.getElementById('videoTimingModal').classList.add('show');
}

function closeVideoTimingModal() {
  document.getElementById('videoTimingModal').classList.remove('show');
}

function renderVideoTimeouts() {
  const list = document.getElementById('vtTimeoutsList');
  if (!S.videoTiming.timeouts || S.videoTiming.timeouts.length === 0) {
    list.innerHTML = '<div style="font-size:9px;color:var(--muted);text-align:center;padding:8px;">No timeouts added</div>';
    return;
  }
  
  list.innerHTML = S.videoTiming.timeouts.map((t, i) => `
    <div style="display:flex;justify-content:space-between;align-items:center;padding:4px;background:var(--panel);border-radius:2px;margin:2px 0;font-size:10px;">
      <span>P${t.period} @ ${t.gameTime} - ${t.duration}s</span>
      <button class="btn-sm" onclick="removeVideoTimeout(${i})" style="padding:1px 4px;font-size:8px;">‚úï</button>
    </div>
  `).join('');
}

function addVideoTimeout() {
  const period = document.getElementById('vtNewTimeoutPeriod').value;
  const gameTime = document.getElementById('vtNewTimeoutTime').value;
  const duration = parseInt(document.getElementById('vtNewTimeoutDuration').value) || 60;
  
  if (!gameTime) {
    toast('Enter game time', 'error');
    return;
  }
  
  if (!S.videoTiming.timeouts) S.videoTiming.timeouts = [];
  S.videoTiming.timeouts.push({ period, gameTime, duration });
  
  // Sort by period then time
  S.videoTiming.timeouts.sort((a, b) => {
    if (a.period !== b.period) return a.period - b.period;
    return b.gameTime.localeCompare(a.gameTime); // Higher time = earlier in period
  });
  
  renderVideoTimeouts();
  updateVideoTimingPreview();
  
  // Clear inputs
  document.getElementById('vtNewTimeoutTime').value = '';
}

function removeVideoTimeout(idx) {
  S.videoTiming.timeouts.splice(idx, 1);
  renderVideoTimeouts();
  updateVideoTimingPreview();
}

function saveVideoTiming() {
  S.videoTiming.videoStartOffset = parseInt(document.getElementById('vtVideoStartOffset').value) || 0;
  S.periodLength = parseInt(document.getElementById('vtPeriodLength').value) || 18;
  S.videoTiming.intermission1 = parseInt(document.getElementById('vtIntermission1').value) || 900;
  S.videoTiming.intermission2 = parseInt(document.getElementById('vtIntermission2').value) || 900;
  S.videoTiming.intermission3 = parseInt(document.getElementById('vtIntermission3').value) || 300;
  S.videoTiming.youtubeUrl = document.getElementById('vtYoutubeUrl').value || '';
  
  // Also update the settings modal period length
  document.getElementById('periodLength').value = S.periodLength;
  
  saveGameData();
  toast('Video timing saved', 'success');
  closeVideoTimingModal();
}

function updateVideoTimingPreview() {
  const periodSec = (parseInt(document.getElementById('vtPeriodLength').value) || 20) * 60;
  const int1 = parseInt(document.getElementById('vtIntermission1').value) || 0;
  const int2 = parseInt(document.getElementById('vtIntermission2').value) || 0;
  const int3 = parseInt(document.getElementById('vtIntermission3').value) || 0;
  const offset = parseInt(document.getElementById('vtVideoStartOffset').value) || 0;
  
  const p1Start = offset;
  const p1End = p1Start + periodSec;
  const p2Start = p1End + int1;
  const p2End = p2Start + periodSec;
  const p3Start = p2End + int2;
  const p3End = p3Start + periodSec;
  const otStart = p3End + int3;
  const otEnd = otStart + 5 * 60;  // 5 min OT
  
  const fmt = (s) => `${Math.floor(s/60)}:${String(s%60).padStart(2,'0')}`;
  
  document.getElementById('vtPreviewP1Start').textContent = fmt(p1Start);
  document.getElementById('vtPreviewP1End').textContent = fmt(p1End);
  document.getElementById('vtPreviewP2Start').textContent = fmt(p2Start);
  document.getElementById('vtPreviewP2End').textContent = fmt(p2End);
  document.getElementById('vtPreviewP3Start').textContent = fmt(p3Start);
  document.getElementById('vtPreviewP3End').textContent = fmt(p3End);
  document.getElementById('vtPreviewOTStart').textContent = fmt(otStart);
  document.getElementById('vtPreviewOTEnd').textContent = fmt(otEnd);
}

/**
 * Calculate running video time for an event
 * @param {number} period - Period number (1, 2, 3, OT)
 * @param {string} gameTime - Game clock time (e.g., "15:30")
 * @returns {number} - Seconds from video start
 */
function calculateRunningVideoTime(period, gameTime) {
  const periodSec = S.periodLength * 60;
  const int1 = S.videoTiming.intermission1 || 0;
  const int2 = S.videoTiming.intermission2 || 0;
  const int3 = S.videoTiming.intermission3 || 0;
  const offset = S.videoTiming.videoStartOffset || 0;
  
  // Parse game time (MM:SS) - time remaining in period
  let timeRemaining = 0;
  if (gameTime) {
    const parts = gameTime.split(':');
    timeRemaining = parseInt(parts[0] || 0) * 60 + parseInt(parts[1] || 0);
  }
  
  // Calculate elapsed time in period
  const elapsedInPeriod = periodSec - timeRemaining;
  
  // Calculate base running time (without timeouts)
  let runningTime = offset;
  
  if (period >= 1) {
    runningTime += elapsedInPeriod;
  }
  if (period >= 2) {
    runningTime += int1 + periodSec;
  }
  if (period >= 3) {
    runningTime += int2 + periodSec;
  }
  if (period >= 4) { // OT
    runningTime += int3 + periodSec; // Add P3 duration + int3
  }
  
  // Add timeout durations that occurred before this point
  const timeouts = S.videoTiming.timeouts || [];
  timeouts.forEach(t => {
    const tPeriod = t.period === 'OT' ? 4 : parseInt(t.period);
    if (tPeriod < period) {
      runningTime += t.duration;
    } else if (tPeriod === period) {
      // Timeout in same period - only add if it happened before current time
      // Higher gameTime = earlier in period
      if (t.gameTime > gameTime) {
        runningTime += t.duration;
      }
    }
  });
  
  return runningTime;
}

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  // Don't trigger if typing in input (unless arrow keys in edit modal)
  const inInput = e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA';
  
  // Arrow keys work in modals for navigation
  if (document.getElementById('editModal').classList.contains('show')) {
    if (e.key === 'ArrowLeft') { navEditEvent(-1); e.preventDefault(); return; }
    if (e.key === 'ArrowRight') { navEditEvent(1); e.preventDefault(); return; }
  }
  if (document.getElementById('editShiftModal').classList.contains('show')) {
    if (e.key === 'ArrowLeft') { navEditShift(-1); e.preventDefault(); return; }
    if (e.key === 'ArrowRight') { navEditShift(1); e.preventDefault(); return; }
  }
  
  if (inInput) return;
  
  switch(e.key) {
    case '?': openHelp(); break;
    case 'Escape': 
      closeSettings(); closeHelp(); 
      document.querySelectorAll('.overlay.show').forEach(m => m.classList.remove('show'));
      break;
    
    // Event type hotkeys
    case 'f': case 'F': setEvtType('Faceoff'); break;
    case 's': case 'S': setEvtType('Shot'); break;
    case 'p': case 'P': setEvtType('Pass'); break;
    case 'g': case 'G': setEvtType('Goal'); break;
    case 't': case 'T': setEvtType('Turnover'); break;
    case 'z': case 'Z': setEvtType('Zone_Entry_Exit'); break;
    case 'n': case 'N': setEvtType('Penalty'); break;
    case 'x': case 'X': setEvtType('Stoppage'); break;
    case 'o': case 'O': setEvtType('Possession'); break;
    case 'v': case 'V': setEvtType('Save'); break;
    case 'r': case 'R': setEvtType('Rebound'); break;
    case 'd': case 'D': setEvtType('DeadIce'); break;
    
    // Quick actions
    case 'h': case 'H': document.getElementById('evtHighlight').checked = !document.getElementById('evtHighlight').checked; break;
    case 'l': case 'L': logEvent(); break;  // Log current event
    case 'Enter': logEvent(); break;  // Also log with Enter
    
    // Team toggle - removed 1/2, now use H/A (v16.06)
    // 1-6 handled in setupKeys() for player selection
    
    // Zone
    case 'q': setZone('o'); break;  // Offensive
    case 'w': setZone('n'); break;  // Neutral
    case 'e': setZone('d'); break;  // Defensive
    
    // Success
    case 'y': case 'Y': document.getElementById('evtSuccess').value = 's'; break;
    case 'u': case 'U': document.getElementById('evtSuccess').value = 'u'; break;
    
    // Period
    case '!': setPeriod(1); break;
    case '@': setPeriod(2); break;
    case '#': setPeriod(3); break;
    case '$': setPeriod('OT'); break;
    
    // Undo XY
    case 'Backspace': undoLastXY(); break;
    
    // Shift actions
    case '[': logShift(); toast('Shift logged', 'success'); break;
    case ']': 
      document.getElementById('shiftStart').value = document.getElementById('clock').value;
      toast('Shift start set', 'info'); 
      break;
    
    // Edit last event
    case 'i': case 'I': 
      if (S.events.length > 0) editEvent(S.events.length - 1);
      break;
    
    // Quick nav
    case ',': if (S.events.length > 0) editEvent(0); break;  // First event
    case '.': if (S.events.length > 0) editEvent(S.events.length - 1); break;  // Last event
  }
});

// ============================================================
// AUTO-SAVE
// ============================================================
function startAutoSave() {
  if (S.saveTimer) clearInterval(S.saveTimer);
  const interval = (parseInt(document.getElementById('autoSaveInt').value) || 30) * 1000;
  S.saveTimer = setInterval(autoSave, interval);
}

function autoSave() {
  if (!S.gameId) return;
  const key = `bs_${S.gameId}`;
  const data = { 
    events: S.events, 
    shifts: S.shifts, 
    evtIdx: S.evtIdx, 
    shiftIdx: S.shiftIdx, 
    videoTiming: S.videoTiming,  // Save video timing per game
    periodLength: S.periodLength,
    homeAttacksRightP1: S.homeAttacksRightP1, // v19: Zone orientation per game
    savedAt: new Date().toISOString() 
  };
  localStorage.setItem(key, JSON.stringify(data));
  S.lastSave = new Date();
  updateSaveIndicator('saved');
  setTimeout(() => updateSaveIndicator(), 2000);
}

function saveGameData() {
  autoSave(); // Trigger save immediately
}

function updateSaveIndicator(status) {
  const el = document.getElementById('saveInd');
  if (status === 'saving') { el.textContent = 'Saving...'; el.className = 'save-ind saving'; }
  else if (status === 'saved') { el.textContent = 'Saved ‚úì'; el.className = 'save-ind saved'; }
  else if (S.lastSave) {
    const ago = Math.round((new Date() - S.lastSave) / 1000);
    el.textContent = ago < 60 ? `${ago}s ago` : `${Math.round(ago/60)}m ago`;
    el.className = 'save-ind';
  } else { el.textContent = '--'; el.className = 'save-ind'; }
}

function loadFromStorage() {
  try {
    const last = localStorage.getItem('bs_lastGame');
    if (last) S.gameId = parseInt(last);
    
    // Check for saved game data
    if (S.gameId) {
      const key = `bs_${S.gameId}`;
      const saved = localStorage.getItem(key);
      if (saved) {
        const data = JSON.parse(saved);
        if (data.events?.length || data.shifts?.length) {
          // Show resume prompt
          showResumePrompt(data);
        }
      }
    }
  } catch(e) { console.log('Error loading from storage:', e); }
}

function showResumePrompt(data) {
  const evtCount = data.events?.length || 0;
  const shiftCount = data.shifts?.length || 0;
  const savedAt = data.savedAt ? new Date(data.savedAt).toLocaleString() : 'unknown';
  
  // Create resume modal dynamically
  const modal = document.createElement('div');
  modal.className = 'overlay show';
  modal.id = 'resumeModal';
  modal.innerHTML = `
    <div class="modal" style="min-width:350px;">
      <h3>üìÇ Resume Session?</h3>
      <p style="font-size:12px;color:var(--muted);margin:12px 0;">Found saved data for this game:</p>
      <div style="background:var(--card);padding:12px;border-radius:4px;margin:12px 0;">
        <div style="display:flex;justify-content:space-between;margin:4px 0;"><span>Events:</span><strong>${evtCount}</strong></div>
        <div style="display:flex;justify-content:space-between;margin:4px 0;"><span>Shifts:</span><strong>${shiftCount}</strong></div>
        <div style="display:flex;justify-content:space-between;margin:4px 0;"><span>Saved:</span><strong>${savedAt}</strong></div>
      </div>
      <div class="modal-actions">
        <button class="btn-success" onclick="resumeSession()">Resume</button>
        <button class="btn-danger" onclick="startNewSession()">Start New</button>
      </div>
    </div>
  `;
  document.body.appendChild(modal);
}

function resumeSession() {
  const key = `bs_${S.gameId}`;
  const saved = localStorage.getItem(key);
  if (saved) {
    const data = JSON.parse(saved);
    S.events = data.events || [];
    S.shifts = data.shifts || [];
    S.evtIdx = data.evtIdx || S.events.length;
    S.shiftIdx = data.shiftIdx || S.shifts.length;
    S.lastSave = data.savedAt ? new Date(data.savedAt) : null;
    
    // v19: Restore zone orientation
    if (data.homeAttacksRightP1 !== undefined) {
      S.homeAttacksRightP1 = data.homeAttacksRightP1;
    }
    if (data.periodLength) {
      S.periodLength = data.periodLength;
    }
    if (data.videoTiming) {
      S.videoTiming = data.videoTiming;
    }
    
    // Update zone labels with restored orientation
    updateZoneLabels();
    
    // Update flip button visual
    const btn = document.getElementById('flipZonesBtn');
    if (btn) {
      btn.style.background = S.homeAttacksRightP1 ? '#374151' : '#7c3aed';
    }
    
    toast(`Restored ${S.events.length} events, ${S.shifts.length} shifts`, 'success');
    renderAll();
    updateSaveIndicator();
    updateNextPlaySuggestions();
  }
  closeResumeModal();
}

function startNewSession() {
  S.events = [];
  S.shifts = [];
  S.evtIdx = 0;
  S.shiftIdx = 0;
  S.lastSave = null;
  
  // Clear saved data
  const key = `bs_${S.gameId}`;
  localStorage.removeItem(key);
  
  toast('Starting new session', 'success');
  renderAll();
  closeResumeModal();
}

function closeResumeModal() {
  const modal = document.getElementById('resumeModal');
  if (modal) modal.remove();
}

function manualSave() {
  if (!S.gameId) { toast('No game loaded', 'error'); return; }
  updateSaveIndicator('saving');
  autoSave();
  toast('Game saved!', 'success');
}

function clearSavedData() {
  if (!S.gameId) return;
  if (!confirm('Clear all saved data for this game? This cannot be undone.')) return;
  
  const key = `bs_${S.gameId}`;
  localStorage.removeItem(key);
  S.events = [];
  S.shifts = [];
  S.evtIdx = 0;
  S.shiftIdx = 0;
  
  toast('Saved data cleared', 'success');
  renderAll();
}

// ============================================================
// BUILD UI
// ============================================================
function buildUI() {
  const grid = document.getElementById('evtTypeGrid');
  // v22.1: Use dynamic event types from Supabase, with "Show More" toggle
  buildEventTypeButtons();
  
  document.getElementById('shiftStartType').innerHTML = LISTS.shiftStart.map(t => `<option value="${t}">${t}</option>`).join('');
  document.getElementById('shiftStopType').innerHTML = LISTS.shiftStop.map(t => `<option value="${t}">${t}</option>`).join('');
  
  ['home','away'].forEach(team => {
    document.getElementById(`${team}F`).innerHTML = ['F1','F2','F3'].map(p => `<div class="slot" data-team="${team}" data-pos="${p}" onclick="selectSlot(this)"><span class="num">${p}</span></div>`).join('');
    document.getElementById(`${team}D`).innerHTML = ['D1','D2'].map(p => `<div class="slot" data-team="${team}" data-pos="${p}" onclick="selectSlot(this)"><span class="num">${p}</span></div>`).join('');
    document.getElementById(`${team}G`).innerHTML = ['G','X'].map(p => `<div class="slot" data-team="${team}" data-pos="${p}" onclick="selectSlot(this)"><span class="num">${p}</span></div>`).join('');
  });
  
  // Edit type dropdown - use dynamic types if available
  buildEditTypeDropdown();
  
  renderXYSlots();
}

// v22.1: Build event type buttons dynamically from dim_event_type
function buildEventTypeButtons() {
  const grid = document.getElementById('evtTypeGrid');
  
  // Main types always shown (common event types)
  const mainTypeCodes = ['Faceoff','Shot','Pass','Goal','Turnover','Zone_Entry_Exit','Stoppage','Penalty','Possession','Save','Rebound','Play'];
  
  // Get types from Supabase or fall back to LISTS.eventTypes
  let allTypes = S.eventTypesDB.length > 0 
    ? S.eventTypesDB.map(e => e.code) 
    : LISTS.eventTypes;
  
  // Separate main and extra types
  const mainTypes = allTypes.filter(t => mainTypeCodes.includes(t));
  const extraTypes = allTypes.filter(t => !mainTypeCodes.includes(t));
  
  // Build main type buttons
  let html = mainTypes.map(t => 
    `<button class="evt-btn" data-type="${t}" onclick="setEvtType('${t}')">${t.replace('_Entry_Exit','')}<kbd>${LISTS.hotkeys[t]||''}</kbd></button>`
  ).join('');
  
  // Add "Show More" button if there are extra types
  if (extraTypes.length > 0) {
    html += `<button class="evt-btn" id="showMoreTypesBtn" onclick="toggleMoreEventTypes()" style="background:var(--surface);border:1px dashed var(--muted);">
      ${S.showAllEventTypes ? '‚óÄ Less' : 'More ‚ñ∂'}
    </button>`;
    
    // Add extra types (hidden by default)
    html += `<div id="extraEventTypes" style="display:${S.showAllEventTypes ? 'contents' : 'none'};">`;
    html += extraTypes.map(t => 
      `<button class="evt-btn" data-type="${t}" onclick="setEvtType('${t}')">${t}<kbd>${LISTS.hotkeys[t]||''}</kbd></button>`
    ).join('');
    html += '</div>';
  }
  
  grid.innerHTML = html;
}

// v22.1: Toggle showing all event types
function toggleMoreEventTypes() {
  S.showAllEventTypes = !S.showAllEventTypes;
  buildEventTypeButtons();
}

// v22.1: Build edit type dropdown with dynamic types
function buildEditTypeDropdown() {
  const dropdown = document.getElementById('editType');
  
  // Get types from Supabase or fall back to LISTS.eventTypes
  const types = S.eventTypesDB.length > 0 
    ? S.eventTypesDB.map(e => e.code) 
    : LISTS.eventTypes;
  
  dropdown.innerHTML = types.map(t => `<option value="${t}">${t}</option>`).join('');
}

// ============================================================
// GAMES & ROSTERS - SUPABASE CONNECTED
// ============================================================
async function loadGames() {
  console.log('loadGames called, S.connected:', S.connected);
  if (S.connected) {
    try {
      console.log('Loading ALL games from dim_schedule...');
      
      // Load ALL games from dim_schedule (not just tracked)
      // Paginate through in case there are many games
      let allGames = [];
      let offset = 0;
      const pageSize = 1000;
      let hasMore = true;
      
      while (hasMore && offset < 50000) {
        console.log(`  Fetching page at offset ${offset}...`);
        const { data, error } = await S.sb.from('dim_schedule')
          .select('game_id,date,home_team_name,away_team_name')
          .order('date', {ascending: false})
          .range(offset, offset + pageSize - 1);
        
        if (error) {
          console.error('Error at offset', offset, ':', error);
          toast('Error loading games: ' + (error.message || error.code), 'error');
          break;
        }
        
        console.log(`  Got ${data?.length || 0} games`);
        
        if (!data || data.length === 0) {
          hasMore = false;
        } else {
          allGames = allGames.concat(data);
          console.log(`  Page ${offset/pageSize + 1}: ${data.length} games (total: ${allGames.length})`);
          offset += pageSize;
          if (data.length < pageSize) hasMore = false;
        }
      }
      
      console.log('Total games from schedule:', allGames.length);
      
      // Dedupe by game_id (in case of any duplicates)
      const gameMap = new Map();
      allGames.forEach(g => {
        if (!gameMap.has(g.game_id)) {
          gameMap.set(g.game_id, {
            game_id: g.game_id,
            game_date: g.date?.split('T')[0] || g.date,
            home_team_name: g.home_team_name,
            away_team_name: g.away_team_name,
            home_team_color: '#3b82f6',
            away_team_color: '#ef4444'
          });
        }
      });
      
      S.games = Array.from(gameMap.values()).sort((a, b) => {
        // Sort by date descending, then by game_id descending
        if (a.game_date !== b.game_date) return b.game_date.localeCompare(a.game_date);
        return b.game_id - a.game_id;
      });
      
      console.log('Final games list:', S.games.length, 'games');
      
      toast(`${S.games.length} games loaded`, 'success');
    } catch(e) { 
      console.error('Failed to load games from Supabase:', e);
      toast('Failed to load games: ' + e.message, 'error');
      S.games = []; 
    }
  } else { 
    S.games = []; 
    toast('Connect to Supabase to load games', 'info');
  }
  
  renderGameSelect(S.games);
  if (S.gameId) document.getElementById('gameSelect').value = S.gameId;
}

function renderGameSelect(games) {
  const sel = document.getElementById('gameSelect');
  sel.innerHTML = '<option value="">-- Select Game (' + games.length + ') --</option>' + games.slice(0, 100).map(g => 
    `<option value="${g.game_id}">${g.game_id}: ${g.home_team_name} vs ${g.away_team_name} (${g.game_date})</option>`
  ).join('');
}

function filterGames(query) {
  if (!query) {
    renderGameSelect(S.games);
    return;
  }
  const q = query.toLowerCase();
  const filtered = S.games.filter(g => 
    g.game_id.toString().includes(q) ||
    g.home_team_name?.toLowerCase().includes(q) ||
    g.away_team_name?.toLowerCase().includes(q) ||
    g.game_date?.includes(q)
  );
  renderGameSelect(filtered);
}

async function selectGame(gid) {
  if (!gid) return;
  S.gameId = parseInt(gid);
  localStorage.setItem('bs_lastGame', gid);
  
  const g = S.games.find(x => x.game_id == gid);
  if (!g) { toast('Game not found', 'error'); return; }
  
  S.homeTeam = g.home_team_name; S.awayTeam = g.away_team_name;
  
  // v15.01: Use cached team data if available, otherwise load from Supabase
  const homeTeamData = S.teams[g.home_team_name];
  const awayTeamData = S.teams[g.away_team_name];
  
  if (homeTeamData && awayTeamData) {
    S.homeColor = homeTeamData.color1 || '#3b82f6';
    S.awayColor = awayTeamData.color1 || '#ef4444';
    S.homeLogo = homeTeamData.logo || null;
    S.awayLogo = awayTeamData.logo || null;
  } else if (S.connected) {
    try {
      const { data: teamData } = await S.sb.from('dim_team')
        .select('team_name,team_color1,team_logo')
        .in('team_name', [g.home_team_name, g.away_team_name]);
      
      if (teamData?.length) {
        const homeTeam = teamData.find(t => t.team_name === g.home_team_name);
        const awayTeam = teamData.find(t => t.team_name === g.away_team_name);
        S.homeColor = homeTeam?.team_color1 || '#3b82f6';
        S.awayColor = awayTeam?.team_color1 || '#ef4444';
        S.homeLogo = homeTeam?.team_logo || null;
        S.awayLogo = awayTeam?.team_logo || null;
      }
    } catch(e) { console.log('Failed to load team colors:', e); }
  }
  console.log('Team colors:', S.homeColor, S.awayColor);
  
  // Update UI with team names (not just Home/Away)
  document.getElementById('homeLbl').textContent = S.homeTeam;
  document.getElementById('awayLbl').textContent = S.awayTeam;
  document.getElementById('evtHomeLbl').textContent = S.homeTeam;
  document.getElementById('evtAwayLbl').textContent = S.awayTeam;
  document.getElementById('homeDot').style.background = S.homeColor;
  document.getElementById('awayDot').style.background = S.awayColor;
  document.documentElement.style.setProperty('--home', S.homeColor);
  document.documentElement.style.setProperty('--away', S.awayColor);
  
  // v15.01: Update team logos if elements exist
  const homeLogoEl = document.getElementById('homeLogoImg');
  const awayLogoEl = document.getElementById('awayLogoImg');
  if (homeLogoEl) homeLogoEl.src = S.homeLogo || '';
  if (awayLogoEl) awayLogoEl.src = S.awayLogo || '';
  
  // Update zone labels on rink (based on current period)
  updateZoneLabels();
  
  await loadRosters(gid);
  loadGameData(gid);
  renderAll();
  toast(`Loaded: ${S.homeTeam} vs ${S.awayTeam}`, 'success');
}

async function loadRosters(gid) {
  if (!S.connected) { 
    generateDemoRosters(); 
    toast('Demo rosters loaded (not connected)', 'info');
    return;
  }
  
  try {
    // Query fact_gameroster for this game
    // Note: player_rating not in table, will be null
    const { data, error } = await S.sb.from('fact_gameroster')
      .select('player_id,player_game_number,player_full_name,player_position,team_venue')
      .eq('game_id', gid)
      .order('player_game_number');
    
    if (error) {
      console.error('Roster query error:', error);
      throw error;
    }
    
    console.log('Raw roster data for game', gid, ':', data?.length, 'players');
    
    if (!data || data.length === 0) {
      // Try alternate column names
      console.log('No data with standard columns, trying alternate...');
      const { data: altData, error: altErr } = await S.sb.from('fact_gameroster')
        .select('*')
        .eq('game_id', gid)
        .limit(50);
      
      if (altErr) throw altErr;
      
      if (altData?.length > 0) {
        console.log('Alt data columns:', Object.keys(altData[0]));
        
        // Try to map alternate column names
        const homeMap = new Map();
        const awayMap = new Map();
        
        altData.forEach(p => {
          const venue = p.team_venue || p.venue || p.team || '';
          const isHome = venue.toLowerCase().includes('home');
          const map = isHome ? homeMap : awayMap;
          const playerId = p.player_id || p.id || '';
          
          if (!map.has(playerId)) {
            map.set(playerId, {
              id: playerId,
              num: String(p.player_game_number || p.jersey_number || p.number || '?'),
              name: p.player_full_name || p.full_name || p.name || 'Unknown',
              pos: normalizePosition(p.player_position || p.position),
              rating: p.player_rating || p.rating || null
            });
          }
        });
        
        S.rosters = {
          home: Array.from(homeMap.values()).sort((a,b) => parseInt(a.num) - parseInt(b.num)),
          away: Array.from(awayMap.values()).sort((a,b) => parseInt(a.num) - parseInt(b.num))
        };
      } else {
        console.log('No roster data found for game', gid);
        generateDemoRosters();
        toast('No roster data - using demo', 'warning');
        return;
      }
    } else {
      // Standard processing - v15: Case-insensitive team_venue check
      const homeMap = new Map();
      const awayMap = new Map();
      
      data.forEach(p => {
        const venue = (p.team_venue || '').toLowerCase();
        const map = venue === 'home' ? homeMap : awayMap;
        if (!map.has(p.player_id)) {
          map.set(p.player_id, { 
            id: p.player_id, 
            num: String(p.player_game_number), 
            name: p.player_full_name, 
            pos: normalizePosition(p.player_position),
            rating: null  // Not in fact_gameroster
          });
        }
      });
      
      S.rosters = { 
        home: Array.from(homeMap.values()).sort((a,b) => parseInt(a.num) - parseInt(b.num)),
        away: Array.from(awayMap.values()).sort((a,b) => parseInt(a.num) - parseInt(b.num))
      };
    }
    
    console.log('Final rosters:', S.rosters.home.length, 'home,', S.rosters.away.length, 'away');
    
    if (S.rosters.home.length === 0 && S.rosters.away.length === 0) {
      toast('No players found for this game', 'warning');
      generateDemoRosters();
    } else {
      toast(`Loaded ${S.rosters.home.length + S.rosters.away.length} players`, 'success');
    }
  } catch(e) { 
    console.error('Failed to load rosters:', e);
    toast('Roster load failed: ' + e.message, 'error');
    generateDemoRosters(); 
  }
}

function generateDemoRosters() {
  S.rosters = {
    home: Array.from({length:12}, (_,i) => ({id:'H'+(i+1), num:String(i+1), name:'Home'+i, pos:i<6?'F':i<10?'D':'G'})),
    away: Array.from({length:12}, (_,i) => ({id:'A'+(i+1), num:String(i+11), name:'Away'+i, pos:i<6?'F':i<10?'D':'G'}))
  };
}

/**
 * Normalize position string to F/D/G format
 * @param {string} pos - Raw position string from database
 * @returns {string} - Normalized position (F, D, or G)
 */
function normalizePosition(pos) {
  if (!pos) return 'F';
  const p = String(pos).toLowerCase().trim();
  if (p === 'g' || p === 'goal' || p === 'goalie' || p === 'goalkeeper' || p === 'goaltender') return 'G';
  if (p === 'd' || p === 'def' || p === 'defense' || p === 'defenseman' || p === 'defenceman') return 'D';
  return 'F'; // Forward by default
}

function loadGameData(gid) {
  try {
    const saved = localStorage.getItem(`bs_${gid}`);
    if (saved) {
      const d = JSON.parse(saved);
      S.events = d.events || []; 
      S.shifts = d.shifts || [];
      S.evtIdx = d.evtIdx || S.events.length; 
      S.shiftIdx = d.shiftIdx || S.shifts.length;
      
      // Restore video timing if saved
      if (d.videoTiming) {
        S.videoTiming = { ...S.videoTiming, ...d.videoTiming };
      }
      if (d.periodLength) {
        S.periodLength = d.periodLength;
      }
    } else {
      S.events = []; S.shifts = []; S.evtIdx = 0; S.shiftIdx = 0;
      // Reset video timing to defaults for new game
      S.videoTiming = {
        videoStartOffset: 0,
        intermission1: 900,
        intermission2: 900,
        timeouts: [],
        youtubeUrl: ''
      };
    }
  } catch(e) { 
    S.events = []; S.shifts = []; S.evtIdx = 0; S.shiftIdx = 0; 
  }
}

// ============================================================
// ZONE AUTO-CALCULATION (switches by period)
// ============================================================
function calculateZone() {
  // Get event_player_1's last XY position
  const evtP1 = S.curr.players.find(p => p.role === 'event_team_player_1');
  if (!evtP1?.xy?.length) return '';
  
  const lastXY = evtP1.xy[evtP1.xy.length - 1];
  if (!lastXY) return '';
  
  // NHL Rink: 200 wide
  // Blue lines at x=75 and x=125 (correct NHL dimensions)
  // 0-75 = left zone, 75-125 = neutral, 125-200 = right zone
  // Use S.homeAttacksRightP1 to determine initial orientation
  // Odd periods (1, 3, OT): Use P1 setting
  // Even periods (2): Flip from P1 setting
  const x = lastXY.x;
  const isOddPeriod = S.period === 1 || S.period === 3 || S.period === 'OT';
  
  // Determine which end is offensive for each team based on configurable setting
  const homeOffensiveRight = isOddPeriod ? S.homeAttacksRightP1 : !S.homeAttacksRightP1;
  
  if (S.evtTeam === 'home') {
    if (homeOffensiveRight) {
      if (x > 125) return 'o';      // Home offensive (right in odd periods)
      else if (x < 75) return 'd';  // Home defensive (left in odd periods)
      else return 'n';
    } else {
      if (x < 75) return 'o';       // Home offensive (left in even periods)
      else if (x > 125) return 'd'; // Home defensive (right in even periods)
      else return 'n';
    }
  } else {
    // Away team is opposite
    if (homeOffensiveRight) {
      if (x < 75) return 'o';       // Away offensive (left in odd periods)
      else if (x > 125) return 'd'; // Away defensive (right in odd periods)
      else return 'n';
    } else {
      if (x > 125) return 'o';      // Away offensive (right in even periods)
      else if (x < 75) return 'd';  // Away defensive (left in even periods)
      else return 'n';
    }
  }
}

function updateZoneLabels() {
  // Update zone labels on rink based on period and configurable setting
  const isOddPeriod = S.period === 1 || S.period === 3 || S.period === 'OT';
  const homeOffensiveRight = isOddPeriod ? S.homeAttacksRightP1 : !S.homeAttacksRightP1;
  const homeShort = (S.homeTeam || 'HOME').toUpperCase().slice(0,6);
  const awayShort = (S.awayTeam || 'AWAY').toUpperCase().slice(0,6);
  
  if (homeOffensiveRight) {
    // Home attacks right
    document.getElementById('leftZoneLbl').textContent = awayShort + ' OFF';
    document.getElementById('rightZoneLbl').textContent = homeShort + ' OFF';
  } else {
    // Home attacks left
    document.getElementById('leftZoneLbl').textContent = homeShort + ' OFF';
    document.getElementById('rightZoneLbl').textContent = awayShort + ' OFF';
  }
}

/**
 * v16: Update team logos in UI
 */
function updateTeamLogos() {
  // Update existing logo img elements
  const homeLogoImg = document.getElementById('homeLogoImg');
  const awayLogoImg = document.getElementById('awayLogoImg');
  
  if (homeLogoImg) {
    if (S.homeLogo) {
      homeLogoImg.src = S.homeLogo;
      homeLogoImg.alt = S.homeTeam;
      homeLogoImg.style.display = 'inline';
    } else {
      homeLogoImg.style.display = 'none';
    }
  }
  
  if (awayLogoImg) {
    if (S.awayLogo) {
      awayLogoImg.src = S.awayLogo;
      awayLogoImg.alt = S.awayTeam;
      awayLogoImg.style.display = 'inline';
    } else {
      awayLogoImg.style.display = 'none';
    }
  }
  
  // Update team dots with team colors
  const homeDot = document.getElementById('homeDot');
  const awayDot = document.getElementById('awayDot');
  if (homeDot) homeDot.style.backgroundColor = S.homeColor || '#3b82f6';
  if (awayDot) awayDot.style.backgroundColor = S.awayColor || '#ef4444';
}

function updateZoneDisplay() {
  const zone = document.getElementById('evtZone').value || calculateZone();
  const el = document.getElementById('zoneDisplay');
  if (zone) {
    const labels = { o: 'OFFENSIVE', d: 'DEFENSIVE', n: 'NEUTRAL' };
    el.innerHTML = `<span class="zone-ind ${zone}">${labels[zone]}</span>`;
  } else { el.innerHTML = ''; }
}

// ============================================================
// SUCCESS AUTO-DERIVATION
// ============================================================
function deriveSuccess() {
  const type = S.curr.type;
  const d1 = document.getElementById('evtD1').value;
  
  // Auto-derive based on event type and detail
  if (type === 'Shot') {
    if (d1.includes('OnNet') || d1.includes('Goal')) return 's';
    if (d1.includes('Missed') || d1.includes('Blocked')) return 'u';
  }
  if (type === 'Pass') {
    if (d1.includes('Completed')) return 's';
    if (d1.includes('Missed') || d1.includes('Intercepted')) return 'u';
  }
  if (type === 'Zone_Entry_Exit') {
    if (d1.includes('Failed')) return 'u';
    if (d1.includes('Entry') || d1.includes('Exit') || d1.includes('Keepin')) return 's';
  }
  if (type === 'Turnover') {
    if (d1.includes('Takeaway')) return 's';
    if (d1.includes('Giveaway')) return 'u';
  }
  if (type === 'Goal') return 's';
  if (type === 'Save') return 's';
  
  return '';
}

/**
 * v16.06: Auto-derive play success for all players based on event success
 * Event team player 1 gets the event success
 * Opposing players get inverse if applicable
 */
function derivePlayerSuccess() {
  const evtSuccess = document.getElementById('evtSuccess').value;
  if (!evtSuccess) return;
  
  S.curr.players.forEach(p => {
    if (p.role === 'event_player_1') {
      // Primary player gets event success
      p.playSuccess = evtSuccess;
    } else if (p.role?.startsWith('event')) {
      // Secondary event players - often also successful if event was
      p.playSuccess = evtSuccess;
    } else if (p.role?.startsWith('opp')) {
      // Opponent players - inverse success for turnovers
      const type = S.curr.type;
      if (type === 'Turnover') {
        p.playSuccess = evtSuccess === 's' ? 'u' : 's';
      }
    }
  });
  
  renderCurrentPlayers();
  toast('Play success auto-derived from event success', 'info');
}

/**
 * v16.06: Auto-calc pressure for selected player
 */
function autoCalcPressure() {
  detectPressure();
  if (S.selectedPlayer) {
    const pressureSel = document.getElementById('pdPressure');
    if (pressureSel && S.selectedPlayer.pressure) {
      pressureSel.value = S.selectedPlayer.pressure;
      toast(`Pressure set to #${S.selectedPlayer.pressure}`, 'info');
    } else {
      toast('No opponent within pressure distance', 'warning');
    }
  }
}

// ============================================================
// PRESSURE AUTO-DETECTION
// ============================================================
function detectPressure() {
  const pressureDist = parseInt(document.getElementById('pressureDist').value) || 10;
  const pixelsPerFoot = 1; // Adjust based on rink scale (200px = 200ft)
  const threshold = pressureDist * pixelsPerFoot;
  
  // For each event player, check distance to opposing players
  const evtPlayers = S.curr.players.filter(p => p.role?.startsWith('event'));
  const oppPlayers = S.curr.players.filter(p => p.role?.startsWith('opp'));
  
  evtPlayers.forEach(ep => {
    if (!ep.xy?.length) return;
    const epPos = ep.xy[ep.xy.length - 1];
    
    let closestOpp = null;
    let closestDist = Infinity;
    
    oppPlayers.forEach(op => {
      if (!op.xy?.length) return;
      const opPos = op.xy[op.xy.length - 1];
      
      const dist = Math.sqrt(Math.pow(epPos.x - opPos.x, 2) + Math.pow(epPos.y - opPos.y, 2));
      if (dist <= threshold && dist < closestDist) {
        closestDist = dist;
        closestOpp = op;
      }
    });
    
    // v16.06: Auto-set pressure if closest opponent is within threshold
    if (closestOpp) {
      ep.pressure = closestOpp.num;
    }
  });
  
  // Update pressure dropdown if a player is selected
  if (S.selectedPlayer && S.selectedPlayer.role?.startsWith('event')) {
    const pressureSel = document.getElementById('pdPressure');
    if (pressureSel && S.selectedPlayer.pressure) {
      pressureSel.value = S.selectedPlayer.pressure;
    }
  }
}

// ============================================================
// RENDER FUNCTIONS
// ============================================================
function renderAll() {
  renderSlots(); 
  renderRosters(); 
  renderQuickAdd(); 
  renderEvents(); 
  renderMarkers(); 
  updateScores(); 
  updateZoneDisplay(); 
  renderShiftLog(); 
  updateBoxScore();
  updateNextPlaySuggestions();
  updateZoneLabels();
}

function renderShiftLog() {
  const body = document.getElementById('shiftLogBody');
  if (!body) return;
  
  // v6: Filter by period
  let filteredShifts = S.shifts;
  if (S.shiftLogFilter && S.shiftLogFilter !== 'all') {
    filteredShifts = S.shifts.filter(s => String(s.period) === S.shiftLogFilter);
  }
  
  // v6: Show up to 50 shifts (scrollable) in ASCENDING order (oldest to newest)
  const displayShifts = filteredShifts.slice(-50);
  const startIdx = filteredShifts.length - displayShifts.length;
  
  body.innerHTML = displayShifts.map((s, i) => {
    const actualIdx = S.shifts.indexOf(s); // Get actual index in full array
    const stoppageTime = s.stoppageTime || 0;
    const stoppageDisplay = stoppageTime > 0 ? `<span style="color:var(--warn);font-size:7px;">${stoppageTime}s</span>` : '';
    
    // Count players
    const homeCount = ['F1','F2','F3','D1','D2','X'].filter(p => s.home?.[p]?.num).length;
    const awayCount = ['F1','F2','F3','D1','D2','X'].filter(p => s.away?.[p]?.num).length;
    const strength = s.strength || `${homeCount}v${awayCount}`;
    
    return `<div class="log-item" style="grid-template-columns: 20px 20px 32px 32px 35px 40px 20px;font-size:8px;cursor:pointer;" onclick="editShift(${actualIdx})" title="Shift #${actualIdx+1} | ${strength} | Stoppage: ${stoppageTime}s">
      <span>${actualIdx + 1}</span>
      <span>P${s.period}</span>
      <span>${s.start_time}</span>
      <span>${s.end_time}</span>
      <span style="color:var(--accent);">${strength}</span>
      <span style="overflow:hidden;text-overflow:ellipsis;font-size:7px;">${s.stop_type || ''}</span>
      ${stoppageDisplay}
    </div>`;
  }).join('') || '<div style="color:var(--muted);font-size:8px;padding:4px;">No shifts</div>';
}

function editShift(idx) {
  S.editingShiftIdx = idx;
  const shift = S.shifts[idx];
  if (!shift) return;
  
  // Populate dropdowns first
  document.getElementById('editShiftStartType').innerHTML = LISTS.shiftStart.map(t => 
    `<option value="${t}" ${shift.start_type === t ? 'selected' : ''}>${t}</option>`
  ).join('');
  document.getElementById('editShiftStopType').innerHTML = LISTS.shiftStop.map(t => 
    `<option value="${t}" ${shift.stop_type === t ? 'selected' : ''}>${t}</option>`
  ).join('');
  
  // Populate edit shift modal
  document.getElementById('editShiftIdx').textContent = idx + 1;
  document.getElementById('editShiftPeriod').value = shift.period;
  document.getElementById('editShiftStartTime').value = shift.start_time;
  document.getElementById('editShiftEndTime').value = shift.end_time;
  document.getElementById('editShiftStrength').value = shift.strength || '5v5';
  
  // Render players
  renderEditShiftPlayers(shift);
  
  document.getElementById('editShiftModal').classList.add('show');
}

function deriveShiftStartType(idx) {
  // Auto-derive start type from previous event/shift
  if (idx === 0) return 'GameStart';
  
  const prevShift = S.shifts[idx - 1];
  if (prevShift?.stop_type === 'GoalScored') return 'FaceoffAfterGoal';
  if (prevShift?.stop_type === 'Penalty') return 'FaceoffAfterPenalty';
  if (prevShift?.stop_type === 'PeriodEnd') return 'PeriodStart';
  if (prevShift?.stop_type === 'Intermission') return 'PeriodStart';
  
  // Check last event
  const lastEvt = S.events.filter(e => e.period === S.period).slice(-1)[0];
  if (lastEvt?.type === 'Goal') return 'FaceoffAfterGoal';
  if (lastEvt?.type === 'Penalty') return 'FaceoffAfterPenalty';
  if (lastEvt?.type === 'Stoppage') return 'Stoppage';
  
  return 'OnTheFly';
}

function deriveShiftStopType() {
  // Auto-derive stop type from last event in shift
  const lastEvt = S.events.filter(e => e.period === S.period).slice(-1)[0];
  if (!lastEvt) return 'OnTheFly';
  
  if (lastEvt.type === 'Goal' && lastEvt.detail1 === 'Goal_Scored') return 'GoalScored';
  if (lastEvt.type === 'Penalty') return 'Penalty';
  if (lastEvt.type === 'Stoppage') return 'Stoppage';
  if (lastEvt.type === 'Intermission') return 'Intermission';
  
  return 'OnTheFly';
}

function saveEditShift() {
  if (S.editingShiftIdx === null) return;
  const shift = S.shifts[S.editingShiftIdx];
  
  shift.period = parseInt(document.getElementById('editShiftPeriod').value);
  shift.start_time = document.getElementById('editShiftStartTime').value;
  shift.end_time = document.getElementById('editShiftEndTime').value;
  shift.start_type = document.getElementById('editShiftStartType').value;
  shift.stop_type = document.getElementById('editShiftStopType').value;
  
  closeEditShiftModal();
  renderShiftLog();
  autoSave();
  toast('Shift updated', 'success');
}

function deleteShift() {
  if (S.editingShiftIdx === null) return;
  if (!confirm('Delete this shift?')) return;
  
  S.shifts.splice(S.editingShiftIdx, 1);
  closeEditShiftModal();
  renderShiftLog();
  autoSave();
  toast('Shift deleted', 'success');
}

/**
 * v20.6: Insert a new shift BEFORE the current one
 */
function insertShiftBefore() {
  if (S.editingShiftIdx === null) return;
  
  const currentShift = S.shifts[S.editingShiftIdx];
  const prevShift = S.editingShiftIdx > 0 ? S.shifts[S.editingShiftIdx - 1] : null;
  
  // Create new shift with interpolated times
  const newShift = {
    period: currentShift.period,
    start_time: prevShift ? prevShift.end_time : currentShift.start_time,
    end_time: currentShift.start_time,
    start_type: prevShift ? deriveShiftStartType(S.editingShiftIdx) : 'OnTheFly',
    stop_type: 'OnTheFly',
    strength: '5v5',
    home: { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null },
    away: { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null }
  };
  
  // Insert at position
  S.shifts.splice(S.editingShiftIdx, 0, newShift);
  
  // Update current index to point to newly inserted shift
  const newIdx = S.editingShiftIdx;
  S.editingShiftIdx = null; // Clear to allow re-edit
  
  closeEditShiftModal();
  renderShiftLog();
  autoSave();
  toast(`Inserted shift #${newIdx + 1}`, 'success');
  
  // Open the new shift for editing
  setTimeout(() => editShift(newIdx), 100);
}

/**
 * v20.6: Insert a new shift AFTER the current one
 */
function insertShiftAfter() {
  if (S.editingShiftIdx === null) return;
  
  const currentShift = S.shifts[S.editingShiftIdx];
  const nextShift = S.editingShiftIdx < S.shifts.length - 1 ? S.shifts[S.editingShiftIdx + 1] : null;
  
  // Create new shift with interpolated times
  const newShift = {
    period: currentShift.period,
    start_time: currentShift.end_time,
    end_time: nextShift ? nextShift.start_time : currentShift.end_time,
    start_type: deriveShiftStartType(S.editingShiftIdx + 1),
    stop_type: 'OnTheFly',
    strength: '5v5',
    home: { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null },
    away: { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null }
  };
  
  // Insert after current position
  const insertIdx = S.editingShiftIdx + 1;
  S.shifts.splice(insertIdx, 0, newShift);
  
  S.editingShiftIdx = null; // Clear to allow re-edit
  
  closeEditShiftModal();
  renderShiftLog();
  autoSave();
  toast(`Inserted shift #${insertIdx + 1}`, 'success');
  
  // Open the new shift for editing
  setTimeout(() => editShift(insertIdx), 100);
}

/**
 * v20.6: Duplicate the current shift
 */
function duplicateShift() {
  if (S.editingShiftIdx === null) return;
  
  const currentShift = S.shifts[S.editingShiftIdx];
  
  // Deep clone the shift
  const newShift = JSON.parse(JSON.stringify(currentShift));
  
  // Insert after current position
  const insertIdx = S.editingShiftIdx + 1;
  S.shifts.splice(insertIdx, 0, newShift);
  
  S.editingShiftIdx = null;
  
  closeEditShiftModal();
  renderShiftLog();
  autoSave();
  toast(`Duplicated shift ‚Üí #${insertIdx + 1}`, 'success');
  
  // Open the new shift for editing
  setTimeout(() => editShift(insertIdx), 100);
}

/**
 * v20.6: Add a new shift at the end of the list
 */
function addNewShift() {
  const lastShift = S.shifts.length > 0 ? S.shifts[S.shifts.length - 1] : null;
  
  // Create new shift
  const newShift = {
    period: lastShift ? lastShift.period : S.period || 1,
    start_time: lastShift ? lastShift.end_time : '20:00',
    end_time: '',
    start_type: lastShift ? deriveShiftStartType(S.shifts.length) : 'GameStart',
    stop_type: '',
    strength: '5v5',
    home: { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null },
    away: { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null }
  };
  
  // Add to end
  S.shifts.push(newShift);
  const newIdx = S.shifts.length - 1;
  
  renderShiftLog();
  autoSave();
  toast(`Added shift #${newIdx + 1}`, 'success');
  
  // Open the new shift for editing
  setTimeout(() => editShift(newIdx), 100);
}

function closeEditShiftModal() {
  document.getElementById('editShiftModal').classList.remove('show');
  S.editingShiftIdx = null;
}

function showAllShifts() {
  // Show all shifts modal
  const body = document.getElementById('allShiftsBody');
  body.innerHTML = S.shifts.map((s, i) => `
    <tr onclick="editShift(${i})" style="cursor:pointer;">
      <td>${i + 1}</td>
      <td>P${s.period}</td>
      <td>${s.start_time}</td>
      <td>${s.end_time}</td>
      <td>${s.start_type}</td>
      <td>${s.stop_type}</td>
      <td>${s.strength || '-'}</td>
    </tr>
  `).join('') || '<tr><td colspan="7">No shifts</td></tr>';
  
  document.getElementById('allShiftsModal').classList.add('show');
}

function showAllEvents() {
  // Show all events modal
  const body = document.getElementById('allEventsBody');
  body.innerHTML = S.events.map((e, i) => `
    <tr onclick="editEvent(${i})" style="cursor:pointer;">
      <td>${i + 1}</td>
      <td>P${e.period}</td>
      <td>${e.start_time || e.time}</td>
      <td>${e.team === 'home' ? S.homeTeam : S.awayTeam}</td>
      <td>${e.type}</td>
      <td>${e.detail1 || ''}</td>
      <td>${e.players?.map(p => p.num).join(',') || ''}</td>
    </tr>
  `).join('') || '<tr><td colspan="7">No events</td></tr>';
  
  document.getElementById('allEventsModal').classList.add('show');
}

function updateBoxScore() {
  // Update team names
  document.getElementById('teamSumHome').textContent = S.homeTeam?.slice(0,8) || 'HOME';
  document.getElementById('teamSumAway').textContent = S.awayTeam?.slice(0,8) || 'AWAY';
  
  // v7: Calculate player stats - ONLY count event_player_1 for most stats
  const playerStats = {};
  
  // Initialize players from rosters with their correct team
  [...(S.rosters?.home || [])].forEach(p => {
    if (p?.num && !playerStats[p.num]) {
      playerStats[p.num] = { 
        num: p.num, name: p.name?.split(' ').pop() || p.name, team: 'home',
        goals: 0, assists: 0, shots: 0, faceoffs: 0, foWins: 0, foLosses: 0
      };
    }
  });
  [...(S.rosters?.away || [])].forEach(p => {
    if (p?.num && !playerStats[p.num]) {
      playerStats[p.num] = { 
        num: p.num, name: p.name?.split(' ').pop() || p.name, team: 'away',
        goals: 0, assists: 0, shots: 0, faceoffs: 0, foWins: 0, foLosses: 0
      };
    }
  });
  
  S.events.forEach(evt => {
    // v7: ONLY count event_player_1 for goals, shots
    const player1 = evt.players?.find(p => 
      p.role === 'event_team_player_1' || p.role === 'event_player_1'
    );
    const oppPlayer1 = evt.players?.find(p => 
      p.role === 'opp_team_player_1' || p.role === 'opp_player_1'
    );
    
    // Initialize player1 stats if needed
    if (player1?.num && !playerStats[player1.num]) {
      playerStats[player1.num] = { 
        num: player1.num, name: player1.name?.split(' ').pop() || player1.name, team: evt.team,
        goals: 0, assists: 0, shots: 0, faceoffs: 0, foWins: 0, foLosses: 0
      };
    }
    
    if (player1?.num) {
      const ps = playerStats[player1.num];
      // Goals - only event_player_1 on Goal events where detail1 = Goal_Scored
      if (evt.type === 'Goal' && (evt.detail1 === 'Goal_Scored' || evt.detail1 === 'Goal_Shootout' || evt.detail1 === 'Goal_PenaltyShot')) ps.goals++;
      // v15.01: SOG - only shots that reached the net (Shot_OnNetSaved, Shot_OnNetGoal) or Goals
      const d1 = (evt.detail1 || '').toLowerCase();
      if (d1.includes('shot_onnetsaved') || d1.includes('shot_onnetgoal') || d1.includes('goal_scored') || d1.includes('goal_shootout') || d1.includes('goal_penaltyshot')) {
        ps.shots++;
      }
      // v7: Faceoffs - event_player_1 gets FO WIN
      if (evt.type === 'Faceoff') { ps.faceoffs++; ps.foWins++; }
    }
    
    // v7: Faceoff LOSS for opp_player_1
    if (evt.type === 'Faceoff' && oppPlayer1?.num) {
      if (!playerStats[oppPlayer1.num]) {
        const oppTeam = evt.team === 'home' ? 'away' : 'home';
        playerStats[oppPlayer1.num] = { 
          num: oppPlayer1.num, name: oppPlayer1.name?.split(' ').pop() || oppPlayer1.name, team: oppTeam,
          goals: 0, assists: 0, shots: 0, faceoffs: 0, foWins: 0, foLosses: 0
        };
      }
      playerStats[oppPlayer1.num].faceoffs++;
      playerStats[oppPlayer1.num].foLosses++;
    }
    
    // v7: Assists - check for '%assist%' in play_detail_1 or play_detail_2
    evt.players?.forEach(p => {
      if (!p?.num) return;
      const pd1 = (p.playD1 || '').toLowerCase();
      const pd2 = (p.playD2 || '').toLowerCase();
      if (pd1.includes('assist') || pd2.includes('assist')) {
        if (!playerStats[p.num]) {
          playerStats[p.num] = { 
            num: p.num, name: p.name?.split(' ').pop() || p.name, team: evt.team,
            goals: 0, assists: 0, shots: 0, faceoffs: 0, foWins: 0, foLosses: 0
          };
        }
        playerStats[p.num].assists++;
      }
    });
  });
  
  // v7: Organize by team, sort by points
  const homePlayers = Object.values(playerStats)
    .filter(p => p.team === 'home' && (p.goals > 0 || p.assists > 0 || p.shots > 0 || p.faceoffs > 0))
    .sort((a, b) => (b.goals + b.assists) - (a.goals + a.assists) || b.goals - a.goals);
  const awayPlayers = Object.values(playerStats)
    .filter(p => p.team === 'away' && (p.goals > 0 || p.assists > 0 || p.shots > 0 || p.faceoffs > 0))
    .sort((a, b) => (b.goals + b.assists) - (a.goals + a.assists) || b.goals - a.goals);
  
  // Render player box score organized by team
  const tbody = document.getElementById('playerBoxBody');
  let html = '';
  
  // Home players section
  if (homePlayers.length > 0) {
    html += `<tr style="background:rgba(59,130,246,0.15);"><td colspan="6" style="font-size:9px;color:var(--home);font-weight:bold;">${S.homeTeam || 'HOME'}</td></tr>`;
    html += homePlayers.slice(0, 5).map(p => {
      const foPct = p.faceoffs > 0 ? `${p.foWins}/${p.faceoffs}` : '-';
      return `<tr onclick="showPlayerDetail('${p.num}')" style="cursor:pointer;">
        <td>${p.num}</td>
        <td style="max-width:50px;overflow:hidden;text-overflow:ellipsis;">${p.name}</td>
        <td style="font-weight:${p.goals>0?'bold':'normal'};">${p.goals}</td>
        <td>${p.assists}</td>
        <td>${p.shots}</td>
        <td style="font-size:9px;">${foPct}</td>
      </tr>`;
    }).join('');
  }
  
  // Away players section
  if (awayPlayers.length > 0) {
    html += `<tr style="background:rgba(239,68,68,0.15);"><td colspan="6" style="font-size:9px;color:var(--away);font-weight:bold;">${S.awayTeam || 'AWAY'}</td></tr>`;
    html += awayPlayers.slice(0, 5).map(p => {
      const foPct = p.faceoffs > 0 ? `${p.foWins}/${p.faceoffs}` : '-';
      return `<tr onclick="showPlayerDetail('${p.num}')" style="cursor:pointer;">
        <td>${p.num}</td>
        <td style="max-width:50px;overflow:hidden;text-overflow:ellipsis;">${p.name}</td>
        <td style="font-weight:${p.goals>0?'bold':'normal'};">${p.goals}</td>
        <td>${p.assists}</td>
        <td>${p.shots}</td>
        <td style="font-size:9px;">${foPct}</td>
      </tr>`;
    }).join('');
  }
  
  tbody.innerHTML = html || '<tr><td colspan="6" style="color:var(--muted);">No stats yet</td></tr>';
  
  // v16: Team SOG totals - only shots that reached the net (Shot_OnNetSaved, Shot_OnNetGoal) or Goals
  // SOG = event_player_1 events where event_detail = "shot_onnetsaved" OR "shot_onnetgoal" OR goal
  const isSOG = (e) => {
    const d1 = (e.detail1 || '').toLowerCase();
    return d1.includes('shot_onnetsaved') || d1.includes('shot_onnetgoal') || 
           d1.includes('goal_scored') || d1.includes('goal_shootout') || d1.includes('goal_penaltyshot');
  };
  const isGoal = (e) => {
    const d1 = (e.detail1 || '').toLowerCase();
    return e.type === 'Goal' && (d1.includes('goal_scored') || d1.includes('goal_shootout') || d1.includes('goal_penaltyshot'));
  };
  const homeGoals = S.events.filter(e => isGoal(e) && e.team === 'home').length;
  const awayGoals = S.events.filter(e => isGoal(e) && e.team === 'away').length;
  const homeShots = S.events.filter(e => isSOG(e) && e.team === 'home').length;
  const awayShots = S.events.filter(e => isSOG(e) && e.team === 'away').length;
  
  document.getElementById('teamSumHomeScore').textContent = homeGoals;
  document.getElementById('teamSumAwayScore').textContent = awayGoals;
  document.getElementById('teamSumHomeSOG').textContent = homeShots;
  document.getElementById('teamSumAwaySOG').textContent = awayShots;
  
  // v16.02: Update center box score (below events)
  const centerBoxHome = document.getElementById('centerBoxHome');
  const centerBoxAway = document.getElementById('centerBoxAway');
  if (centerBoxHome) centerBoxHome.textContent = S.homeTeam?.slice(0,8) || 'HOME';
  if (centerBoxAway) centerBoxAway.textContent = S.awayTeam?.slice(0,8) || 'AWAY';
  const centerBoxHomeScore = document.getElementById('centerBoxHomeScore');
  const centerBoxAwayScore = document.getElementById('centerBoxAwayScore');
  if (centerBoxHomeScore) centerBoxHomeScore.textContent = homeGoals;
  if (centerBoxAwayScore) centerBoxAwayScore.textContent = awayGoals;
  const centerBoxHomeSOG = document.getElementById('centerBoxHomeSOG');
  const centerBoxAwaySOG = document.getElementById('centerBoxAwaySOG');
  if (centerBoxHomeSOG) centerBoxHomeSOG.textContent = homeShots;
  if (centerBoxAwaySOG) centerBoxAwaySOG.textContent = awayShots;
  
  // Also update header score
  document.getElementById('scoreH').textContent = homeGoals;
  document.getElementById('scoreA').textContent = awayGoals;
}

function showPlayerDetail(num) {
  // Calculate player stats
  const playerStats = calculatePlayerStats();
  const ps = playerStats[num];
  if (!ps) { toast('Player not found', 'error'); return; }
  
  document.getElementById('playerDetailName').textContent = `#${ps.num} ${ps.name}`;
  document.getElementById('pdGoals').textContent = ps.goals;
  document.getElementById('pdAssists').textContent = ps.assists;
  document.getElementById('pdShots').textContent = ps.shots;
  document.getElementById('pdFO').textContent = ps.faceoffs ? Math.round(ps.foWins / ps.faceoffs * 100) + '%' : '-';
  document.getElementById('pdTOI').textContent = formatTOI(ps.toi || 0);
  document.getElementById('pdHits').textContent = ps.hits || 0;
  document.getElementById('pdBlocks').textContent = ps.blocks || 0;
  
  // Recent events for this player
  const recentEvts = S.events.filter(e => e.players?.some(p => p.num === num)).slice(-10);
  document.getElementById('pdRecentEvents').innerHTML = recentEvts.map(e => {
    const role = e.players.find(p => p.num === num)?.role || '';
    return `<div style="padding:2px 0;border-bottom:1px solid var(--border);">P${e.period} ${e.start_time || e.time} - ${e.type} (${role.replace('_team_player_','')})</div>`;
  }).join('') || '<div style="color:var(--muted);">No events</div>';
  
  document.getElementById('playerDetailModal').classList.add('show');
}

function showFullBoxScore() {
  const playerStats = calculatePlayerStats();
  
  // v16: Team totals - only count Goal_Scored for goals, proper SOG calculation
  const isGoal = (e) => {
    const d1 = (e.detail1 || '').toLowerCase();
    return e.type === 'Goal' && (d1.includes('goal_scored') || d1.includes('goal_shootout') || d1.includes('goal_penaltyshot'));
  };
  const isSOG = (e) => {
    const d1 = (e.detail1 || '').toLowerCase();
    return d1.includes('shot_onnetsaved') || d1.includes('shot_onnetgoal') || 
           d1.includes('goal_scored') || d1.includes('goal_shootout') || d1.includes('goal_penaltyshot');
  };
  const homeGoals = S.events.filter(e => isGoal(e) && e.team === 'home').length;
  const awayGoals = S.events.filter(e => isGoal(e) && e.team === 'away').length;
  const homeShots = S.events.filter(e => isSOG(e) && e.team === 'home').length;
  const awayShots = S.events.filter(e => isSOG(e) && e.team === 'away').length;
  const homeFO = S.events.filter(e => e.type === 'Faceoff' && e.team === 'home' && (e.success === 's' || e.success === 'Y')).length;
  const awayFO = S.events.filter(e => e.type === 'Faceoff' && e.team === 'away' && (e.success === 's' || e.success === 'Y')).length;
  
  document.getElementById('boxModalHome').textContent = S.homeTeam;
  document.getElementById('boxModalAway').textContent = S.awayTeam;
  document.getElementById('boxModalHomeScore').textContent = homeGoals;
  document.getElementById('boxModalAwayScore').textContent = awayGoals;
  document.getElementById('boxModalHomeSOG').textContent = homeShots;
  document.getElementById('boxModalAwaySOG').textContent = awayShots;
  document.getElementById('boxModalHomeFO').textContent = homeFO;
  document.getElementById('boxModalAwayFO').textContent = awayFO;
  
  // v6: Organize player table by team (home first, then away), then by points
  const allStats = Object.values(playerStats);
  const homeStats = allStats.filter(p => p.team === 'home').sort((a, b) => 
    (b.goals + b.assists) - (a.goals + a.assists) || b.goals - a.goals
  );
  const awayStats = allStats.filter(p => p.team === 'away').sort((a, b) => 
    (b.goals + b.assists) - (a.goals + a.assists) || b.goals - a.goals
  );
  
  // Build table HTML with team headers
  let tableHtml = '';
  
  // Home team section
  if (homeStats.length > 0) {
    tableHtml += `<tr style="background:var(--home);color:#fff;"><td colspan="9" style="padding:4px 8px;font-weight:bold;">${S.homeTeam || 'HOME'}</td></tr>`;
    tableHtml += homeStats.map(p => {
      const foPct = p.faceoffs ? Math.round(p.foWins / p.faceoffs * 100) : '-';
      return `<tr onclick="showPlayerDetail('${p.num}')" style="cursor:pointer;border-left:3px solid var(--home);">
        <td>${p.num}</td>
        <td>${p.name}</td>
        <td>-</td>
        <td style="font-weight:${p.goals>0?'bold':'normal'};">${p.goals}</td>
        <td>${p.assists}</td>
        <td style="font-weight:bold;">${p.goals + p.assists}</td>
        <td>${p.shots}</td>
        <td>${foPct}${foPct !== '-' ? '%' : ''}</td>
        <td>${formatTOI(p.toi || 0)}</td>
      </tr>`;
    }).join('');
  }
  
  // Away team section
  if (awayStats.length > 0) {
    tableHtml += `<tr style="background:var(--away);color:#fff;"><td colspan="9" style="padding:4px 8px;font-weight:bold;">${S.awayTeam || 'AWAY'}</td></tr>`;
    tableHtml += awayStats.map(p => {
      const foPct = p.faceoffs ? Math.round(p.foWins / p.faceoffs * 100) : '-';
      return `<tr onclick="showPlayerDetail('${p.num}')" style="cursor:pointer;border-left:3px solid var(--away);">
        <td>${p.num}</td>
        <td>${p.name}</td>
        <td>-</td>
        <td style="font-weight:${p.goals>0?'bold':'normal'};">${p.goals}</td>
        <td>${p.assists}</td>
        <td style="font-weight:bold;">${p.goals + p.assists}</td>
        <td>${p.shots}</td>
        <td>${foPct}${foPct !== '-' ? '%' : ''}</td>
        <td>${formatTOI(p.toi || 0)}</td>
      </tr>`;
    }).join('');
  }
  
  document.getElementById('boxModalBody').innerHTML = tableHtml || '<tr><td colspan="9">No stats</td></tr>';
  
  document.getElementById('boxScoreModal').classList.add('show');
}

function calculatePlayerStats() {
  const stats = {};
  
  // Initialize from rosters
  [...S.rosters.home, ...S.rosters.away].forEach(p => {
    stats[p.num] = {
      num: p.num,
      name: p.name,
      team: S.rosters.home.includes(p) ? 'home' : 'away',
      goals: 0, assists: 0, shots: 0, faceoffs: 0, foWins: 0, foLosses: 0, hits: 0, blocks: 0, toi: 0
    };
  });
  
  // v6: Calculate from events - only count event_player_1 for most stats
  S.events.forEach(evt => {
    evt.players?.forEach(p => {
      if (!stats[p.num]) {
        stats[p.num] = { num: p.num, name: p.name, team: evt.team, goals: 0, assists: 0, shots: 0, faceoffs: 0, foWins: 0, foLosses: 0, hits: 0, blocks: 0, toi: 0 };
      }
      const ps = stats[p.num];
      
      // Goals - only event_player_1 is the scorer
      if (evt.type === 'Goal' && evt.detail1 === 'Goal_Scored' && p.role === 'event_player_1') {
        ps.goals++;
      }
      
      // v6: Assists - check for '%assist%' in play_detail1 or play_detail2
      if (evt.type === 'Goal' && evt.detail1 === 'Goal_Scored') {
        const pd1Lower = (p.playD1 || '').toLowerCase();
        const pd2Lower = (p.playD2 || '').toLowerCase();
        if (pd1Lower.includes('assist') || pd2Lower.includes('assist')) {
          ps.assists++;
        }
      }
      
      // Shots - only event_player_1
      if ((evt.type === 'Shot' || evt.type === 'Goal') && p.role === 'event_player_1') {
        ps.shots++;
      }
      
      // v6: Faceoffs - event_player_1 = FO taken for event team
      // FO win = event_player_1 when event success = 's' 
      // FO loss = opp_player_1 on same event (they lost)
      if (evt.type === 'Faceoff') {
        if (p.role === 'event_player_1') {
          ps.faceoffs++;
          if (evt.success === 's' || evt.success === 'Y' || evt.success === true) {
            ps.foWins++;
          } else {
            ps.foLosses++;
          }
        }
        // The opp_player_1 on a faceoff = the opposing center who took the draw
        if (p.role === 'opp_player_1') {
          ps.faceoffs++;
          if (evt.success === 's' || evt.success === 'Y' || evt.success === true) {
            // Event team won, so opp lost
            ps.foLosses++;
          } else {
            // Event team lost, so opp won
            ps.foWins++;
          }
        }
      }
      
      // Hits - only event_player_1
      if (evt.type === 'Hit' && p.role === 'event_player_1') ps.hits++;
      
      // Blocks - opponent blocked the shot
      if (evt.detail1?.includes('Blocked') && p.role?.startsWith('opp')) ps.blocks++;
    });
  });
  
  // Calculate TOI from shifts
  S.shifts.forEach(shift => {
    const duration = parseTime(shift.start_time) - parseTime(shift.end_time);
    if (duration <= 0) return;
    
    ['home', 'away'].forEach(team => {
      ['F1','F2','F3','D1','D2','G','X'].forEach(pos => {
        const p = shift[team]?.[pos];
        if (p?.num && stats[p.num]) {
          stats[p.num].toi += duration;
        }
      });
    });
  });
  
  return stats;
}

function parseTime(timeStr) {
  if (!timeStr) return 0;
  const [min, sec] = timeStr.split(':').map(Number);
  return (min || 0) * 60 + (sec || 0);
}

function formatTOI(seconds) {
  if (!seconds) return '--:--';
  const min = Math.floor(seconds / 60);
  const sec = Math.floor(seconds % 60);
  return `${min}:${sec.toString().padStart(2, '0')}`;
}

function updateNextPlaySuggestions() {
  const lastEvt = S.events[S.events.length - 1];
  const suggestions = lastEvt ? (LISTS.nextEventSuggestions[lastEvt.type] || []) : ['Faceoff'];
  
  document.getElementById('nextPlaySuggestions').innerHTML = suggestions.map(t => 
    `<button class="btn-sm" onclick="selectNextEvent('${t}')" style="margin:0 2px;">${t}</button>`
  ).join('');
  
  // Update linked event dropdown
  updateLinkedEventsDropdown();
}

function selectNextEvent(type) {
  // Get the last event to carry over data
  const lastEvt = S.events[S.events.length - 1];
  
  // Set the event type
  setEvtType(type);
  
  // Carry over all player data if appropriate
  if (lastEvt) {
    // Carry over all players on ice (keep XY positions)
    if (LISTS.linkedEvents[type]?.includes(lastEvt.type)) {
      // Auto-link
      S.linkedEventIdx = lastEvt.idx;
      document.getElementById('linkedEvtSelect').value = lastEvt.idx;
      
      // Copy players with XY
      S.curr.players = lastEvt.players.map(p => ({
        ...p,
        xy: [...(p.xy || [])] // Clone XY array
      }));
      
      // Copy puck XY
      if (lastEvt.puckXY?.length) {
        S.curr.puckXY = [...lastEvt.puckXY];
      }
      
      // Copy zone and time
      document.getElementById('evtZone').value = lastEvt.zone || '';
      document.getElementById('evtStartTime').value = lastEvt.start_time || lastEvt.end_time || '';
    }
    
    // Special cases for role swaps (Shot‚ÜíSave: shooter becomes opp)
    if (type === 'Save' && lastEvt.type === 'Shot') {
      S.curr.players = lastEvt.players.map(p => ({
        ...p,
        role: p.role.startsWith('event') ? p.role.replace('event', 'opp') : p.role.replace('opp', 'event'),
        xy: [...(p.xy || [])]
      }));
      // Swap event team
      S.evtTeam = S.evtTeam === 'home' ? 'away' : 'home';
      updateEvtTeamUI();
    }
  }
  
  renderQuickAdd();
  renderMarkers();
  toast(`${type} - data carried over`, 'success');
}

function updateEvtTeamUI() {
  document.querySelectorAll('.team-toggle button').forEach(b => b.classList.remove('active'));
  document.querySelector(`.team-toggle .${S.evtTeam}`).classList.add('active');
}

function updateLinkedEventsDropdown() {
  const sel = document.getElementById('linkedEvtSelect');
  if (!sel) return;
  
  // Show last 10 events for linking
  const recentEvents = S.events.slice(-10).reverse();
  sel.innerHTML = '<option value="">-- None --</option>' + recentEvents.map(e => {
    const time = e.start_time || e.time || '';
    const players = e.players?.map(p => p.num).join(',') || '';
    return `<option value="${e.idx}">#${e.idx + 1} ${e.type} ${time} [${players}]</option>`;
  }).join('');
  
  // Auto-suggest link based on current event type
  if (S.curr.type && recentEvents.length) {
    const lastEvt = recentEvents[0];
    const canLink = LISTS.linkedEvents[S.curr.type];
    if (canLink && canLink.includes(lastEvt.type)) {
      sel.value = lastEvt.idx;
      S.linkedEventIdx = lastEvt.idx;
      document.getElementById('linkedEvtInfo').textContent = `‚Üê Auto-linked to ${lastEvt.type}`;
      // Apply linked data
      applyLinkedEventData();
    } else {
      document.getElementById('linkedEvtInfo').textContent = '';
    }
  }
}

function onLinkedEvtChange() {
  const val = document.getElementById('linkedEvtSelect').value;
  S.linkedEventIdx = val ? parseInt(val) : null;
  if (S.linkedEventIdx) {
    applyLinkedEventData();
  }
}

// ============================================================
// AUTO BUTTONS
// ============================================================
function autoZone() {
  const zone = calculateZone();
  if (zone) {
    document.getElementById('evtZone').value = zone;
    toast(`Zone: ${zone === 'o' ? 'Offensive' : zone === 'd' ? 'Defensive' : 'Neutral'}`, 'success');
  } else {
    toast('Add player XY to auto-detect zone', 'error');
  }
}

function autoSuccess() {
  const success = deriveSuccess();
  if (success) {
    document.getElementById('evtSuccess').value = success;
    toast(`Success: ${success === 's' ? 'Successful' : 'Unsuccessful'}`, 'success');
  } else {
    toast('Select event type and detail first', 'error');
  }
}

/**
 * v16: Auto-calculate side of puck based on zone and player team
 */
function autoSideOfPuck() {
  if (!S.selectedPlayer) {
    toast('Select a player first', 'error');
    return;
  }
  
  const zone = document.getElementById('evtZone').value;
  if (!zone) {
    toast('Set zone first', 'error');
    return;
  }
  
  // Determine if player is on event team or opponent
  const isEventTeam = S.selectedPlayer.role?.startsWith('event');
  const eventTeam = S.evtTeam; // 'home' or 'away'
  const playerTeam = isEventTeam ? eventTeam : (eventTeam === 'home' ? 'away' : 'home');
  
  // Calculate side of puck relative to player's team
  // If player is home and zone is offensive (attacking their opponent's goal), they're offensive
  // Zone is always from the event team's perspective
  let sideOfPuck;
  if (playerTeam === eventTeam) {
    // Same team as event - zone matches directly
    sideOfPuck = zone === 'o' ? 'Offensive' : (zone === 'd' ? 'Defensive' : '');
  } else {
    // Opponent team - zone is inverted
    sideOfPuck = zone === 'o' ? 'Defensive' : (zone === 'd' ? 'Offensive' : '');
  }
  
  if (sideOfPuck) {
    document.getElementById('pdSideOfPuck').value = sideOfPuck;
    updatePlayerDetail('sideOfPuck', sideOfPuck);
    toast(`Side of puck: ${sideOfPuck}`, 'success');
  } else {
    toast('Could not determine side (neutral zone)', 'info');
  }
}

function autoStrength() {
  const strength = deriveStrength();
  if (strength) {
    document.getElementById('evtStrength').value = strength;
    toast(`Strength: ${strength}`, 'success');
  } else {
    toast('Fill player slots first', 'error');
  }
}

function updatePlayD2() {
  // Update Play Detail 2 dropdown based on Play Detail 1
  if (!S.selectedPlayer) return;
  
  const d1 = document.getElementById('pdPlayD1').value;
  // v15.02: Use S.playDetails2 from dim_play_detail_2 for second dropdown
  // These are independent of the first dropdown selection
  const pd2Opts = S.playDetails2?.length > 0 
    ? S.playDetails2.map(p => p.name) 
    : [];
  
  // v16.02: Use datalist for searchable dropdown
  document.getElementById('pdPlayD2List').innerHTML = pd2Opts.map(o => `<option value="${o}">`).join('');
}

function deriveStrength() {
  // Count players on ice (excluding empty slots)
  const homeOnIce = Object.values(S.slots.home).filter(Boolean).length;
  const awayOnIce = Object.values(S.slots.away).filter(Boolean).length;
  
  // Check for goalie
  const homeHasGoalie = !!S.slots.home.G;
  const awayHasGoalie = !!S.slots.away.G;
  
  // Calculate skaters
  const homeSkaters = homeOnIce - (homeHasGoalie ? 1 : 0);
  const awaySkaters = awayOnIce - (awayHasGoalie ? 1 : 0);
  
  // Empty net situations
  if (!homeHasGoalie && homeOnIce >= 5) return 'ENA'; // Empty net away (extra attacker for home)
  if (!awayHasGoalie && awayOnIce >= 5) return 'ENH'; // Empty net home
  
  // Standard situations
  if (homeSkaters === 5 && awaySkaters === 5) return '5v5';
  if (homeSkaters === 5 && awaySkaters === 4) return '5v4';
  if (homeSkaters === 4 && awaySkaters === 5) return '4v5';
  if (homeSkaters === 4 && awaySkaters === 4) return '4v4';
  if (homeSkaters === 5 && awaySkaters === 3) return '5v3';
  if (homeSkaters === 3 && awaySkaters === 5) return '3v5';
  if (homeSkaters === 3 && awaySkaters === 3) return '3v3';
  
  return `${homeSkaters}v${awaySkaters}`;
}

function renderSlots() {
  ['home','away'].forEach(team => {
    ['F1','F2','F3','D1','D2','G','X'].forEach(pos => {
      const el = document.querySelector(`.slot[data-team="${team}"][data-pos="${pos}"]`);
      if (!el) return;
      const p = S.slots[team][pos];
      if (p) { el.innerHTML = `<span class="num">${p.num}</span><span class="name">${p.name}</span>`; el.classList.add('filled'); }
      else { el.innerHTML = `<span class="num">${pos}</span>`; el.classList.remove('filled'); }
    });
  });
}

function renderRosters() {
  ['home','away'].forEach(team => {
    const onIce = Object.values(S.slots[team]).filter(Boolean).map(p => p.num);
    const roster = S.rosters[team];
    
    // Group by position
    const groups = { F: [], D: [], G: [] };
    roster.forEach(p => {
      const pos = (p.pos || 'F').toUpperCase();
      if (pos === 'G') groups.G.push(p);
      else if (pos === 'D' || pos === 'LD' || pos === 'RD') groups.D.push(p);
      else groups.F.push(p);
    });
    
    // Render grouped roster
    let html = '';
    ['F', 'D', 'G'].forEach(grp => {
      if (groups[grp].length === 0) return;
      html += `<div class="roster-group"><span class="roster-group-label">${grp === 'F' ? 'Forwards' : grp === 'D' ? 'Defense' : 'Goalie'}</span>`;
      html += groups[grp].map(p => {
        const used = onIce.includes(p.num);
        const lastName = getLastName(p.name);
        const rating = p.rating ? `<span class="rating">${p.rating}</span>` : '';
        return `<button class="roster-btn ${used?'on-ice':''}" onclick="assignPlayer('${team}','${p.num}')"><span class="num">${p.num}</span><span class="name">${lastName}</span>${rating}</button>`;
      }).join('');
      html += '</div>';
    });
    
    document.getElementById(`${team}Roster`).innerHTML = html;
  });
}

function getLastName(fullName) {
  if (!fullName) return '?';
  const parts = fullName.trim().split(' ');
  return parts[parts.length - 1];
}

function renderQuickAdd() {
  const evtTeam = S.evtTeam;
  const oppTeam = evtTeam === 'home' ? 'away' : 'home';
  const onIce = num => Object.values(S.slots[evtTeam]).some(p => p?.num === num);
  const oppOnIce = num => Object.values(S.slots[oppTeam]).some(p => p?.num === num);
  const inEvt = num => S.curr.players.some(p => p.num === num);
  
  // Event quick add - players on ice for event team
  document.getElementById('evtQuickAdd').innerHTML = S.rosters[evtTeam]
    .filter(p => onIce(p.num))
    .map(p => `<button class="${inEvt(p.num)?'in-evt':''}" onclick="togglePlayer('${p.num}','evt')">${p.num}</button>`).join('');
  
  // Opp quick add
  document.getElementById('oppQuickAdd').innerHTML = S.rosters[oppTeam]
    .filter(p => oppOnIce(p.num))
    .map(p => `<button class="${inEvt(p.num)?'in-evt':''}" onclick="togglePlayer('${p.num}','opp')">${p.num}</button>`).join('');
  
  // Event players display
  const evtPs = S.curr.players.filter(p => p.role.startsWith('event'));
  document.getElementById('evtPlayers').innerHTML = evtPs.map(p => {
    const sel = S.selectedPlayer?.num === p.num;
    const xyCount = p.xy?.length || 0;
    const suClass = p.playSuccess ? (p.playSuccess === 's' ? 's' : 'u') : '';
    return `<span class="player-chip evt ${sel?'selected':''}" onclick="selectPlayer('${p.num}')"><span class="num">${p.num}</span>${p.name}${xyCount?`<span style="color:var(--accent);font-size:7px;">‚óè${xyCount}</span>`:''}${p.playSuccess?`<span class="su ${suClass}">${p.playSuccess}</span>`:''}<span class="remove" onclick="event.stopPropagation();removePlayer('${p.num}')">‚úï</span></span>`;
  }).join('') || '<span style="color:var(--muted);font-size:8px;">Click players below</span>';
  
  // Opp players display
  const oppPs = S.curr.players.filter(p => p.role.startsWith('opp'));
  document.getElementById('oppPlayers').innerHTML = oppPs.map(p => {
    const sel = S.selectedPlayer?.num === p.num;
    const xyCount = p.xy?.length || 0;
    const suClass = p.playSuccess ? (p.playSuccess === 's' ? 's' : 'u') : '';
    return `<span class="player-chip opp ${sel?'selected':''}" onclick="selectPlayer('${p.num}')"><span class="num">${p.num}</span>${p.name}${xyCount?`<span style="color:var(--accent);font-size:7px;">‚óè${xyCount}</span>`:''}${p.playSuccess?`<span class="su ${suClass}">${p.playSuccess}</span>`:''}<span class="remove" onclick="event.stopPropagation();removePlayer('${p.num}')">‚úï</span></span>`;
  }).join('') || '<span style="color:var(--muted);font-size:8px;">Click players below</span>';
  
  // Player selector for XY
  const sel = document.getElementById('xyPlayerSel');
  if (S.xyMode === 'player') {
    sel.style.display = 'inline-block';
    sel.innerHTML = '<option value="">Select</option>' + S.curr.players.map(p => `<option value="${p.num}" ${S.selectedPlayer?.num===p.num?'selected':''}>#${p.num} ${p.name}</option>`).join('');
  } else { sel.style.display = 'none'; }
  
  // Player details panel
  const pdEl = document.getElementById('playerDetails');
  if (S.selectedPlayer) {
    pdEl.style.display = 'block';
    document.getElementById('pdPlayerNum').textContent = '#' + S.selectedPlayer.num + ' ' + S.selectedPlayer.name;
    // v15.01: Use S.playDetails1 from dim_play_detail for first dropdown
    const pd1Opts = S.playDetails1?.length > 0 
      ? S.playDetails1.map(p => p.name) 
      : (document.getElementById('evtZone').value === 'd' ? LISTS.playDefensive : LISTS.playOffensive);
    // v16.02: Use datalist for searchable dropdowns
    document.getElementById('pdPlayD1List').innerHTML = pd1Opts.map(o => `<option value="${o}">`).join('');
    document.getElementById('pdPlayD1').value = S.selectedPlayer.playD1 || '';
    // v15.01: Use S.playDetails2 from dim_play_detail_2 for second dropdown
    const pd2Opts = S.playDetails2?.length > 0 
      ? S.playDetails2.map(p => p.name) 
      : [];
    document.getElementById('pdPlayD2List').innerHTML = pd2Opts.map(o => `<option value="${o}">`).join('');
    document.getElementById('pdPlayD2').value = S.selectedPlayer.playD2 || '';
    document.getElementById('pdPlaySuccess').value = S.selectedPlayer.playSuccess || '';
    // v16: Side of puck dropdown
    document.getElementById('pdSideOfPuck').value = S.selectedPlayer.sideOfPuck || '';
    
    // Pressure dropdown - opposing players
    const oppTeam = S.evtTeam === 'home' ? 'away' : 'home';
    const oppInEvt = S.curr.players.filter(p => p.role.startsWith('opp'));
    document.getElementById('pdPressure').innerHTML = '<option value="">--</option>' + oppInEvt.map(p => `<option value="${p.num}" ${S.selectedPlayer.pressure===p.num?'selected':''}>#${p.num}</option>`).join('');
  } else { pdEl.style.display = 'none'; }
}

function renderXYSlots() {
  const el = document.getElementById('xySlots');
  const max = 6;
  let data = S.xyMode === 'puck' ? S.curr.puckXY : (S.selectedPlayer?.xy || []);
  el.innerHTML = Array.from({length: max}, (_, i) => {
    const has = data[i];
    const active = S.xySlot === i + 1;
    return `<button class="xy-slot ${has?'has':''} ${active?'active':''}" onclick="setXYSlot(${i+1})">${i+1}</button>`;
  }).join('');
}

function renderEvents() {
  const body = document.getElementById('evtListBody');
  if (!body) {
    console.error('evtListBody element not found!');
    return;
  }
  
  // v20.4: Populate filter dropdowns with current values
  populateEventFilterDropdowns();
  
  // v16.04: Debug - log event periods
  console.log('renderEvents called');
  console.log('  S.events count:', S.events?.length || 0);
  console.log('  S.eventLogFilter:', S.eventLogFilter);
  
  // v15.02: Period filter
  let filteredEvents = S.events || [];
  const periodFilter = (S.eventLogFilter || 'all').toLowerCase();
  
  if (periodFilter && periodFilter !== 'all') {
    filteredEvents = filteredEvents.filter(e => {
      const evtPeriod = String(e.period || '').toLowerCase();
      if (periodFilter === 'ot') {
        return evtPeriod === 'ot' || evtPeriod === '4' || parseInt(evtPeriod) > 3;
      }
      return evtPeriod === periodFilter;
    });
  }
  
  // v20.4: Apply advanced filters
  const f = S.eventFilters || {};
  
  if (f.type) {
    filteredEvents = filteredEvents.filter(e => e.type === f.type);
  }
  if (f.detail1) {
    filteredEvents = filteredEvents.filter(e => (e.detail1 || e.detail) === f.detail1);
  }
  if (f.detail2) {
    filteredEvents = filteredEvents.filter(e => e.detail2 === f.detail2);
  }
  if (f.playDetail1) {
    filteredEvents = filteredEvents.filter(e => {
      const p1 = (e.players || []).find(p => p.role?.startsWith('event') || !p.role?.startsWith('opp'));
      return p1?.playD1 === f.playDetail1;
    });
  }
  if (f.playDetail2) {
    filteredEvents = filteredEvents.filter(e => {
      const p1 = (e.players || []).find(p => p.role?.startsWith('event') || !p.role?.startsWith('opp'));
      return p1?.playD2 === f.playDetail2;
    });
  }
  if (f.team) {
    filteredEvents = filteredEvents.filter(e => e.team === f.team);
  }
  if (f.eventIdx !== null && f.eventIdx !== undefined) {
    filteredEvents = filteredEvents.filter(e => S.events.indexOf(e) + 1 === f.eventIdx);
  }
  if (f.linkedIdx !== null && f.linkedIdx !== undefined) {
    filteredEvents = filteredEvents.filter(e => e.linkedEventIdx !== null && e.linkedEventIdx + 1 === f.linkedIdx);
  }
  if (f.shiftIdx !== null && f.shiftIdx !== undefined) {
    filteredEvents = filteredEvents.filter(e => e.shiftIdx === f.shiftIdx || e.shift_index === f.shiftIdx);
  }
  
  // Debug log
  console.log('  After filters: ' + filteredEvents.length + ' events to display');
  
  body.innerHTML = filteredEvents.map((e) => {
    const i = S.events.indexOf(e); // Get actual index in full array
    
    // Get event players and opp players
    const evtPlayers = (e.players || []).filter(p => p.role?.startsWith('event') || !p.role?.startsWith('opp'));
    const oppPlayers = (e.players || []).filter(p => p.role?.startsWith('opp'));
    
    const evtPlayerStr = evtPlayers.map(p => p.num).join(',') || '-';
    const oppPlayerStr = oppPlayers.map(p => p.num).join(',') || '-';
    
    // Get primary player info
    const primaryPlayer = evtPlayers[0];
    const primaryPD1 = primaryPlayer?.playD1?.replace('Play-','').replace(/_/g,' ').substring(0,10) || '';
    const primaryPD2 = primaryPlayer?.playD2?.replace('Play-','').replace(/_/g,' ').substring(0,10) || '';
    const primarySuccess = primaryPlayer?.playSuccess || '';
    
    // Other display values
    const hasXY = e.puckXY?.length || e.players?.some(p => p.xy?.length);
    const timeDisplay = e.start_time || e.time || '';
    const highlight = e.isHighlight ? '‚≠ê' : '';
    const linked = e.linkedEventIdx !== null && e.linkedEventIdx !== undefined ? e.linkedEventIdx + 1 : '';
    const detail = e.detail1 || e.detail || '';
    const detail2 = e.detail2 || '';
    const zone = e.zone ? e.zone.substring(0,1).toUpperCase() : '';
    const success = e.success === true || e.success === 1 || e.success === 's' || e.success === 'Y' ? '‚úì' : 
                   (e.success === false || e.success === 0 || e.success === 'u' || e.success === 'N' ? '‚úó' : '');
    const team = e.team === 'home' ? 'H' : 'A';
    const shiftIdx = e.shiftIdx || e.shift_index || '';
    
    // Build title for hover
    const hoverTitle = [
      'Event #' + (i+1),
      'Type: ' + e.type,
      'Detail: ' + detail + (detail2 ? ' / ' + detail2 : ''),
      'Team: ' + e.team,
      'Shift: ' + (shiftIdx || 'none'),
      'Event Players: ' + (evtPlayers.map(p => '#' + p.num + ' ' + p.name).join(', ') || 'none'),
      'Opp Players: ' + (oppPlayers.map(p => '#' + p.num + ' ' + p.name).join(', ') || 'none'),
      primaryPlayer ? 'P1 Play: ' + primaryPD1 + (primaryPD2 ? ' / ' + primaryPD2 : '') + ' ' + primarySuccess : '',
      e.linkedEventIdx != null ? 'Linked to #' + (e.linkedEventIdx + 1) : '',
      hasXY ? 'Has XY: Yes' : ''
    ].filter(Boolean).join('\\n');
    
    // v20.4: Expanded columns - #, Sh, Lnk, Time, T, Type, Detail1, Detail2, Z, S, EvtP, OppP, PD1, PD2, PS, XY, star
    return '<div class="evt-item" onclick="editEvent(' + i + ')" ondblclick="quickEditEvent(' + i + ')" title="' + hoverTitle + '">' +
      '<span class="idx">' + (i+1) + '</span>' +
      '<span class="seq" title="Shift #' + shiftIdx + '">' + shiftIdx + '</span>' +
      '<span class="link" title="Linked Event #' + linked + '">' + linked + '</span>' +
      '<span class="time">P' + e.period + ' ' + timeDisplay + '</span>' +
      '<span class="team">' + team + '</span>' +
      '<span class="type">' + e.type + '</span>' +
      '<span class="detail" title="' + detail + '">' + detail.substring(0,12) + '</span>' +
      '<span class="detail" title="' + detail2 + '">' + detail2.substring(0,12) + '</span>' +
      '<span class="zone">' + zone + '</span>' +
      '<span class="success">' + success + '</span>' +
      '<span class="evtp" title="Event Players: ' + evtPlayers.map(p => p.num + ':' + p.name).join(', ') + '">' + evtPlayerStr + '</span>' +
      '<span class="oppp" title="Opp Players: ' + oppPlayers.map(p => p.num + ':' + p.name).join(', ') + '">' + oppPlayerStr + '</span>' +
      '<span class="pd1" title="' + primaryPD1 + '">' + primaryPD1.substring(0,8) + '</span>' +
      '<span class="pd1" title="' + primaryPD2 + '">' + primaryPD2.substring(0,8) + '</span>' +
      '<span class="psucc">' + primarySuccess + '</span>' +
      '<span class="xy-dot">' + (hasXY?'‚óè':'') + '</span>' +
      '<span class="hl">' + highlight + '</span>' +
    '</div>';
  }).join('') || '<div style="color:var(--muted);padding:10px;text-align:center;font-size:10px;">No events to display</div>';
  
  // Debug log
  console.log('  renderEvents complete. Filtered count:', filteredEvents.length);
}
// Quick inline edit for event
function quickEditEvent(idx) {
  const evt = S.events[idx];
  
  // Build edit options
  const fields = [
    { name: 'Type', key: 'type', value: evt.type },
    { name: 'Detail 1', key: 'detail1', value: evt.detail1 || evt.detail || '' },
    { name: 'Detail 2', key: 'detail2', value: evt.detail2 || '' },
    { name: 'Linked Index', key: 'linkedEventIdx', value: evt.linkedEventIdx || '' },
    { name: 'Zone (Off/Neu/Def)', key: 'zone', value: evt.zone || '' },
    { name: 'Success (Y/N)', key: 'success', value: evt.success === true ? 'Y' : evt.success === false ? 'N' : '' },
    { name: 'Start Time', key: 'start_time', value: evt.start_time || '' },
    { name: 'Highlight (Y/N)', key: 'isHighlight', value: evt.isHighlight ? 'Y' : 'N' },
  ];
  
  const choice = prompt(
    `Quick Edit Event #${idx+1}\nEnter field number to edit:\n` +
    fields.map((f, i) => `${i+1}. ${f.name}: ${f.value}`).join('\n') +
    '\n\n(or 0 to cancel)'
  );
  
  if (!choice || choice === '0') return;
  
  const fieldIdx = parseInt(choice) - 1;
  if (fieldIdx < 0 || fieldIdx >= fields.length) {
    toast('Invalid selection', 'error');
    return;
  }
  
  const field = fields[fieldIdx];
  const newValue = prompt(`${field.name}:`, field.value);
  
  if (newValue !== null) {
    if (field.key === 'linkedEventIdx') {
      evt.linkedEventIdx = newValue ? parseInt(newValue) : null;
    } else if (field.key === 'success') {
      evt.success = newValue.toUpperCase() === 'Y' ? true : newValue.toUpperCase() === 'N' ? false : null;
    } else if (field.key === 'isHighlight') {
      evt.isHighlight = newValue.toUpperCase() === 'Y';
    } else if (field.key === 'detail1') {
      evt.detail1 = newValue;
      evt.detail = newValue; // Also update legacy field
    } else {
      evt[field.key] = newValue;
    }
    saveGameData();
    renderEvents();
    toast(`Updated ${field.name}`, 'success');
  }
}

function renderMarkers() {
  const layer = document.getElementById('markers');
  layer.innerHTML = '';
  const histCnt = parseInt(document.getElementById('xyHistCnt').value) || 5;
  
  // Historical events
  const recent = S.events.slice(-histCnt);
  recent.forEach((evt, ei) => {
    const opacity = 0.2 + (ei / histCnt) * 0.6;
    const evtColor = evt.team === 'home' ? S.homeColor : S.awayColor;
    const oppColor = evt.team === 'home' ? S.awayColor : S.homeColor;
    const extraData = { evtNum: evt.idx, evtType: evt.type };
    if (evt.puckXY?.length) drawPath(evt.puckXY, '#000', '#fff', opacity, layer, null, false, extraData);
    evt.players?.forEach(p => {
      if (p.xy?.length) {
        const color = p.role.startsWith('event') ? evtColor : oppColor;
        drawPath(p.xy, color, '#fff', opacity, layer, p.num, false, { ...extraData, playerName: p.name });
      }
    });
  });
  
  // Current event
  if (S.curr.puckXY?.length) drawPath(S.curr.puckXY, '#00d4aa', '#fff', 1, layer, 'üèí', true);
  S.curr.players?.forEach(p => {
    if (p.xy?.length) {
      const color = p.role.startsWith('event') ? S.homeColor : S.awayColor;
      const sel = S.selectedPlayer?.num === p.num;
      drawPath(p.xy, color, sel ? '#fff' : '#000', 1, layer, p.num, true, { playerName: p.name });
    }
  });
}

function drawPath(points, fill, stroke, opacity, layer, label, current, extraData = {}) {
  if (!points?.length) return;
  
  // v16.06: Convert center-relative coords to SVG coords for display
  // Stored: (0,0) = center ice. SVG: (100, 42.5) = center ice
  const toSvg = (pt) => ({
    x: pt.x + 100,
    y: pt.y + 42.5,
    seq: pt.seq,
    origX: pt.x,  // Keep original for tooltip
    origY: pt.y
  });
  
  const sorted = [...points].map(toSvg).sort((a,b) => a.seq - b.seq);
  
  for (let i = 0; i < sorted.length - 1; i++) {
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', sorted[i].x); line.setAttribute('y1', sorted[i].y);
    line.setAttribute('x2', sorted[i+1].x); line.setAttribute('y2', sorted[i+1].y);
    line.setAttribute('stroke', fill); line.setAttribute('stroke-width', current ? 1 : 0.5);
    line.setAttribute('stroke-dasharray', current ? 'none' : '2,1'); line.setAttribute('opacity', opacity * 0.7);
    layer.appendChild(line);
  }
  
  sorted.forEach((pt, i) => {
    const last = i === sorted.length - 1;
    // v16.06: Reduced marker size - current last=2.5, current other=1.5, history last=2, history other=1.2
    const r = current ? (last ? 2.5 : 1.5) : (last ? 2 : 1.2);
    const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    c.setAttribute('cx', pt.x); c.setAttribute('cy', pt.y); c.setAttribute('r', r);
    c.setAttribute('fill', fill); c.setAttribute('stroke', stroke);
    c.setAttribute('stroke-width', last ? 0.5 : 0.3); c.setAttribute('opacity', opacity);
    // v16.06: pointer-events: none allows clicking through markers to add new points
    c.style.pointerEvents = 'none';
    
    // Add data attributes for tooltip - use center-relative coords
    c.dataset.x = Math.round(pt.origX * 10) / 10;
    c.dataset.y = Math.round(pt.origY * 10) / 10;
    if (label === 'üèí') {
      c.dataset.type = 'puck';
    } else if (label && !isNaN(parseInt(label))) {
      c.dataset.type = 'player';
      c.dataset.num = label;
      c.dataset.name = extraData.playerName || '';
    } else if (extraData.evtNum) {
      c.dataset.type = 'history';
      c.dataset.evtnum = extraData.evtNum;
      c.dataset.evttype = extraData.evtType || '';
    }
    
    layer.appendChild(c);
    
    if (last && label) {
      const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      t.setAttribute('x', pt.x); t.setAttribute('y', pt.y + 1);
      t.setAttribute('fill', stroke); t.setAttribute('font-size', current ? '3.5' : '3');
      t.setAttribute('font-weight', 'bold'); t.setAttribute('text-anchor', 'middle');
      t.setAttribute('dominant-baseline', 'middle'); t.setAttribute('opacity', opacity);
      t.textContent = label;
      t.style.pointerEvents = 'none'; // Let events pass through to circle
      layer.appendChild(t);
    }
  });
}

function updateScores() {
  const goals = S.events.filter(e => e.type === 'Goal' && e.detail1?.includes('Scored'));
  document.getElementById('scoreH').textContent = goals.filter(e => e.team === 'home').length;
  document.getElementById('scoreA').textContent = goals.filter(e => e.team === 'away').length;
  updateQuickStats(); // v5
}

/**
 * Update quick stats bar (v5)
 */
function updateQuickStats() {
  // Event & shift counts
  document.getElementById('qsEvents').textContent = S.events.length;
  document.getElementById('qsShifts').textContent = S.shifts.length;
  
  // v16: SOG (shots on goal) - only shots that reached the net or goals
  const isSOG = (e) => {
    const d1 = (e.detail1 || '').toLowerCase();
    return d1.includes('shot_onnetsaved') || d1.includes('shot_onnetgoal') || 
           d1.includes('goal_scored') || d1.includes('goal_shootout') || d1.includes('goal_penaltyshot');
  };
  const homeSOG = S.events.filter(e => isSOG(e) && e.team === 'home').length;
  const awaySOG = S.events.filter(e => isSOG(e) && e.team === 'away').length;
  document.getElementById('qsSOG').textContent = `${homeSOG}-${awaySOG}`;
  
  // Faceoffs
  const faceoffs = S.events.filter(e => e.type === 'Faceoff');
  const homeFO = faceoffs.filter(e => e.team === 'home' && e.success === 's').length;
  const awayFO = faceoffs.filter(e => e.team === 'away' && e.success === 's').length;
  document.getElementById('qsFO').textContent = `${homeFO}-${awayFO}`;
  
  // Penalties
  const penalties = S.events.filter(e => e.type === 'Penalty');
  const homePEN = penalties.filter(e => e.team === 'home').length;
  const awayPEN = penalties.filter(e => e.team === 'away').length;
  document.getElementById('qsPEN').textContent = `${homePEN}-${awayPEN}`;
  
  // Current strength from slots
  const homeCount = ['F1','F2','F3','D1','D2','X'].filter(p => S.slots.home?.[p]?.num).length;
  const awayCount = ['F1','F2','F3','D1','D2','X'].filter(p => S.slots.away?.[p]?.num).length;
  const strength = `${homeCount}v${awayCount}`;
  const strengthEl = document.getElementById('qsStrength');
  strengthEl.textContent = strength;
  strengthEl.className = 'value strength-indicator';
  if (homeCount > awayCount) strengthEl.classList.add('pp');
  else if (homeCount < awayCount) strengthEl.classList.add('pk');
  else strengthEl.classList.add('even');
}

// ============================================================
// SLOTS & ROSTERS
// ============================================================
function selectSlot(el) {
  document.querySelectorAll('.slot').forEach(s => s.classList.remove('selected'));
  el.classList.add('selected');
  S.selectedSlot = { team: el.dataset.team, pos: el.dataset.pos };
}

function assignPlayer(team, num) {
  if (!S.selectedSlot || S.selectedSlot.team !== team) {
    const positions = ['F1','F2','F3','D1','D2','G','X'];
    for (const pos of positions) { if (!S.slots[team][pos]) { S.selectedSlot = { team, pos }; break; } }
  }
  if (!S.selectedSlot) return;
  const p = S.rosters[team].find(x => x.num === num);
  if (!p) return;
  S.slots[team][S.selectedSlot.pos] = p;
  S.selectedSlot = null;
  renderSlots(); renderRosters(); renderQuickAdd();
  onSlotsChanged(); // Update strength
}

function clearSlots(team) {
  Object.keys(S.slots[team]).forEach(pos => S.slots[team][pos] = null);
  renderSlots(); renderRosters(); renderQuickAdd();
  onSlotsChanged(); // Update strength
}

// ============================================================
// EVENT ENTRY
// ============================================================
function setEvtTeam(team) {
  S.evtTeam = team;
  document.querySelectorAll('.team-toggle button').forEach(b => b.classList.remove('active'));
  document.querySelector(`.team-toggle .${team}`).classList.add('active');
  renderQuickAdd();
  updateZoneDisplay();
}

function setEvtType(type) {
  S.curr.type = type;
  document.querySelectorAll('.evt-btn').forEach(b => b.classList.remove('active'));
  document.querySelector(`.evt-btn[data-type="${type}"]`)?.classList.add('active');
  
  // v16.06: Use S.eventDetails1 from dim_event_detail if available
  let d1Options = [];
  if (S.eventDetails1?.length > 0) {
    d1Options = S.eventDetails1
      .filter(e => e.eventType === type)
      .map(e => e.name);
  }
  
  // Fall back to LISTS.details if no Supabase data
  if (d1Options.length === 0) {
    const opts = LISTS.details[type] || { d1: [], d2: [] };
    d1Options = opts.d1 || [];
  }
  
  document.getElementById('evtD1').innerHTML = '<option value="">--</option>' + 
    d1Options.map(o => `<option value="${o}">${o}</option>`).join('');
  document.getElementById('evtD2').innerHTML = '<option value="">--</option>';
  
  // Update linked events dropdown based on current type
  updateLinkedEventsDropdown();
  
  // Apply linked event data if linked
  applyLinkedEventData();
  
  // Auto-derive zone from position if we have XY
  const zone = calculateZone();
  if (zone) document.getElementById('evtZone').value = zone;
  
  // Auto-derive strength from slots
  const strength = deriveStrength();
  if (strength) document.getElementById('evtStrength').value = strength;
}

function onD1Change() {
  const type = S.curr.type;
  const d1 = document.getElementById('evtD1').value;
  
  let d2Opts = [];
  
  // v16.08: Use S.eventDetails2 from dim_event_detail_2 - filter by code prefix
  if (S.eventDetails2?.length > 0) {
    // Determine code prefix based on detail1 value
    let codePrefix = null;
    if (d1.startsWith('Shot_')) codePrefix = 'Shot_';
    else if (d1.startsWith('Pass_')) codePrefix = 'Pass_';
    else if (d1.startsWith('Goal_')) codePrefix = 'Goal_';
    else if (d1.startsWith('Save_')) codePrefix = 'Save_';
    else if (d1.startsWith('Penalty_')) codePrefix = 'Penalty_';
    else if (d1.includes('Giveaway')) codePrefix = 'Giveaway_';
    else if (d1.includes('Takeaway')) codePrefix = 'Takeaway_';
    else if (d1.includes('Entry')) codePrefix = 'ZoneEntry_';
    else if (d1.includes('Exit') || d1.includes('Keepin')) codePrefix = 'ZoneExit_';
    else if (d1 === 'Stoppage_Play') codePrefix = 'Stoppage_';
    else if (d1 === 'Play_Offensive') codePrefix = 'PlayOffensive_';
    else if (d1 === 'Play_Defensive') codePrefix = 'PlayDefensive_';
    else if (d1.startsWith('Faceoff_')) codePrefix = 'Faceoff_';
    else if (d1.startsWith('Possession_')) codePrefix = 'Possession_';
    else if (d1.startsWith('Rebound_')) codePrefix = 'Rebound_';
    
    if (codePrefix) {
      d2Opts = S.eventDetails2
        .filter(e => e.code && e.code.startsWith(codePrefix))
        .map(e => e.name);
      console.log('Detail2 filter:', codePrefix, '‚Üí', d2Opts.length, 'options');
    }
  }
  
  // Fall back to LISTS.details if no Supabase data
  if (d2Opts.length === 0) {
    const opts = LISTS.details[type] || {};
    d2Opts = opts.d2 || [];
    if (d1.includes('Giveaway') && opts.d2_Giveaway) d2Opts = opts.d2_Giveaway;
    else if (d1.includes('Takeaway') && opts.d2_Takeaway) d2Opts = opts.d2_Takeaway;
    else if (d1.includes('Entry') && opts.d2_Entry) d2Opts = opts.d2_Entry;
    else if (d1.includes('Exit') && opts.d2_Exit) d2Opts = opts.d2_Exit;
    else if (d1.includes('Play') && opts.d2_Play) d2Opts = opts.d2_Play;
    else if (d1.includes('Offensive') && opts.d2_Offensive) d2Opts = opts.d2_Offensive;
    else if (d1.includes('Defensive') && opts.d2_Defensive) d2Opts = opts.d2_Defensive;
    else if (d1.includes('Keepin') && opts.d2_Exit) d2Opts = opts.d2_Exit;
  }
  
  document.getElementById('evtD2').innerHTML = '<option value="">--</option>' + d2Opts.map(o => `<option value="${o}">${o}</option>`).join('');
  
  // Auto-derive success
  const success = deriveSuccess();
  if (success) document.getElementById('evtSuccess').value = success;
  
  // Check if this is a shot on goal - prompt for net location
  if ((type === 'Shot' && d1.includes('OnNet')) || type === 'Goal') {
    setTimeout(() => document.getElementById('netModal').classList.add('show'), 100);
  }
}

function togglePlayer(num, role) {
  const team = role === 'evt' ? S.evtTeam : (S.evtTeam === 'home' ? 'away' : 'home');
  const p = S.rosters[team].find(x => x.num === num);
  if (!p) return;
  
  const existingIdx = S.curr.players.findIndex(x => x.num === num);
  if (existingIdx >= 0) {
    S.curr.players.splice(existingIdx, 1);
    if (S.selectedPlayer?.num === num) S.selectedPlayer = null;
  } else {
    const roleNum = S.curr.players.filter(x => x.role.startsWith(role === 'evt' ? 'event' : 'opp')).length + 1;
    S.curr.players.push({
      ...p, role: `${role === 'evt' ? 'event' : 'opp'}_team_player_${roleNum}`,
      roleNum, xy: [], playD1: '', playD2: '', playSuccess: '', pressure: '', sideOfPuck: ''
    });
  }
  renumberPlayers();
  renderQuickAdd(); renderMarkers();
}

function removePlayer(num) {
  S.curr.players = S.curr.players.filter(p => p.num !== num);
  if (S.selectedPlayer?.num === num) S.selectedPlayer = null;
  renumberPlayers();
  renderQuickAdd(); renderMarkers();
}

function renumberPlayers() {
  let evtN = 1, oppN = 1;
  S.curr.players.forEach(p => {
    if (p.role.startsWith('event')) { p.role = `event_team_player_${evtN}`; p.roleNum = evtN++; }
    else { p.role = `opp_team_player_${oppN}`; p.roleNum = oppN++; }
  });
}

function selectPlayer(num) {
  S.selectedPlayer = S.curr.players.find(p => p.num === num) || null;
  if (S.selectedPlayer && S.xyMode !== 'player') setXYMode('player');
  renderQuickAdd(); renderXYSlots();
}

function updatePlayerDetail(field, val) {
  if (!S.selectedPlayer) return;
  S.selectedPlayer[field] = val;
  renderQuickAdd();
}

// ============================================================
// XY HANDLING
// ============================================================
function setXYMode(mode) {
  S.xyMode = mode;
  document.getElementById('puckModeBtn').classList.toggle('active', mode === 'puck');
  document.getElementById('playerModeBtn').classList.toggle('active', mode === 'player');
  document.getElementById('modeInd').textContent = mode === 'puck' ? 'üèí PUCK' : 'üë§ PLAYER';
  document.getElementById('modeInd').className = 'mode-ind ' + mode;
  S.xySlot = 1;
  renderXYSlots(); renderQuickAdd();
}

function setXYSlot(n) {
  S.xySlot = n;
  renderXYSlots();
}

function selectXYPlayer(num) {
  S.selectedPlayer = S.curr.players.find(p => p.num === num) || null;
  S.xySlot = 1;
  renderXYSlots(); renderQuickAdd();
}

function handleRinkClick(event) {
  const svg = document.getElementById('rinkSvg');
  const rect = svg.getBoundingClientRect();
  const pt = svg.createSVGPoint();
  pt.x = event.clientX; pt.y = event.clientY;
  const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
  
  // v16.06: Store as center-relative (0,0 = center ice)
  // Rink is 200x85, center at (100, 42.5)
  const relX = Math.round((svgPt.x - 100) * 100) / 100;  // -100 to +100
  const relY = Math.round((svgPt.y - 42.5) * 100) / 100; // -42.5 to +42.5
  const xy = { x: relX, y: relY, seq: S.xySlot };
  
  // Store for undo
  S.xyHistory.push({ mode: S.xyMode, player: S.selectedPlayer?.num, slot: S.xySlot, prev: null });
  
  if (S.xyMode === 'puck') {
    // For possession events, also set event_player_1 XY
    const d2 = document.getElementById('evtD2').value;
    const isPossession = LISTS.possessionEvents.includes(S.curr.type) || LISTS.possessionDetails.includes(d2);
    
    S.curr.puckXY[S.xySlot - 1] = xy;
    
    if (isPossession) {
      const p1 = S.curr.players.find(p => p.role === 'event_team_player_1');
      if (p1) {
        p1.xy[S.xySlot - 1] = {...xy};
      }
    }
    
    S.xySlot = Math.min(S.xySlot + 1, 10);
  } else if (S.selectedPlayer) {
    S.selectedPlayer.xy[S.xySlot - 1] = xy;
    S.xySlot = Math.min(S.xySlot + 1, 10);
  }
  
  renderXYSlots(); renderMarkers(); updateZoneDisplay(); detectPressure(); renderQuickAdd();
}

function undoLastXY() {
  if (!S.xyHistory.length) return;
  const last = S.xyHistory.pop();
  
  if (last.mode === 'puck') {
    S.curr.puckXY.pop();
    S.xySlot = Math.max(1, S.curr.puckXY.length + 1);
  } else if (last.player) {
    const p = S.curr.players.find(p => p.num === last.player);
    if (p) {
      p.xy.pop();
      S.xySlot = Math.max(1, p.xy.length + 1);
    }
  }
  
  renderXYSlots(); renderMarkers();
  toast('Undo XY', 'success');
}

function clearCurrentXY() {
  if (S.xyMode === 'puck') S.curr.puckXY = [];
  else if (S.selectedPlayer) S.selectedPlayer.xy = [];
  S.xySlot = 1;
  renderXYSlots(); renderMarkers();
}

function clearRink() {
  S.xyHistory = [];
  renderMarkers();
  toast('Rink cleared', 'success');
}

/**
 * Handle mouse hover over rink for XY tooltips (v5)
 * Shows coordinates on hover, and player info when hovering markers
 */
function handleRinkHover(event) {
  const svg = document.getElementById('rinkSvg');
  const tooltip = document.getElementById('xyTooltip');
  if (!svg || !tooltip) return;
  
  const rect = svg.getBoundingClientRect();
  const pt = svg.createSVGPoint();
  pt.x = event.clientX; pt.y = event.clientY;
  const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
  
  // v16.06: Show center-relative coordinates
  const x = Math.round((svgPt.x - 100) * 10) / 10;
  const y = Math.round((svgPt.y - 42.5) * 10) / 10;
  
  // Check if hovering over a marker
  const target = event.target;
  let tooltipContent = `(${x}, ${y})`;
  
  if (target && target.dataset && target.dataset.type) {
    const type = target.dataset.type;
    const markerX = target.dataset.x || '--';
    const markerY = target.dataset.y || '--';
    
    if (type === 'puck') {
      tooltipContent = `üèí Puck (${markerX}, ${markerY})`;
    } else if (type === 'player') {
      const num = target.dataset.num || '?';
      const name = target.dataset.name || '';
      tooltipContent = `#${num} ${name}\n(${markerX}, ${markerY})`;
    } else if (type === 'history') {
      const evtNum = target.dataset.evtnum || '?';
      const evtType = target.dataset.evttype || '';
      tooltipContent = `Event #${evtNum} - ${evtType}\n(${markerX}, ${markerY})`;
    }
  }
  
  // Position tooltip at cursor
  tooltip.textContent = tooltipContent;
  tooltip.style.display = 'block';
  tooltip.style.left = (event.clientX - rect.left) + 'px';
  tooltip.style.top = (event.clientY - rect.top) + 'px';
}

/**
 * Hide XY tooltip (v5)
 */
function hideXYTooltip() {
  const tooltip = document.getElementById('xyTooltip');
  if (tooltip) tooltip.style.display = 'none';
}

// ============================================================
// NET LOCATION
// ============================================================
function handleNetClick(event) {
  const svg = document.getElementById('netSvg');
  const rect = svg.getBoundingClientRect();
  const x = ((event.clientX - rect.left) / rect.width) * 72;
  const y = ((event.clientY - rect.top) / rect.height) * 48;
  
  S.curr.netXY = { x: Math.round(x * 10) / 10, y: Math.round(y * 10) / 10 };
  
  const marker = document.getElementById('netMarker');
  marker.innerHTML = `<circle cx="${S.curr.netXY.x}" cy="${S.curr.netXY.y}" r="4" fill="#00d4aa" stroke="#fff" stroke-width="1"/>`;
}

function clearNetXY() {
  S.curr.netXY = null;
  document.getElementById('netMarker').innerHTML = '';
}

function closeNetModal() {
  document.getElementById('netModal').classList.remove('show');
}

// ============================================================
// LOG EVENT
// ============================================================
function logEvent() {
  if (!S.curr.type) { toast('Select event type', 'error'); return; }
  
  // Get start time - default from clock
  let startTime = document.getElementById('evtStartTime').value || document.getElementById('clock').value;
  // Get end time - default to start time
  let endTime = document.getElementById('evtEndTime').value || startTime;
  
  // Auto-derive zone if not set
  let zone = document.getElementById('evtZone').value || calculateZone();
  
  // Auto-derive success if not set
  let success = document.getElementById('evtSuccess').value || deriveSuccess();
  
  // Auto-derive strength from players on ice
  let strength = document.getElementById('evtStrength').value || deriveStrength();
  
  // Check highlight flag
  let isHighlight = document.getElementById('isHighlight').checked;
  
  // Detect pressure for all event players
  detectPressure();
  
  // Build linked event chain
  let linkedEventChain = [];
  if (S.linkedEventIdx !== null) {
    linkedEventChain.push(S.linkedEventIdx);
    // Check if linked event has its own chain
    const linkedEvt = S.events.find(e => e.idx === S.linkedEventIdx);
    if (linkedEvt?.linkedEventChain?.length) {
      linkedEventChain = [...linkedEvt.linkedEventChain, S.linkedEventIdx];
    }
  }
  
  const evt = {
    idx: S.evtIdx++,
    game_id: S.gameId,
    period: S.period,
    start_time: startTime,
    end_time: endTime,
    team: S.evtTeam,
    type: S.curr.type,
    detail1: document.getElementById('evtD1').value,
    detail2: document.getElementById('evtD2').value,
    zone,
    success,
    strength,
    linkedEventIdx: S.linkedEventIdx, // Direct link to previous event
    linkedEventChain, // Full chain: [shot_idx, save_idx] for rebound
    isHighlight, // Mark as highlight for video
    puckXY: [...S.curr.puckXY],
    netXY: S.curr.netXY,
    players: S.curr.players.map(p => ({...p, xy: [...(p.xy || [])]}))
  };
  
  S.events.push(evt);
  S.lastEndTime = endTime; // Store for next event's start time
  S.linkedEventIdx = null; // Clear linked event
  
  const highlightIcon = isHighlight ? ' ‚≠ê' : '';
  toast(`Event #${evt.idx + 1}: ${evt.type}${highlightIcon}`, 'success');
  
  clearEvent();
  // Pre-fill next event's start time with this event's end time
  document.getElementById('evtStartTime').value = endTime;
  
  renderEvents(); renderMarkers(); updateScores(); updateBoxScore();
  updateNextPlaySuggestions();
  autoSave();
  
  // Auto-edit next: open edit modal for the just-logged event (v5)
  if (document.getElementById('autoEditNext')?.checked) {
    setTimeout(() => editEvent(S.events.length - 1), 100);
  }
}

function clearEvent() {
  const preserveStartTime = document.getElementById('evtStartTime').value;
  S.curr = { type: null, players: [], puckXY: [], netXY: null };
  S.selectedPlayer = null;
  S.xySlot = 1;
  S.xyHistory = [];
  document.querySelectorAll('.evt-btn').forEach(b => b.classList.remove('active'));
  document.getElementById('evtD1').innerHTML = '<option value="">--</option>';
  document.getElementById('evtD2').innerHTML = '<option value="">--</option>';
  document.getElementById('evtZone').value = '';
  document.getElementById('evtSuccess').value = '';
  document.getElementById('evtStartTime').value = preserveStartTime; // Keep for chaining
  document.getElementById('evtEndTime').value = '';
  document.getElementById('isHighlight').checked = false;
  document.getElementById('zoneDisplay').innerHTML = '';
  renderQuickAdd(); renderXYSlots(); renderMarkers();
}

// ============================================================
// QUICK TIME & EVENT HELPERS (v5)
// ============================================================

/**
 * Copy current clock time to start time field
 */
function copyClockToStart() {
  const clock = document.getElementById('clock').value;
  document.getElementById('evtStartTime').value = clock;
  toast(`Start: ${clock}`, 'info');
}

/**
 * Copy current clock time to end time field
 */
function copyClockToEnd() {
  const clock = document.getElementById('clock').value;
  document.getElementById('evtEndTime').value = clock;
  toast(`End: ${clock}`, 'info');
}

/**
 * Copy last event's end time to current start time
 */
function copyLastEventTime() {
  if (S.events.length === 0) {
    toast('No previous events', 'info');
    return;
  }
  const lastEvt = S.events[S.events.length - 1];
  const time = lastEvt.end_time || lastEvt.start_time || '';
  document.getElementById('evtStartTime').value = time;
  toast(`Copied: ${time}`, 'info');
}

/**
 * v6: Nudge start time by variable seconds
 */
function nudgeStartTime(direction) {
  const amount = parseInt(document.getElementById('timeNudgeAmount').value) || 5;
  const startTimeEl = document.getElementById('evtStartTime');
  const newTime = nudgeTime(startTimeEl.value, direction * amount);
  startTimeEl.value = newTime;
  toast(`Start: ${newTime}`, 'info');
}

/**
 * v6: Nudge end time by variable seconds
 */
function nudgeEndTime(direction) {
  const amount = parseInt(document.getElementById('timeNudgeAmount').value) || 5;
  const endTimeEl = document.getElementById('evtEndTime');
  const newTime = nudgeTime(endTimeEl.value, direction * amount);
  endTimeEl.value = newTime;
  toast(`End: ${newTime}`, 'info');
}

/**
 * v6: Helper to add/subtract seconds from a time string (MM:SS)
 * Hockey clock counts DOWN, so adding seconds means earlier in period
 */
function nudgeTime(timeStr, seconds) {
  if (!timeStr) {
    // Use clock if no time set
    timeStr = document.getElementById('clock').value || '20:00';
  }
  const [min, sec] = (timeStr || '20:00').split(':').map(Number);
  let totalSec = (min || 0) * 60 + (sec || 0);
  totalSec += seconds; // Add seconds (hockey clock, so + goes earlier)
  
  // Clamp to 0:00 - 20:00
  totalSec = Math.max(0, Math.min(1200, totalSec));
  
  const newMin = Math.floor(totalSec / 60);
  const newSec = totalSec % 60;
  return `${newMin}:${String(newSec).padStart(2, '0')}`;
}

/**
 * Duplicate the last event with current time
 */
function duplicateLastEvent() {
  if (S.events.length === 0) {
    toast('No events to duplicate', 'info');
    return;
  }
  
  const lastEvt = S.events[S.events.length - 1];
  
  // Set event type
  setEvtType(lastEvt.type);
  
  // Set team
  setEvtTeam(lastEvt.team);
  
  // Set details
  setTimeout(() => {
    document.getElementById('evtD1').value = lastEvt.detail1 || '';
    onD1Change();
    setTimeout(() => {
      document.getElementById('evtD2').value = lastEvt.detail2 || '';
    }, 50);
  }, 50);
  
  // Set zone, success, strength
  document.getElementById('evtZone').value = lastEvt.zone || '';
  document.getElementById('evtSuccess').value = lastEvt.success || '';
  document.getElementById('evtStrength').value = lastEvt.strength || '5v5';
  
  // Copy players
  S.curr.players = lastEvt.players.map(p => ({
    ...p,
    xy: [] // Don't copy XY - needs new positions
  }));
  
  renderQuickAdd();
  toast(`Duplicated: ${lastEvt.type}`, 'success');
}

/**
 * Format time input as MM:SS while typing
 */
function formatTimeInput(input) {
  let val = input.value.replace(/[^0-9]/g, '');
  if (val.length > 4) val = val.slice(0, 4);
  if (val.length >= 3) {
    val = val.slice(0, -2) + ':' + val.slice(-2);
  }
  input.value = val;
}

/**
 * Quick time entry: type 1530 and it becomes 15:30
 */
function setupTimeInputs() {
  ['evtStartTime', 'evtEndTime', 'clock', 'shiftStart', 'shiftEnd'].forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      el.addEventListener('blur', () => {
        let val = el.value.replace(/[^0-9:]/g, '');
        // If no colon and 3-4 digits, auto-format
        if (!val.includes(':') && val.length >= 3) {
          val = val.slice(0, -2) + ':' + val.slice(-2);
        }
        // Ensure seconds are padded
        if (val.includes(':')) {
          const [min, sec] = val.split(':');
          val = min + ':' + (sec || '00').padStart(2, '0');
        }
        el.value = val;
      });
    }
  });
}

// ============================================================
// EDIT EVENT MODAL
// ============================================================
function editEvent(idx) {
  S.editingEvtIdx = idx;
  const evt = S.events[idx];
  
  // Ensure players array exists
  if (!evt.players) evt.players = [];
  if (!evt.puckXY) evt.puckXY = [];
  
  document.getElementById('editEvtIdx').textContent = idx + 1;
  document.getElementById('editHighlightBadge').textContent = evt.isHighlight ? '‚≠ê' : '';
  document.getElementById('editType').value = evt.type;
  document.getElementById('editTeam').value = evt.team;
  document.getElementById('editStartTime').value = evt.start_time || evt.time || '';
  document.getElementById('editEndTime').value = evt.end_time || evt.start_time || evt.time || '';
  document.getElementById('editZone').value = evt.zone || '';
  document.getElementById('editSuccess').value = evt.success || '';
  document.getElementById('editStrength').value = evt.strength || '5v5';
  document.getElementById('editHighlight').checked = evt.isHighlight || false;
  
  // Linked event index (editable)
  const linkedIdxEl = document.getElementById('editLinkedIdx');
  if (linkedIdxEl) {
    linkedIdxEl.value = (evt.linkedEventIdx !== null && evt.linkedEventIdx !== undefined) ? evt.linkedEventIdx + 1 : '';
  }
  
  // Sequence and play keys (display only)
  const seqKeyEl = document.getElementById('editSeqKey');
  const playKeyEl = document.getElementById('editPlayKey');
  if (seqKeyEl) seqKeyEl.textContent = evt.sequenceIdx || evt.seqIdx || evt.sequence_key || '--';
  if (playKeyEl) playKeyEl.textContent = evt.playIdx || evt.play_key || '--';
  
  // v15: Show event_id and event_index
  const eventIdEl = document.getElementById('editEventId');
  const eventIndexEl = document.getElementById('editEventIndex');
  if (eventIdEl) eventIdEl.textContent = evt.eventId || evt.event_id || '--';
  if (eventIndexEl) eventIndexEl.textContent = evt.idx || (idx + 1);
  
  // Show linked chain
  const chainText = evt.linkedEventChain?.length 
    ? `Chain: ${evt.linkedEventChain.map(i => `#${i+1}`).join(' ‚Üí ')} ‚Üí #${idx+1}`
    : (evt.linkedEventIdx !== null && evt.linkedEventIdx !== undefined ? `Linked to #${evt.linkedEventIdx + 1}` : '--');
  document.getElementById('editLinkedChain').textContent = chainText;
  
  onEditTypeChange();
  document.getElementById('editD1').value = evt.detail1 || '';
  // v16.06: Pass detail2 to preserve it in dropdown options
  onEditD1Change(evt.detail2 || '');
  
  renderEditPlayers(evt.players);
  renderEditPuckXY(evt.puckXY);
  
  // Populate XY target dropdown (puck + each player)
  const xyTargetSel = document.getElementById('editXYTarget');
  xyTargetSel.innerHTML = '<option value="puck">Puck</option>' + 
    (evt.players || []).map((p, i) => `<option value="player_${i}">#${p.num} ${p.name}</option>`).join('');
  
  renderEditRinkMarkers();
  
  // Show/hide net section for shots/goals
  const showNet = ['Shot', 'Goal'].includes(evt.type);
  document.getElementById('editNetSection').style.display = showNet ? 'block' : 'none';
  if (showNet) {
    renderEditNetMarker(evt.netXY);
    document.getElementById('editNetLocation').textContent = getNetLocationName(evt.netXY) || '--';
  }
  
  document.getElementById('editModal').classList.add('show');
}

function renderEditNetMarker(netXY) {
  const g = document.getElementById('editNetMarker');
  if (!g) return;
  
  if (netXY?.x != null && netXY?.y != null) {
    g.innerHTML = `<circle cx="${netXY.x}" cy="${netXY.y}" r="4" fill="#10b981" stroke="#fff" stroke-width="1"/>`;
  } else {
    g.innerHTML = '';
  }
}

function getNetLocationName(netXY) {
  if (!netXY?.x || !netXY?.y) return null;
  const x = netXY.x;
  const y = netXY.y;
  
  // Divide net into zones (72x48 viewbox)
  if (y < 16) {
    return x < 36 ? 'Top Left' : 'Top Right';
  } else if (y > 32) {
    return x < 36 ? 'Low Left' : 'Low Right';
  } else {
    return 'Five Hole';
  }
}

function handleEditNetClick(event) {
  if (S.editingEvtIdx === null) return;
  
  const svg = document.getElementById('editNetSvg');
  const pt = svg.createSVGPoint();
  pt.x = event.clientX; pt.y = event.clientY;
  const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
  
  const netXY = { x: Math.round(svgPt.x), y: Math.round(svgPt.y) };
  S.events[S.editingEvtIdx].netXY = netXY;
  
  renderEditNetMarker(netXY);
  document.getElementById('editNetLocation').textContent = getNetLocationName(netXY);
  toast('Net location set: ' + getNetLocationName(netXY), 'success');
}

function clearEditNetXY() {
  if (S.editingEvtIdx === null) return;
  S.events[S.editingEvtIdx].netXY = null;
  renderEditNetMarker(null);
  document.getElementById('editNetLocation').textContent = '--';
  toast('Net location cleared', 'info');
}

function renderEditRinkMarkers() {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  const g = document.getElementById('editRinkMarkers');
  if (!g) return;
  
  let markers = '';
  const target = document.getElementById('editXYTarget')?.value || 'puck';
  
  // Render puck XY
  (evt.puckXY || []).forEach((xy, i) => {
    const isActive = target === 'puck';
    markers += `<circle cx="${xy.x}" cy="${xy.y}" r="3" fill="${isActive ? '#ef4444' : '#666'}" stroke="#fff" stroke-width="0.5" style="cursor:pointer;" onclick="selectEditXY('puck', ${i})"/>`;
    markers += `<text x="${xy.x + 4}" y="${xy.y - 2}" font-size="4" fill="#fff">P${i+1}</text>`;
  });
  
  // Render player XYs
  (evt.players || []).forEach((p, pi) => {
    const isActive = target === `player_${pi}`;
    (p.xy || []).forEach((xy, i) => {
      const color = p.role.startsWith('event') ? '#3b82f6' : '#ef4444';
      markers += `<circle cx="${xy.x}" cy="${xy.y}" r="2.5" fill="${isActive ? color : '#666'}" stroke="#fff" stroke-width="0.3" style="cursor:pointer;" onclick="selectEditXY('player_${pi}', ${i})"/>`;
      markers += `<text x="${xy.x + 3}" y="${xy.y - 1}" font-size="3" fill="#fff">${p.num}.${i+1}</text>`;
    });
  });
  
  g.innerHTML = markers;
}

function handleEditRinkClick(event) {
  if (S.editingEvtIdx === null) return;
  
  const svg = document.getElementById('editRinkSvg');
  const pt = svg.createSVGPoint();
  pt.x = event.clientX; pt.y = event.clientY;
  const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
  
  const xy = { x: Math.round(svgPt.x * 10) / 10, y: Math.round(svgPt.y * 10) / 10, seq: 1 };
  
  const evt = S.events[S.editingEvtIdx];
  const target = document.getElementById('editXYTarget').value;
  
  if (target === 'puck') {
    if (S.editingXYIdx !== null && evt.puckXY?.[S.editingXYIdx]) {
      evt.puckXY[S.editingXYIdx] = xy;
    } else {
      evt.puckXY = evt.puckXY || [];
      evt.puckXY.push(xy);
    }
    renderEditPuckXY(evt.puckXY);
  } else if (target.startsWith('player_')) {
    const pi = parseInt(target.split('_')[1]);
    if (evt.players?.[pi]) {
      if (S.editingXYIdx !== null && evt.players[pi].xy?.[S.editingXYIdx]) {
        evt.players[pi].xy[S.editingXYIdx] = xy;
      } else {
        evt.players[pi].xy = evt.players[pi].xy || [];
        evt.players[pi].xy.push(xy);
      }
    }
  }
  
  S.editingXYIdx = null;
  renderEditRinkMarkers();
  renderEditPlayers(evt.players);
}

function selectEditXY(target, idx) {
  document.getElementById('editXYTarget').value = target;
  S.editingXYIdx = idx;
  renderEditRinkMarkers();
  toast(`Selected ${target} point ${idx + 1} - click rink to move`, 'info');
}

function addEditXYPoint() {
  // Just click on rink to add
  toast('Click on rink to add XY point', 'info');
}

function onEditTypeChange() {
  const type = document.getElementById('editType').value;
  
  // v16.06: Use S.eventDetails1 from dim_event_detail if available
  let d1Options = [];
  if (S.eventDetails1?.length > 0) {
    d1Options = S.eventDetails1
      .filter(e => e.eventType === type)
      .map(e => e.name);
  }
  
  // Fall back to LISTS.details if no Supabase data
  if (d1Options.length === 0) {
    const opts = LISTS.details[type] || { d1: [], d2: [] };
    d1Options = opts.d1 || [];
  }
  
  document.getElementById('editD1').innerHTML = '<option value="">--</option>' + 
    d1Options.map(o => `<option value="${o}">${o}</option>`).join('');
  document.getElementById('editD2').innerHTML = '<option value="">--</option>';
}

function onEditD1Change(preserveD2Value = null) {
  const type = document.getElementById('editType').value;
  const d1 = document.getElementById('editD1').value;
  
  // Get current d2 value or use preserved value
  const currentD2 = preserveD2Value || document.getElementById('editD2').value;
  
  let d2Opts = [];
  
  // v16.08: Use S.eventDetails2 from dim_event_detail_2 - filter by code prefix
  if (S.eventDetails2?.length > 0) {
    // Determine code prefix based on detail1 value
    let codePrefix = null;
    if (d1.startsWith('Shot_')) codePrefix = 'Shot_';
    else if (d1.startsWith('Pass_')) codePrefix = 'Pass_';
    else if (d1.startsWith('Goal_')) codePrefix = 'Goal_';
    else if (d1.startsWith('Save_')) codePrefix = 'Save_';
    else if (d1.startsWith('Penalty_')) codePrefix = 'Penalty_';
    else if (d1.includes('Giveaway')) codePrefix = 'Giveaway_';
    else if (d1.includes('Takeaway')) codePrefix = 'Takeaway_';
    else if (d1.includes('Entry')) codePrefix = 'ZoneEntry_';
    else if (d1.includes('Exit') || d1.includes('Keepin')) codePrefix = 'ZoneExit_';
    else if (d1 === 'Stoppage_Play') codePrefix = 'Stoppage_';
    else if (d1 === 'Play_Offensive') codePrefix = 'PlayOffensive_';
    else if (d1 === 'Play_Defensive') codePrefix = 'PlayDefensive_';
    else if (d1.startsWith('Faceoff_')) codePrefix = 'Faceoff_';
    else if (d1.startsWith('Possession_')) codePrefix = 'Possession_';
    else if (d1.startsWith('Rebound_')) codePrefix = 'Rebound_';
    
    if (codePrefix) {
      d2Opts = S.eventDetails2
        .filter(e => e.code && e.code.startsWith(codePrefix))
        .map(e => e.name);
    }
  }
  
  // Fall back to LISTS.details if no Supabase data
  if (d2Opts.length === 0) {
    const opts = LISTS.details[type] || {};
    d2Opts = opts.d2 || [];
    if (d1.includes('Giveaway') && opts.d2_Giveaway) d2Opts = opts.d2_Giveaway;
    else if (d1.includes('Takeaway') && opts.d2_Takeaway) d2Opts = opts.d2_Takeaway;
    else if (d1.includes('Entry') && opts.d2_Entry) d2Opts = opts.d2_Entry;
    else if (d1.includes('Exit') && opts.d2_Exit) d2Opts = opts.d2_Exit;
    else if (d1.includes('Play') && opts.d2_Play) d2Opts = opts.d2_Play;
    else if (d1.includes('Offensive') && opts.d2_Offensive) d2Opts = opts.d2_Offensive;
    else if (d1.includes('Defensive') && opts.d2_Defensive) d2Opts = opts.d2_Defensive;
    else if (d1.includes('Keepin') && opts.d2_Exit) d2Opts = opts.d2_Exit;
  }
  
  // Build options HTML
  let optionsHtml = '<option value="">--</option>' + d2Opts.map(o => `<option value="${o}">${o}</option>`).join('');
  
  // If current/preserved value not in options, add it at top
  if (currentD2 && !d2Opts.includes(currentD2)) {
    optionsHtml = `<option value="">--</option><option value="${currentD2}">${currentD2} (loaded)</option>` + 
                  d2Opts.map(o => `<option value="${o}">${o}</option>`).join('');
  }
  
  document.getElementById('editD2').innerHTML = optionsHtml;
  
  // Restore selection if it existed
  if (currentD2) {
    document.getElementById('editD2').value = currentD2;
  }
}

function renderEditPlayers(players) {
  const container = document.getElementById('editPlayersContainer');
  
  // v16.06: Build options with player-specific selection
  const buildPD1Options = (playerValue) => {
    let opts = S.playDetails1.length > 0 
      ? S.playDetails1.map(p => `<option value="${p.name}" ${p.name === playerValue ? 'selected' : ''}>${p.name}</option>`).join('')
      : LISTS.playOffensive.concat(LISTS.playDefensive).map(o => `<option value="${o}" ${o === playerValue ? 'selected' : ''}>${o}</option>`).join('');
    
    // If player has a value not in options, add it
    if (playerValue && !S.playDetails1.find(pd => pd.name === playerValue)) {
      opts = `<option value="${playerValue}" selected>${playerValue}</option>` + opts;
    }
    return opts;
  };
  
  const buildPD2Options = (playerValue) => {
    let opts = S.playDetails2.length > 0 
      ? S.playDetails2.map(p => `<option value="${p.name}" ${p.name === playerValue ? 'selected' : ''}>${p.name}</option>`).join('')
      : '';
    
    // If player has a value not in options, add it
    if (playerValue && !S.playDetails2.find(pd => pd.name === playerValue)) {
      opts = `<option value="${playerValue}" selected>${playerValue}</option>` + opts;
    }
    return opts;
  };
  
  // Player role options
  const eventRoles = S.playerRoles.filter(r => r.type === 'event_team');
  const oppRoles = S.playerRoles.filter(r => r.type === 'opp_team');
  
  container.innerHTML = (players || []).map((p, i) => {
    const isOpp = p.role?.startsWith('opp');
    const roleOptions = isOpp ? oppRoles : eventRoles;
    const roleOpts = roleOptions.length > 0 
      ? roleOptions.map(r => `<option value="${r.code}" ${p.role===r.code?'selected':''}>${r.name}</option>`).join('')
      : `<option value="event_player_1">Event Player 1</option><option value="event_player_2">Event Player 2</option><option value="opp_player_1">Opp Player 1</option>`;
    
    // Build role select with current value highlighted
    const currentRole = p.role || '';
    const buildRoleOption = (val, label) => {
      const selected = currentRole === val ? 'selected' : '';
      return `<option value="${val}" ${selected}>${label}</option>`;
    };
    
    return `
    <div class="edit-player-row" data-idx="${i}" style="display:grid;grid-template-columns:80px 90px 130px 130px 60px 25px;gap:4px;align-items:center;margin-bottom:6px;padding:4px;background:var(--panel);border-radius:3px;">
      <span class="pnum" style="font-weight:bold;font-size:10px;">#${p.num} ${p.name?.split(' ').pop() || ''}</span>
      <select onchange="updateEditPlayer(${i}, 'role', this.value)" style="font-size:9px;" title="Player Role">
        <option value="">-- Role --</option>
        <optgroup label="Event Team">
          ${buildRoleOption('event_player_1', 'Event P1')}
          ${buildRoleOption('event_player_2', 'Event P2')}
          ${buildRoleOption('event_player_3', 'Event P3')}
          ${buildRoleOption('event_player_4', 'Event P4')}
          ${buildRoleOption('event_player_5', 'Event P5')}
          ${buildRoleOption('event_player_6', 'Event P6')}
          ${buildRoleOption('event_goalie', 'Event Goalie')}
        </optgroup>
        <optgroup label="Opponent">
          ${buildRoleOption('opp_player_1', 'Opp P1')}
          ${buildRoleOption('opp_player_2', 'Opp P2')}
          ${buildRoleOption('opp_player_3', 'Opp P3')}
          ${buildRoleOption('opp_player_4', 'Opp P4')}
          ${buildRoleOption('opp_player_5', 'Opp P5')}
          ${buildRoleOption('opp_player_6', 'Opp P6')}
          ${buildRoleOption('opp_goalie', 'Opp Goalie')}
        </optgroup>
      </select>
      <select onchange="updateEditPlayer(${i}, 'playD1', this.value)" style="font-size:9px;" title="Play Detail 1">
        <option value="">-- Play D1 --</option>
        ${buildPD1Options(p.playD1)}
      </select>
      <select onchange="updateEditPlayer(${i}, 'playD2', this.value)" style="font-size:9px;" title="Play Detail 2">
        <option value="">-- Play D2 --</option>
        ${buildPD2Options(p.playD2)}
      </select>
      <select onchange="updateEditPlayer(${i}, 'playSuccess', this.value)" style="font-size:9px;" title="Success">
        <option value="">Succ</option>
        <option value="s" ${p.playSuccess==='s'?'selected':''}>S</option>
        <option value="u" ${p.playSuccess==='u'?'selected':''}>U</option>
      </select>
      <button class="btn-sm btn-danger" onclick="removeEditPlayer(${i})" style="padding:2px 4px;">‚úï</button>
    </div>`;
  }).join('') || '<p style="color:var(--muted);font-size:9px;">No players - click + Add to add players</p>';
}

function renderEditPuckXY(puckXY) {
  const container = document.getElementById('editPuckXY');
  container.innerHTML = (puckXY || []).map((xy, i) => 
    `<button class="edit-xy-btn has" onclick="editXYPoint('puck', ${i})" title="(${xy.x}, ${xy.y})">${i+1}: (${Math.round(xy.x)}, ${Math.round(xy.y)})</button>
     <button class="btn-sm btn-danger" onclick="deleteXYPoint('puck', ${i})" style="padding:2px 4px;">‚úï</button>`
  ).join('') + '<button class="edit-xy-btn" onclick="addXYPoint(\'puck\')">+ Add XY</button>';
}

function renderEditPlayerXY(players) {
  // Add player XY display to edit modal
  const playerContainer = document.getElementById('editPlayersContainer');
  if (!playerContainer || !players?.length) return;
  
  // Append XY info to each player row (already in renderEditPlayers)
}

function editXYPoint(type, idx) {
  if (S.editingEvtIdx === null) return;
  S.editingXYType = type;
  S.editingXYIdx = idx;
  
  // Show mini rink modal for XY editing
  document.getElementById('xyEditModal').classList.add('show');
  renderXYEditRink();
}

function addXYPoint(type) {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  
  if (type === 'puck') {
    evt.puckXY = evt.puckXY || [];
    evt.puckXY.push({ x: 100, y: 42.5, seq: evt.puckXY.length + 1 });
    renderEditPuckXY(evt.puckXY);
  }
}

function deleteXYPoint(type, idx) {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  
  if (type === 'puck' && evt.puckXY) {
    evt.puckXY.splice(idx, 1);
    renderEditPuckXY(evt.puckXY);
  }
}

function renderXYEditRink() {
  // Highlight current point on mini rink
  const marker = document.getElementById('xyEditMarker');
  if (!marker) return;
  
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  
  let xy = null;
  if (S.editingXYType === 'puck' && evt.puckXY?.[S.editingXYIdx]) {
    xy = evt.puckXY[S.editingXYIdx];
  }
  
  if (xy) {
    marker.innerHTML = `<circle cx="${xy.x}" cy="${xy.y}" r="3" fill="#ef4444" stroke="#fff" stroke-width="0.5"/>`;
  } else {
    marker.innerHTML = '';
  }
}

function handleXYEditClick(event) {
  if (S.editingEvtIdx === null) return;
  
  const svg = document.getElementById('xyEditSvg');
  const rect = svg.getBoundingClientRect();
  const pt = svg.createSVGPoint();
  pt.x = event.clientX; pt.y = event.clientY;
  const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
  
  const xy = { x: Math.round(svgPt.x * 100) / 100, y: Math.round(svgPt.y * 100) / 100 };
  
  const evt = S.events[S.editingEvtIdx];
  
  if (S.editingXYType === 'puck' && evt.puckXY?.[S.editingXYIdx]) {
    evt.puckXY[S.editingXYIdx].x = xy.x;
    evt.puckXY[S.editingXYIdx].y = xy.y;
    renderEditPuckXY(evt.puckXY);
  }
  
  renderXYEditRink();
}

function closeXYEditModal() {
  document.getElementById('xyEditModal').classList.remove('show');
  S.editingXYType = null;
  S.editingXYIdx = null;
}

function updateEditPlayer(idx, field, val) {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  if (evt.players[idx]) evt.players[idx][field] = val;
}

function removeEditPlayer(idx) {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  evt.players.splice(idx, 1);
  renderEditPlayers(evt.players);
}

function addPlayerToEdit() {
  if (S.editingEvtIdx === null) {
    toast('No event being edited', 'error');
    return;
  }
  
  const evt = S.events[S.editingEvtIdx];
  
  // Set team based on event being edited
  document.getElementById('pickerTeam').value = evt.team || S.evtTeam;
  
  // Check if rosters are loaded
  if (!S.rosters.home?.length && !S.rosters.away?.length) {
    toast('No rosters loaded - select a game first', 'error');
    return;
  }
  
  renderPlayerPicker();
  document.getElementById('playerPickerModal').classList.add('show');
}

function setBackupPath(val) {
  if (val) document.getElementById('backupPath').value = val;
}

function renderPlayerPicker() {
  const team = document.getElementById('pickerTeam').value;
  const roster = S.rosters[team] || [];
  
  document.getElementById('playerPickerList').innerHTML = roster.map(p => `
    <div class="picker-player" onclick="selectPlayerFromPicker('${p.num}', '${p.name}')" 
         style="padding:6px;margin:2px 0;background:var(--card);border-radius:3px;cursor:pointer;display:flex;justify-content:space-between;">
      <span><strong>#${p.num}</strong> ${p.name}</span>
      <span style="color:var(--muted);">${p.pos || 'F'}</span>
    </div>
  `).join('') || '<div style="color:var(--muted);">No players</div>';
}

function selectPlayerFromPicker(num, name) {
  if (S.editingEvtIdx === null) {
    toast('No event being edited', 'error');
    return;
  }
  const evt = S.events[S.editingEvtIdx];
  
  // Ensure players array exists
  if (!evt.players) evt.players = [];
  
  const role = document.getElementById('pickerRole').value;
  const team = document.getElementById('pickerTeam').value;
  
  // Check if player already in event
  if (evt.players.some(p => p.num === num)) {
    toast(`#${num} already in event`, 'error');
    return;
  }
  
  // Determine next role number
  const existingRoles = evt.players.filter(p => p.role.startsWith(role)).length;
  const roleNum = existingRoles + 1;
  
  evt.players.push({
    num, name, 
    role: `${role}_${roleNum}`,
    roleNum,
    team,
    xy: [],
    playD1: '', playD2: '', playSuccess: '', pressure: '', sideOfPuck: ''
  });
  
  renderEditPlayers(evt.players);
  
  // Update XY target dropdown
  const xyTargetSel = document.getElementById('editXYTarget');
  xyTargetSel.innerHTML = '<option value="puck">Puck</option>' + 
    evt.players.map((p, i) => `<option value="player_${i}">#${p.num} ${p.name}</option>`).join('');
  
  closePlayerPicker();
  toast(`Added #${num} ${name}`, 'success');
}

function closePlayerPicker() {
  document.getElementById('playerPickerModal').classList.remove('show');
}

// ============================================================
// VERIFICATION PANEL
// ============================================================
async function openVerifyModal() {
  // Set noradhockey link
  const link = document.getElementById('noradGameLink');
  if (S.gameId) {
    link.href = `https://noradhockey.com/event/${S.gameId}/`;
    link.style.display = 'inline';
    
    // v15.02: Auto-populate official score from dim_schedule if connected
    if (S.connected) {
      try {
        console.log('Loading official score for game', S.gameId);
        const { data: schedData, error: schedError } = await S.sb.from('dim_schedule')
          .select('home_total_goals,away_total_goals,home_team_period1_goals,home_team_period2_goals,home_team_period3_goals,away_team_period1_goals,away_team_period2_goals,away_team_period3_goals')
          .eq('game_id', S.gameId)
          .single();
        
        if (schedError) {
          console.error('Error loading official score:', schedError);
        }
        
        console.log('Official score data:', schedData);
        
        if (schedData) {
          // Store in hidden fields
          document.getElementById('officialHomeGoals').value = schedData.home_total_goals ?? 0;
          document.getElementById('officialAwayGoals').value = schedData.away_total_goals ?? 0;
          
          // Display total goals
          document.getElementById('officialHomeGoalsDisplay').textContent = schedData.home_total_goals ?? 0;
          document.getElementById('officialAwayGoalsDisplay').textContent = schedData.away_total_goals ?? 0;
          
          // Display by period
          const hp1 = schedData.home_team_period1_goals ?? '-';
          const hp2 = schedData.home_team_period2_goals ?? '-';
          const hp3 = schedData.home_team_period3_goals ?? '-';
          const ap1 = schedData.away_team_period1_goals ?? '-';
          const ap2 = schedData.away_team_period2_goals ?? '-';
          const ap3 = schedData.away_team_period3_goals ?? '-';
          
          document.getElementById('officialHomeByPeriod').textContent = `P1: ${hp1} | P2: ${hp2} | P3: ${hp3}`;
          document.getElementById('officialAwayByPeriod').textContent = `P1: ${ap1} | P2: ${ap2} | P3: ${ap3}`;
          
          // Store period data for comparison
          S.officialPeriodGoals = {
            home: { 1: hp1, 2: hp2, 3: hp3 },
            away: { 1: ap1, 2: ap2, 3: ap3 }
          };
          
          console.log('Official score loaded successfully');
        } else {
          console.log('No schedule data found for game', S.gameId);
        }
        
        // v6: Load fact_gameroster for verification
        const { data: rosterData } = await S.sb.from('fact_gameroster')
          .select('player_game_number,player_full_name,goals,assist,team_venue')
          .eq('game_id', S.gameId);
        
        if (rosterData) {
          S.rosterStats = {};
          rosterData.forEach(p => {
            S.rosterStats[String(p.player_game_number)] = {
              name: p.player_full_name,
              goals: parseInt(p.goals) || 0,
              assists: parseInt(p.assist) || 0,
              team: (p.team_venue || '').toLowerCase() === 'home' ? 'home' : 'away'
            };
          });
        }
      } catch(e) { console.log('Could not auto-populate score:', e); }
    }
  } else {
    link.style.display = 'none';
  }
  
  runVerification();
  document.getElementById('verifyModal').classList.add('show');
}

function closeVerifyModal() {
  document.getElementById('verifyModal').classList.remove('show');
}

function runVerification() {
  // v6: Count tracked goals by team and period
  const homeGoals = S.events.filter(e => e.type === 'Goal' && e.detail1 === 'Goal_Scored' && e.team === 'home');
  const awayGoals = S.events.filter(e => e.type === 'Goal' && e.detail1 === 'Goal_Scored' && e.team === 'away');
  
  // Count by period
  const homeP1 = homeGoals.filter(g => g.period === 1 || g.period === '1').length;
  const homeP2 = homeGoals.filter(g => g.period === 2 || g.period === '2').length;
  const homeP3 = homeGoals.filter(g => g.period === 3 || g.period === '3').length;
  const awayP1 = awayGoals.filter(g => g.period === 1 || g.period === '1').length;
  const awayP2 = awayGoals.filter(g => g.period === 2 || g.period === '2').length;
  const awayP3 = awayGoals.filter(g => g.period === 3 || g.period === '3').length;
  
  document.getElementById('verifyHomeGoals').textContent = homeGoals.length;
  document.getElementById('verifyAwayGoals').textContent = awayGoals.length;
  document.getElementById('verifyHomeByPeriod').textContent = `P1: ${homeP1} | P2: ${homeP2} | P3: ${homeP3}`;
  document.getElementById('verifyAwayByPeriod').textContent = `P1: ${awayP1} | P2: ${awayP2} | P3: ${awayP3}`;
  
  // Compare to official
  const officialHome = parseInt(document.getElementById('officialHomeGoals').value) || 0;
  const officialAway = parseInt(document.getElementById('officialAwayGoals').value) || 0;
  
  const resultEl = document.getElementById('verifyResult');
  if (homeGoals.length === officialHome && awayGoals.length === officialAway) {
    resultEl.innerHTML = '‚úÖ VERIFIED - Goals match official score!';
    resultEl.style.background = 'rgba(16, 185, 129, 0.2)';
    resultEl.style.color = 'var(--success)';
  } else {
    const diff = `Home: ${homeGoals.length} vs ${officialHome}, Away: ${awayGoals.length} vs ${officialAway}`;
    resultEl.innerHTML = `‚ùå MISMATCH - ${diff}`;
    resultEl.style.background = 'rgba(239, 68, 68, 0.2)';
    resultEl.style.color = 'var(--danger)';
  }
  
  // v6: Build goal list with scorer # and assist # (from %assist% in play_detail)
  const allGoals = [...homeGoals, ...awayGoals].sort((a, b) => {
    if (a.period !== b.period) return a.period - b.period;
    return (b.start_time || '20:00').localeCompare(a.start_time || '20:00');
  });
  
  // Track for warnings
  const warnings = [];
  
  document.getElementById('verifyGoalsList').innerHTML = allGoals.map(g => {
    const scorer = g.players?.find(p => p.role === 'event_player_1');
    
    // v6: Find assists by checking for '%assist%' in play_detail1 or play_detail2
    const assisters = (g.players || []).filter(p => {
      const pd1 = (p.playD1 || '').toLowerCase();
      const pd2 = (p.playD2 || '').toLowerCase();
      return pd1.includes('assist') || pd2.includes('assist');
    });
    
    const scorerNum = scorer?.num || '';
    const scorerName = scorer?.name || '';
    const assistStr = assisters.length > 0 
      ? assisters.map(a => `#${a.num}`).join(', ')
      : 'Unassisted';
    
    // v6: Check against roster stats
    let rosterMatch = '‚úì';
    if (S.rosterStats && scorerNum) {
      const rosterPlayer = S.rosterStats[scorerNum];
      if (rosterPlayer) {
        // Check if roster shows this player has a goal
        if (rosterPlayer.goals === 0) {
          rosterMatch = '‚ö†Ô∏è';
          warnings.push(`#${scorerNum} ${scorerName} scored but roster shows 0 goals`);
        }
      } else {
        rosterMatch = '?';
        warnings.push(`#${scorerNum} ${scorerName} not found in roster`);
      }
      
      // Check assisters
      assisters.forEach(a => {
        const assistRoster = S.rosterStats[a.num];
        if (assistRoster && assistRoster.assists === 0) {
          warnings.push(`#${a.num} has assist but roster shows 0 assists`);
        }
      });
    }
    
    return `<tr>
      <td>P${g.period}</td>
      <td>${g.start_time || '--'}</td>
      <td style="color:${g.team === 'home' ? 'var(--home)' : 'var(--away)'};">${g.team === 'home' ? (S.homeTeam || 'HOME') : (S.awayTeam || 'AWAY')}</td>
      <td><strong>#${scorerNum}</strong> ${scorerName}</td>
      <td>${assistStr}</td>
      <td>${rosterMatch}</td>
    </tr>`;
  }).join('') || '<tr><td colspan="6" style="text-align:center;color:var(--muted);">No goals recorded</td></tr>';
  
  // v6: Additional warnings
  if (homeGoals.length !== officialHome) warnings.push(`Home goals off by ${Math.abs(homeGoals.length - officialHome)}`);
  if (awayGoals.length !== officialAway) warnings.push(`Away goals off by ${Math.abs(awayGoals.length - officialAway)}`);
  
  // Check period mismatches
  if (S.officialPeriodGoals) {
    if (S.officialPeriodGoals.home[1] !== '-' && homeP1 !== parseInt(S.officialPeriodGoals.home[1])) {
      warnings.push(`P1 home goals: ${homeP1} tracked vs ${S.officialPeriodGoals.home[1]} official`);
    }
    if (S.officialPeriodGoals.home[2] !== '-' && homeP2 !== parseInt(S.officialPeriodGoals.home[2])) {
      warnings.push(`P2 home goals: ${homeP2} tracked vs ${S.officialPeriodGoals.home[2]} official`);
    }
    if (S.officialPeriodGoals.away[1] !== '-' && awayP1 !== parseInt(S.officialPeriodGoals.away[1])) {
      warnings.push(`P1 away goals: ${awayP1} tracked vs ${S.officialPeriodGoals.away[1]} official`);
    }
    if (S.officialPeriodGoals.away[2] !== '-' && awayP2 !== parseInt(S.officialPeriodGoals.away[2])) {
      warnings.push(`P2 away goals: ${awayP2} tracked vs ${S.officialPeriodGoals.away[2]} official`);
    }
  }
  
  // Goals without scorers
  const goalsWithoutScorer = allGoals.filter(g => !g.players?.find(p => p.role === 'event_player_1'));
  if (goalsWithoutScorer.length > 0) warnings.push(`${goalsWithoutScorer.length} goal(s) missing scorer`);
  
  // v6: Display warnings in dedicated section
  const warningsEl = document.getElementById('verifyWarnings');
  const warningsListEl = document.getElementById('verifyWarningsList');
  if (warnings.length > 0) {
    warningsEl.style.display = 'block';
    warningsListEl.innerHTML = warnings.map(w => `<div>‚Ä¢ ${w}</div>`).join('');
  } else {
    warningsEl.style.display = 'none';
  }
}

// ============================================================
// LOAD EXISTING GAME
// ============================================================
function openLoadGameModal() {
  if (!S.connected) {
    toast('Connect to Supabase first', 'error');
    return;
  }
  populateLoadGameSelect();
  document.getElementById('loadGameModal').classList.add('show');
}

function closeLoadGameModal() {
  document.getElementById('loadGameModal').classList.remove('show');
}

async function populateLoadGameSelect() {
  const select = document.getElementById('loadGameSelect');
  select.innerHTML = '<option value="">Loading tracked games...</option>';
  
  try {
    // Paginate through fact_events to get ALL game_ids
    console.log('Load modal: Querying fact_events...');
    const allGameIds = new Set();
    let offset = 0;
    const pageSize = 1000;
    let hasMore = true;
    
    while (hasMore && offset < 50000) {
      const { data, error } = await S.sb.from('fact_events')
        .select('game_id')
        .range(offset, offset + pageSize - 1);
      
      if (error) break;
      if (!data || data.length === 0) {
        hasMore = false;
      } else {
        data.forEach(r => allGameIds.add(r.game_id));
        offset += pageSize;
        if (data.length < pageSize) hasMore = false;
      }
    }
    
    const trackedGameIds = Array.from(allGameIds);
    console.log('Load modal: Found game IDs:', trackedGameIds);
    
    if (trackedGameIds.length === 0) {
      select.innerHTML = '<option value="">No tracked games found</option>';
      return;
    }
    
    // Get game details for tracked games
    const { data: games } = await S.sb.from('dim_schedule')
      .select('game_id,date,home_team_name,away_team_name')
      .in('game_id', trackedGameIds)
      .order('date', { ascending: false });
    
    console.log('Load modal: Schedule returned', games?.length, 'rows');
    
    // Dedupe
    const seen = new Set();
    const uniqueGames = (games || []).filter(g => {
      if (seen.has(g.game_id)) return false;
      seen.add(g.game_id);
      return true;
    });
    
    select.innerHTML = '<option value="">Select tracked game (' + uniqueGames.length + ')</option>' + 
      uniqueGames.map(g => `<option value="${g.game_id}">${g.game_id} - ${g.date?.split('T')[0]} ${g.home_team_name} vs ${g.away_team_name}</option>`).join('');
      
    console.log('Load game modal:', uniqueGames.length, 'tracked games');
  } catch(e) {
    toast('Failed to load games', 'error');
    console.error(e);
  }
}

async function previewLoadGame() {
  const gameId = document.getElementById('loadGameSelect').value;
  if (!gameId) {
    document.getElementById('loadPreviewEvents').textContent = '--';
    document.getElementById('loadPreviewShifts').textContent = '--';
    return;
  }
  
  try {
    const { count: evtCount } = await S.sb.from('fact_events').select('*', { count: 'exact', head: true }).eq('game_id', gameId);
    const { count: shiftCount } = await S.sb.from('fact_shifts').select('*', { count: 'exact', head: true }).eq('game_id', gameId);
    
    document.getElementById('loadPreviewEvents').textContent = evtCount || 0;
    document.getElementById('loadPreviewShifts').textContent = shiftCount || 0;
  } catch(e) {
    console.error(e);
  }
}

async function confirmLoadGame() {
  const gameId = document.getElementById('loadGameSelect').value;
  if (!gameId) { toast('Select a game', 'error'); return; }
  
  try {
    toast('Loading game data from Supabase...', 'info');
    console.log('=== LOADING GAME:', gameId, '===');
    
    // First set the game ID and find game info
    S.gameId = parseInt(gameId);
    const g = S.games.find(x => x.game_id == gameId);
    if (g) {
      S.homeTeam = g.home_team_name;
      S.awayTeam = g.away_team_name;
      console.log('Game info:', S.homeTeam, 'vs', S.awayTeam);
      
      // v16: Load team colors and logos from S.teams (loaded in loadReferenceData)
      const homeTeamData = S.teams[S.homeTeam] || {};
      const awayTeamData = S.teams[S.awayTeam] || {};
      S.homeColor = homeTeamData.color1 || '#3b82f6';
      S.awayColor = awayTeamData.color1 || '#ef4444';
      S.homeLogo = homeTeamData.logo || null;
      S.awayLogo = awayTeamData.logo || null;
      console.log('Team colors:', S.homeColor, S.awayColor);
      console.log('Team logos:', S.homeLogo, S.awayLogo);
      
      // v16: Apply team colors to CSS variables
      document.documentElement.style.setProperty('--home', S.homeColor);
      document.documentElement.style.setProperty('--away', S.awayColor);
      
      // v16: Update UI labels with team names (not Home/Away)
      document.getElementById('homeLbl').textContent = S.homeTeam;
      document.getElementById('awayLbl').textContent = S.awayTeam;
      document.getElementById('evtHomeLbl').textContent = S.homeTeam;
      document.getElementById('evtAwayLbl').textContent = S.awayTeam;
      
      // v16: Update team logos if available
      updateTeamLogos();
      updateZoneLabels();
    }
    
    // Update the main game dropdown
    document.getElementById('gameSelect').value = gameId;
    
    // Load events with pagination (Supabase 1000 row limit)
    console.log('Loading events...');
    let allEvents = [];
    let offset = 0;
    let hasMore = true;
    
    while (hasMore) {
      const { data, error } = await S.sb.from('fact_events')
        .select('*')
        .eq('game_id', gameId)
        .order('event_id')
        .range(offset, offset + 999);
      
      if (error) {
        console.error('Event load error:', error);
        throw error;
      }
      
      if (!data || data.length === 0) {
        hasMore = false;
      } else {
        allEvents = allEvents.concat(data);
        console.log(`  Events page: ${data.length} (total: ${allEvents.length})`);
        offset += 1000;
        if (data.length < 1000) hasMore = false;
      }
    }
    console.log('Total events loaded:', allEvents.length);
    
    // Load shifts with pagination
    console.log('Loading shifts...');
    let allShifts = [];
    offset = 0;
    hasMore = true;
    
    while (hasMore) {
      const { data, error } = await S.sb.from('fact_shifts')
        .select('*')
        .eq('game_id', gameId)
        .order('shift_index')
        .range(offset, offset + 999);
      
      if (error) {
        console.error('Shift load error:', error);
        throw error;
      }
      
      if (!data || data.length === 0) {
        hasMore = false;
      } else {
        allShifts = allShifts.concat(data);
        console.log(`  Shifts page: ${data.length} (total: ${allShifts.length})`);
        offset += 1000;
        if (data.length < 1000) hasMore = false;
      }
    }
    console.log('Total shifts loaded:', allShifts.length);
    
    // Load event players for player details
    console.log('Loading event players...');
    let allPlayers = [];
    offset = 0;
    hasMore = true;
    
    while (hasMore) {
      const { data, error } = await S.sb.from('fact_event_players')
        .select('*')
        .eq('game_id', gameId)
        .range(offset, offset + 999);
      
      if (error) {
        console.error('Player load error:', error);
        throw error;
      }
      
      if (!data || data.length === 0) {
        hasMore = false;
      } else {
        allPlayers = allPlayers.concat(data);
        console.log(`  Players page: ${data.length} (total: ${allPlayers.length})`);
        offset += 1000;
        if (data.length < 1000) hasMore = false;
      }
    }
    console.log('Total player rows loaded:', allPlayers.length);
    
    // v16.02: Debug - log column names from first player row
    if (allPlayers.length > 0) {
      console.log('Player columns:', Object.keys(allPlayers[0]));
      // Find a player with play_detail data for debugging
      const playerWithPD = allPlayers.find(p => p.play_detail1 || p.play_detail_1 || p['play_detail1']);
      if (playerWithPD) {
        console.log('Sample player with play_detail:', {
          event_id: playerWithPD.event_id,
          player_game_number: playerWithPD.player_game_number,
          play_detail1: playerWithPD.play_detail1,
          'play_detail_1': playerWithPD.play_detail_1,
          play_detail_2: playerWithPD.play_detail_2,
          'play_detail2': playerWithPD.play_detail2
        });
      } else {
        console.log('No players with play_detail found in sample');
        // Log first 3 players to see all fields
        console.log('First 3 players:', allPlayers.slice(0, 3).map(p => ({...p})));
      }
    }
    
    // Group players by event_id
    const playersByEvent = {};
    allPlayers.forEach(p => {
      const evtId = p.event_id;
      if (!playersByEvent[evtId]) playersByEvent[evtId] = [];
      playersByEvent[evtId].push(p);
    });
    console.log('Events with players:', Object.keys(playersByEvent).length);
    
    // Convert events to tracker format
    console.log('Converting events to tracker format...');
    S.events = allEvents.map((e, i) => {
      const evtPlayers = playersByEvent[e.event_id] || [];
      
      // v15: Fix team loading - use player_team from event_player_1, compare to home_team
      // The team_venue column in fact_events is unreliable (often all 'Away')
      // Instead, find the event_player_1 and check their player_team vs home_team
      let isHome = false;
      const eventPlayer1 = evtPlayers.find(p => 
        p.player_role === 'event_player_1' || p.player_role === 'event_team_player_1'
      );
      if (eventPlayer1) {
        // Compare player_team to home_team to determine if home or away
        isHome = eventPlayer1.player_team === e.home_team || eventPlayer1.player_team === S.homeTeam;
      } else {
        // Fallback: try team_venue but normalize case
        const teamVenue = (e.team_venue || e.team || '').toLowerCase();
        isHome = teamVenue === 'home' || teamVenue === 'h';
      }
      
      return {
        idx: i + 1,
        eventId: e.event_id,
        game_id: e.game_id,
        period: e.period,
        start_time: `${e.event_start_min || 0}:${String(e.event_start_sec || 0).padStart(2, '0')}`,
        end_time: `${e.event_end_min || e.event_start_min || 0}:${String(e.event_end_sec || e.event_start_sec || 0).padStart(2, '0')}`,
        team: isHome ? 'home' : 'away',
        type: e.event_type,
        detail1: e.event_detail,
        detail2: e.event_detail_2,
        zone: e.event_team_zone?.charAt(0).toLowerCase() || '',
        success: e.event_successful,
        strength: e.strength || '5v5',
        isHighlight: e.is_highlight === 1 || e.is_highlight === true,
        linkedEventIdx: e.linked_event_key || null,
        sequenceIdx: e.sequence_key || null,
        playIdx: e.play_key || null,
        puckXY: (e.puck_x_start != null && e.puck_y_start != null) ? 
          [{ x: e.puck_x_start, y: e.puck_y_start }] : [],
        players: evtPlayers.map(p => {
          // v16.02: Debug play_detail mapping
          const pd1 = p.play_detail1 || p.play_detail_1 || p.player_play_detail_1 || '';
          const pd2 = p.play_detail_2 || p.play_detail2 || p.player_play_detail_2 || '';
          // v16.03: Target debug for specific event/player
          if (e.event_id === 'EV1896901058' || (pd1 && pd1.toLowerCase().includes('forced'))) {
            console.log(`üéØ TARGET DEBUG - Event ${e.event_id}, Player #${p.player_game_number}:`);
            console.log('  Raw play_detail1:', p.play_detail1);
            console.log('  Raw play_detail_2:', p.play_detail_2);
            console.log('  Mapped pd1:', pd1);
            console.log('  Mapped pd2:', pd2);
          }
          return {
          num: String(p.player_game_number || ''),
          name: p.player_name || '',
          role: p.player_role || 'event_team_player_1',
          roleNum: p.role_number || 1,
          // v16.02: Enhanced column checking with debug
          playD1: pd1,
          playD2: pd2,
          playSuccess: p.play_detail_successful || p.play_successful || '',
          pressure: p.pressured_pressurer || '',
          sideOfPuck: p.side_of_puck || '',
          teamVenue: p.team_venue || '',
          xy: (p.player_x != null && p.player_y != null) ? 
            [{ x: p.player_x, y: p.player_y }] : []
        };})
      };
    });
    console.log('Converted', S.events.length, 'events');
    
    // v16.03: Debug summary - count events with play_detail data
    const eventsWithPD = S.events.filter(e => e.players?.some(p => p.playD1 || p.playD2));
    console.log(`Events with play_detail data: ${eventsWithPD.length}/${S.events.length}`);
    if (eventsWithPD.length > 0) {
      console.log('Sample events with PD:', eventsWithPD.slice(0, 5).map(e => ({
        eventId: e.eventId,
        type: e.type,
        players: e.players?.map(p => ({ num: p.num, playD1: p.playD1, playD2: p.playD2 }))
      })));
    }
    // Check for specific event
    const targetEvent = S.events.find(e => e.eventId === 'EV1896901058');
    if (targetEvent) {
      console.log('üéØ Found EV1896901058:', targetEvent);
    } else {
      console.log('‚ö†Ô∏è EV1896901058 not found in loaded events');
    }
    
    // Convert shifts to tracker format
    console.log('Converting shifts to tracker format...');
    S.shifts = allShifts.map((sh, i) => ({
      idx: i + 1,
      shiftId: sh.shift_id,
      period: sh.period,
      start_time: `${sh.shift_start_min || 0}:${String(sh.shift_start_sec || 0).padStart(2, '0')}`,
      end_time: `${sh.shift_end_min || 0}:${String(sh.shift_end_sec || 0).padStart(2, '0')}`,
      start_type: sh.shift_start_type || 'OnTheFly',  // v17: Fixed to match LISTS format
      stop_type: sh.shift_stop_type || 'OnTheFly',    // v17: Fixed to match LISTS format
      strength: sh.strength || '5v5',
      stoppageTime: sh.stoppage_time || 0,
      home: {
        F1: sh.home_forward_1 ? { num: String(sh.home_forward_1) } : null,
        F2: sh.home_forward_2 ? { num: String(sh.home_forward_2) } : null,
        F3: sh.home_forward_3 ? { num: String(sh.home_forward_3) } : null,
        D1: sh.home_defense_1 ? { num: String(sh.home_defense_1) } : null,
        D2: sh.home_defense_2 ? { num: String(sh.home_defense_2) } : null,
        G: sh.home_goalie ? { num: String(sh.home_goalie) } : null,
        X: sh.home_xtra ? { num: String(sh.home_xtra) } : null
      },
      away: {
        F1: sh.away_forward_1 ? { num: String(sh.away_forward_1) } : null,
        F2: sh.away_forward_2 ? { num: String(sh.away_forward_2) } : null,
        F3: sh.away_forward_3 ? { num: String(sh.away_forward_3) } : null,
        D1: sh.away_defense_1 ? { num: String(sh.away_defense_1) } : null,
        D2: sh.away_defense_2 ? { num: String(sh.away_defense_2) } : null,
        G: sh.away_goalie ? { num: String(sh.away_goalie) } : null,
        X: sh.away_xtra ? { num: String(sh.away_xtra) } : null
      }
    }));
    console.log('Converted', S.shifts.length, 'shifts');
    
    S.evtIdx = S.events.length;
    S.shiftIdx = S.shifts.length;
    
    // Load rosters
    console.log('Loading rosters...');
    await loadRosters(gameId);
    
    // Close modal and render everything
    closeLoadGameModal();
    
    // Full render
    console.log('Rendering UI...');
    renderAll();
    renderRosters();
    renderEvents();
    renderShiftLog();
    updateScores();
    updateBoxScore();
    
    // Update localStorage
    localStorage.setItem('bs_lastGame', gameId);
    
    toast(`‚úÖ Loaded ${S.events.length} events, ${S.shifts.length} shifts`, 'success');
    console.log('=== LOAD COMPLETE ===');
    
  } catch(e) {
    toast('Failed to load game: ' + e.message, 'error');
    console.error('Load game error:', e);
  }
}

// ============================================================
// CLEAR ALL DATA
// ============================================================
function clearAllData() {
  if (!confirm('‚ö†Ô∏è Clear ALL events and shifts for this game?\n\nThis cannot be undone!')) return;
  if (!confirm('Are you REALLY sure? All tracking data will be lost.')) return;
  
  S.events = [];
  S.shifts = [];
  S.evtIdx = 0;
  S.shiftIdx = 0;
  S.lastSave = null;
  
  // Clear localStorage
  if (S.gameId) {
    localStorage.removeItem(`bs_${S.gameId}`);
  }
  
  renderAll();
  updateScores();
  updateBoxScore();
  
  toast('All data cleared', 'success');
  closeSettings();
}

/**
 * Clear all events (with confirmation)
 */
function clearAllEvents() {
  if (S.events.length === 0) {
    toast('No events to clear', 'info');
    return;
  }
  if (!confirm(`‚ö†Ô∏è Clear ALL ${S.events.length} events?\n\nThis cannot be undone!`)) return;
  
  S.events = [];
  S.evtIdx = 0;
  
  renderEvents();
  updateScores();
  updateBoxScore();
  renderMarkers();
  autoSave();
  
  toast(`Cleared all events`, 'success');
}

/**
 * Clear all shifts (with confirmation)
 */
function clearAllShifts() {
  if (S.shifts.length === 0) {
    toast('No shifts to clear', 'info');
    return;
  }
  if (!confirm(`‚ö†Ô∏è Clear ALL ${S.shifts.length} shifts?\n\nThis cannot be undone!`)) return;
  
  S.shifts = [];
  S.shiftIdx = 0;
  
  renderShiftLog();
  updateBoxScore();
  autoSave();
  
  toast(`Cleared all shifts`, 'success');
}

// ============================================================
// LINKED EVENT LOGIC
// ============================================================
function applyLinkedEventData() {
  // Copy XY data from linked event chain to current event
  // This applies to ALL linked event types
  if (S.linkedEventIdx === null && S.linkedEventIdx !== 0) return;
  
  const currType = S.curr.type;
  
  // ============================================================
  // FIND THE BEST SOURCE FOR XY DATA
  // Priority: 1) Most recent sibling (same linked_event), 2) Source event, 3) Previous event
  // ============================================================
  
  let sourceEvt = null;
  let sourceDesc = '';
  
  // 1. Check for sibling events (same linked_event) - get the most recent one with XY
  const siblings = S.events
    .filter(e => e.linkedEventIdx === S.linkedEventIdx && e.puckXY?.length)
    .sort((a, b) => b.idx - a.idx); // Most recent first
  
  if (siblings.length > 0) {
    sourceEvt = siblings[0];
    sourceDesc = `sibling #${sourceEvt.idx + 1} (${sourceEvt.type})`;
  }
  
  // 2. If no sibling has XY, check the source event itself
  if (!sourceEvt) {
    const linkedEvt = S.events.find(e => e.idx === S.linkedEventIdx);
    if (linkedEvt?.puckXY?.length) {
      sourceEvt = linkedEvt;
      sourceDesc = `source #${linkedEvt.idx + 1} (${linkedEvt.type})`;
    }
  }
  
  // 3. If still no XY, check the most recent event (regardless of linked_event)
  if (!sourceEvt && S.events.length > 0) {
    const lastEvt = S.events[S.events.length - 1];
    if (lastEvt?.puckXY?.length) {
      sourceEvt = lastEvt;
      sourceDesc = `previous #${lastEvt.idx + 1} (${lastEvt.type})`;
    }
  }
  
  // If no source found with XY, just copy zone from linked event
  if (!sourceEvt) {
    const linkedEvt = S.events.find(e => e.idx === S.linkedEventIdx);
    if (linkedEvt?.zone) {
      document.getElementById('evtZone').value = linkedEvt.zone;
    }
    toast(`Linked to #${S.linkedEventIdx + 1} (no XY to copy)`, 'info');
    return;
  }
  
  // ============================================================
  // COPY ALL XY DATA FROM SOURCE
  // ============================================================
  
  // Copy puck XY
  if (sourceEvt.puckXY?.length) {
    S.curr.puckXY = JSON.parse(JSON.stringify(sourceEvt.puckXY));
  }
  
  // Copy net XY if available
  if (sourceEvt.netXY) {
    S.curr.netXY = JSON.parse(JSON.stringify(sourceEvt.netXY));
  }
  
  // Copy ALL player positions from source event
  if (sourceEvt.players?.length) {
    // Determine if teams should swap roles (e.g., Shot‚ÜíSave)
    const shouldSwapTeams = (
      (currType === 'Save' && sourceEvt.type === 'Shot') ||
      (currType === 'Block' && sourceEvt.type === 'Shot')
    );
    
    sourceEvt.players.forEach(srcPlayer => {
      // Deep copy the player
      const newPlayer = JSON.parse(JSON.stringify(srcPlayer));
      
      // Map role if teams should swap
      if (shouldSwapTeams && newPlayer.role) {
        if (newPlayer.role.includes('event_team')) {
          newPlayer.role = newPlayer.role.replace('event_team', 'opp_team');
        } else if (newPlayer.role.includes('opp_team')) {
          newPlayer.role = newPlayer.role.replace('opp_team', 'event_team');
        }
      }
      
      // Check if this player already exists in current event
      const existingIdx = S.curr.players.findIndex(p => 
        p.num === newPlayer.num && p.team === newPlayer.team
      );
      
      if (existingIdx >= 0) {
        // Merge XY data into existing player
        if (newPlayer.xy?.length) {
          S.curr.players[existingIdx].xy = newPlayer.xy;
        }
      } else {
        // Add player with XY
        S.curr.players.push(newPlayer);
      }
    });
  }
  
  // Copy zone from source or linked event
  const zoneSource = sourceEvt.zone || S.events.find(e => e.idx === S.linkedEventIdx)?.zone;
  if (zoneSource) {
    document.getElementById('evtZone').value = zoneSource;
  }
  
  // Re-render to show copied data
  renderQuickAdd();
  renderMarkers();
  
  // Show confirmation
  toast(`Copied XY from ${sourceDesc}`, 'info');
}

// ============================================================
// EDIT SHIFT PLAYERS
// ============================================================
function editShiftPlayers(shiftIdx) {
  S.editingShiftIdx = shiftIdx;
  const shift = S.shifts[shiftIdx];
  if (!shift) return;
  
  // Open edit shift modal with player editing capability
  document.getElementById('editShiftIdx').textContent = shiftIdx + 1;
  document.getElementById('editShiftPeriod').value = shift.period;
  document.getElementById('editShiftStartTime').value = shift.start_time || '';
  document.getElementById('editShiftEndTime').value = shift.end_time || '';
  document.getElementById('editShiftStartType').value = shift.start_type || '';
  document.getElementById('editShiftStopType').value = shift.stop_type || '';
  document.getElementById('editShiftStrength').value = shift.strength || '5v5';
  
  // Render player slots in edit modal
  renderEditShiftPlayers(shift);
  
  document.getElementById('editShiftModal').classList.add('show');
}

function renderEditShiftPlayers(shift) {
  const container = document.getElementById('editShiftPlayersContainer');
  if (!container) return;
  
  // Build player options for each team
  const buildPlayerOptions = (team, currentNum) => {
    const roster = S.rosters[team] || [];
    // Convert currentNum to string for comparison (Excel imports as number, roster might be string)
    const currentNumStr = currentNum != null ? String(currentNum) : '';
    
    // If roster is empty but we have a current number, show it as an option
    if (roster.length === 0 && currentNumStr) {
      return `<option value="">--</option><option value="${currentNumStr}" selected>#${currentNumStr}</option>`;
    }
    
    return `<option value="">--</option>` + roster.map(p => {
      const numStr = String(p.num);
      const selected = numStr === currentNumStr ? 'selected' : '';
      return `<option value="${numStr}" ${selected}>#${p.num} ${p.name?.split(' ').pop() || ''}</option>`;
    }).join('');
  };
  
  let html = '<div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;">';
  
  // Home players
  html += `<div>
    <div style="font-size:10px;font-weight:bold;color:var(--home);margin-bottom:6px;border-bottom:1px solid var(--home);padding-bottom:2px;">HOME</div>
    <div style="display:grid;gap:4px;">`;
  
  // Forwards
  html += `<div style="font-size:8px;color:var(--muted);margin-top:4px;">Forwards</div>`;
  ['F1','F2','F3'].forEach(pos => {
    const p = shift.home?.[pos];
    html += `<div style="display:flex;align-items:center;gap:4px;">
      <span style="width:20px;font-size:9px;color:var(--accent);">${pos}</span>
      <select onchange="updateShiftPlayer('home','${pos}',this.value)" style="flex:1;font-size:9px;padding:2px;">
        ${buildPlayerOptions('home', p?.num)}
      </select>
    </div>`;
  });
  
  // Defense
  html += `<div style="font-size:8px;color:var(--muted);margin-top:4px;">Defense</div>`;
  ['D1','D2'].forEach(pos => {
    const p = shift.home?.[pos];
    html += `<div style="display:flex;align-items:center;gap:4px;">
      <span style="width:20px;font-size:9px;color:var(--accent);">${pos}</span>
      <select onchange="updateShiftPlayer('home','${pos}',this.value)" style="flex:1;font-size:9px;padding:2px;">
        ${buildPlayerOptions('home', p?.num)}
      </select>
    </div>`;
  });
  
  // Goalie & Extra
  html += `<div style="font-size:8px;color:var(--muted);margin-top:4px;">Goalie / Extra</div>`;
  ['G','X'].forEach(pos => {
    const p = shift.home?.[pos];
    html += `<div style="display:flex;align-items:center;gap:4px;">
      <span style="width:20px;font-size:9px;color:var(--accent);">${pos}</span>
      <select onchange="updateShiftPlayer('home','${pos}',this.value)" style="flex:1;font-size:9px;padding:2px;">
        ${buildPlayerOptions('home', p?.num)}
      </select>
    </div>`;
  });
  
  html += '</div></div>';
  
  // Away players  
  html += `<div>
    <div style="font-size:10px;font-weight:bold;color:var(--away);margin-bottom:6px;border-bottom:1px solid var(--away);padding-bottom:2px;">AWAY</div>
    <div style="display:grid;gap:4px;">`;
  
  // Forwards
  html += `<div style="font-size:8px;color:var(--muted);margin-top:4px;">Forwards</div>`;
  ['F1','F2','F3'].forEach(pos => {
    const p = shift.away?.[pos];
    html += `<div style="display:flex;align-items:center;gap:4px;">
      <span style="width:20px;font-size:9px;color:var(--accent);">${pos}</span>
      <select onchange="updateShiftPlayer('away','${pos}',this.value)" style="flex:1;font-size:9px;padding:2px;">
        ${buildPlayerOptions('away', p?.num)}
      </select>
    </div>`;
  });
  
  // Defense
  html += `<div style="font-size:8px;color:var(--muted);margin-top:4px;">Defense</div>`;
  ['D1','D2'].forEach(pos => {
    const p = shift.away?.[pos];
    html += `<div style="display:flex;align-items:center;gap:4px;">
      <span style="width:20px;font-size:9px;color:var(--accent);">${pos}</span>
      <select onchange="updateShiftPlayer('away','${pos}',this.value)" style="flex:1;font-size:9px;padding:2px;">
        ${buildPlayerOptions('away', p?.num)}
      </select>
    </div>`;
  });
  
  // Goalie & Extra
  html += `<div style="font-size:8px;color:var(--muted);margin-top:4px;">Goalie / Extra</div>`;
  ['G','X'].forEach(pos => {
    const p = shift.away?.[pos];
    html += `<div style="display:flex;align-items:center;gap:4px;">
      <span style="width:20px;font-size:9px;color:var(--accent);">${pos}</span>
      <select onchange="updateShiftPlayer('away','${pos}',this.value)" style="flex:1;font-size:9px;padding:2px;">
        ${buildPlayerOptions('away', p?.num)}
      </select>
    </div>`;
  });
  
  html += '</div></div></div>';
  
  container.innerHTML = html;
}

/**
 * Update a player in the shift being edited
 */
function updateShiftPlayer(team, pos, playerNum) {
  if (S.editingShiftIdx === null) return;
  const shift = S.shifts[S.editingShiftIdx];
  
  if (!shift[team]) shift[team] = {};
  
  if (playerNum) {
    // Find player in roster
    const roster = S.rosters[team] || [];
    const player = roster.find(p => p.num === playerNum);
    shift[team][pos] = player ? { num: player.num, name: player.name } : { num: playerNum };
  } else {
    shift[team][pos] = null;
  }
  
  // Update strength
  shift.strength = deriveStrengthFromShift(shift);
  document.getElementById('editShiftStrength').value = shift.strength;
}

/**
 * Derive strength from shift player counts
 */
function deriveStrengthFromShift(shift) {
  const countPlayers = (team) => {
    let count = 0;
    ['F1','F2','F3','D1','D2','X'].forEach(pos => {
      if (shift[team]?.[pos]?.num) count++;
    });
    return count;
  };
  
  const homeSkaters = countPlayers('home');
  const awaySkaters = countPlayers('away');
  
  // Check for empty net
  const homeEN = !shift.home?.G?.num;
  const awayEN = !shift.away?.G?.num;
  
  if (homeEN || awayEN) return 'ENG';
  if (homeSkaters === awaySkaters) return `${homeSkaters}v${awaySkaters}`;
  return `${homeSkaters}v${awaySkaters}`;
}

// ============================================================
// RENDER ALL (utility)
// ============================================================
// (renderAll is defined earlier - this is a comment placeholder)
// ============================================================

function saveEditEvent() {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  
  evt.type = document.getElementById('editType').value;
  evt.team = document.getElementById('editTeam').value;
  evt.start_time = document.getElementById('editStartTime').value;
  evt.end_time = document.getElementById('editEndTime').value;
  evt.zone = document.getElementById('editZone').value;
  evt.success = document.getElementById('editSuccess').value;
  evt.strength = document.getElementById('editStrength').value;
  evt.detail1 = document.getElementById('editD1').value;
  evt.detail2 = document.getElementById('editD2').value;
  evt.isHighlight = document.getElementById('editHighlight').checked;
  
  // Save linked event index (convert from 1-based to 0-based)
  const linkedIdxEl = document.getElementById('editLinkedIdx');
  if (linkedIdxEl) {
    const linkedVal = linkedIdxEl.value ? parseInt(linkedIdxEl.value) - 1 : null;
    evt.linkedEventIdx = (linkedVal !== null && linkedVal >= 0) ? linkedVal : null;
  }
  
  closeEditModal();
  renderEvents(); updateScores(); updateBoxScore();
  autoSave();
  toast('Event updated', 'success');
}

function deleteEvent() {
  if (S.editingEvtIdx === null) return;
  if (!confirm('Delete this event?')) return;
  
  S.events.splice(S.editingEvtIdx, 1);
  closeEditModal();
  renderEvents(); updateScores(); updateBoxScore();
  autoSave();
  toast('Event deleted', 'success');
}

/**
 * v20.7: Insert a new event BEFORE the current one
 */
function insertEventBefore() {
  if (S.editingEvtIdx === null) return;
  
  const currentEvt = S.events[S.editingEvtIdx];
  
  // Create new blank event with same context
  const newEvt = {
    period: currentEvt.period,
    team: currentEvt.team,
    type: '',
    detail1: '',
    detail2: '',
    zone: currentEvt.zone || '',
    success: '',
    strength: currentEvt.strength || '5v5',
    start_time: currentEvt.start_time,
    end_time: '',
    players: [],
    puckXY: [],
    linkedEventIdx: null,
    isHighlight: false
  };
  
  // Insert at position
  S.events.splice(S.editingEvtIdx, 0, newEvt);
  
  const newIdx = S.editingEvtIdx;
  S.editingEvtIdx = null;
  
  closeEditModal();
  renderEvents(); updateScores(); updateBoxScore();
  autoSave();
  toast(`Inserted event #${newIdx + 1}`, 'success');
  
  // Open the new event for editing
  setTimeout(() => editEvent(newIdx), 100);
}

/**
 * v20.7: Insert a new event AFTER the current one
 */
function insertEventAfter() {
  if (S.editingEvtIdx === null) return;
  
  const currentEvt = S.events[S.editingEvtIdx];
  
  // Create new blank event with same context
  const newEvt = {
    period: currentEvt.period,
    team: currentEvt.team,
    type: '',
    detail1: '',
    detail2: '',
    zone: currentEvt.zone || '',
    success: '',
    strength: currentEvt.strength || '5v5',
    start_time: currentEvt.start_time,
    end_time: '',
    players: [],
    puckXY: [],
    linkedEventIdx: null,
    isHighlight: false
  };
  
  // Insert after current position
  const insertIdx = S.editingEvtIdx + 1;
  S.events.splice(insertIdx, 0, newEvt);
  
  S.editingEvtIdx = null;
  
  closeEditModal();
  renderEvents(); updateScores(); updateBoxScore();
  autoSave();
  toast(`Inserted event #${insertIdx + 1}`, 'success');
  
  // Open the new event for editing
  setTimeout(() => editEvent(insertIdx), 100);
}

/**
 * v20.7: Duplicate the current event
 */
function duplicateEvent() {
  if (S.editingEvtIdx === null) return;
  
  const currentEvt = S.events[S.editingEvtIdx];
  
  // Deep clone the event
  const newEvt = JSON.parse(JSON.stringify(currentEvt));
  // Clear linking to avoid confusion
  newEvt.linkedEventIdx = null;
  newEvt.eventId = null;
  newEvt.event_id = null;
  
  // Insert after current position
  const insertIdx = S.editingEvtIdx + 1;
  S.events.splice(insertIdx, 0, newEvt);
  
  S.editingEvtIdx = null;
  
  closeEditModal();
  renderEvents(); updateScores(); updateBoxScore();
  autoSave();
  toast(`Duplicated event ‚Üí #${insertIdx + 1}`, 'success');
  
  // Open the new event for editing
  setTimeout(() => editEvent(insertIdx), 100);
}

/**
 * v20.7: Add a new event at the end of the list
 */
function addNewEvent() {
  const lastEvt = S.events.length > 0 ? S.events[S.events.length - 1] : null;
  
  // Create new blank event
  const newEvt = {
    period: lastEvt ? lastEvt.period : S.period || 1,
    team: S.evtTeam || 'home',
    type: '',
    detail1: '',
    detail2: '',
    zone: '',
    success: '',
    strength: '5v5',
    start_time: lastEvt ? lastEvt.start_time : '',
    end_time: '',
    players: [],
    puckXY: [],
    linkedEventIdx: null,
    isHighlight: false
  };
  
  // Add to end
  S.events.push(newEvt);
  const newIdx = S.events.length - 1;
  
  renderEvents(); updateScores(); updateBoxScore();
  autoSave();
  toast(`Added event #${newIdx + 1}`, 'success');
  
  // Open the new event for editing
  setTimeout(() => editEvent(newIdx), 100);
}

function closeEditModal() {
  document.getElementById('editModal').classList.remove('show');
  S.editingEvtIdx = null;
}

/**
 * Navigate to previous/next event in edit modal
 * @param {number} dir - Direction (-1 for prev, 1 for next)
 */
function navEditEvent(dir) {
  if (S.editingEvtIdx === null) return;
  
  // Save current event first
  saveEditEventSilent();
  
  const newIdx = S.editingEvtIdx + dir;
  if (newIdx < 0 || newIdx >= S.events.length) {
    toast(dir < 0 ? 'First event' : 'Last event', 'info');
    return;
  }
  
  editEvent(newIdx);
}

/**
 * Navigate to previous/next shift in edit modal
 * @param {number} dir - Direction (-1 for prev, 1 for next)
 */
function navEditShift(dir) {
  if (S.editingShiftIdx === null) return;
  
  // Save current shift first
  saveEditShiftSilent();
  
  const newIdx = S.editingShiftIdx + dir;
  if (newIdx < 0 || newIdx >= S.shifts.length) {
    toast(dir < 0 ? 'First shift' : 'Last shift', 'info');
    return;
  }
  
  editShift(newIdx);
}

/**
 * Save event without closing modal or showing toast
 */
function saveEditEventSilent() {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  
  evt.type = document.getElementById('editType').value;
  evt.team = document.getElementById('editTeam').value;
  evt.start_time = document.getElementById('editStartTime').value;
  evt.end_time = document.getElementById('editEndTime').value;
  evt.zone = document.getElementById('editZone').value;
  evt.success = document.getElementById('editSuccess').value;
  evt.strength = document.getElementById('editStrength').value;
  evt.detail1 = document.getElementById('editD1').value;
  evt.detail2 = document.getElementById('editD2').value;
  evt.isHighlight = document.getElementById('editHighlight').checked;
  
  const linkedIdxEl = document.getElementById('editLinkedIdx');
  if (linkedIdxEl) {
    const linkedVal = linkedIdxEl.value ? parseInt(linkedIdxEl.value) - 1 : null;
    evt.linkedEventIdx = (linkedVal !== null && linkedVal >= 0) ? linkedVal : null;
  }
  
  autoSave();
}

/**
 * Save shift without closing modal or showing toast
 */
function saveEditShiftSilent() {
  if (S.editingShiftIdx === null) return;
  const shift = S.shifts[S.editingShiftIdx];
  
  shift.period = document.getElementById('editShiftPeriod').value;
  shift.start_time = document.getElementById('editShiftStartTime').value;
  shift.end_time = document.getElementById('editShiftEndTime').value;
  shift.start_type = document.getElementById('editShiftStartType').value;
  shift.stop_type = document.getElementById('editShiftStopType').value;
  
  autoSave();
}

/**
 * Clear all events (keep shifts)
 */
function clearAllEvents() {
  if (!S.gameId) { toast('No game loaded', 'error'); return; }
  if (!confirm(`‚ö†Ô∏è Clear ALL ${S.events.length} events?\n\nShifts will be kept. This cannot be undone!`)) return;
  
  S.events = [];
  S.evtIdx = 0;
  
  renderAll();
  autoSave();
  toast('All events cleared', 'success');
}

/**
 * Clear all shifts (keep events)
 */
function clearAllShifts() {
  if (!S.gameId) { toast('No game loaded', 'error'); return; }
  if (!confirm(`‚ö†Ô∏è Clear ALL ${S.shifts.length} shifts?\n\nEvents will be kept. This cannot be undone!`)) return;
  
  S.shifts = [];
  S.shiftIdx = 0;
  
  renderShiftLog();
  autoSave();
  toast('All shifts cleared', 'success');
}

// ============================================================
// SHIFTS
// ============================================================

/**
 * Calculate total stoppage duration during a shift
 * Looks for Stoppage/Clockstop events within the shift time window
 * @param {object} shift - Shift object with period, start_time, end_time
 * @returns {number} - Total stoppage time in seconds
 */
function calculateShiftStoppageTime(shift) {
  if (!shift.start_time || !shift.end_time) return 0;
  
  const parseTime = (t) => {
    if (!t) return 0;
    const [min, sec] = t.split(':').map(Number);
    return (min || 0) * 60 + (sec || 0);
  };
  
  const shiftStartSec = parseTime(shift.start_time);  // Time remaining at shift start
  const shiftEndSec = parseTime(shift.end_time);      // Time remaining at shift end
  
  // Find stoppage events in this shift's period and time window
  // Note: Higher time = earlier in period (clock counts down)
  let stoppageTotal = 0;
  
  S.events.forEach(evt => {
    if (evt.period !== shift.period) return;
    if (evt.type !== 'Stoppage' && evt.type !== 'Clockstop' && evt.type !== 'Timeout') return;
    
    const evtTimeSec = parseTime(evt.start_time);
    
    // Check if event falls within shift (between end and start because clock counts down)
    if (evtTimeSec <= shiftStartSec && evtTimeSec >= shiftEndSec) {
      // Get event duration
      const evtEndSec = parseTime(evt.end_time);
      const duration = Math.abs(evtTimeSec - evtEndSec);
      
      // If no end time, use default durations
      if (duration > 0) {
        stoppageTotal += duration;
      } else {
        // Default durations by type
        if (evt.type === 'Timeout') stoppageTotal += 60;
        else if (evt.detail1?.includes('Icing')) stoppageTotal += 15;
        else if (evt.detail1?.includes('Offside')) stoppageTotal += 10;
        else stoppageTotal += 5;  // Default 5 sec for other stoppages
      }
    }
  });
  
  return stoppageTotal;
}

/**
 * Calculate shift duration in seconds
 */
function calculateShiftDuration(shift) {
  if (!shift.start_time || !shift.end_time) return 0;
  
  const parseTime = (t) => {
    const [min, sec] = t.split(':').map(Number);
    return (min || 0) * 60 + (sec || 0);
  };
  
  // Clock counts down, so start > end
  return parseTime(shift.start_time) - parseTime(shift.end_time);
}

// Helper to check if event time falls within shift time range
// Clock counts DOWN (18:00 -> 0:00), so "between" means: start >= time >= end
function isTimeBetween(eventTime, shiftStart, shiftEnd) {
  if (!eventTime || !shiftStart || !shiftEnd) return false;
  
  const parseTime = (t) => {
    if (!t) return 0;
    const [min, sec] = String(t).split(':').map(Number);
    return (min || 0) * 60 + (sec || 0);
  };
  
  const evt = parseTime(eventTime);
  const start = parseTime(shiftStart);
  const end = parseTime(shiftEnd);
  
  // Clock counts down, so start > end (e.g., 18:00 to 16:30)
  return evt <= start && evt >= end;
}

function logShift() {
  const start = document.getElementById('shiftStart').value;
  const end = document.getElementById('shiftEnd').value || document.getElementById('clock').value;
  
  const shift = {
    idx: S.shiftIdx++,
    game_id: S.gameId,
    period: S.period,
    start_time: start,
    end_time: end,
    start_type: document.getElementById('shiftStartType').value,
    stop_type: document.getElementById('shiftStopType').value,
    strength: deriveStrength(),
    home: {...S.slots.home},
    away: {...S.slots.away}
  };
  
  // Calculate stoppage time during this shift
  shift.stoppageTime = calculateShiftStoppageTime(shift);
  
  // Calculate shift duration
  shift.duration = calculateShiftDuration(shift);
  
  S.shifts.push(shift);
  document.getElementById('shiftStart').value = end;
  document.getElementById('shiftEnd').value = '';
  S.lastEndTime = end;
  
  renderShiftLog();
  toast(`Shift #${shift.idx + 1} logged (${shift.stoppageTime}s stoppage)`, 'success');
  autoSave();
}

// Auto-update strength when slots change
function onSlotsChanged() {
  const strength = deriveStrength();
  document.getElementById('evtStrength').value = strength;
  updateQuickStats(); // v5
}

// ============================================================
// PERIOD & CLOCK
// ============================================================
function setPeriod(p) {
  S.period = p;
  document.querySelectorAll('.period-btn').forEach(b => b.classList.remove('active'));
  document.querySelector(`.period-btn[data-p="${p}"]`)?.classList.add('active');
  
  // Set clock based on period
  if (p === 'OT') {
    document.getElementById('clock').value = '5:00';
  } else {
    document.getElementById('clock').value = S.periodLength + ':00';
  }
  
  // Update zone labels (they switch each period)
  updateZoneLabels();
}

/**
 * Flip which end home team attacks in P1
 * For beer league where benches aren't fixed home/away
 */
function flipZones() {
  S.homeAttacksRightP1 = !S.homeAttacksRightP1;
  updateZoneLabels();
  
  const direction = S.homeAttacksRightP1 ? 'RIGHT' : 'LEFT';
  const homeShort = (S.homeTeam || 'HOME').toUpperCase();
  toast(`${homeShort} attacks ${direction} in P1/P3`, 'info');
  
  // Update button visual
  const btn = document.getElementById('flipZonesBtn');
  if (btn) {
    btn.style.background = S.homeAttacksRightP1 ? '#374151' : '#7c3aed';
  }
  
  autoSave();
}

function updateClock() {
  // Just store the value, could trigger other updates
}

// ============================================================
// EXPORT
// ============================================================
function exportData() {
  if (!S.gameId) { toast('No game loaded', 'error'); return; }
  
  // Build LONG format export (one row per player per event)
  // Format matches ETL expected input with underscore suffix for input columns
  const rows = [];
  
  // Track zone changes for zone_change_index
  let lastZone = null;
  let zoneChangeIdx = 0;
  
  S.events.forEach((evt, i) => {
    const startTime = evt.start_time || evt.time || '';
    const endTime = evt.end_time || evt.start_time || evt.time || '';
    const [startMin, startSec] = (startTime || '').split(':');
    const [endMin, endSec] = (endTime || '').split(':');
    
    // Map zone to abbreviation (o/d/n)
    const zoneAbbr = evt.zone || 'n';
    
    // Track zone changes
    if (zoneAbbr !== lastZone) {
      zoneChangeIdx++;
      lastZone = zoneAbbr;
    }
    
    // Calculate time totals
    const periodLength = S.periodLength || 18;
    const startMinInt = parseInt(startMin) || 0;
    const startSecInt = parseInt(startSec) || 0;
    const endMinInt = parseInt(endMin) || startMinInt;
    const endSecInt = parseInt(endSec) || startSecInt;
    const startTotalSec = (periodLength - startMinInt) * 60 + startSecInt;
    const endTotalSec = (periodLength - endMinInt) * 60 + endSecInt;
    
    // Running time calculations
    const period = parseInt(evt.period) || 1;
    const periodOffset = (period - 1) * periodLength * 60;
    const eventRunningStart = periodOffset + startTotalSec;
    const eventRunningEnd = periodOffset + endTotalSec;
    
    // Duration
    const duration = endTotalSec - startTotalSec;
    
    const base = {
      // Input columns (underscore suffix for ETL)
      'event_index_flag_': i + 1,
      'sequence_index_flag_': evt.sequenceIdx || '',
      'play_index_flag_': evt.playIdx || '',
      'linked_event_index_flag_': evt.linkedEventIdx !== null ? evt.linkedEventIdx + 1 : '',
      'event_start_min_': startMin || '',
      'event_start_sec_': startSec || '',
      'event_end_min_': endMin || '',
      'event_end_sec_': endSec || '',
      'event_team_zone_': zoneAbbr,
      'event_type_': evt.type,
      'event_detail_': evt.detail1 || '',
      'event_detail_2_': evt.detail2 || '',
      'event_successful_': evt.success || '',
      'team_': evt.team === 'home' ? 'h' : 'a',
      // Additional derived columns
      'period': evt.period,
      'event_index': 1000 + i,  // ETL format: 1000-based
      'tracking_event_index': 1000 + i,  // Same as event_index
      'linked_event_index': evt.linkedEventIdx !== null ? 1000 + evt.linkedEventIdx : '',
      'game_id': S.gameId,
      'home_team': S.homeTeam,
      'away_team': S.awayTeam,
      'strength': evt.strength || '5v5',
      'event_team_zone': zoneAbbr === 'o' ? 'Offensive' : zoneAbbr === 'd' ? 'Defensive' : 'Neutral',
      // Non-underscore duplicates (ETL uses both)
      'event_start_min': startMin || '',
      'event_start_sec': startSec || '',
      'event_end_min': endMin || '',
      'event_end_sec': endSec || '',
      'event_detail': evt.detail1 || '',
      'event_detail_2': evt.detail2 || '',
      'event_successful': evt.success || '',
      // Calculated columns
      'time_start_total_seconds': startTotalSec,
      'time_end_total_seconds': endTotalSec,
      'duration': duration,
      'period_start_total_running_seconds': periodOffset,
      'running_video_time': evt.videoTime || eventRunningStart,
      'event_running_start': eventRunningStart,
      'event_running_end': eventRunningEnd,
      'running_intermission_duration': 0,  // TODO: track intermissions
      'zone_change_index': zoneChangeIdx,
      'shift_index': evt.shiftIdx || '',
      'is_highlight': evt.isHighlight ? 1 : 0,
      'Type': evt.type  // Legacy uppercase column
    };
    
    // Add puck XY
    (evt.puckXY || []).forEach((xy, j) => {
      base[`puck_x_${j+1}`] = xy.x;
      base[`puck_y_${j+1}`] = xy.y;
    });
    
    // Net XY
    if (evt.netXY) {
      base.net_x = evt.netXY.x;
      base.net_y = evt.netXY.y;
    }
    
    // One row per player
    if (evt.players?.length) {
      evt.players.forEach(p => {
        const row = {...base};
        row['player_game_number_'] = p.num;
        row['player_game_number'] = p.num;
        // role_abrev: e1, e2, o1, o2, etc.
        const isOpp = p.role?.includes('opp');
        const rolePrefix = isOpp ? 'o' : 'e';
        row['role_abrev'] = rolePrefix + (p.roleNum || 1);
        row['role_abrev_binary_'] = rolePrefix;  // Just 'e' or 'o'
        row.player_role = p.role;
        row.player_name = p.name;
        row['play_detail1_'] = p.playD1 || '';
        row['play_detail2_'] = p.playD2 || '';
        row['play_detail_successful_'] = p.playSuccess || '';
        row['pressured_pressurer_'] = p.pressure || '';
        row['side_of_puck_'] = p.sideOfPuck || '';  // v16
        row.play_detail1 = p.playD1 || '';
        row.play_detail_2 = p.playD2 || '';
        row.play_detail_successful = p.playSuccess || '';
        row.pressured_pressurer = p.pressure || '';
        row.side_of_puck = p.sideOfPuck || '';  // v16
        
        // Player XY
        (p.xy || []).forEach((xy, j) => {
          row[`player_x_${j+1}`] = xy.x;
          row[`player_y_${j+1}`] = xy.y;
        });
        
        rows.push(row);
      });
    } else {
      // Event with no players still needs a row
      base['player_game_number_'] = '';
      base['role_abrev'] = '';
      rows.push(base);
    }
  });
  
  // Create workbook
  const wb = XLSX.utils.book_new();
  
  // Metadata sheet (v19: includes zone orientation)
  const metadata = [{
    game_id: S.gameId,
    home_team: S.homeTeam,
    away_team: S.awayTeam,
    period_length_minutes: S.periodLength,
    home_attacks_right_p1: S.homeAttacksRightP1 ? 1 : 0,
    export_timestamp: new Date().toISOString(),
    tracker_version: 'v19.18'
  }];
  const wsMeta = XLSX.utils.json_to_sheet(metadata);
  XLSX.utils.book_append_sheet(wb, wsMeta, 'metadata');
  
  // Events sheet
  if (rows.length) {
    const ws = XLSX.utils.json_to_sheet(rows);
    XLSX.utils.book_append_sheet(wb, ws, 'events');
  }
  
  // Shifts sheet
  if (S.shifts.length) {
    // Calculate running goals from events AND per-shift goals
    let homeGoals = 0;
    let awayGoals = 0;
    
    // Pre-calculate goals by shift for running totals AND per-shift plus/minus
    const goalsByShift = [];
    S.shifts.forEach((s, i) => {
      // Store running total at shift START
      const goalsAtStart = { home: homeGoals, away: awayGoals };
      
      // Find goals that occurred IN this shift
      const shiftEvents = S.events.filter(e => 
        e.shiftIdx === i || 
        (e.period === s.period && isTimeBetween(e.start_time, s.start_time, s.end_time))
      );
      
      let homePlus = 0;  // Goals FOR home during this shift (EV/SH only)
      let awayPlus = 0;  // Goals FOR away during this shift (EV/SH only)
      
      // Get shift strength for PP determination
      const shiftStrength = s.strength || '5v5';
      const [homeStr, awayStr] = shiftStrength.split('v').map(n => parseInt(n) || 5);
      const homePP = homeStr > awayStr;  // Home on power play
      const awayPP = awayStr > homeStr;  // Away on power play
      
      shiftEvents.forEach(e => {
        if (e.type === 'Goal' && e.detail1 === 'Goal_Scored') {
          // Always update running total
          if (e.team === 'home') {
            homeGoals++;
            // Plus/minus: Only count if NOT a power play goal
            // Home goal on home PP = no +/- change
            // Home goal at EV or SH = +1 for home, -1 for away
            if (!homePP) {
              homePlus++;
            }
          } else {
            awayGoals++;
            // Away goal on away PP = no +/- change
            // Away goal at EV or SH = +1 for away, -1 for home
            if (!awayPP) {
              awayPlus++;
            }
          }
        }
      });
      
      goalsByShift.push({ 
        startHome: goalsAtStart.home, 
        startAway: goalsAtStart.away,
        homePlus: homePlus,      // Home EV/SH goals during shift (home +)
        homeMinus: awayPlus,     // Away EV/SH goals during shift (home -)
        awayPlus: awayPlus,      // Away EV/SH goals during shift (away +)
        awayMinus: homePlus      // Home EV/SH goals during shift (away -)
      });
    });
    
    // Helper to determine zone from X coordinate
    const getZoneFromX = (x, team) => {
      if (x === null || x === undefined) return null;
      // Rink is 200ft, center at 100
      // Home attacks right (x > 125 = offensive), Away attacks left (x < 75 = offensive)
      const isHome = team === 'home';
      if (x > 125) return isHome ? 'o' : 'd';  // Right side
      if (x < 75) return isHome ? 'd' : 'o';   // Left side
      return 'n';  // Neutral zone (75-125)
    };
    
    const shiftRows = S.shifts.map((s, i) => {
      // Calculate stoppage time if not already calculated
      const stoppageTime = s.stoppageTime ?? calculateShiftStoppageTime(s);
      const duration = s.duration ?? calculateShiftDuration(s);
      
      // Calculate time totals
      const startMin = parseInt(s.start_time?.split(':')[0]) || 0;
      const startSec = parseInt(s.start_time?.split(':')[1]) || 0;
      const endMin = parseInt(s.end_time?.split(':')[0]) || 0;
      const endSec = parseInt(s.end_time?.split(':')[1]) || 0;
      const periodLength = S.periodLength || 18;
      
      const startTotalSec = (periodLength - startMin) * 60 + startSec;
      const endTotalSec = (periodLength - endMin) * 60 + endSec;
      
      // Running time calculations
      const periodOffset = ((parseInt(s.period) || 1) - 1) * periodLength * 60;
      const startRunning = periodOffset + startTotalSec;
      const endRunning = periodOffset + endTotalSec;
      
      // Count skaters (F + D only, not goalie or xtra for strength)
      const homeSkaters = ['F1','F2','F3','D1','D2'].filter(p => s.home?.[p]?.num).length 
                        + (s.home?.X?.num ? 1 : 0);  // Add xtra if present
      const awaySkaters = ['F1','F2','F3','D1','D2'].filter(p => s.away?.[p]?.num).length
                        + (s.away?.X?.num ? 1 : 0);  // Add xtra if present
      
      // Empty net flags (1 if NO goalie)
      const homeEN = s.home?.G?.num ? 0 : 1;
      const awayEN = s.away?.G?.num ? 0 : 1;
      
      // Power play / penalty kill flags
      // PP = more skaters than opponent AND have a goalie (not empty net)
      const homePP = (homeSkaters > awaySkaters && homeEN === 0) ? 1 : 0;
      const awayPP = (awaySkaters > homeSkaters && awayEN === 0) ? 1 : 0;
      // PK = opponent has PP
      const homePK = awayPP;
      const awayPK = homePP;
      
      // Situation text
      let situation = 'Full Strength';
      if (homePP) situation = 'Power Play';
      else if (homePK) situation = 'Shorthanded';
      else if (homeSkaters === 4 && awaySkaters === 4) situation = '4v4';
      else if (homeSkaters === 3 && awaySkaters === 3) situation = '3v3';
      else if (homeEN || awayEN) situation = 'Empty Net';
      
      // Get events in this shift for zone derivation
      const shiftEvents = S.events.filter(e => 
        e.shiftIdx === i || 
        (e.period === s.period && isTimeBetween(e.start_time, s.start_time, s.end_time))
      );
      
      // Derive start zone from first event with XY
      let startZone = s.zoneStart || null;
      let endZone = s.zoneEnd || null;
      
      if (!startZone && shiftEvents.length > 0) {
        const firstEvt = shiftEvents[0];
        const firstX = firstEvt.puckXY?.[0]?.x;
        startZone = getZoneFromX(firstX, 'home');
      }
      
      if (!endZone && shiftEvents.length > 0) {
        const lastEvt = shiftEvents[shiftEvents.length - 1];
        const lastX = lastEvt.puckXY?.[lastEvt.puckXY?.length - 1]?.x || lastEvt.puckXY?.[0]?.x;
        endZone = getZoneFromX(lastX, 'home');
      }
      
      // Running score at shift start and plus/minus during shift
      const shiftGoals = goalsByShift[i] || { startHome: 0, startAway: 0, homePlus: 0, homeMinus: 0, awayPlus: 0, awayMinus: 0 };
      
      return {
        shift_index: i + 1,
        Period: s.period,
        shift_start_min: s.start_time?.split(':')[0],
        shift_start_sec: s.start_time?.split(':')[1],
        shift_end_min: s.end_time?.split(':')[0],
        shift_end_sec: s.end_time?.split(':')[1],
        shift_start_type: s.start_type,
        shift_stop_type: s.stop_type,
        shift_duration: duration,
        stoppage_time: stoppageTime,
        home_forward_1: s.home?.F1?.num || '',
        home_forward_2: s.home?.F2?.num || '',
        home_forward_3: s.home?.F3?.num || '',
        home_defense_1: s.home?.D1?.num || '',
        home_defense_2: s.home?.D2?.num || '',
        home_goalie: s.home?.G?.num || '',
        home_xtra: s.home?.X?.num || '',
        away_forward_1: s.away?.F1?.num || '',
        away_forward_2: s.away?.F2?.num || '',
        away_forward_3: s.away?.F3?.num || '',
        away_defense_1: s.away?.D1?.num || '',
        away_defense_2: s.away?.D2?.num || '',
        away_goalie: s.away?.G?.num || '',
        away_xtra: s.away?.X?.num || '',
        game_id: S.gameId,
        home_team: S.homeTeam,
        away_team: S.awayTeam,
        strength: `${homeSkaters}v${awaySkaters}`,
        // Calculated columns for ETL
        shift_start_total_seconds: startTotalSec,
        shift_end_total_seconds: endTotalSec,
        home_team_strength: homeSkaters,
        away_team_strength: awaySkaters,
        home_team_en: homeEN,
        away_team_en: awayEN,
        home_team_pk: homePK,
        home_team_pp: homePP,
        away_team_pp: awayPP,
        away_team_pk: awayPK,
        situation: situation,
        home_goals: shiftGoals.startHome,
        away_goals: shiftGoals.startAway,
        // Plus/minus: goals FOR and AGAINST during this shift
        home_team_plus: shiftGoals.homePlus,    // Home goals scored during shift
        home_team_minus: shiftGoals.homeMinus,  // Away goals scored during shift (against home)
        away_team_plus: shiftGoals.awayPlus,    // Away goals scored during shift
        away_team_minus: shiftGoals.awayMinus,  // Home goals scored during shift (against away)
        // Zone tracking (derived from XY or explicit)
        home_ozone_start: startZone === 'o' ? 1 : 0,
        home_ozone_end: endZone === 'o' ? 1 : 0,
        home_dzone_start: startZone === 'd' ? 1 : 0,
        home_dzone_end: endZone === 'd' ? 1 : 0,
        home_nzone_start: startZone === 'n' ? 1 : 0,
        home_nzone_end: endZone === 'n' ? 1 : 0,
        period_start_total_running_seconds: periodOffset,
        running_video_time: s.videoTime || startRunning,
        shift_start_running_time: startRunning,
        shift_end_running_time: endRunning
      };
    });
    const ws2 = XLSX.utils.json_to_sheet(shiftRows);
    XLSX.utils.book_append_sheet(wb, ws2, 'shifts');
  }
  
  XLSX.writeFile(wb, `${S.gameId}_tracking.xlsx`);
  toast('Exported!', 'success');
}

// ============================================================
// IMPORT EXCEL
// ============================================================
async function importExcel(file) {
  if (!file) return;
  
  try {
    const data = await file.arrayBuffer();
    const wb = XLSX.read(data, { type: 'array' });
    
    console.log('Import: Sheets found:', wb.SheetNames);
    
    // Check for required sheets
    const hasEvents = wb.SheetNames.includes('events');
    const hasShifts = wb.SheetNames.includes('shifts');
    const hasMetadata = wb.SheetNames.includes('metadata');
    
    if (!hasEvents && !hasShifts) {
      toast('No events or shifts sheet found', 'error');
      return;
    }
    
    // Read metadata sheet if present (v19: includes zone orientation)
    if (hasMetadata) {
      const metaSheet = XLSX.utils.sheet_to_json(wb.Sheets['metadata']);
      if (metaSheet.length > 0) {
        const meta = metaSheet[0];
        if (meta.home_attacks_right_p1 !== undefined) {
          S.homeAttacksRightP1 = meta.home_attacks_right_p1 === 1 || meta.home_attacks_right_p1 === true;
          updateZoneLabels();
          const btn = document.getElementById('flipZonesBtn');
          if (btn) btn.style.background = S.homeAttacksRightP1 ? '#374151' : '#7c3aed';
        }
        if (meta.period_length_minutes) {
          S.periodLength = meta.period_length_minutes;
        }
        console.log('Import: Loaded metadata - homeAttacksRightP1:', S.homeAttacksRightP1);
      }
    }
    
    // Parse events sheet
    let importedEvents = [];
    let gameId = null;
    let homeTeam = null;
    let awayTeam = null;
    
    if (hasEvents) {
      const eventsSheet = XLSX.utils.sheet_to_json(wb.Sheets['events']);
      console.log('Import: Raw events rows:', eventsSheet.length);
      
      // Get game info from first row
      if (eventsSheet.length > 0) {
        gameId = eventsSheet[0].game_id;
        homeTeam = eventsSheet[0].home_team;
        awayTeam = eventsSheet[0].away_team;
      }
      
      // Group rows by event_index to reconstruct events with multiple players
      // The Excel is in LONG format (one row per player per event)
      const eventGroups = {};
      
      eventsSheet.forEach(row => {
        // Get event index - try multiple column names
        const eventIdx = row.event_index || row['event_index_flag_'] || row.event_index_ || row.tracking_event_index || 0;
        if (!eventIdx) return;
        
        // Get event type - prefer event_type_ over Type (Type is often sparse/calculated)
        const eventType = row.event_type_ || row['event_type_'] || row.Type || '';
        if (!eventType) return; // Skip rows without event type
        
        // Get times - check non-underscore columns first (they have actual data), then underscore versions
        const startMin = row.event_start_min ?? row['event_start_min_'] ?? '';
        const startSec = row.event_start_sec ?? row['event_start_sec_'] ?? '';
        const endMin = row.event_end_min ?? row['event_end_min_'] ?? '';
        const endSec = row.event_end_sec ?? row['event_end_sec_'] ?? '';
        
        if (!eventGroups[eventIdx]) {
          eventGroups[eventIdx] = {
            rows: [],
            period: row.period,
            type: eventType,
            team: parseTeam(row.team_ || row['team_'] || row.team_venue || row.team_venue_abv),
            zone: parseZone(row.event_team_zone_ || row['event_team_zone_'] || row.event_team_zone),
            success: parseSuccess(row.event_successful_ || row['event_successful_'] || row.event_successful),
            detail1: row.event_detail_ || row['event_detail_'] || row.event_detail || '',
            detail2: row.event_detail_2_ || row['event_detail_2_'] || row.event_detail_2 || '',
            start_time: formatTime(startMin, startSec),
            end_time: formatTime(endMin, endSec),
            strength: row.strength || '5v5',
            linkedEventIdx: row.linked_event_index_ || row['linked_event_index_'] || row.linked_event_index || null,
            sequenceIdx: row.sequence_index_ || row['sequence_index_'] || row.sequence_index || null,
            playIdx: row.play_index_ || row['play_index_'] || row.play_index || null
          };
        }
        eventGroups[eventIdx].rows.push(row);
      });
      
      // Convert groups to events
      Object.keys(eventGroups).sort((a, b) => parseInt(a) - parseInt(b)).forEach((idx, i) => {
        const group = eventGroups[idx];
        const evt = {
          idx: i,
          period: parseInt(group.period) || 1,
          type: group.type || 'Unknown',
          team: group.team,
          zone: group.zone,
          success: group.success,
          detail1: group.detail1,
          detail2: group.detail2,
          start_time: group.start_time,
          end_time: group.end_time || group.start_time,
          strength: group.strength,
          linkedEventIdx: group.linkedEventIdx ? parseInt(group.linkedEventIdx) - 1 : null,
          sequenceIdx: group.sequenceIdx,
          playIdx: group.playIdx,
          players: [],
          puckXY: [],
          isHighlight: false
        };
        
        // Add players from rows
        group.rows.forEach(row => {
          const playerNum = row.player_game_number_ || row['player_game_number_'] || row.player_game_number;
          if (playerNum && !isNaN(parseInt(playerNum))) {
            const roleAbrev = row.role_abrev || '';
            const playerRoleRaw = row.player_role || '';
            const playerRole = parseRoleFromRaw(playerRoleRaw, roleAbrev);
            const numInt = parseInt(playerNum);
            
            // Determine player team based on role
            // event_team_player = same team as event
            // opp_team_player = opposite team
            const isOppPlayer = playerRoleRaw.includes('opp') || roleAbrev.toLowerCase().startsWith('o');
            const playerTeam = isOppPlayer 
              ? (group.team === 'home' ? 'away' : 'home')
              : group.team;
            
            // Try to get name from roster
            const roster = S.rosters?.[playerTeam] || [];
            const rosterPlayer = roster.find(p => parseInt(p.num) === numInt);
            const playerName = rosterPlayer?.name || row.player_name || `#${numInt}`;
            
            evt.players.push({
              num: numInt,
              name: playerName,
              team: playerTeam,
              role: playerRole,
              roleNum: parseRoleNum(roleAbrev),
              playD1: row.play_detail1_ || row['play_detail1_'] || row.play_detail1 || '',
              playD2: row.play_detail2_ || row['play_detail2_'] || row.play_detail_2 || '',
              playSuccess: row.play_detail_successful_ || row['play_detail_successful_'] || row.play_detail_successful || '',
              pressure: row.pressured_pressurer_ || row['pressured_pressurer_'] || row.pressured_pressurer || '',
              sideOfPuck: row.side_of_puck_ || row['side_of_puck_'] || row.side_of_puck || '',
              xy: []
            });
          }
          
          // Extract puck XY coordinates
          for (let j = 1; j <= 10; j++) {
            const px = row[`puck_x_${j}`];
            const py = row[`puck_y_${j}`];
            if (px !== undefined && py !== undefined && !isNaN(px) && !isNaN(py)) {
              // Only add if not already present (since it's repeated per player row)
              if (!evt.puckXY.find(p => p.x === px && p.y === py)) {
                evt.puckXY.push({ x: parseFloat(px), y: parseFloat(py) });
              }
            }
          }
        });
        
        importedEvents.push(evt);
      });
      
      console.log('Import: Parsed events:', importedEvents.length);
    }
    
    // Parse shifts sheet
    let importedShifts = [];
    
    if (hasShifts) {
      const shiftsSheet = XLSX.utils.sheet_to_json(wb.Sheets['shifts']);
      console.log('Import: Raw shifts rows:', shiftsSheet.length);
      
      // Get game info if not already set
      if (!gameId && shiftsSheet.length > 0) {
        gameId = shiftsSheet[0].game_id;
        homeTeam = shiftsSheet[0].home_team;
        awayTeam = shiftsSheet[0].away_team;
      }
      
      shiftsSheet.forEach((row, i) => {
        // Handle NaN values for stop_type
        let stopType = row.shift_stop_type;
        if (stopType === null || stopType === undefined || (typeof stopType === 'number' && isNaN(stopType)) || stopType === 'nan') {
          stopType = '';
        }
        
        const shift = {
          period: parseInt(row.Period) || 1,
          start_time: formatTime(row.shift_start_min, row.shift_start_sec),
          end_time: formatTime(row.shift_end_min, row.shift_end_sec),
          start_type: row.shift_start_type || 'OnTheFly',
          stop_type: stopType,
          strength: row.strength || '5v5',
          duration: row.shift_duration || null,
          stoppageTime: row.stoppage_time || 0,
          home: {
            F1: parsePlayer(row.home_forward_1, 'home'),
            F2: parsePlayer(row.home_forward_2, 'home'),
            F3: parsePlayer(row.home_forward_3, 'home'),
            D1: parsePlayer(row.home_defense_1, 'home'),
            D2: parsePlayer(row.home_defense_2, 'home'),
            G: parsePlayer(row.home_goalie, 'home'),
            X: parsePlayer(row.home_xtra, 'home')
          },
          away: {
            F1: parsePlayer(row.away_forward_1, 'away'),
            F2: parsePlayer(row.away_forward_2, 'away'),
            F3: parsePlayer(row.away_forward_3, 'away'),
            D1: parsePlayer(row.away_defense_1, 'away'),
            D2: parsePlayer(row.away_defense_2, 'away'),
            G: parsePlayer(row.away_goalie, 'away'),
            X: parsePlayer(row.away_xtra, 'away')
          }
        };
        importedShifts.push(shift);
      });
      
      console.log('Import: Parsed shifts:', importedShifts.length);
    }
    
    // Confirm import
    const evtCount = importedEvents.length;
    const shiftCount = importedShifts.length;
    const msg = `Import ${evtCount} events and ${shiftCount} shifts from game ${gameId}?\n\nThis will REPLACE current data.\n\nNote: Select the game in dropdown FIRST to load rosters for player name lookup.`;
    
    if (!confirm(msg)) {
      toast('Import cancelled', 'info');
      document.getElementById('importFileInput').value = '';
      return;
    }
    
    // Try to select the game if we have a gameId
    if (gameId) {
      S.gameId = parseInt(gameId);
      S.homeTeam = homeTeam;
      S.awayTeam = awayTeam;
      
      // Try to select the game in dropdown and load roster
      const gameSelect = document.getElementById('gameSelect');
      if (gameSelect && gameSelect.querySelector(`option[value="${gameId}"]`)) {
        gameSelect.value = gameId;
        // Try to load roster for this game
        try {
          await selectGame(gameId);
          // Re-process players with loaded roster
          importedShifts = importedShifts.map(shift => ({
            ...shift,
            home: {
              F1: shift.home.F1 ? parsePlayer(shift.home.F1.num, 'home') : null,
              F2: shift.home.F2 ? parsePlayer(shift.home.F2.num, 'home') : null,
              F3: shift.home.F3 ? parsePlayer(shift.home.F3.num, 'home') : null,
              D1: shift.home.D1 ? parsePlayer(shift.home.D1.num, 'home') : null,
              D2: shift.home.D2 ? parsePlayer(shift.home.D2.num, 'home') : null,
              G: shift.home.G ? parsePlayer(shift.home.G.num, 'home') : null,
              X: shift.home.X ? parsePlayer(shift.home.X.num, 'home') : null
            },
            away: {
              F1: shift.away.F1 ? parsePlayer(shift.away.F1.num, 'away') : null,
              F2: shift.away.F2 ? parsePlayer(shift.away.F2.num, 'away') : null,
              F3: shift.away.F3 ? parsePlayer(shift.away.F3.num, 'away') : null,
              D1: shift.away.D1 ? parsePlayer(shift.away.D1.num, 'away') : null,
              D2: shift.away.D2 ? parsePlayer(shift.away.D2.num, 'away') : null,
              G: shift.away.G ? parsePlayer(shift.away.G.num, 'away') : null,
              X: shift.away.X ? parsePlayer(shift.away.X.num, 'away') : null
            }
          }));
        } catch (e) {
          console.log('Could not load game roster:', e);
        }
      }
    }
    
    // v20.5: Load dim values and check for mapping needs
    await loadDimValuesForValidation();
    const mappingsNeeded = analyzeImportMappings(importedEvents);
    
    // Function to complete import (called after mappings are applied or skipped)
    const completeImport = (events, shifts) => {
      S.events = events;
      S.shifts = shifts;
      S.evtIdx = events.length;
      S.shiftIdx = shifts.length;
      
      // POST-IMPORT: Propagate XY data to linked events missing it
      propagateXYToLinkedEvents();
      
      // Render
      renderAll();
      autoSave();
      
      toast(`Imported ${events.length} events, ${shifts.length} shifts`, 'success');
      console.log('Import complete:', { events: S.events.length, shifts: S.shifts.length });
    };
    
    // If mappings needed, show modal
    if (mappingsNeeded.length > 0) {
      console.log('Import: Found', mappingsNeeded.length, 'values needing mapping review');
      showMappingModal(
        mappingsNeeded,
        // onAccept - apply mappings then complete
        (finalMappings) => {
          const mappedEvents = applyMappingsToEvents(importedEvents, finalMappings);
          completeImport(mappedEvents, importedShifts);
        },
        // onSkip - complete without mappings
        () => {
          toast('Skipped value mapping - using original values', 'info');
          completeImport(importedEvents, importedShifts);
        }
      );
    } else {
      // No mappings needed - all values match
      console.log('Import: All values match dim tables');
      completeImport(importedEvents, importedShifts);
    }
    
  } catch (e) {
    console.error('Import error:', e);
    toast('Import failed: ' + e.message, 'error');
  }
  
  // Reset file input
  document.getElementById('importFileInput').value = '';
}

/**
 * POST-IMPORT: Propagate XY data to linked events missing it
 * For each event without puckXY, find a sibling (same linkedEventIdx) that has XY and copy it
 */
function propagateXYToLinkedEvents() {
  if (!S.events?.length) return;
  
  let propagatedCount = 0;
  
  // Group events by linkedEventIdx
  const linkedGroups = {};
  S.events.forEach((evt, idx) => {
    if (evt.linkedEventIdx !== null && evt.linkedEventIdx !== undefined) {
      const key = evt.linkedEventIdx;
      if (!linkedGroups[key]) linkedGroups[key] = [];
      linkedGroups[key].push({ evt, idx });
    }
  });
  
  // For each linked group, find events with XY and propagate to those without
  Object.values(linkedGroups).forEach(group => {
    // Find events in this group that have XY data
    const withXY = group.filter(g => g.evt.puckXY?.length > 0);
    const withoutXY = group.filter(g => !g.evt.puckXY?.length);
    
    if (withXY.length === 0 || withoutXY.length === 0) return;
    
    // Use the most recent event with XY as source
    const source = withXY.sort((a, b) => b.idx - a.idx)[0].evt;
    
    // Copy XY to events missing it
    withoutXY.forEach(({ evt, idx }) => {
      // Copy puck XY
      if (source.puckXY?.length) {
        S.events[idx].puckXY = JSON.parse(JSON.stringify(source.puckXY));
      }
      // Copy net XY
      if (source.netXY) {
        S.events[idx].netXY = JSON.parse(JSON.stringify(source.netXY));
      }
      // Copy player XY (without role swapping for simplicity during import)
      if (source.players?.length) {
        source.players.forEach(srcPlayer => {
          if (!srcPlayer.xy?.length) return;
          
          const existingIdx = S.events[idx].players?.findIndex(p => 
            p.num === srcPlayer.num && p.team === srcPlayer.team
          );
          
          if (existingIdx >= 0) {
            S.events[idx].players[existingIdx].xy = JSON.parse(JSON.stringify(srcPlayer.xy));
          } else {
            if (!S.events[idx].players) S.events[idx].players = [];
            S.events[idx].players.push(JSON.parse(JSON.stringify(srcPlayer)));
          }
        });
      }
      propagatedCount++;
    });
  });
  
  if (propagatedCount > 0) {
    console.log(`Propagated XY data to ${propagatedCount} linked events`);
    toast(`Filled XY for ${propagatedCount} linked events`, 'info');
  }
}

// Helper functions for import
function parseTeam(value) {
  if (!value) return 'home';
  const v = String(value).toLowerCase().trim();
  if (v === 'h' || v === 'home' || v.includes('home')) return 'home';
  if (v === 'a' || v === 'away' || v.includes('away')) return 'away';
  return 'home';
}

function parseZone(value) {
  if (!value) return 'n';
  const v = String(value).toLowerCase().trim();
  if (v === 'o' || v === 'off' || v.includes('offensive')) return 'o';
  if (v === 'd' || v === 'def' || v.includes('defensive')) return 'd';
  if (v === 'n' || v === 'neu' || v.includes('neutral')) return 'n';
  return 'n';
}

function parseSuccess(value) {
  if (value === null || value === undefined || value === '') return null;
  const v = String(value).toLowerCase().trim();
  if (v === 's' || v === 'y' || v === 'yes' || v === 'true' || v === '1') return true;
  if (v === 'u' || v === 'n' || v === 'no' || v === 'false' || v === '0') return false;
  return null;
}

function formatTime(min, sec) {
  if (min === null || min === undefined || min === '') return '';
  const m = String(min).padStart(2, '0');
  const s = String(sec || 0).padStart(2, '0');
  return `${m}:${s}`;
}

function parsePlayer(num, team) {
  if (!num || isNaN(parseInt(num))) return null;
  const numInt = parseInt(num);
  
  // Try to find player name from roster
  const roster = S.rosters?.[team] || [];
  const rosterPlayer = roster.find(p => parseInt(p.num) === numInt);
  
  return { 
    num: numInt, 
    name: rosterPlayer?.name || `#${numInt}` 
  };
}

function parseRoleFromRaw(rawRole, abrev) {
  // Convert Excel role format to tracker format
  // Excel: event_team_player_1, opp_team_player_1
  // Tracker: event_player_1, opp_player_1
  if (rawRole) {
    // Replace event_team_player with event_player
    if (rawRole.includes('event_team_player')) {
      return rawRole.replace('event_team_player', 'event_player');
    }
    // Replace opp_team_player with opp_player
    if (rawRole.includes('opp_team_player')) {
      return rawRole.replace('opp_team_player', 'opp_player');
    }
    // Already in correct format
    if (rawRole.includes('event_player') || rawRole.includes('opp_player')) {
      return rawRole;
    }
  }
  
  // Fall back to parsing from abbreviation
  return parseRoleFromAbrev(abrev);
}

function parseRoleFromAbrev(abrev) {
  if (!abrev) return 'event_player_1';
  const a = String(abrev).toLowerCase().trim();
  
  // e, e1, e2 -> event_player_X
  if (a === 'e' || a.startsWith('e')) {
    const num = parseInt(a.substring(1)) || 1;
    return `event_player_${num}`;
  }
  // o, o1, o2 -> opp_player_X
  if (a === 'o' || a.startsWith('o')) {
    const num = parseInt(a.substring(1)) || 1;
    return `opp_player_${num}`;
  }
  // h1, h2 -> event_player (home)
  if (a.startsWith('h')) {
    const num = parseInt(a.substring(1)) || 1;
    return `event_player_${num}`;
  }
  // a1, a2 -> could be either depending on context
  if (a.startsWith('a')) {
    const num = parseInt(a.substring(1)) || 1;
    return `event_player_${num}`;
  }
  
  return 'event_player_1';
}

function parseRoleNum(abrev) {
  if (!abrev) return 1;
  const match = String(abrev).match(/\d+/);
  return match ? parseInt(match[0]) : 1;
}

// ============================================================
// KEYBOARD
// ============================================================
function setupKeys() {
  document.addEventListener('keydown', e => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
    
    const key = e.key.toUpperCase();
    
    // Event type hotkeys - flash indicator on activation (v5)
    const typeMap = { F:'Faceoff', S:'Shot', P:'Pass', G:'Goal', T:'Turnover', Z:'Zone_Entry_Exit', N:'Penalty', X:'Stoppage', O:'Possession', V:'Save', R:'Rebound', D:'DeadIce', Y:'Play' };
    if (typeMap[key]) { 
      setEvtType(typeMap[key]); 
      flashHotkeyIndicator(key);
      return; 
    }
    
    // Enter = log event
    if (e.key === 'Enter') { logEvent(); return; }
    
    // Escape = clear or close modals
    if (e.key === 'Escape') { 
      // Close any open modals first
      const modals = document.querySelectorAll('.overlay.show');
      if (modals.length > 0) {
        modals.forEach(m => m.classList.remove('show'));
        return;
      }
      clearEvent(); 
      return; 
    }
    
    // L = log shift
    if (key === 'L') { logShift(); return; }
    
    // E = end shift (v5)
    if (key === 'E') { endShift(); return; }
    
    // Tab = switch XY mode
    if (e.key === 'Tab') { e.preventDefault(); setXYMode(S.xyMode === 'puck' ? 'player' : 'puck'); return; }
    
    // v16.06: P = switch to puck XY mode
    if (key === 'P' && !e.ctrlKey && !e.altKey) { setXYMode('puck'); toast('üèí Puck XY mode', 'info'); return; }
    
    // H/A = set team
    if (key === 'H') { setEvtTeam('home'); return; }
    if (key === 'A') { setEvtTeam('away'); return; }
    
    // ` (backtick) = switch to puck XY mode (v16.06)
    if (e.key === '`') { 
      setXYMode('puck'); 
      toast('Switched to Puck XY mode', 'info'); 
      return; 
    }
    
    // v6: 1-6 = select event player slot (not period anymore)
    // Use Alt+1-6 for opponent players (Ctrl+1-6 conflicts with browser tab switching)
    if (['1','2','3','4','5','6'].includes(e.key)) {
      e.preventDefault();
      if (e.altKey) {
        // Alt+1-6: Select opponent player (works reliably unlike Ctrl+1-6)
        selectEventPlayerSlot('opp', parseInt(e.key));
      } else if (e.ctrlKey) {
        // Ctrl+1-6: Also try for opponent (may not work in all browsers)
        selectEventPlayerSlot('opp', parseInt(e.key));
      } else {
        // 1-6: Select event team player
        selectEventPlayerSlot('evt', parseInt(e.key));
      }
      return;
    }
    
    // Q = quick line change (v6)
    if (key === 'Q') { quickLineChange(); return; }
    
    // W = cycle forward presets, Shift+W = cycle D presets (v6)
    if (key === 'W') {
      if (e.shiftKey) {
        cyclePreset(S.evtTeam, 'D');
      } else {
        cyclePreset(S.evtTeam, 'F');
      }
      return;
    }
    
    // * = toggle highlight (v5)
    if (e.key === '*' || (e.shiftKey && e.key === '8')) {
      const hl = document.getElementById('isHighlight');
      if (hl) { hl.checked = !hl.checked; toast(hl.checked ? '‚≠ê Highlight ON' : 'Highlight OFF', 'info'); }
      return;
    }
    
    // Ctrl+Z = undo last XY (v5)
    if (e.ctrlKey && key === 'Z') { e.preventDefault(); undoLastXY(); return; }
    
    // Arrow keys in edit modals (v5)
    if (e.key === 'ArrowLeft' && S.editingEvtIdx !== null) { navEditEvent(-1); return; }
    if (e.key === 'ArrowRight' && S.editingEvtIdx !== null) { navEditEvent(1); return; }
    if (e.key === 'ArrowLeft' && S.editingShiftIdx !== null) { navEditShift(-1); return; }
    if (e.key === 'ArrowRight' && S.editingShiftIdx !== null) { navEditShift(1); return; }
    
    // ? = open help
    if (e.key === '?') { openHelp(); return; }
  });
}

/**
 * Flash hotkey indicator for visual feedback (v5)
 */
function flashHotkeyIndicator(key) {
  const btn = document.querySelector(`.evt-btn[data-hotkey="${key}"]`);
  if (btn) {
    btn.classList.add('hotkey-flash');
    setTimeout(() => btn.classList.remove('hotkey-flash'), 300);
  }
}

/**
 * End current shift with current clock time (v5)
 */
function endShift() {
  const clock = document.getElementById('clock').value;
  document.getElementById('shiftEnd').value = clock;
  toast(`Shift end set to ${clock}`, 'info');
}

// ============================================================
// V6 FEATURES: LINE PRESETS, PERIOD FILTERS, COMPACT MODE
// ============================================================

// Line preset storage
S.linePresets = JSON.parse(localStorage.getItem('bs_line_presets') || '{}');
S.shiftLogFilter = 'all';
S.eventLogFilter = 'all';
// v20.4: Advanced event filters
S.eventFilters = {
  type: '',
  detail1: '',
  detail2: '',
  playDetail1: '',
  playDetail2: '',
  team: '',
  eventIdx: null,
  linkedIdx: null,
  shiftIdx: null
};
S.selectedPlayerSlot = null;
S.compactMode = false;

// v20.5: Dim table value cache for import validation
S.dimValues = {
  event_type: [],
  event_detail: [],
  event_detail_2: [],
  play_detail: [],
  play_detail_2: [],
  loaded: false
};
S.pendingMappings = null; // Holds mappings during modal review

/**
 * v20.5: Load dim table values from Supabase for import validation
 * v22.1: Fixed to load ALL values and better fallback
 */
async function loadDimValuesForValidation() {
  if (S.dimValues.loaded) return true;
  
  try {
    // Try Supabase first
    if (typeof supabase !== 'undefined' && S.sb) {
      const tables = [
        { name: 'dim_event_type', field: 'event_type', col: 'event_type_code' },
        { name: 'dim_event_detail', field: 'event_detail', col: 'event_detail_code' },
        { name: 'dim_event_detail_2', field: 'event_detail_2', col: 'event_detail_2_code' },
        { name: 'dim_play_detail', field: 'play_detail', col: 'play_detail_code' },
        { name: 'dim_play_detail_2', field: 'play_detail_2', col: 'play_detail_2_code' }
      ];
      
      let loadedCount = 0;
      for (const t of tables) {
        // v22.1: Load ALL rows (up to 1000) - use .limit(1000) to ensure we get everything
        const { data, error } = await S.sb.from(t.name).select(t.col).limit(1000);
        if (!error && data && data.length > 0) {
          S.dimValues[t.field] = data.map(r => r[t.col]).filter(Boolean);
          loadedCount++;
          console.log(`Loaded ${S.dimValues[t.field].length} values from ${t.name}`);
        } else {
          console.warn(`Failed to load ${t.name}:`, error || 'no data');
        }
      }
      
      if (loadedCount >= 3) {
        S.dimValues.loaded = true;
        console.log('Loaded dim values from Supabase:', Object.keys(S.dimValues).map(k => `${k}: ${S.dimValues[k]?.length || 0}`).join(', '));
        return true;
      }
    }
  } catch (e) {
    console.warn('Supabase dim load failed, using fallback:', e);
  }
  
  // v22.1: Comprehensive fallback values (if Supabase load fails)
  S.dimValues.event_type = ['Shot', 'Save', 'Pass', 'Faceoff', 'Turnover', 'Zone_Entry_Exit', 'Possession', 'Penalty', 'Hit', 'Block', 'Stoppage', 'Goal', 'GameStart', 'GameEnd', 'PeriodStart', 'PeriodEnd', 'Rebound', 'DeadIce', 'Play', 'Intermission', 'Clockstop', 'Timeout', 'LoosePuck', 'PenaltyShot_Shootout', 'Penalty_Delayed'];
  
  S.dimValues.event_detail = ['Shot_OnNetSaved', 'Shot_Goal', 'Goal_Scored', 'Shot_Missed', 'Shot_MissedWide', 'Shot_MissedHigh', 'Shot_HitPost', 'Shot_Blocked', 'Shot_TippedOnNetSaved', 'Shot_OnNetGoal', 'Shot_BlockedSameTeam', 'Shot_Deflected', 'Pass_Completed', 'Pass_Missed', 'Pass_Intercepted', 'Pass_Deflected', 'Turnover_Giveaway', 'Turnover_Takeaway', 'Zone_Entry', 'Zone_Exit', 'Zone_Keepin', 'Zone_EntryFailed', 'Zone_ExitFailed', 'Faceoff_Won', 'Faceoff_Lost', 'Faceoff_PeriodStart', 'Faceoff_GameStart', 'Faceoff_AfterGoal', 'Faceoff_AfterPenalty', 'Faceoff_AfterStoppage', 'Save_Rebound', 'Save_Freeze', 'Save_Played', 'Stoppage_PeriodEnd', 'Stoppage_Play', 'Stoppage_Other', 'Stoppage_GameEnd', 'Penalty_Minor', 'Penalty_Major', 'Penalty_Misconduct', 'Goal_Shootout', 'Goal_PenaltyShot', 'Rebound_TeamRecovered', 'Rebound_OppRecovered', 'Rebound_ShotGenerated', 'DeadIce_Icing', 'DeadIce_Offside', 'DeadIce_PuckOut', 'Play_Offensive', 'Play_Defensive', 'Breakaway', 'PuckRetrieval', 'PuckRecovery', 'Regroup', 'LoosePuck'];
  
  // v22.1: Full list of event_detail_2 values
  S.dimValues.event_detail_2 = [
    // Pass modifiers
    'Pass_Forehand', 'Pass_Backhand', 'Pass_Bank', 'Pass_Stretch', 'Pass_Rim/Wrap', 'Pass_Drop', 'Pass_Dump', 'Pass_OneTouch', 'Pass_Lob', 'Pass_Reverse', 'Pass_QuickUp', 'Pass_GiveAndGo', 'Pass_SecondTouch', 'Pass_Tipped', 'Pass_Deflected/TippedShot', 'Pass_ReceiverMissed', 'Pass_Other',
    // Shot modifiers
    'Shot_Wrist', 'Shot_Slap', 'Shot_Backhand', 'Shot_Snap', 'Shot_WrapAround', 'Shot_Bat', 'Shot_Poke', 'Shot_OneTime', 'Shot_Tip', 'Shot_Deflection', 'Shot_Other', 'Shot_BetweenLegs', 'Shot_Cradle',
    // Goal modifiers
    'Goal_Wrist', 'Goal_Slap', 'Goal_Backhand', 'Goal_Snap', 'Goal_WrapAround', 'Goal_Bat', 'Goal_Poke', 'Goal_OneTime', 'Goal_Tip', 'Goal_Deflection', 'Goal_Dumpin', 'Goal_Other', 'Goal_BetweenLegs', 'Goal_Cradle',
    // Save modifiers
    'Save_Glove', 'Save_Blocker', 'Save_Pad', 'Save_Stick', 'Save_Butterfly', 'Save_Other',
    // Zone entry modifiers
    'ZoneEntry_Rush', 'ZoneEntry_Carry', 'ZoneEntry_Pass', 'ZoneEntry_DumpIn', 'ZoneEntry_Chip', 'ZoneEntry_OppTeam', 'ZoneEntry_PassMiss/Misplay',
    // Zone exit modifiers  
    'ZoneExit_Rush', 'ZoneExit_Carry', 'ZoneExit_Pass', 'ZoneExit_Clear', 'ZoneExit_Chip', 'ZoneExit_PassMiss/Misplay',
    // Giveaway modifiers
    'Giveaway_Misplayed', 'Giveaway_BattleLost', 'Giveaway_PassIntercepted', 'Giveaway_PassMissed', 'Giveaway_PassBlocked', 'Giveaway_PassReceiverMissed', 'Giveaway_ShotBlocked', 'Giveaway_ShotMissed', 'Giveaway_DumpInZone', 'Giveaway_ZoneClear/Dump', 'Giveaway_ZoneEntry/ExitMisplay', 'Giveaway_AttemptedZoneClear/Dump', 'Giveaway_Other',
    // Takeaway modifiers
    'Takeaway_BattleWon', 'Takeaway_PokeCheck', 'Takeaway_PassIntercepted', 'Takeaway_PassBlocked', 'Takeaway_Other',
    // Stoppage modifiers
    'Stoppage_Icing', 'Stoppage_Offsides', 'Stoppage_GoalieStoppage', 'Stoppage_PuckOut', 'Stoppage_Penalty', 'Stoppage_Goal', 'Stoppage_HandPass', 'Stoppage_NetOff', 'Stoppage_Injury',
    // Penalty modifiers
    'Penalty_Tripping', 'Penalty_Hooking', 'Penalty_Slashing', 'Penalty_Interference', 'Penalty_Holding', 'Penalty_Roughing', 'Penalty_HighSticking', 'Penalty_CrossChecking', 'Penalty_Boarding', 'Penalty_Other',
    // Play context modifiers
    'Deke', 'DriveMiddle', 'DriveWide', 'DumpChase', 'Rush', 'Cycle', 'Rebound', 'OneTimer', 'Tip', 'Deflection', 'Breakaway', 'OddManRush', 'CrashNet', 'Forecheck', 'Backcheck', 'NetFront', 'PointShot', 'Screen',
    // Zone keep-in
    'Zone_KeepIn', 'ZoneEntry_KeepIn'
  ];
  
  // v22.1: Comprehensive play_detail fallback (111 values from dim_play_detail)
  S.dimValues.play_detail = ['AssistPrimary','AssistSecondary','AssistTertiary','AttemptedBlockedShot','AttemptedBreakOutClear','AttemptedBreakOutPass','AttemptedBreakOutRush','AttemptedEntryDumpIn','AttemptedEntryPass','AttemptedEntryRush','AttemptedKeepin','AttemptedPass','AttemptedShot','AttemptedTip/Deflection','Backcheck','BeatDeke','BeatFake','BeatMiddle','BeatSpeed','BeatWide','BlockedShot','BoxOut','Breakout','CededZoneEntry','CededZoneExit','Chip','ClearingAttempt','Contain','CrashNet','CutBack','Cycle','DeflectedShot','Deke','Delay','DelayedOffside','DriveCorner','DriveMiddle','DriveNetMiddle','DriveNetWide','DriveWide','Dump/RimInZone','DumpChase','DumpInAttempt','EndToEndRush','FakeShot','ForcedDumpin/Clear','ForcedLostPossession','ForcedMissedPass','ForcedMissedShot','ForcedTurnover','ForceWide','ForecedOutside','Forecheck','FrontofNet','GapControl','GiveAndGo','InShotPassLane','LoosePuckBattleLost','LoosePuckBattleWon','LostPuck','ManOnMan','MisplayedPuck','OpenIceDeke','Other','PassDeflected','PassForTip','PassIntercepted','PenaltyKillClear','PokeCheck','Pressure','PuckRecoveryRetreivalAttemptedClear','PuckRecoveryRetreivalClear','PuckRecoveryRetreivalDumpIn','PuckRecoveryRetreivalFaceoff','PuckRecoveryRetreivalLoosePuckBattle','PuckRecoveryRetreivalOther','PuckRecoveryRetreivalPass','PuckRecoveryRetreivalRebound','PuckRecoveryRetreivalShot','PuckRecoveryRetreivalTurnover','PuckRetrievalDumpIn','PuckRetrievalRebound','PuckRetrievalShot','QuickUp','ReceiverMissed','RecoveryRetreivalDumpIn','RecoveryRetreivalFaceoff','RecoveryRetreivalOther','RecoveryRetreivalPass','RecoveryRetreivalRebound','RecoveryRetreivalShot','RecoveryRetreivalTurnover','RecoveryRetrievalDumpIn','RecoveryRetrievalShot','Regroup','RegroupClear','RegroupDumpin','Reverse','Screen','SecondTouch','SeperateFromPuck','Speed','StickCheck','StoppedDeke','Surf','Tracker','Wheel','Zone','ZoneEntryDenial','ZoneExitDenial','ZoneKeepin'];
  
  // v22.1: Comprehensive play_detail_2 fallback (111 values from dim_play_detail_2)
  S.dimValues.play_detail_2 = ['AssistPrimary','AssistSecondary','AssistTertiary','AttemptedBlockedShot','AttemptedBreakOutClear','AttemptedBreakOutPass','AttemptedBreakOutRush','AttemptedEntryDumpIn','AttemptedEntryPass','AttemptedEntryRush','AttemptedKeepin','AttemptedPass','AttemptedShot','AttemptedTip/Deflection','Backcheck','BeatDeke','BeatFake','BeatMiddle','BeatSpeed','BeatWide','BlockedShot','BoxOut','Breakout','CededZoneEntry','CededZoneExit','Chip','ClearingAttempt','Contain','CrashNet','CutBack','Cycle','DeflectedShot','Deke','Delay','DelayedOffside','DriveCorner','DriveMiddle','DriveNetMiddle','DriveNetWide','DriveWide','Dump/RimInZone','DumpChase','DumpInAttempt','EndToEndRush','FakeShot','ForcedDumpin/Clear','ForcedLostPossession','ForcedMissedPass','ForcedMissedShot','ForcedTurnover','ForceWide','ForecedOutside','Forecheck','FrontofNet','GapControl','GiveAndGo','InShotPassLane','LoosePuckBattleLost','LoosePuckBattleWon','LostPuck','ManOnMan','MisplayedPuck','OpenIceDeke','Other','PassDeflected','PassForTip','PassIntercepted','PenaltyKillClear','PokeCheck','Pressure','PuckRecoveryRetreivalAttemptedClear','PuckRecoveryRetreivalClear','PuckRecoveryRetreivalDumpIn','PuckRecoveryRetreivalFaceoff','PuckRecoveryRetreivalLoosePuckBattle','PuckRecoveryRetreivalOther','PuckRecoveryRetreivalPass','PuckRecoveryRetreivalRebound','PuckRecoveryRetreivalShot','PuckRecoveryRetreivalTurnover','PuckRetrievalDumpIn','PuckRetrievalRebound','PuckRetrievalShot','QuickUp','ReceiverMissed','RecoveryRetreivalDumpIn','RecoveryRetreivalFaceoff','RecoveryRetreivalOther','RecoveryRetreivalPass','RecoveryRetreivalRebound','RecoveryRetreivalShot','RecoveryRetreivalTurnover','RecoveryRetrievalDumpIn','RecoveryRetrievalShot','Regroup','RegroupClear','RegroupDumpin','Reverse','Screen','SecondTouch','SeperateFromPuck','Speed','StickCheck','StoppedDeke','Surf','Tracker','Wheel','Zone','ZoneEntryDenial','ZoneExitDenial','ZoneKeepin'];
  
  S.dimValues.loaded = true;
  console.log('Loaded fallback dim values (Supabase unavailable)');
  return true;
}

/**
 * v20.5: Normalize string for fuzzy matching
 * Handles: case, underscores vs hyphens vs spaces, common prefixes
 */
function normalizeForMatch(str) {
  if (!str) return '';
  return str
    .toLowerCase()
    .replace(/[-_ ]/g, '')  // Remove separators
    .replace(/^(play|shot|pass|zone|turnover|giveaway|takeaway|save|faceoff|goal)[_-]?/i, '')  // Remove common prefixes for matching
    .trim();
}

/**
 * v20.5: Calculate match score between two strings (0-100)
 */
function matchScore(a, b) {
  if (!a || !b) return 0;
  const na = normalizeForMatch(a);
  const nb = normalizeForMatch(b);
  
  // Exact match (normalized)
  if (na === nb) return 100;
  
  // One contains the other
  if (na.includes(nb) || nb.includes(na)) return 85;
  
  // Levenshtein-ish: count common chars
  const setA = new Set(na.split(''));
  const setB = new Set(nb.split(''));
  const intersection = [...setA].filter(c => setB.has(c)).length;
  const union = new Set([...setA, ...setB]).size;
  const similarity = union > 0 ? (intersection / union) * 100 : 0;
  
  return Math.round(similarity);
}

/**
 * v20.5: Find best match from valid values
 */
function findBestMatch(value, validValues, threshold = 60) {
  if (!value || !validValues?.length) return { match: null, score: 0, type: 'none' };
  
  // Check exact match first (case-insensitive)
  const exactMatch = validValues.find(v => v.toLowerCase() === value.toLowerCase());
  if (exactMatch) return { match: exactMatch, score: 100, type: 'exact' };
  
  // Fuzzy match
  let best = { match: null, score: 0 };
  for (const candidate of validValues) {
    const score = matchScore(value, candidate);
    if (score > best.score) {
      best = { match: candidate, score };
    }
  }
  
  if (best.score >= threshold) {
    return { ...best, type: 'fuzzy' };
  }
  
  return { match: null, score: best.score, type: 'none' };
}

/**
 * v20.5: Analyze imported events and find mappings needed
 */
function analyzeImportMappings(events) {
  const fields = [
    { key: 'type', dimKey: 'event_type', label: 'Event Type' },
    { key: 'detail1', dimKey: 'event_detail', label: 'Event Detail' },
    { key: 'detail', dimKey: 'event_detail', label: 'Event Detail' },  // Alias
    { key: 'detail2', dimKey: 'event_detail_2', label: 'Event Detail 2' }
  ];
  
  // Also check player play details
  const playerFields = [
    { key: 'playD1', dimKey: 'play_detail', label: 'Play Detail 1' },
    { key: 'playD2', dimKey: 'play_detail_2', label: 'Play Detail 2' }
  ];
  
  const mappings = [];
  const seenValues = new Set();
  
  // Collect unique values from events
  for (const evt of events) {
    for (const f of fields) {
      const val = evt[f.key];
      if (val && !seenValues.has(`${f.dimKey}:${val}`)) {
        seenValues.add(`${f.dimKey}:${val}`);
        const result = findBestMatch(val, S.dimValues[f.dimKey]);
        if (result.type !== 'exact') {
          mappings.push({
            field: f.label,
            dimKey: f.dimKey,
            eventKey: f.key,
            original: val,
            ...result
          });
        }
      }
    }
    
    // Check player play details
    for (const player of (evt.players || [])) {
      for (const f of playerFields) {
        const val = player[f.key];
        if (val && !seenValues.has(`${f.dimKey}:${val}`)) {
          seenValues.add(`${f.dimKey}:${val}`);
          const result = findBestMatch(val, S.dimValues[f.dimKey]);
          if (result.type !== 'exact') {
            mappings.push({
              field: f.label,
              dimKey: f.dimKey,
              eventKey: f.key,
              isPlayerField: true,
              original: val,
              ...result
            });
          }
        }
      }
    }
  }
  
  return mappings;
}

/**
 * v20.5: Show mapping modal for user review
 * v22.1: Added "Show More" functionality and ensured correct dim table per field
 */
function showMappingModal(mappings, onAccept, onSkip) {
  // Create modal HTML
  const fuzzyCount = mappings.filter(m => m.type === 'fuzzy').length;
  const noMatchCount = mappings.filter(m => m.type === 'none').length;
  
  let tableRows = mappings.map((m, i) => {
    // v22.1: Get options ONLY from the correct dim table for this field
    const allOptions = S.dimValues[m.dimKey] || [];
    const dimTableName = m.dimKey; // e.g., "event_detail_2"
    
    // v22.1: Sort options by relevance to the original value
    const scoredOptions = allOptions.map(o => ({
      value: o,
      score: matchScore(m.original, o)
    })).sort((a, b) => b.score - a.score);
    
    // v22.1: Show top 8 matches initially, with "Show More" to expand
    const topOptions = scoredOptions.slice(0, 8);
    const hasMore = scoredOptions.length > 8;
    
    // Build select HTML with top matches first
    let selectHtml = '<select id="mapping_' + i + '" class="mapping-select" onchange="handleMappingSelect(this, ' + i + ', \'' + m.dimKey + '\')">';
    selectHtml += '<option value="">-- No mapping --</option>';
    
    // Add suggested match first if it exists and not in top options
    if (m.match && !topOptions.find(o => o.value === m.match)) {
      const mScore = scoredOptions.find(o => o.value === m.match)?.score || m.score;
      selectHtml += '<option value="' + m.match + '" selected>‚úì ' + m.match + ' (' + mScore + '%)</option>';
    }
    
    // Add top scored options
    for (const opt of topOptions) {
      const selected = opt.value === m.match ? 'selected' : '';
      const scoreLabel = opt.score > 0 ? ' (' + opt.score + '%)' : '';
      selectHtml += '<option value="' + opt.value + '" ' + selected + '>' + opt.value + scoreLabel + '</option>';
    }
    
    // Add "Show More" option if there are more values
    if (hasMore) {
      selectHtml += '<option value="__SHOW_MORE__">‚ñº Show all ' + allOptions.length + ' from ' + dimTableName + '...</option>';
    }
    
    selectHtml += '</select>';
    
    const typeIcon = m.type === 'fuzzy' ? '‚âà' : '?';
    
    return '<tr data-dimkey="' + m.dimKey + '">' +
      '<td class="field">' + m.field + '</td>' +
      '<td class="original">' + m.original + '</td>' +
      '<td>' + typeIcon + '</td>' +
      '<td>' + selectHtml + '</td>' +
      '<td class="score">' + m.score + '%</td>' +
    '</tr>';
  }).join('');
  
  const modalHtml = 
    '<div class="modal mapping-modal" id="mappingModal">' +
      '<h3>üìã Import Value Mapping</h3>' +
      '<p class="summary">' +
        'Found <strong>' + mappings.length + '</strong> values needing review: ' +
        '<span style="color:var(--accent)">' + fuzzyCount + ' fuzzy matches</span>, ' +
        '<span style="color:var(--danger)">' + noMatchCount + ' no matches</span>' +
      '</p>' +
      '<p style="font-size:10px;color:var(--muted);">Each dropdown shows top matches from its correct dim table. Click "Show all" to see all options.</p>' +
      '<div class="mapping-legend">' +
        '<span><span class="dot exact"></span> Exact (auto-mapped)</span>' +
        '<span><span class="dot fuzzy"></span> Fuzzy (suggested)</span>' +
        '<span><span class="dot none"></span> No match (select manually)</span>' +
      '</div>' +
      '<table class="mapping-table">' +
        '<thead>' +
          '<tr><th>Field</th><th>Original Value</th><th>Type</th><th>Map To</th><th>Score</th></tr>' +
        '</thead>' +
        '<tbody>' + tableRows + '</tbody>' +
      '</table>' +
      '<div class="modal-actions">' +
        '<button class="btn-cancel" onclick="closeMappingModal(false)">Skip (Keep Original)</button>' +
        '<button class="btn-success" onclick="closeMappingModal(true)">Apply Mappings</button>' +
      '</div>' +
    '</div>' +
    '<div class="modal-overlay" onclick="closeMappingModal(false)"></div>';
  
  // Store callbacks
  S.pendingMappings = { mappings, onAccept, onSkip };
  
  // Show modal
  const container = document.createElement('div');
  container.id = 'mappingModalContainer';
  container.innerHTML = modalHtml;
  document.body.appendChild(container);
}

/**
 * v22.1: Handle mapping select change - expand to show all options when "Show More" selected
 */
function handleMappingSelect(select, idx, dimKey) {
  if (select.value === '__SHOW_MORE__') {
    // Get all options from the correct dim table
    const allOptions = S.dimValues[dimKey] || [];
    const original = S.pendingMappings?.mappings[idx]?.original || '';
    
    // Sort by match score
    const scoredOptions = allOptions.map(o => ({
      value: o,
      score: matchScore(original, o)
    })).sort((a, b) => b.score - a.score);
    
    // Rebuild select with ALL options
    let newHtml = '<option value="">-- No mapping --</option>';
    for (const opt of scoredOptions) {
      const scoreLabel = opt.score > 0 ? ' (' + opt.score + '%)' : '';
      newHtml += '<option value="' + opt.value + '">' + opt.value + scoreLabel + '</option>';
    }
    
    select.innerHTML = newHtml;
    select.value = ''; // Reset selection so user can pick
    
    // Update the row to show it's expanded
    const row = select.closest('tr');
    if (row) {
      row.style.backgroundColor = 'rgba(100, 200, 255, 0.1)';
    }
    
    toast('Showing all ' + allOptions.length + ' values from ' + dimKey, 'info');
  }
}

function closeMappingModal(apply) {
  const container = document.getElementById('mappingModalContainer');
  if (!container) return;
  
  if (apply && S.pendingMappings) {
    // Read user selections
    const finalMappings = S.pendingMappings.mappings.map((m, i) => {
      const select = document.getElementById(`mapping_${i}`);
      return {
        ...m,
        mappedTo: select?.value || null
      };
    }).filter(m => m.mappedTo); // Only include ones with a mapping
    
    if (S.pendingMappings.onAccept) {
      S.pendingMappings.onAccept(finalMappings);
    }
  } else {
    if (S.pendingMappings?.onSkip) {
      S.pendingMappings.onSkip();
    }
  }
  
  container.remove();
  S.pendingMappings = null;
}

/**
 * v20.5: Apply mappings to events array
 */
function applyMappingsToEvents(events, mappings) {
  if (!mappings?.length) return events;
  
  // Build lookup: original -> mapped
  const lookup = {};
  for (const m of mappings) {
    const key = `${m.eventKey}:${m.original}`;
    lookup[key] = m.mappedTo;
  }
  
  // Apply to events
  let changeCount = 0;
  for (const evt of events) {
    // Event-level fields
    for (const field of ['type', 'detail', 'detail1', 'detail2']) {
      const key = `${field}:${evt[field]}`;
      if (lookup[key]) {
        console.log(`Mapping ${field}: ${evt[field]} ‚Üí ${lookup[key]}`);
        evt[field] = lookup[key];
        changeCount++;
      }
    }
    
    // Player-level fields
    for (const player of (evt.players || [])) {
      for (const field of ['playD1', 'playD2']) {
        const key = `${field}:${player[field]}`;
        if (lookup[key]) {
          console.log(`Mapping player ${field}: ${player[field]} ‚Üí ${lookup[key]}`);
          player[field] = lookup[key];
          changeCount++;
        }
      }
    }
  }
  
  toast(`Applied ${changeCount} value mappings`, 'success');
  return events;
}

/**
 * Load a line preset into slots
 */
function loadPreset(team, preset) {
  const key = `${team}_${preset}`;
  const presetData = S.linePresets[key];
  if (!presetData || !presetData.players || presetData.players.length === 0) {
    toast(`No ${preset} preset saved for ${team}`, 'info');
    return;
  }
  
  // Determine which slots to fill based on preset type
  const isForward = preset.startsWith('F');
  const slots = isForward ? ['F1','F2','F3'] : ['D1','D2'];
  
  // Clear relevant slots first
  slots.forEach(slot => { S.slots[team][slot] = null; });
  
  // Fill slots with preset players
  presetData.players.forEach((num, i) => {
    if (i < slots.length) {
      const player = S.rosters[team].find(p => String(p.num) === String(num));
      if (player) {
        S.slots[team][slots[i]] = player;
      }
    }
  });
  
  renderSlots();
  renderRosters();
  onSlotsChanged();
  toast(`Loaded ${team} ${preset}: ${presetData.players.join(', ')}`, 'success');
}

/**
 * Save current slots as a preset
 */
function savePreset(team, preset) {
  const isForward = preset.startsWith('F');
  const slots = isForward ? ['F1','F2','F3'] : ['D1','D2'];
  
  const players = slots
    .map(slot => S.slots[team]?.[slot]?.num)
    .filter(num => num);
  
  if (players.length === 0) {
    toast(`No players in ${preset} slots`, 'warning');
    return;
  }
  
  const key = `${team}_${preset}`;
  S.linePresets[key] = { name: preset, players };
  localStorage.setItem('bs_line_presets', JSON.stringify(S.linePresets));
  toast(`Saved ${team} ${preset}: ${players.join(', ')}`, 'success');
}

/**
 * Cycle through forward or defense presets
 */
function cyclePreset(team, type) {
  const presets = type === 'F' ? ['F1','F2','F3'] : ['D1','D2'];
  const currentIdx = S.cycleIdx?.[team]?.[type] || 0;
  const nextIdx = (currentIdx + 1) % presets.length;
  
  if (!S.cycleIdx) S.cycleIdx = {};
  if (!S.cycleIdx[team]) S.cycleIdx[team] = {};
  S.cycleIdx[team][type] = nextIdx;
  
  loadPreset(team, presets[nextIdx]);
}

/**
 * Open line preset configuration modal
 */
function openLinePresetModal() {
  // Build modal content showing current presets
  let html = '<div style="max-height:400px;overflow-y:auto;">';
  
  ['home', 'away'].forEach(team => {
    html += `<h4 style="color:var(--accent);margin:8px 0 4px;">${team.toUpperCase()} PRESETS</h4>`;
    
    // Forward lines
    ['F1','F2','F3'].forEach(preset => {
      const key = `${team}_${preset}`;
      const data = S.linePresets[key];
      const players = data?.players?.join(', ') || 'Not set';
      html += `
        <div style="display:flex;gap:8px;align-items:center;margin:4px 0;">
          <span style="width:30px;font-weight:bold;">${preset}:</span>
          <span style="flex:1;color:var(--muted);">${players}</span>
          <button class="btn-sm" onclick="savePreset('${team}','${preset}')">Save Current</button>
          <button class="btn-sm" onclick="clearPreset('${team}','${preset}')">Clear</button>
        </div>`;
    });
    
    // Defense pairs
    ['D1','D2'].forEach(preset => {
      const key = `${team}_${preset}`;
      const data = S.linePresets[key];
      const players = data?.players?.join(', ') || 'Not set';
      html += `
        <div style="display:flex;gap:8px;align-items:center;margin:4px 0;">
          <span style="width:30px;font-weight:bold;">${preset}:</span>
          <span style="flex:1;color:var(--muted);">${players}</span>
          <button class="btn-sm" onclick="savePreset('${team}','${preset}')">Save Current</button>
          <button class="btn-sm" onclick="clearPreset('${team}','${preset}')">Clear</button>
        </div>`;
    });
  });
  
  html += '</div>';
  
  // Use a simple alert-style modal
  const modal = document.createElement('div');
  modal.className = 'overlay show';
  modal.id = 'linePresetModal';
  modal.innerHTML = `
    <div class="modal" style="min-width:400px;">
      <h3>‚öôÔ∏è Line Presets Configuration</h3>
      ${html}
      <p style="font-size:9px;color:var(--muted);margin-top:8px;">
        Fill slots with players, then click "Save Current" to save as a preset.
        Use preset buttons or W/Shift+W to cycle presets.
      </p>
      <div class="modal-actions" style="margin-top:16px;">
        <button class="btn-primary" onclick="closeLinePresetModal()">Close</button>
      </div>
    </div>`;
  document.body.appendChild(modal);
}

function closeLinePresetModal() {
  const modal = document.getElementById('linePresetModal');
  if (modal) modal.remove();
}

function clearPreset(team, preset) {
  const key = `${team}_${preset}`;
  delete S.linePresets[key];
  localStorage.setItem('bs_line_presets', JSON.stringify(S.linePresets));
  closeLinePresetModal();
  openLinePresetModal();
  toast(`Cleared ${team} ${preset}`, 'info');
}

/**
 * Filter shift log by period
 */
function filterShiftLog(period) {
  S.shiftLogFilter = period;
  
  // Update tab styles
  document.querySelectorAll('#leftPanel .period-filter-tab').forEach(tab => {
    tab.classList.toggle('active', tab.dataset.filter === period);
  });
  
  renderShiftLog();
}

/**
 * Filter event log by period
 */
function filterEventLog(period) {
  S.eventLogFilter = period;
  
  // Update tab styles
  document.querySelectorAll('.evt-list .period-filter-tab').forEach(tab => {
    tab.classList.toggle('active', tab.dataset.filter === period);
  });
  
  renderEvents();
}

/**
 * v20.4: Populate filter dropdowns with unique values from events
 */
function populateEventFilterDropdowns() {
  if (!S.events?.length) return;
  
  // Collect unique values
  const types = new Set();
  const detail1s = new Set();
  const detail2s = new Set();
  const pd1s = new Set();
  const pd2s = new Set();
  
  S.events.forEach(e => {
    if (e.type) types.add(e.type);
    if (e.detail1 || e.detail) detail1s.add(e.detail1 || e.detail);
    if (e.detail2) detail2s.add(e.detail2);
    
    // Get play details from primary player
    const primaryPlayer = (e.players || []).find(p => p.role?.startsWith('event') || !p.role?.startsWith('opp'));
    if (primaryPlayer?.playD1) pd1s.add(primaryPlayer.playD1);
    if (primaryPlayer?.playD2) pd2s.add(primaryPlayer.playD2);
  });
  
  // Helper to populate a select
  const populateSelect = (id, values) => {
    const sel = document.getElementById(id);
    if (!sel) return;
    const current = sel.value;
    sel.innerHTML = '<option value="">All</option>' + 
      [...values].sort().map(v => `<option value="${v}">${v.substring(0,15)}</option>`).join('');
    sel.value = current; // Restore selection
  };
  
  populateSelect('filterEvtType', types);
  populateSelect('filterEvtDetail1', detail1s);
  populateSelect('filterEvtDetail2', detail2s);
  populateSelect('filterPlayDetail1', pd1s);
  populateSelect('filterPlayDetail2', pd2s);
}

/**
 * v20.4: Apply event filters from UI
 */
function applyEventFilters() {
  S.eventFilters.type = document.getElementById('filterEvtType')?.value || '';
  S.eventFilters.detail1 = document.getElementById('filterEvtDetail1')?.value || '';
  S.eventFilters.detail2 = document.getElementById('filterEvtDetail2')?.value || '';
  S.eventFilters.playDetail1 = document.getElementById('filterPlayDetail1')?.value || '';
  S.eventFilters.playDetail2 = document.getElementById('filterPlayDetail2')?.value || '';
  S.eventFilters.team = document.getElementById('filterEvtTeam')?.value || '';
  
  const evtIdxVal = document.getElementById('filterEvtIdx')?.value;
  S.eventFilters.eventIdx = evtIdxVal ? parseInt(evtIdxVal) : null;
  
  const linkIdxVal = document.getElementById('filterLinkIdx')?.value;
  S.eventFilters.linkedIdx = linkIdxVal ? parseInt(linkIdxVal) : null;
  
  const shiftIdxVal = document.getElementById('filterShiftIdx')?.value;
  S.eventFilters.shiftIdx = shiftIdxVal ? parseInt(shiftIdxVal) : null;
  
  renderEvents();
}

/**
 * v20.4: Clear all event filters
 */
function clearEventFilters() {
  S.eventFilters = {
    type: '',
    detail1: '',
    detail2: '',
    playDetail1: '',
    playDetail2: '',
    team: '',
    eventIdx: null,
    linkedIdx: null,
    shiftIdx: null
  };
  
  // Clear UI elements
  ['filterEvtType', 'filterEvtDetail1', 'filterEvtDetail2', 'filterPlayDetail1', 
   'filterPlayDetail2', 'filterEvtTeam'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.value = '';
  });
  ['filterEvtIdx', 'filterLinkIdx', 'filterShiftIdx'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.value = '';
  });
  
  renderEvents();
  toast('Filters cleared', 'info');
}

/**
 * Toggle compact mode
 */
function toggleCompactMode() {
  S.compactMode = !S.compactMode;
  document.body.classList.toggle('compact-mode', S.compactMode);
  toast(S.compactMode ? 'Compact mode ON' : 'Compact mode OFF', 'info');
}

/**
 * Toggle event log visibility (v17)
 */
function toggleEventLog() {
  const section = document.getElementById('eventLogSection');
  const body = document.getElementById('evtListBody');
  const tabs = section?.querySelector('.period-filter-tabs');
  
  if (body) {
    const isHidden = body.style.display === 'none';
    body.style.display = isHidden ? 'block' : 'none';
    if (tabs) tabs.style.display = isHidden ? 'flex' : 'none';
    toast(isHidden ? 'Event log shown' : 'Event log hidden', 'info');
  }
}

/**
 * Select event player slot for XY/details editing (v6)
 */
function selectEventPlayerSlot(type, num) {
  const rolePrefix = type === 'evt' ? 'event_player_' : 'opp_player_';
  const role = rolePrefix + num;
  
  // Check if player with this role already exists
  let player = S.curr.players.find(p => p.role === role);
  
  if (player) {
    // Player exists - just SELECT them (don't add duplicate)
    S.selectedPlayer = player;
    setXYMode('player');
    S.xySlot = 1;
    renderXYSlots();
    renderCurrentPlayers(); // Highlight selected player
    toast(`Selected ${type === 'evt' ? 'Event' : 'Opp'} P${num}: #${player.num}`, 'info');
    return;
  }
  
  // Player doesn't exist - try to add from slots
  const team = type === 'evt' ? S.evtTeam : (S.evtTeam === 'home' ? 'away' : 'home');
  const slots = S.slots[team];
  
  // Map slot positions to player numbers (F1, F2, F3, D1, D2)
  const slotMap = { 1: 'F1', 2: 'F2', 3: 'F3', 4: 'D1', 5: 'D2', 6: 'G' };
  const slotKey = slotMap[num];
  const slotPlayer = slots[slotKey];
  
  if (slotPlayer) {
    // Add player to current event
    player = {
      num: slotPlayer.num,
      name: slotPlayer.name,
      team: team,
      role: role,
      roleNum: num,
      xy: [],
      playD1: '',
      playD2: '',
      playSuccess: '',
      pressuredBy: '',
      sideOfPuck: ''
    };
    S.curr.players.push(player);
    S.selectedPlayer = player;
    setXYMode('player');
    S.xySlot = 1;
    renderXYSlots();
    renderCurrentPlayers();
    toast(`Added ${type === 'evt' ? 'Event' : 'Opp'} P${num}: #${slotPlayer.num} ${slotPlayer.name}`, 'success');
  } else {
    toast(`${type === 'evt' ? 'Event' : 'Opp'} Player ${num} - No player in slot ${slotKey}`, 'warning');
    return;
  }
}

/**
 * Quick line change - ends all current shifts and starts new ones (v6)
 */
function quickLineChange() {
  const clock = document.getElementById('clock').value;
  
  // Log current shift with end time
  document.getElementById('shiftEnd').value = clock;
  logShift();
  
  // Start new shift immediately
  document.getElementById('shiftStart').value = clock;
  document.getElementById('shiftEnd').value = '';
  
  toast('Quick line change recorded', 'success');
}

// ============================================================
// RESIZE PANELS
// ============================================================
let resizing = null;
function startResize(e, panel) {
  resizing = { panel, startX: e.clientX, startWidth: document.getElementById(panel + 'Panel').offsetWidth };
  document.addEventListener('mousemove', doResize);
  document.addEventListener('mouseup', stopResize);
}
function doResize(e) {
  if (!resizing) return;
  const diff = e.clientX - resizing.startX;
  const newWidth = resizing.panel === 'left' ? resizing.startWidth + diff : resizing.startWidth - diff;
  document.getElementById(resizing.panel + 'Panel').style.width = Math.max(150, Math.min(400, newWidth)) + 'px';
}
function stopResize() { resizing = null; document.removeEventListener('mousemove', doResize); document.removeEventListener('mouseup', stopResize); }

// ============================================================
// TOAST
// ============================================================
function toast(msg, type = '') {
  const el = document.getElementById('toast');
  el.textContent = msg;
  el.className = 'toast show ' + type;
  setTimeout(() => el.classList.remove('show'), 2000);
}

// ============================================================
// START
// ============================================================
document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
