<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BenchSight Tracker v23.3</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<style>
:root {
  --bg: #0a0e14; --panel: #131920; --card: #1a222c; --input: #0d1117;
  --border: #2a3441; --accent: #00d4aa; --accent2: #00b4d8;
  --success: #10b981; --warn: #f59e0b; --danger: #ef4444;
  --text: #e2e8f0; --muted: #64748b; --home: #3b82f6; --away: #ef4444;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: 'SF Mono', monospace; background: var(--bg); color: var(--text); font-size: 11px; overflow: hidden; height: 100vh; }
:root {
  --left-panel-width: 220px;
  --right-panel-width: 320px;
  --base-font-size: 11px;
}
.app { display: grid; grid-template-rows: 36px 1fr; height: 100vh; }
.header { background: var(--panel); border-bottom: 1px solid var(--border); padding: 0 8px; display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
.header h1 { font-size: 12px; background: linear-gradient(135deg, var(--accent), var(--accent2)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
.main { display: grid; grid-template-columns: var(--left-panel-width) 1fr var(--right-panel-width); height: 100%; overflow: hidden; }
.panel { background: var(--panel); border-right: 1px solid var(--border); display: flex; flex-direction: column; overflow: hidden; position: relative; min-width: 150px; }
.panel:last-child { border-right: none; border-left: 1px solid var(--border); }

/* v23.8: Responsive layout adjustments */
@media (max-width: 1400px) {
  :root {
    --left-panel-width: 200px;
    --right-panel-width: 300px;
    --base-font-size: 10px;
  }
}

@media (max-width: 1200px) {
  :root {
    --left-panel-width: 180px;
    --right-panel-width: 280px;
    --base-font-size: 9px;
  }
  .header { font-size: 9px; }
  .panel-header { font-size: 8px; }
}

@media (max-width: 1000px) {
  .main { grid-template-columns: 160px 1fr 240px; }
  :root {
    --left-panel-width: 160px;
    --right-panel-width: 240px;
  }
}

@media (max-height: 700px) {
  .panel-body { max-height: calc(100vh - 150px) !important; }
}
.panel-header { background: var(--card); padding: 4px 8px; font-size: 9px; font-weight: 600; text-transform: uppercase; color: var(--accent); border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; }
.panel-body { flex: 1; overflow-y: auto; padding: 6px; }
select, input, button { font-family: inherit; font-size: 10px; background: var(--input); border: 1px solid var(--border); color: var(--text); padding: 4px 6px; border-radius: 3px; }
select:focus, input:focus { border-color: var(--accent); outline: none; }
button { cursor: pointer; } button:hover { background: var(--card); border-color: var(--accent); }
.btn-sm { padding: 2px 5px; font-size: 9px; }
.btn-sm.active { background: var(--accent); color: #000; }
#quickDetailRow .btn-sm.active { background: var(--accent); color: #000; font-weight: bold; }
.btn-primary { background: var(--accent); color: #000; border-color: var(--accent); }
.btn-success { background: var(--success); color: #fff; }
.btn-danger { background: var(--danger); color: #fff; }
kbd { background: var(--bg); border: 1px solid var(--border); padding: 0 3px; border-radius: 2px; font-size: 8px; color: var(--muted); }
.form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 4px; }
.form-row.tri { grid-template-columns: 1fr 1fr 1fr; }
.form-group { display: flex; flex-direction: column; gap: 1px; }
.form-group label { font-size: 7px; color: var(--muted); text-transform: uppercase; }
.form-group select, .form-group input { width: 100%; }

/* Resize handles - v23.8: Enhanced for modular layout */
.resize-handle { position: absolute; background: transparent; z-index: 10; }
.resize-handle:hover { background: var(--accent); opacity: 0.5; }
.resize-handle.right { right: 0; top: 0; width: 4px; height: 100%; cursor: ew-resize; }
.resize-handle.left { left: 0; top: 0; width: 4px; height: 100%; cursor: ew-resize; }
.resize-handle.active { background: var(--accent); opacity: 0.8; }

/* Header */
.game-select { width: 200px; }
.game-search { background: var(--input); border: 1px solid var(--border); color: var(--text); padding: 4px 8px; border-radius: 3px; width: 150px; font-size: 10px; }
.clock { font-size: 16px; font-weight: 700; color: var(--accent); background: var(--bg); padding: 2px 8px; border-radius: 3px; border: 1px solid var(--border); }
.score { font-size: 14px; font-weight: 700; }
.score-h { color: var(--home); } .score-a { color: var(--away); }
.period-btns { display: flex; gap: 2px; }
.period-btn { padding: 2px 6px; } .period-btn.active { background: var(--accent); color: #000; }
.header-right { margin-left: auto; display: flex; gap: 6px; align-items: center; }
.status { font-size: 8px; color: var(--muted); }
.save-ind { font-size: 7px; padding: 1px 4px; border-radius: 4px; background: var(--card); }
.save-ind.saving { background: var(--warn); color: #000; }
.save-ind.saved { background: var(--success); color: #fff; }
.conn { font-size: 7px; padding: 1px 4px; border-radius: 8px; }
.conn.on { background: var(--success); color: #fff; } .conn.off { background: var(--muted); color: #fff; }

/* Shift Panel */
.team-sec { margin-bottom: 8px; }
.team-hdr { display: flex; justify-content: space-between; align-items: center; padding: 3px 6px; background: var(--card); border-radius: 3px; margin-bottom: 3px; }
.team-hdr h4 { font-size: 9px; display: flex; align-items: center; gap: 4px; }
.team-dot { width: 8px; height: 8px; border-radius: 50%; }
.slots { display: grid; grid-template-columns: 20px 1fr; gap: 2px; margin-bottom: 2px; }
.slot-lbl { font-size: 7px; color: var(--muted); display: flex; align-items: center; }
.slot-row { display: flex; gap: 2px; }
.slot { flex: 1; min-height: 24px; border-radius: 3px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; border: 2px solid var(--border); background: var(--input); font-size: 10px; position: relative; transition: transform 0.1s, box-shadow 0.1s; }
.slot .num { font-weight: 700; } .slot .name { font-size: 6px; color: var(--muted); max-width: 40px; overflow: hidden; text-overflow: ellipsis; }
.slot.filled { border-color: var(--success); background: var(--card); cursor: grab; }
.slot.filled:active { cursor: grabbing; }
.slot.selected { box-shadow: 0 0 0 2px var(--accent); }
.slot.drag-over { border-color: var(--accent); background: rgba(0,212,170,0.2); transform: scale(1.05); }
.slot.dragging { opacity: 0.5; transform: scale(0.95); }
.slot .clear-x { position: absolute; top: -4px; right: -4px; width: 14px; height: 14px; border-radius: 50%; background: var(--danger); color: #fff; font-size: 10px; line-height: 14px; text-align: center; cursor: pointer; display: none; border: 1px solid var(--bg); z-index: 5; }
.slot.filled:hover .clear-x { display: block; }
.slot .clear-x:hover { background: #dc2626; transform: scale(1.1); }

/* Save Location UI */
.save-location-box { background: var(--card); border: 1px solid var(--border); border-radius: 4px; padding: 8px; margin-bottom: 8px; }
.save-location-box .folder-display { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
.save-location-box .folder-path { flex: 1; background: var(--bg); border: 1px solid var(--border); border-radius: 3px; padding: 6px 8px; font-size: 10px; color: var(--text); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.save-location-box .folder-path.empty { color: var(--muted); font-style: italic; }
.save-location-box .folder-actions { display: flex; gap: 4px; }
.save-location-box .folder-status { font-size: 9px; color: var(--muted); margin-top: 4px; }
.save-location-box .folder-status.ready { color: var(--success); }
.save-location-box .folder-status.error { color: var(--danger); }
.roster { background: var(--card); border-radius: 3px; padding: 3px; max-height: 100px; overflow-y: auto; }
.roster-group { margin-bottom: 4px; }
.roster-group-label { font-size: 7px; color: var(--accent); text-transform: uppercase; display: block; margin-bottom: 2px; }
.roster-btn { padding: 2px 4px; font-size: 8px; border-radius: 2px; cursor: pointer; border: 1px solid var(--border); background: var(--input); display: inline-flex; flex-direction: column; align-items: center; min-width: 36px; margin: 1px; }
.roster-btn .num { font-weight: 700; } .roster-btn .name { font-size: 6px; color: var(--muted); }
.roster-btn .rating { font-size: 6px; color: var(--accent); background: var(--bg); padding: 0 2px; border-radius: 2px; margin-top: 1px; }
.roster-btn:hover { background: var(--accent); color: #000; }
.roster-btn.on-ice { opacity: 0.3; }
.shift-times { display: grid; grid-template-columns: 1fr 1fr; gap: 3px; margin-top: 4px; padding: 4px; background: var(--card); border-radius: 3px; }
.shift-times label { font-size: 6px; color: var(--muted); }
.shift-actions { display: flex; gap: 3px; margin-top: 4px; }
.shift-actions button { flex: 1; padding: 6px; font-size: 9px; }

/* Center - Rink */
.center { display: flex; flex-direction: column; background: var(--panel); overflow-y: auto; }
.video-section { border-bottom: 2px solid var(--accent); }
.video-section .speed-btn.active { background: var(--accent); color: #000; }
.video-toggle-bar:hover { background: var(--panel); }
.rink-wrap { flex: 1; display: flex; align-items: center; justify-content: center; padding: 8px; position: relative; min-height: 300px; max-height: 450px; }
#rinkSvg { max-width: 100%; max-height: 100%; cursor: crosshair; }
.mode-ind { position: absolute; top: 6px; left: 50%; transform: translateX(-50%); padding: 3px 10px; border-radius: 12px; font-size: 9px; font-weight: 600; border: 2px solid; }
.mode-ind.puck { background: #000; color: #fff; border-color: #fff; }
.mode-ind.player { background: var(--accent); color: #000; border-color: var(--accent); }
.xy-controls { display: flex; gap: 4px; padding: 4px 8px; background: var(--card); border-top: 1px solid var(--border); align-items: center; flex-wrap: wrap; justify-content: center; }
.xy-btn { padding: 2px 6px; font-size: 9px; } .xy-btn.active { background: var(--accent); color: #000; }
.xy-slots { display: flex; gap: 1px; }
.xy-slot { width: 18px; height: 18px; border-radius: 2px; display: flex; align-items: center; justify-content: center; font-size: 8px; cursor: pointer; border: 1px solid var(--border); background: var(--input); }
.xy-slot.has { background: var(--success); color: #fff; } .xy-slot.active { box-shadow: 0 0 0 2px var(--accent); }
.xy-player-sel { min-width: 80px; font-size: 9px; }

/* Event List */
.evt-list { border-top: 1px solid var(--border); flex: 0 0 auto; min-height: 120px; max-height: 280px; overflow-y: auto; background: var(--card); }
.evt-header { display: grid; grid-template-columns: 35px 45px 100px 1fr 20px; gap: 2px; padding: 2px 6px; background: var(--card); font-size: 7px; color: var(--muted); position: sticky; top: 0; }
/* v20.4: Expanded columns - #, Sh, Lnk, Time, T, Type, Detail1, Detail2, Z, S, EvtP, OppP, PD1, PD2, PS, XY, ‚≠ê */
.evt-item { display: grid; grid-template-columns: 30px 22px 22px 20px 48px 48px 14px 46px 30px 58px 58px 14px 12px 30px 30px 46px 46px 12px 12px 12px; gap: 1px; padding: 2px 3px; border-bottom: 1px solid var(--border); font-size: 7px; cursor: pointer; align-items: center; }
.evt-move-btns { display: flex; flex-direction: column; gap: 1px; }
.evt-move-btns button { padding: 1px 3px; font-size: 8px; line-height: 1; min-height: auto; }
/* v20.4: Event log filter row */
.evt-filter-row { display: flex; flex-wrap: wrap; gap: 4px; padding: 4px 6px; background: var(--panel); border-bottom: 1px solid var(--border); align-items: center; }
.evt-filter-row select, .evt-filter-row input { font-size: 8px; padding: 2px 4px; background: var(--card); border: 1px solid var(--border); color: var(--text); border-radius: 3px; }
.evt-filter-row select { max-width: 80px; }
.evt-filter-row input { width: 40px; }
.evt-filter-row label { font-size: 7px; color: var(--muted); margin-right: 2px; }
.evt-filter-row .filter-group { display: flex; align-items: center; gap: 2px; }
.evt-filter-row .btn-clear { font-size: 8px; padding: 2px 6px; background: var(--danger); color: white; border: none; border-radius: 3px; cursor: pointer; }
.evt-item:hover { background: var(--panel); }
.evt-item.active { background: rgba(0,212,170,0.1); }
.evt-item.event-highlight { background: rgba(59,130,246,0.2); border-left: 3px solid var(--accent); font-weight: 600; } /* v23.8: Highlight target event */
.evt-item .idx { color: var(--accent); font-family: monospace; font-size: 7px; }
.evt-item .seq { color: var(--accent2); font-family: monospace; font-size: 6px; }
.evt-item .link { color: var(--warn); font-family: monospace; font-size: 6px; }
.evt-item .time { color: var(--muted); font-size: 7px; }
.evt-item .team { font-weight: bold; font-size: 7px; }
.evt-item .type { font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 7px; }
.evt-item .detail { color: var(--muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 6px; }
.evt-item .zone { color: var(--accent2); font-size: 6px; }
.evt-item .success { color: var(--success); font-size: 7px; }
.evt-item .evtp { font-size: 6px; color: var(--accent); font-family: monospace; }
.evt-item .oppp { font-size: 6px; color: var(--muted); font-family: monospace; }
.evt-item .pd1 { font-size: 5px; color: var(--muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.evt-item .psucc { font-size: 6px; color: var(--success); }
.evt-item .xy-dot { color: var(--accent); font-size: 10px; font-weight: bold; }
.evt-item .hl { color: var(--warn); }

/* Right Panel - Event Entry */
.team-toggle { display: flex; gap: 2px; margin-bottom: 4px; }
.team-toggle button { flex: 1; padding: 5px; font-size: 9px; }
.team-toggle .swap-btn { flex: 0 0 28px; background: var(--card); border: 1px solid var(--border); font-size: 12px; padding: 2px; }
.team-toggle .swap-btn:hover { background: var(--accent); color: #000; }
.team-toggle .home.active { background: var(--home); color: #fff; }
.team-toggle .away.active { background: var(--away); color: #fff; }
.evt-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 2px; margin-bottom: 6px; }
.evt-btn { padding: 4px 2px; display: flex; flex-direction: column; align-items: center; font-size: 8px; border-radius: 3px; }
.evt-btn kbd { font-size: 7px; } .evt-btn.active { background: var(--accent); color: #000; }
.section { margin-bottom: 6px; }
.section-title { font-size: 8px; color: var(--muted); margin-bottom: 2px; display: flex; justify-content: space-between; }
.player-list { background: var(--card); border-radius: 3px; padding: 3px; min-height: 28px; }
.player-chip { display: inline-flex; align-items: center; gap: 2px; padding: 2px 5px; margin: 1px; border-radius: 3px; font-size: 9px; cursor: grab; border: 1px solid var(--border); background: var(--input); transition: transform 0.1s, opacity 0.1s; }
.player-chip:active { cursor: grabbing; }
.player-chip.dragging { opacity: 0.5; transform: scale(0.95); }
.player-chip.drag-over { transform: scale(1.05); box-shadow: 0 0 0 2px var(--accent); }
.player-chip .role-num { font-size: 7px; color: var(--muted); background: var(--bg); padding: 0 3px; border-radius: 2px; margin-right: 2px; }
.player-chip.evt { border-color: var(--accent); background: rgba(0,212,170,0.1); }
.player-chip.evt .role-num { color: var(--accent); }
.player-chip.opp { border-color: var(--danger); background: rgba(239,68,68,0.1); }
.player-chip.opp .role-num { color: var(--danger); }
.player-list { background: var(--card); border-radius: 3px; padding: 3px; min-height: 28px; }
.player-list.drag-target { background: rgba(0,212,170,0.1); border: 1px dashed var(--accent); }
.player-chip.selected { box-shadow: 0 0 0 2px var(--warn); }
.player-chip .num { font-weight: 700; }
.player-chip .su { font-size: 7px; padding: 0 2px; border-radius: 2px; margin-left: 2px; }
.player-chip .su.s { background: var(--success); color: #fff; }
.player-chip .su.u { background: var(--danger); color: #fff; }
.player-chip .remove { color: var(--muted); margin-left: 2px; } .player-chip .remove:hover { color: var(--danger); }
.quick-add { display: flex; flex-wrap: wrap; gap: 2px; padding: 3px; background: var(--card); border-radius: 3px; }
.quick-add button { padding: 2px 4px; font-size: 8px; min-width: 24px; }
.quick-add button.in-evt { background: var(--accent); color: #000; }
.quick-add button.recent { border: 2px solid var(--warning); box-shadow: 0 0 4px var(--warning); }
.player-details { background: var(--card); border-radius: 3px; padding: 4px; margin-top: 4px; font-size: 8px; }
.player-details h5 { color: var(--accent); margin-bottom: 3px; font-size: 9px; }
.log-actions { display: flex; gap: 3px; margin-top: 6px; }
.log-actions button { flex: 1; padding: 8px; font-size: 10px; }

/* Zone indicator */
.zone-ind { display: inline-block; padding: 2px 6px; border-radius: 3px; font-size: 8px; font-weight: bold; margin-left: 4px; }
.zone-ind.o { background: var(--success); color: #fff; }
.zone-ind.d { background: var(--danger); color: #fff; }
.zone-ind.n { background: var(--warn); color: #000; }

/* Modals */
.overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.85); display: none; align-items: center; justify-content: center; z-index: 100; }
.overlay.show { display: flex; }
.modal { background: var(--panel); border: 1px solid var(--border); border-radius: 6px; padding: 12px; min-width: 400px; max-width: 600px; max-height: 80vh; overflow-y: auto; }
.modal h3 { font-size: 12px; color: var(--accent); margin-bottom: 8px; }
.modal-actions { display: flex; gap: 4px; margin-top: 10px; }
.modal-actions button { flex: 1; }
/* v20.5: Mapping modal for import validation */
.mapping-modal { min-width: 700px; max-width: 900px; }
.mapping-modal h3 { font-size: 14px; margin-bottom: 12px; }
.mapping-modal .summary { font-size: 11px; color: var(--muted); margin-bottom: 10px; }
.mapping-table { width: 100%; border-collapse: collapse; font-size: 10px; margin: 10px 0; }
.mapping-table th { background: var(--card); color: var(--accent); padding: 6px 8px; text-align: left; border: 1px solid var(--border); }
.mapping-table td { padding: 6px 8px; border: 1px solid var(--border); }
.mapping-table tr:hover { background: rgba(0,212,255,0.1); }
.mapping-table .field { color: var(--muted); font-size: 9px; }
.mapping-table .original { color: var(--warn); font-family: monospace; }
.mapping-table .matched { color: var(--success); font-family: monospace; }
.mapping-table .no-match { color: var(--danger); }
.mapping-table select { font-size: 9px; padding: 2px 4px; max-width: 180px; background: var(--card); border: 1px solid var(--border); color: var(--text); }
.mapping-table .score { font-size: 9px; color: var(--muted); }
.mapping-legend { display: flex; gap: 15px; font-size: 9px; margin: 8px 0; }
.mapping-legend span { display: flex; align-items: center; gap: 4px; }
.mapping-legend .dot { width: 8px; height: 8px; border-radius: 50%; }
.mapping-legend .dot.exact { background: var(--success); }
.mapping-legend .dot.fuzzy { background: var(--accent); }
.mapping-legend .dot.none { background: var(--danger); }
.modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 999; }
.mapping-modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1000; }

/* Edit Modal Specific */
.edit-player-row { display: flex; gap: 4px; align-items: center; padding: 4px; background: var(--input); border-radius: 3px; margin-bottom: 4px; }
.edit-player-row .pnum { font-weight: bold; min-width: 50px; }
.edit-player-row select, .edit-player-row input { flex: 1; }
.edit-xy-grid { display: flex; gap: 2px; flex-wrap: wrap; margin-top: 4px; }
.edit-xy-btn { width: 24px; height: 24px; border-radius: 3px; display: flex; align-items: center; justify-content: center; font-size: 8px; cursor: pointer; }
.edit-xy-btn.has { background: var(--success); color: #fff; }

/* Toast */
.toast { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); background: var(--card); border: 1px solid var(--border); padding: 6px 14px; border-radius: 4px; font-size: 10px; z-index: 200; opacity: 0; transition: opacity 0.2s; }
.toast.show { opacity: 1; }
.toast.success { border-color: var(--success); color: var(--success); }
.toast.error { border-color: var(--danger); color: var(--danger); }

/* XY Tooltip v5 */
.xy-tooltip { position: absolute; background: rgba(0,0,0,0.9); color: #fff; padding: 6px 10px; border-radius: 4px; font-size: 10px; pointer-events: none; z-index: 100; white-space: nowrap; transform: translate(-50%, -100%); margin-top: -8px; }
.xy-tooltip::after { content: ''; position: absolute; bottom: -4px; left: 50%; transform: translateX(-50%); border-left: 5px solid transparent; border-right: 5px solid transparent; border-top: 5px solid rgba(0,0,0,0.9); }

/* Clear All Buttons v5 */
.clear-all-btn { padding: 4px 8px; font-size: 8px; background: var(--danger); color: #fff; border: none; border-radius: 3px; cursor: pointer; margin-left: 4px; }
.clear-all-btn:hover { background: #dc2626; }

/* Auto-popup checkbox v5 */
.auto-popup-row { display: flex; align-items: center; gap: 8px; margin: 8px 0; padding: 6px; background: var(--card); border-radius: 4px; font-size: 9px; }
.auto-popup-row input[type="checkbox"] { margin: 0; }

/* Enhanced player chip inline edit v5 */
.player-chip { position: relative; }
.player-chip .inline-edit { position: absolute; top: 100%; left: 0; background: var(--panel); border: 1px solid var(--accent); border-radius: 4px; padding: 4px; z-index: 50; min-width: 150px; display: none; }
.player-chip:hover .inline-edit.active { display: block; }

/* Collapsible sections */
.collapsible-section { margin-bottom: 4px; }
.collapsible-header { display: flex; justify-content: space-between; align-items: center; padding: 4px 6px; background: var(--card); border: 1px solid var(--border); border-radius: 3px; cursor: pointer; font-size: 8px; user-select: none; }
.collapsible-header:hover { background: var(--panel); }
.collapsible-icon { font-size: 8px; color: var(--muted); transition: transform 0.2s; margin-left: 4px; }
.collapsible-content { display: none; }
.collapsible-content.show { display: block !important; }
.collapsible-content.show[style*="display:flex"] { display: flex !important; }

/* Hotkey indicator flash v5 */
.hotkey-flash { animation: hotkey-pulse 0.3s ease-out; }
@keyframes hotkey-pulse { 0% { box-shadow: 0 0 0 0 rgba(0,212,170,0.5); } 100% { box-shadow: 0 0 0 10px rgba(0,212,170,0); } }

/* Event type colors v5 */
.evt-btn[data-type="Goal"] { border-color: #22c55e !important; }
.evt-btn[data-type="Goal"].active { background: #22c55e !important; }
.evt-btn[data-type="Shot"] { border-color: #3b82f6 !important; }
.evt-btn[data-type="Shot"].active { background: #3b82f6 !important; }
.evt-btn[data-type="Penalty"] { border-color: #ef4444 !important; }
.evt-btn[data-type="Penalty"].active { background: #ef4444 !important; }
.evt-btn[data-type="Turnover"] { border-color: #f59e0b !important; }
.evt-btn[data-type="Turnover"].active { background: #f59e0b !important; }

/* Quick stats bar v5 */
.quick-stats { display: flex; gap: 8px; padding: 4px 8px; background: var(--card); font-size: 9px; border-bottom: 1px solid var(--border); }
.quick-stat { display: flex; align-items: center; gap: 4px; }
.quick-stat .label { color: var(--muted); }
.quick-stat .value { font-weight: bold; color: var(--accent); }

/* Period indicator enhanced v5 */
.period-btn.active { background: var(--accent); color: #000; font-weight: bold; }

/* Shift strength indicator v5 */
.strength-indicator { padding: 2px 6px; border-radius: 3px; font-size: 9px; font-weight: bold; }
.strength-indicator.pp { background: rgba(34,197,94,0.2); color: #22c55e; }
.strength-indicator.pk { background: rgba(239,68,68,0.2); color: #ef4444; }
.strength-indicator.even { background: rgba(100,116,139,0.2); color: #94a3b8; }

/* v6: Period filter tabs */
.period-filter-tabs { display: flex; gap: 2px; padding: 4px 8px; background: var(--bg); border-bottom: 1px solid var(--border); }
.period-filter-tab { padding: 2px 8px; font-size: 8px; border: 1px solid var(--border); border-radius: 3px; cursor: pointer; background: var(--input); color: var(--muted); }
.period-filter-tab.active { background: var(--accent); color: #000; border-color: var(--accent); }

/* v6: Line presets */
.line-presets { padding: 4px 8px; background: var(--card); border-bottom: 1px solid var(--border); font-size: 8px; }
.preset-row { display: flex; gap: 4px; align-items: center; margin-bottom: 2px; }
.preset-btn { padding: 2px 6px; font-size: 8px; border-radius: 3px; cursor: pointer; border: 1px solid var(--border); background: var(--input); }
.preset-btn:hover { background: var(--accent); color: #000; }
.preset-btn.active { border-color: var(--success); }

/* v6: Compact mode */
.compact-mode .panel-body { padding: 4px; }
.compact-mode .team-sec { margin-bottom: 4px; }
.compact-mode .team-hdr { padding: 2px 4px; margin-bottom: 2px; }
.compact-mode .slots { margin-bottom: 1px; }
.compact-mode .slot { min-height: 20px; font-size: 9px; }
.compact-mode .roster { max-height: 60px; padding: 2px; }
.compact-mode .roster-btn { padding: 1px 2px; font-size: 7px; min-width: 28px; }
.compact-mode .quick-stats { padding: 2px 8px; }

/* v6: Selected player indicator */
.selected-player-slot { box-shadow: 0 0 0 2px var(--accent), 0 0 8px var(--accent); }
.player-selector { display: inline-flex; align-items: center; gap: 2px; padding: 1px 4px; border-radius: 3px; font-size: 8px; cursor: pointer; border: 1px solid var(--border); }
.player-selector.selected { background: var(--accent); color: #000; border-color: var(--accent); }
</style>
</head>
<body>
<div class="app">
  <!-- Header -->
  <header class="header">
    <h1>üèí BenchSight v16.08</h1>
    <div style="display:flex;gap:4px;align-items:center;">
      <input type="text" id="gameSearch" class="game-search" placeholder="üîç Search games..." oninput="filterGames(this.value)">
      <select id="gameSelect" class="game-select" onchange="selectGame(this.value)"></select>
      <button class="btn-sm" onclick="loadGames()" title="Reload Games">üîÑ</button>
    </div>
    <div class="period-btns">
      <button class="period-btn active" data-p="1" onclick="setPeriod(1)" title="Period 1">P1</button>
      <button class="period-btn" data-p="2" onclick="setPeriod(2)" title="Period 2">P2</button>
      <button class="period-btn" data-p="3" onclick="setPeriod(3)" title="Period 3">P3</button>
      <button class="period-btn" data-p="OT" onclick="setPeriod('OT')" title="Overtime">OT</button>
      <span id="periodLengthIndicator" style="font-size:9px;color:var(--muted);margin-left:4px;" title="Current period length">(18m)</span>
      <button id="flipZonesBtn" onclick="flipZones()" title="Flip which end home attacks in P1 (for beer league variable benches)" style="margin-left:8px;padding:2px 6px;font-size:10px;background:#374151;">‚ü∑ Flip</button>
      <button class="btn-sm" onclick="showPeriodEndChecklist()" title="Period checklist & verification" style="font-size:9px;">üìã Check</button>
      <button class="btn-sm" onclick="setVideoOffset()" title="Set video sync offset" style="font-size:9px;">üé¨ Sync</button>
    </div>
    <span class="score"><span class="score-h" id="scoreH">0</span> - <span class="score-a" id="scoreA">0</span></span>
    <input type="text" class="clock" id="clock" value="18:00" style="width:60px;text-align:center;" onchange="updateClock()" oninput="autoFormatTime(this)">
    <div class="header-right">
      <span class="save-ind" id="saveInd">--</span>
      <button class="btn-sm" onclick="manualSave()" title="Save Now">üíæ</button>
      <button class="btn-sm" onclick="openLoadGameModal()" title="Load Existing Game">üìÇ</button>
      <button class="btn-sm" onclick="openVerifyModal()" title="Verify Goals">‚úÖ</button>
      <button class="btn-sm" onclick="openVideoTimingModal()" title="Video Timing">üé¨</button>
      <span class="conn off" id="connStatus">OFFLINE</span>
      <button class="btn-sm" onclick="openSettings()" title="Settings & Configuration">‚öôÔ∏è</button>
      <button class="btn-sm" onclick="openHelp()" title="Quick Help (?)">‚ùì</button>
      <button class="btn-sm" onclick="openUserGuide()" title="Full User Guide" style="background:var(--accent);color:#000;">üìñ</button>
      <button class="btn-sm btn-success" onclick="exportData()" title="Export game data to Excel">üì• Export</button>
      <button class="btn-sm" style="background:#6366f1;" onclick="document.getElementById('importFileInput').click()" title="Import game data from Excel">üì§ Import</button>
      <input type="file" id="importFileInput" accept=".xlsx,.xls" style="display:none" onchange="importExcel(this.files[0])">
    </div>
  </header>
  
  <!-- Quick Stats Bar (v5) -->
  <div class="quick-stats" id="quickStatsBar">
    <div class="quick-stat"><span class="label">Events:</span><span class="value" id="qsEvents">0</span></div>
    <div class="quick-stat"><span class="label">Shifts:</span><span class="value" id="qsShifts">0</span></div>
    <div class="quick-stat"><span class="label">SOG:</span><span class="value" id="qsSOG">0-0</span></div>
    <div class="quick-stat"><span class="label">FO:</span><span class="value" id="qsFO">0-0</span></div>
    <div class="quick-stat"><span class="label">PEN:</span><span class="value" id="qsPEN">0-0</span></div>
    <div class="quick-stat" style="margin-left:auto;"><span class="label">Strength:</span><span class="value strength-indicator even" id="qsStrength">5v5</span></div>
  </div>
  
  <!-- v23.5: Workflow Bars -->
  <div class="workflow-bars" style="padding:4px 8px;background:var(--panel);border-bottom:1px solid var(--border);display:flex;flex-wrap:wrap;gap:8px;align-items:center;font-size:10px;">
    <!-- Possession -->
    <div style="display:flex;align-items:center;gap:4px;">
      <span style="color:var(--muted);font-size:8px;">POSS:</span>
          <button class="btn-sm" onclick="setPossession('home')" style="padding:2px 6px;background:var(--home);color:#fff;font-size:9px;" title="Set possession to Home team">H</button>
      <div id="possessionDisplay" style="display:flex;align-items:center;width:80px;font-size:9px;">
        <span style="color:var(--home);">50%</span>
        <div style="flex:1;height:6px;background:var(--away);border-radius:3px;margin:0 4px;overflow:hidden;">
          <div style="width:50%;height:100%;background:var(--home);"></div>
        </div>
        <span style="color:var(--away);">50%</span>
      </div>
          <button class="btn-sm" onclick="setPossession('away')" style="padding:2px 6px;background:var(--away);color:#fff;font-size:9px;" title="Set possession to Away team">A</button>
      <button class="btn-sm" onclick="resetPossessionTimers()" style="padding:2px 4px;font-size:8px;" title="Reset">‚Ü∫</button>
    </div>
    
    <span style="color:var(--border);">|</span>
    
    <!-- Penalty Box -->
    <div style="display:flex;align-items:center;gap:4px;">
      <span style="color:var(--muted);font-size:8px;">BOX:</span>
      <div id="penaltyBoxDisplay" style="display:flex;gap:4px;">
        <span style="font-size:9px;color:var(--muted);">No penalties</span>
      </div>
    </div>
    
    <span style="color:var(--border);">|</span>
    
    <!-- Quick Actions -->
    <div style="display:flex;align-items:center;gap:4px;">
      <button class="btn-sm" id="undoBtn" onclick="undo()" style="padding:2px 6px;font-size:9px;" title="Undo (Ctrl+Z)" disabled>‚Ü© Undo</button>
      <button class="btn-sm" id="batchSelectBtn" onclick="toggleBatchSelectMode()" style="padding:2px 6px;font-size:9px;" title="Batch select events">‚òë Batch</button>
      <button class="btn-sm" onclick="toggleKeyboardXYMode()" style="padding:2px 6px;font-size:9px;" title="WASD to move, Enter to place">‚å® XY</button>
      <button class="btn-sm" onclick="toggleStatsOverlay()" style="padding:2px 6px;font-size:9px;" title="Show stats on video">üìä</button>
      <button class="btn-sm" onclick="addQuickNote()" style="padding:2px 6px;font-size:9px;" title="Add note to event">üìù</button>
    </div>
    
    <span style="color:var(--border);">|</span>
    
    <!-- Recent Players -->
    <div style="display:flex;align-items:center;gap:4px;flex:1;">
      <span style="color:var(--muted);font-size:8px;">RECENT:</span>
      <div id="recentPlayersBar" style="display:flex;gap:2px;flex-wrap:wrap;">
        <span style="font-size:8px;color:var(--muted);">Recent players appear here</span>
      </div>
    </div>
  </div>
  
  <!-- v23.5: Event Queue & Suggestions -->
  <div style="display:flex;gap:8px;padding:4px 8px;background:var(--card);border-bottom:1px solid var(--border);align-items:center;min-height:24px;">
    <div id="eventSuggestions" style="display:flex;align-items:center;gap:4px;"></div>
    <div id="eventQueueDisplay" style="display:flex;align-items:center;gap:4px;flex-wrap:wrap;margin-left:auto;"></div>
    <button class="btn-sm" onclick="toggleSuggestions()" style="padding:2px 4px;font-size:8px;" title="Toggle suggestions">üí°</button>
  </div>
  
  <!-- v23.5: Speed Tools Bar -->
  <div style="display:flex;gap:8px;padding:3px 8px;background:var(--panel);border-bottom:1px solid var(--border);align-items:center;font-size:9px;">
    <!-- Mode Toggles -->
    <div style="display:flex;align-items:center;gap:2px;">
      <span style="color:var(--muted);font-size:8px;">MODE:</span>
      <button class="btn-sm" id="mirrorModeBtn" onclick="toggleMirrorMode()" style="padding:2px 5px;font-size:8px;" title="Auto-flip XY for P2">üîÑ Mirror</button>
      <button class="btn-sm" onclick="toggleAutoZone()" style="padding:2px 5px;font-size:8px;" title="Auto-set zone from XY">üéØ AutoZ</button>
      <button class="btn-sm" onclick="toggleGoalieAutoAdd()" style="padding:2px 5px;font-size:8px;" title="Auto-Add Goalie: When enabled, automatically adds the opposing team's goalie as an opponent player when you log Shot, Goal, Save, or Rebound events. Saves time by not having to manually add the goalie each time.">ü•Ö AutoG</button>
      <button class="btn-sm" onclick="toggleNumpadMode()" style="padding:2px 5px;font-size:8px;" title="Use numpad for player slots">üî¢ Numpad</button>
    </div>
    
    <span style="color:var(--border);">|</span>
    
    <!-- Quick Stoppages -->
    <div style="display:flex;align-items:center;gap:2px;">
      <span style="color:var(--muted);font-size:8px;">STOP:</span>
      <button class="btn-sm" onclick="quickIcing('home')" style="padding:2px 5px;font-size:8px;background:var(--home);color:#fff;" title="Quick Icing - Home">Ice-H</button>
      <button class="btn-sm" onclick="quickIcing('away')" style="padding:2px 5px;font-size:8px;background:var(--away);color:#fff;" title="Quick Icing - Away">Ice-A</button>
      <button class="btn-sm" onclick="quickOffside()" style="padding:2px 5px;font-size:8px;" title="Quick Offside">Offside</button>
    </div>
    
    <span style="color:var(--border);">|</span>
    
    <!-- Strength Quick -->
    <div style="display:flex;align-items:center;gap:2px;">
      <span style="color:var(--muted);font-size:8px;">STR:</span>
      <button class="btn-sm strength-btn" data-strength="5v5" onclick="setStrength('5v5')" style="padding:2px 5px;font-size:8px;" title="Set strength: 5v5 (Even)">5v5</button>
      <button class="btn-sm strength-btn" data-strength="5v4" onclick="setStrength('5v4')" style="padding:2px 5px;font-size:8px;background:var(--success);" title="Set strength: 5v4 (Power Play)">PP</button>
      <button class="btn-sm strength-btn" data-strength="4v5" onclick="setStrength('4v5')" style="padding:2px 5px;font-size:8px;background:var(--danger);" title="Set strength: 4v5 (Penalty Kill)">PK</button>
      <button class="btn-sm strength-btn" data-strength="4v4" onclick="setStrength('4v4')" style="padding:2px 5px;font-size:8px;" title="Set strength: 4v4">4v4</button>
    </div>
    
    <span style="color:var(--border);">|</span>
    
    <!-- Empty Net & Tools -->
    <div style="display:flex;align-items:center;gap:2px;">
      <button class="btn-sm" onclick="toggleEmptyNet('home')" style="padding:2px 5px;font-size:8px;" title="Home empty net">EN-H</button>
      <button class="btn-sm" onclick="toggleEmptyNet('away')" style="padding:2px 5px;font-size:8px;" title="Away empty net">EN-A</button>
      <span id="emptyNetIndicator" style="display:none;font-weight:bold;padding:0 4px;"></span>
    </div>
    
    <span style="color:var(--border);">|</span>
    
    <!-- Analysis Tools -->
    <div style="display:flex;align-items:center;gap:2px;">
      <button class="btn-sm" onclick="findEventGaps()" style="padding:2px 5px;font-size:8px;" title="Find gaps in coverage">üîç Gaps</button>
      <button class="btn-sm" onclick="runConsistencyCheck()" style="padding:2px 5px;font-size:8px;" title="Check for issues">‚úÖ Check</button>
      <button class="btn-sm" onclick="toggleShotChartOverlay()" style="padding:2px 5px;font-size:8px;" title="Shot Chart Overlay: Display all tracked shots on the rink visualization. Goals appear in green, shots on goal in team colors. Helps visualize shot locations and patterns throughout the game.">üìç Shots</button>
    </div>
    
    <span style="color:var(--border);">|</span>
    
    <!-- Macros & Tools -->
    <div style="display:flex;align-items:center;gap:2px;">
      <button class="btn-sm" id="macroRecordBtn" onclick="recordingMacro ? stopRecordingMacro() : startRecordingMacro()" style="padding:2px 5px;font-size:8px;" title="Record event macro">‚è∫ Rec</button>
      <button class="btn-sm" onclick="showMacroManager()" style="padding:2px 5px;font-size:8px;" title="Manage macros">üé¨ Macros</button>
      <button class="btn-sm" onclick="toggleFloatingVideo()" style="padding:2px 5px;font-size:8px;" title="Floating video window">üì∫ Float</button>
    </div>
    
    <span style="color:var(--border);">|</span>
    
    <!-- Progress -->
    <div id="progressBar" style="min-width:100px;"></div>
  </div>

  <!-- Main -->
  <div class="main">
    <!-- Left: Shifts -->
    <div class="panel" id="leftPanel">
      <div class="resize-handle right" onmousedown="startResize(event, 'left')"></div>
      <div class="panel-header">
        <span>Shift Tracking</span>
        <button class="btn-sm" onclick="toggleCompactMode()" title="Toggle Compact Mode">‚äü</button>
      </div>
      <!-- v6: Line Presets - Collapsible -->
      <div class="collapsible-section">
        <div class="collapsible-header" onclick="toggleCollapsible('linePresetsBar')">
          <span style="color:var(--muted);">LINE PRESETS</span>
          <span class="collapsible-icon" id="linePresetsBarIcon">‚ñ∂</span>
        </div>
        <div class="line-presets collapsible-content" id="linePresetsBar" style="display:none;">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:2px;">
            <button class="btn-sm" onclick="openLinePresetModal()" title="Line presets">‚öôÔ∏è</button>
          </div>
          <div class="preset-row">
            <button class="preset-btn" onclick="loadPreset('home','F1')" title="Load Home F1 preset">F1</button>
            <button class="preset-btn" onclick="loadPreset('home','F2')" title="Load Home F2 preset">F2</button>
            <button class="preset-btn" onclick="loadPreset('home','F3')" title="Load Home F3 preset">F3</button>
            <button class="preset-btn" onclick="loadPreset('home','D1')" title="Load Home D1 preset">D1</button>
            <button class="preset-btn" onclick="loadPreset('home','D2')" title="Load Home D2 preset">D2</button>
            <span style="color:var(--muted);font-size:7px;">Home</span>
          </div>
          <div class="preset-row">
            <button class="preset-btn" onclick="loadPreset('away','F1')" title="Load Away F1 preset">F1</button>
            <button class="preset-btn" onclick="loadPreset('away','F2')" title="Load Away F2 preset">F2</button>
            <button class="preset-btn" onclick="loadPreset('away','F3')" title="Load Away F3 preset">F3</button>
            <button class="preset-btn" onclick="loadPreset('away','D1')" title="Load Away D1 preset">D1</button>
            <button class="preset-btn" onclick="loadPreset('away','D2')" title="Load Away D2 preset">D2</button>
            <span style="color:var(--muted);font-size:7px;">Away</span>
          </div>
        </div>
      </div>
      <div class="panel-body">
        <!-- Home Team -->
        <div class="team-sec">
          <div class="team-hdr">
            <h4><img id="homeLogoImg" src="" alt="" style="height:20px;width:auto;margin-right:4px;display:none;vertical-align:middle;" onerror="this.style.display='none'" onload="this.style.display='inline'"><span class="team-dot" id="homeDot" style="background:var(--home)"></span><span id="homeLbl">Home</span></h4>
            <button class="btn-sm" onclick="clearSlots('home')" title="Clear all home team slots">Clear</button>
          </div>
          <div class="slots"><span class="slot-lbl">F</span><div class="slot-row" id="homeF"></div></div>
          <div class="slots"><span class="slot-lbl">D</span><div class="slot-row" id="homeD"></div></div>
          <div class="slots"><span class="slot-lbl">G</span><div class="slot-row" id="homeG"></div></div>
          <div class="roster" id="homeRoster"></div>
        </div>
        <!-- Away Team -->
        <div class="team-sec">
          <div class="team-hdr">
            <h4><img id="awayLogoImg" src="" alt="" style="height:20px;width:auto;margin-right:4px;display:none;vertical-align:middle;" onerror="this.style.display='none'" onload="this.style.display='inline'"><span class="team-dot" id="awayDot" style="background:var(--away)"></span><span id="awayLbl">Away</span></h4>
            <button class="btn-sm" onclick="clearSlots('away')" title="Clear all away team slots">Clear</button>
          </div>
          <div class="slots"><span class="slot-lbl">F</span><div class="slot-row" id="awayF"></div></div>
          <div class="slots"><span class="slot-lbl">D</span><div class="slot-row" id="awayD"></div></div>
          <div class="slots"><span class="slot-lbl">G</span><div class="slot-row" id="awayG"></div></div>
          <div class="roster" id="awayRoster"></div>
        </div>
        <!-- Shift Times -->
        <div class="shift-times">
          <div class="form-group"><label>Start Type</label><select id="shiftStartType"></select></div>
          <div class="form-group"><label>Stop Type</label><select id="shiftStopType"></select></div>
          <div class="form-group"><label>Start</label><input type="text" id="shiftStart" value="18:00" oninput="autoFormatTime(this)"></div>
          <div class="form-group"><label>End</label><input type="text" id="shiftEnd" value="" oninput="autoFormatTime(this)"></div>
        </div>
        <div class="shift-actions">
          <button class="btn-success" onclick="logShift()" title="Log current shift (L key)">Log Shift <kbd>L</kbd></button>
        </div>
        <!-- Shift Log -->
        <div class="log-container" style="margin-top:8px;">
          <div class="panel-header" style="font-size:8px;display:flex;justify-content:space-between;">
            <span>Shift Log</span>
            <span>
              <button class="btn-sm" onclick="addNewShift()" title="Add New Shift" style="background:var(--success);">‚ûï</button>
              <button class="clear-all-btn" onclick="clearAllShifts()" title="Clear All Shifts">üóëÔ∏è All</button>
              <button class="btn-sm" onclick="showAllShifts()" title="View all shifts in modal">View All</button>
            </span>
          </div>
          <!-- v6: Period filter tabs -->
          <div class="period-filter-tabs">
            <button class="period-filter-tab active" data-filter="all" onclick="filterShiftLog('all')" title="Show all shifts">ALL</button>
            <button class="period-filter-tab" data-filter="1" onclick="filterShiftLog('1')" title="Show Period 1 shifts">P1</button>
            <button class="period-filter-tab" data-filter="2" onclick="filterShiftLog('2')" title="Show Period 2 shifts">P2</button>
            <button class="period-filter-tab" data-filter="3" onclick="filterShiftLog('3')" title="Show Period 3 shifts">P3</button>
            <button class="period-filter-tab" data-filter="OT" onclick="filterShiftLog('OT')" title="Show Overtime shifts">OT</button>
          </div>
          <div class="log-header" style="grid-template-columns: 25px 25px 40px 40px 60px;">
            <span>#</span><span>P</span><span>Start</span><span>End</span><span>Type</span>
          </div>
          <!-- v23.8: Player search for shift log -->
          <div style="padding:4px 8px;background:var(--card);border-bottom:1px solid var(--border);">
            <input type="text" id="shiftLogPlayerSearch" placeholder="üîç Search by player # or name..." style="width:100%;font-size:9px;padding:4px 8px;border:1px solid var(--border);border-radius:4px;background:var(--bg);color:var(--text);" oninput="filterShiftLogByPlayer(this.value)" title="Search shifts by player jersey number or name (searches all shift players)">
          </div>
          <div id="shiftLogBody" style="max-height:200px;overflow-y:auto;"></div>
        </div>
        <!-- v23.8: Box Score Button - moved to header for visibility -->
        <div style="margin-top:8px;padding:6px;background:var(--accent);border-radius:4px;">
          <button class="btn-sm" onclick="showFullBoxScore()" style="width:100%;font-weight:bold;background:#fff;color:var(--accent);font-size:11px;padding:6px;" title="Show full box score with all player stats">üìä FULL BOX SCORE</button>
        </div>
        <!-- Player Box Score -->
        <div class="box-score" style="margin-top:8px;background:var(--card);border-radius:4px;padding:6px;">
          <div style="font-size:8px;color:var(--muted);margin-bottom:4px;">
            <span>PLAYER STATS</span>
          </div>
          <div id="playerBoxScore" style="max-height:120px;overflow-y:auto;">
            <table style="width:100%;font-size:8px;border-collapse:collapse;">
              <thead>
                <tr style="color:var(--muted);">
                  <td>#</td><td>Name</td><td>G</td><td>A</td><td>SOG</td><td>TOI</td>
                </tr>
              </thead>
              <tbody id="playerBoxBody"></tbody>
            </table>
          </div>
        </div>
        <!-- Team Summary -->
        <div class="team-summary" style="margin-top:4px;background:var(--card);border-radius:4px;padding:4px;font-size:8px;">
          <div style="display:flex;justify-content:space-between;">
            <span><span id="teamSumHome">HOME</span>: <strong id="teamSumHomeScore">0</strong></span>
            <span><span id="teamSumAway">AWAY</span>: <strong id="teamSumAwayScore">0</strong></span>
          </div>
          <div style="display:flex;justify-content:space-between;color:var(--muted);margin-top:2px;">
            <span>SOG: <span id="teamSumHomeSOG">0</span></span>
            <span>SOG: <span id="teamSumAwaySOG">0</span></span>
          </div>
        </div>
      </div>
    </div>

    <!-- Center: Rink -->
    <div class="center">
      <!-- v15.01: VIDEO PLAYER SECTION -->
      <div class="video-section" id="videoSection" style="display:none;">
        <div class="video-header" style="display:flex;justify-content:space-between;align-items:center;padding:4px 8px;background:var(--card);border-bottom:1px solid var(--border);">
          <div style="display:flex;align-items:center;gap:8px;">
            <span style="font-size:10px;font-weight:600;color:var(--accent);">üé¨ VIDEO</span>
            <select id="videoSourceSelect" onchange="switchVideoSource()" style="font-size:9px;width:120px;">
              <option value="">-- Sources --</option>
            </select>
            <button class="btn-sm" onclick="showAddVideoModal()" title="Add Video Source">+</button>
            <input type="file" id="videoFileInput" accept="video/*" style="display:none;" onchange="loadVideoFromFile(event)">
            <button class="btn-sm" onclick="document.getElementById('videoFileInput').click()" title="Load local file">üìÅ</button>
            <button class="btn-sm" onclick="showVideoSourcesManager()" title="Manage video sources">‚öôÔ∏è</button>
          </div>
          <div style="display:flex;align-items:center;gap:4px;">
            <!-- Video source hotkey buttons -->
            <div id="videoHotkeyBar" style="display:flex;gap:2px;margin-right:8px;"></div>
            <span id="videoTimeDisplay" style="font-size:12px;font-family:monospace;color:var(--accent);background:var(--bg);padding:2px 6px;border-radius:3px;">00:00:00</span>
            <span style="color:var(--muted);font-size:8px;">‚Üí</span>
            <span id="gameTimeFromVideo" style="font-size:10px;font-family:monospace;color:var(--warn);">P1 20:00</span>
            <button class="btn-sm" onclick="toggleVideoSection()" title="Minimize">‚ñº</button>
          </div>
        </div>
        <div id="videoPlayerContainer" style="position:relative;width:100%;height:200px;background:#000;overflow:hidden;">
          <!-- YouTube or HTML5 video will be inserted here -->
          <div id="videoPlaceholder" style="display:flex;align-items:center;justify-content:center;height:100%;color:var(--muted);font-size:11px;">
            No video loaded. Click + or üìÅ to add a video.
          </div>
          <div id="youtubePlayer" style="display:none;width:100%;height:100%;"></div>
          <video id="localVideoPlayer" style="display:none;width:100%;height:100%;" controls></video>
        </div>
        <!-- Video Scrub Bar -->
        <div id="videoScrubBar" style="padding:2px 8px;background:var(--card);"></div>
        <div class="video-controls" style="display:flex;gap:4px;padding:4px 8px;background:var(--card);border-top:1px solid var(--border);align-items:center;flex-wrap:wrap;">
          <!-- Playback controls -->
          <button class="btn-sm" onclick="videoSeek(-10)" title="Back 10s (Shift+‚Üê)">‚è™10</button>
          <button class="btn-sm" onclick="videoSeek(-1)" title="Back 1s (‚Üê)">‚óÄ1</button>
          <button class="btn-sm" onclick="videoFrameStep(-1)" title="Back 1 frame">|‚óÄ</button>
          <button class="btn-sm btn-primary" onclick="videoPlayPause()" id="videoPlayBtn" title="Play/Pause (Space)">‚ñ∂</button>
          <button class="btn-sm" onclick="videoFrameStep(1)" title="Forward 1 frame">‚ñ∂|</button>
          <button class="btn-sm" onclick="videoSeek(1)" title="Forward 1s">1‚ñ∂</button>
          <button class="btn-sm" onclick="videoSeek(10)" title="Forward 10s">10‚è©</button>
          
          <span style="color:var(--border);">|</span>
          
          <!-- Speed controls -->
          <span style="font-size:8px;color:var(--muted);">Speed:</span>
          <button class="btn-sm speed-btn" onclick="setVideoSpeed(0.25)" data-speed="0.25" title="Set video speed: 0.25x">0.25x</button>
          <button class="btn-sm speed-btn" onclick="setVideoSpeed(0.5)" data-speed="0.5" title="Set video speed: 0.5x">0.5x</button>
          <button class="btn-sm speed-btn active" onclick="setVideoSpeed(1)" data-speed="1" title="Set video speed: 1x (normal)">1x</button>
          <button class="btn-sm speed-btn" onclick="setVideoSpeed(1.5)" data-speed="1.5" title="Set video speed: 1.5x">1.5x</button>
          <button class="btn-sm speed-btn" onclick="setVideoSpeed(2)" data-speed="2" title="Set video speed: 2x">2x</button>
          
          <span style="color:var(--border);">|</span>
          
          <!-- Time sync controls -->
          <label style="font-size:8px;color:var(--muted);display:flex;align-items:center;gap:2px;">
            <input type="checkbox" id="videoAutoSync" checked onchange="toggleVideoAutoSync()"> Auto-sync times
          </label>
          <button class="btn-sm" onclick="captureStartTime()" title="Set event/shift START to current video time">üìç Start</button>
          <button class="btn-sm" onclick="captureEndTime()" title="Set event/shift END to current video time">üìç End</button>
          
          <span style="color:var(--border);">|</span>
          
          <!-- Zoom controls -->
          <span style="font-size:8px;color:var(--muted);">Zoom:</span>
          <button class="btn-sm" onclick="videoZoomOut()" title="Zoom out (-)">‚àí</button>
          <button class="btn-sm" onclick="videoZoomReset()" title="Reset zoom (0)">1:1</button>
          <button class="btn-sm" onclick="videoZoomIn()" title="Zoom in (+)">+</button>
          
          <span style="color:var(--border);">|</span>
          
          <!-- Hotkeys -->
          <span style="font-size:7px;color:var(--muted);">Keys: <kbd>Space</kbd>=play <kbd>‚Üê‚Üí</kbd>=¬±1s <kbd>‚áß‚Üê‚Üí</kbd>=¬±10s <kbd>;'</kbd>=frame <kbd>+-</kbd>=zoom</span>
        </div>
        <!-- Game Markers -->
        <div class="video-markers" style="display:flex;gap:4px;padding:4px 8px;background:var(--panel);border-top:1px solid var(--border);align-items:center;">
          <span style="font-size:8px;color:var(--muted);">Game Markers:</span>
          <button class="btn-sm" onclick="setGameMarker('P1Start')" title="Mark P1 puck drop">P1üèí</button>
          <button class="btn-sm" onclick="setGameMarker('P1End')" title="Mark P1 end">P1üõë</button>
          <button class="btn-sm" onclick="setGameMarker('P2Start')" title="Mark P2 puck drop">P2üèí</button>
          <button class="btn-sm" onclick="setGameMarker('P2End')" title="Mark P2 end">P2üõë</button>
          <button class="btn-sm" onclick="setGameMarker('P3Start')" title="Mark P3 puck drop">P3üèí</button>
          <button class="btn-sm" onclick="setGameMarker('P3End')" title="Mark P3 end">P3üõë</button>
          <button class="btn-sm" onclick="setGameMarker('OTStart')" title="Mark OT puck drop">OTüèí</button>
          <button class="btn-sm" onclick="addStoppageMarker()" title="Add stoppage (timeout, injury, etc)">‚è∏Ô∏è+</button>
          <span style="margin-left:auto;font-size:8px;color:var(--muted);" id="markerStatus">No markers set</span>
        </div>
      </div>
      <!-- Video Toggle Bar (shown when minimized) -->
      <div class="video-toggle-bar" id="videoToggleBar" style="display:flex;justify-content:space-between;align-items:center;padding:2px 8px;background:var(--card);border-bottom:1px solid var(--border);cursor:pointer;" onclick="toggleVideoSection()">
        <span style="font-size:9px;color:var(--accent);">üé¨ VIDEO</span>
        <span id="videoMiniTime" style="font-size:10px;font-family:monospace;color:var(--muted);">--:--:--</span>
        <span style="font-size:8px;color:var(--muted);">‚ñ≤ Expand</span>
      </div>
      
      <div class="rink-wrap">
        <div class="mode-ind puck" id="modeInd">üèí PUCK</div>
        <div class="xy-tooltip" id="xyTooltip" style="display:none;"></div>
        <svg id="rinkSvg" viewBox="0 0 200 85">
          <defs>
            <linearGradient id="iceGrad" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" style="stop-color:#f0f9ff;stop-opacity:1"/>
              <stop offset="50%" style="stop-color:#e0f2fe;stop-opacity:1"/>
              <stop offset="100%" style="stop-color:#f0f9ff;stop-opacity:1"/>
            </linearGradient>
            <pattern id="iceTexture" patternUnits="userSpaceOnUse" width="4" height="4">
              <rect width="4" height="4" fill="#e0f2fe" opacity="0.3"/>
              <circle cx="1" cy="1" r="0.3" fill="#fff" opacity="0.4"/>
            </pattern>
          </defs>
          
          <!-- Ice surface -->
          <rect x="0" y="0" width="200" height="85" fill="url(#iceGrad)" rx="14" ry="14"/>
          <rect x="0" y="0" width="200" height="85" fill="url(#iceTexture)" rx="14" ry="14"/>
          <!-- Boards -->
          <rect x="0" y="0" width="200" height="85" fill="none" rx="14" ry="14" stroke="#1f2937" stroke-width="2"/>
          
          <!-- Blue lines -->
          <rect x="74" y="0" width="2" height="85" fill="#1e40af"/>
          <rect x="124" y="0" width="2" height="85" fill="#1e40af"/>
          
          <!-- Red center line (dashed) -->
          <line x1="100" y1="0" x2="100" y2="85" stroke="#dc2626" stroke-width="1.5" stroke-dasharray="4,2"/>
          
          <!-- Goal lines -->
          <line x1="11" y1="0" x2="11" y2="85" stroke="#dc2626" stroke-width="1"/>
          <line x1="189" y1="0" x2="189" y2="85" stroke="#dc2626" stroke-width="1"/>
          
          <!-- Center ice logo -->
          <circle cx="100" cy="42.5" r="10" fill="rgba(30,58,138,0.08)" stroke="none"/>
          <image href="https://www.noradhockey.com/wp-content/uploads/2022/05/New-NORAD-Logo-White.png" x="88" y="31" width="24" height="23" preserveAspectRatio="xMidYMid meet"/>
          
          <!-- Center circle -->
          <circle cx="100" cy="42.5" r="15" fill="none" stroke="#1e40af" stroke-width="1"/>
          <circle cx="100" cy="42.5" r="1" fill="#1e40af"/>
          
          <!-- Left zone circles -->
          <circle cx="31" cy="22" r="15" fill="none" stroke="#dc2626" stroke-width="0.8"/>
          <circle cx="31" cy="22" r="1" fill="#dc2626"/>
          <circle cx="31" cy="63" r="15" fill="none" stroke="#dc2626" stroke-width="0.8"/>
          <circle cx="31" cy="63" r="1" fill="#dc2626"/>
          
          <!-- Right zone circles -->
          <circle cx="169" cy="22" r="15" fill="none" stroke="#dc2626" stroke-width="0.8"/>
          <circle cx="169" cy="22" r="1" fill="#dc2626"/>
          <circle cx="169" cy="63" r="15" fill="none" stroke="#dc2626" stroke-width="0.8"/>
          <circle cx="169" cy="63" r="1" fill="#dc2626"/>
          
          <!-- Neutral zone dots -->
          <circle cx="80" cy="22" r="1" fill="#dc2626"/>
          <circle cx="80" cy="63" r="1" fill="#dc2626"/>
          <circle cx="120" cy="22" r="1" fill="#dc2626"/>
          <circle cx="120" cy="63" r="1" fill="#dc2626"/>
          
          <!-- Creases - NHL standard: 8ft wide, 4.5ft deep (scaled: 4 wide, 2.25 deep) -->
          <path d="M 11 38.5 L 15 38.5 A 4 4 0 0 1 15 46.5 L 11 46.5 Z" fill="rgba(59,130,246,0.25)" stroke="#3b82f6" stroke-width="0.8"/>
          <path d="M 189 38.5 L 185 38.5 A 4 4 0 0 0 185 46.5 L 189 46.5 Z" fill="rgba(59,130,246,0.25)" stroke="#3b82f6" stroke-width="0.8"/>
          
          <!-- Left goal -->
          <rect x="7" y="39" width="4" height="7" fill="#111827" stroke="#f8fafc" stroke-width="0.5"/>
          <line x1="7" y1="40" x2="10" y2="42.5" stroke="#374151" stroke-width="0.3"/>
          <line x1="7" y1="45" x2="10" y2="42.5" stroke="#374151" stroke-width="0.3"/>
          
          <!-- Right goal -->
          <rect x="189" y="39" width="4" height="7" fill="#111827" stroke="#f8fafc" stroke-width="0.5"/>
          <line x1="193" y1="40" x2="190" y2="42.5" stroke="#374151" stroke-width="0.3"/>
          <line x1="193" y1="45" x2="190" y2="42.5" stroke="#374151" stroke-width="0.3"/>
          
          <!-- Trapezoids -->
          <path d="M 0 28 L 11 34 L 11 51 L 0 57" fill="none" stroke="#dc2626" stroke-width="0.5"/>
          <path d="M 200 28 L 189 34 L 189 51 L 200 57" fill="none" stroke="#dc2626" stroke-width="0.5"/>
          
          <!-- Zone labels -->
          <text x="43" y="81" font-size="3.5" fill="#64748b" text-anchor="middle" id="leftZoneLbl">AWAY OFF</text>
          <text x="100" y="81" font-size="3.5" fill="#64748b" text-anchor="middle">NEUTRAL</text>
          <text x="157" y="81" font-size="3.5" fill="#64748b" text-anchor="middle" id="rightZoneLbl">HOME OFF</text>
          
          <!-- Markers -->
          <g id="markers"></g>
        </svg>
      </div>
      <div class="xy-controls">
        <button class="xy-btn active" id="puckModeBtn" onclick="setXYMode('puck')" title="Place puck position (multiple clicks = trajectory)">üèí Puck</button>
        <button class="xy-btn" id="playerModeBtn" onclick="setXYMode('player')" title="Place player positions">üë§ Player</button>
        <select class="xy-player-sel" id="xyPlayerSel" onchange="selectXYPlayer(this.value)" title="Select player to place XY"></select>
        <span style="color:var(--muted);font-size:8px;margin-left:4px;">Slot:</span>
        <div class="xy-slots" id="xySlots"></div>
        <span id="xySlotIndicator" style="font-size:9px;color:var(--accent);margin-left:2px;">‚Üí auto-advance</span>
        <button class="btn-sm" onclick="undoLastXY()" title="Undo last XY placement (Ctrl+Z)">‚Ü©</button>
        <button class="btn-sm btn-danger" onclick="clearCurrentXY()" title="Clear current item XY">‚úï</button>
        <button class="btn-sm" onclick="clearRink()" title="Clear all markers from rink">üóë</button>
        <span style="margin-left:4px;font-size:8px;color:var(--muted);">Hist:</span>
        <input type="number" id="xyHistCnt" value="5" min="0" max="20" style="width:30px;font-size:9px;" onchange="renderMarkers()" title="Past events to show">
      </div>
      <!-- v23.4: Timeline Scrub -->
      <div id="timelineScrub" style="display:flex;gap:2px;margin:4px 0;padding:4px;background:var(--panel);border-radius:4px;overflow-x:auto;max-width:100%;">
        <span style="font-size:8px;color:var(--muted);white-space:nowrap;">Timeline:</span>
        <div id="timelineEvents" style="display:flex;gap:1px;flex:1;"></div>
      </div>
      <!-- Event List -->
      <div class="evt-list" id="eventLogSection">
        <div class="evt-header" style="display:flex;justify-content:space-between;align-items:center;">
          <!-- v20.4: Header columns now match expanded body columns -->
          <span style="display:flex;align-items:center;gap:4px;">
            <button class="btn-sm" onclick="showFullBoxScore()" title="Full Box Score" style="background:var(--accent);color:#fff;font-weight:bold;padding:4px 8px;">üìä Box</button>
            <button class="btn-sm" onclick="toggleEventLog()" title="Toggle Event Log">üìù</button>
            <span id="evtLogHeader" style="display:grid;grid-template-columns:30px 22px 22px 20px 48px 48px 14px 46px 30px 58px 58px 14px 12px 30px 30px 46px 46px 12px 12px 12px;gap:1px;flex:1;font-size:6px;">
              <span>‚Üï</span><span>#</span><span>Sh</span><span>Lnk</span><span>Time</span><span>Adj</span><span>T</span><span>Type</span><span>PIM</span><span>Detail1</span><span>Detail2</span><span>Z</span><span>S</span><span>EvtP</span><span>OppP</span><span>PD1</span><span>PD2</span><span>PS</span><span>XY</span><span>‚≠ê</span>
            </span>
          </span>
          <span>
            <button class="btn-sm" onclick="addNewEvent()" title="Add New Event" style="background:var(--success);">‚ûï</button>
            <button class="clear-all-btn" onclick="clearAllEvents()" title="Clear All Events">üóëÔ∏è All</button>
            <button class="btn-sm" onclick="showAllEvents()" style="margin-left:4px;" title="Show all events in modal">All</button>
          </span>
        </div>
        <!-- v6: Period filter tabs for events -->
        <div class="period-filter-tabs">
          <button class="period-filter-tab active" data-filter="all" onclick="filterEventLog('all')" title="Show all periods">ALL</button>
          <button class="period-filter-tab" data-filter="1" onclick="filterEventLog('1')" title="Show Period 1 events">P1</button>
          <button class="period-filter-tab" data-filter="2" onclick="filterEventLog('2')" title="Show Period 2 events">P2</button>
          <button class="period-filter-tab" data-filter="3" onclick="filterEventLog('3')" title="Show Period 3 events">P3</button>
          <button class="period-filter-tab" data-filter="OT" onclick="filterEventLog('OT')" title="Show Overtime events">OT</button>
        </div>
        <!-- v23.8: Player search for event log -->
        <div style="padding:4px 8px;background:var(--card);border-bottom:1px solid var(--border);">
          <input type="text" id="eventLogPlayerSearch" placeholder="üîç Search by player # or name..." style="width:100%;font-size:9px;padding:4px 8px;border:1px solid var(--border);border-radius:4px;background:var(--bg);color:var(--text);" oninput="filterEventLogByPlayer(this.value)" title="Search events by player jersey number or name (searches all event/opp players)">
        </div>
        <!-- v20.4: Advanced filter row -->
        <div class="evt-filter-row" id="evtFilterRow">
          <div class="filter-group">
            <label>Type:</label>
            <select id="filterEvtType" onchange="applyEventFilters()">
              <option value="">All</option>
            </select>
          </div>
          <div class="filter-group">
            <label>Detail1:</label>
            <select id="filterEvtDetail1" onchange="applyEventFilters()">
              <option value="">All</option>
            </select>
          </div>
          <div class="filter-group">
            <label>Detail2:</label>
            <select id="filterEvtDetail2" onchange="applyEventFilters()">
              <option value="">All</option>
            </select>
          </div>
          <div class="filter-group">
            <label>PD1:</label>
            <select id="filterPlayDetail1" onchange="applyEventFilters()">
              <option value="">All</option>
            </select>
          </div>
          <div class="filter-group">
            <label>PD2:</label>
            <select id="filterPlayDetail2" onchange="applyEventFilters()">
              <option value="">All</option>
            </select>
          </div>
          <div class="filter-group">
            <label>Team:</label>
            <select id="filterEvtTeam" onchange="applyEventFilters()">
              <option value="">All</option>
              <option value="home">Home</option>
              <option value="away">Away</option>
            </select>
          </div>
          <div class="filter-group">
            <label>Evt#:</label>
            <input type="number" id="filterEvtIdx" min="1" placeholder="#" onchange="applyEventFilters()">
          </div>
          <div class="filter-group">
            <label>Show X before:</label>
            <input type="number" id="filterEventsBefore" min="0" max="50" placeholder="0" value="0" style="width:50px;" onchange="applyEventFilters()" title="Show X events before the found event">
          </div>
          <div class="filter-group">
            <label>Show X after:</label>
            <input type="number" id="filterEventsAfter" min="0" max="50" placeholder="0" value="0" style="width:50px;" onchange="applyEventFilters()" title="Show X events after the found event">
          </div>
          <div class="filter-group">
            <label>Link#:</label>
            <input type="number" id="filterLinkIdx" min="1" placeholder="#" onchange="applyEventFilters()">
          </div>
          <div class="filter-group">
            <label>Shift#:</label>
            <input type="number" id="filterShiftIdx" min="1" placeholder="#" onchange="applyEventFilters()">
          </div>
          <button class="btn-clear" onclick="clearEventFilters()">Clear</button>
        </div>
        <div id="evtListBody" style="max-height:300px;overflow-y:auto;"></div>
      </div>
      <!-- Next Play Suggestions -->
      <div class="next-play-bar" style="background:var(--card);padding:4px 8px;border-top:1px solid var(--border);">
        <span style="font-size:8px;color:var(--muted);">NEXT:</span>
        <span id="nextPlaySuggestions" style="font-size:9px;"></span>
      </div>
      <!-- v16.02: Box Score moved here - more visible below events -->
      <div class="center-box-score" style="background:var(--card);padding:8px;border-top:2px solid var(--accent);border-bottom:2px solid var(--accent);">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
          <span style="font-size:11px;color:var(--accent);font-weight:bold;">üìä BOX SCORE</span>
          <button class="btn-sm" onclick="showFullBoxScore()" style="font-weight:bold;background:var(--accent);color:#fff;padding:4px 12px;" title="Show full box score with all player stats">Full Box Score</button>
        </div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;font-size:10px;">
          <div style="text-align:center;">
            <span id="centerBoxHome" style="font-weight:bold;color:var(--home);">HOME</span>
            <span style="font-size:20px;font-weight:bold;display:block;" id="centerBoxHomeScore">0</span>
            <span style="font-size:8px;color:var(--muted);">SOG: <span id="centerBoxHomeSOG">0</span></span>
          </div>
          <div style="text-align:center;">
            <span id="centerBoxAway" style="font-weight:bold;color:var(--away);">AWAY</span>
            <span style="font-size:20px;font-weight:bold;display:block;" id="centerBoxAwayScore">0</span>
            <span style="font-size:8px;color:var(--muted);">SOG: <span id="centerBoxAwaySOG">0</span></span>
          </div>
        </div>
      </div>
    </div>

    <!-- Right: Event Entry -->
    <div class="panel" id="rightPanel">
      <div class="resize-handle right" style="left:0;right:auto;" onmousedown="startResize(event, 'right')"></div>
      <div class="panel-header"><span>Event Entry</span><span id="zoneDisplay"></span></div>
      <div class="panel-body">
        <!-- Team Toggle -->
        <div class="team-toggle">
          <button class="home active" id="evtHomeLbl" onclick="setEvtTeam('home')" title="Set event team to Home">Home</button>
          <button class="swap-btn" onclick="swapEvtTeam()" title="Swap Event/Opp Teams">‚áÑ</button>
          <button class="away" id="evtAwayLbl" onclick="setEvtTeam('away')" title="Set event team to Away">Away</button>
        </div>
        <!-- Event Types -->
        <div class="evt-grid" id="evtTypeGrid"></div>
        <!-- Quick Faceoff (v23.3) - Collapsible -->
        <div class="collapsible-section">
          <div class="collapsible-header" onclick="toggleCollapsible('quickFaceoffRow')">
            <span style="font-size:8px;color:var(--muted);">FO:</span>
            <span class="collapsible-icon" id="quickFaceoffRowIcon">‚ñ∂</span>
          </div>
          <div id="quickFaceoffRow" class="collapsible-content" style="display:none;gap:4px;margin:4px 0;padding:4px;background:var(--panel);border-radius:4px;">
            <button class="btn-sm" onclick="quickFaceoff('o','evt')" title="Offensive zone, Won" style="flex:1;font-size:9px;">O-Win</button>
            <button class="btn-sm" onclick="quickFaceoff('o','opp')" title="Offensive zone, Lost" style="flex:1;font-size:9px;">O-Loss</button>
            <button class="btn-sm" onclick="quickFaceoff('n','evt')" title="Neutral zone, Won" style="flex:1;font-size:9px;">N-Win</button>
            <button class="btn-sm" onclick="quickFaceoff('n','opp')" title="Neutral zone, Lost" style="flex:1;font-size:9px;">N-Loss</button>
            <button class="btn-sm" onclick="quickFaceoff('d','evt')" title="Defensive zone, Won" style="flex:1;font-size:9px;">D-Win</button>
            <button class="btn-sm" onclick="quickFaceoff('d','opp')" title="Defensive zone, Lost" style="flex:1;font-size:9px;">D-Loss</button>
          </div>
        </div>
        <!-- Quick Stoppage (v23.4) - Collapsible -->
        <div class="collapsible-section">
          <div class="collapsible-header" onclick="toggleCollapsible('quickStoppageRow')">
            <span style="font-size:8px;color:var(--muted);">STOP:</span>
            <span class="collapsible-icon" id="quickStoppageRowIcon">‚ñ∂</span>
          </div>
          <div id="quickStoppageRow" class="collapsible-content" style="display:none;gap:4px;margin:4px 0;padding:4px;background:var(--panel);border-radius:4px;">
            <button class="btn-sm" onclick="quickStoppage('Icing')" title="Icing" style="flex:1;font-size:9px;">üßä Icing</button>
            <button class="btn-sm" onclick="quickStoppage('Offside')" title="Offside" style="flex:1;font-size:9px;">üö´ Offside</button>
            <button class="btn-sm" onclick="quickStoppage('PuckOutOfPlay')" title="Puck out of play" style="flex:1;font-size:9px;">üèí Out</button>
            <button class="btn-sm" onclick="quickStoppage('Timeout')" title="Timeout" style="flex:1;font-size:9px;">‚è∏Ô∏è T/O</button>
            <button class="btn-sm" onclick="quickStoppage('GoalieFreeze')" title="Goalie freeze" style="flex:1;font-size:9px;">ü•Ö Freeze</button>
          </div>
        </div>
        <!-- Quick Penalty (v23.3) - Collapsible -->
        <div class="collapsible-section">
          <div class="collapsible-header" onclick="toggleCollapsible('quickPenaltyRow')">
            <span style="font-size:8px;color:var(--muted);">PEN:</span>
            <span class="collapsible-icon" id="quickPenaltyRowIcon">‚ñ∂</span>
          </div>
          <div id="quickPenaltyRow" class="collapsible-content" style="display:none;gap:4px;margin:4px 0;padding:4px;background:var(--panel);border-radius:4px;">
            <select id="quickPenPlayer" style="flex:2;font-size:9px;"><option value="">Player #</option></select>
            <select id="quickPenType" style="flex:2;font-size:9px;">
              <option value="">Type</option>
              <option value="Penalty_Tripping">Tripping</option>
              <option value="Penalty_Hooking">Hooking</option>
              <option value="Penalty_Slashing">Slashing</option>
              <option value="Penalty_Holding">Holding</option>
              <option value="Penalty_Interference">Interference</option>
              <option value="Penalty_HighSticking">High Stick</option>
              <option value="Penalty_Roughing">Roughing</option>
              <option value="Penalty_CrossChecking">Cross-Check</option>
              <option value="Penalty_Boarding">Boarding</option>
              <option value="Penalty_Other">Other</option>
            </select>
            <button class="btn-sm" onclick="quickPenalty()" title="Log penalty" style="background:var(--danger);color:#fff;">+Pen</button>
          </div>
        </div>
        <!-- Power Play Timer (v23.4) -->
        <div id="ppTimerRow" style="display:none;gap:4px;margin:4px 0;padding:6px 8px;background:linear-gradient(90deg,var(--home),var(--away));border-radius:4px;color:#fff;font-weight:bold;align-items:center;">
          <span id="ppTimerTeam" style="font-size:10px;">PP:</span>
          <span id="ppTimerDisplay" style="font-size:14px;margin-left:8px;">3:00</span>
          <input type="number" id="ppMinutes" value="3" min="1" max="5" style="width:35px;margin-left:8px;font-size:10px;" title="Penalty minutes" onchange="updatePPMinutes()">
          <span style="font-size:8px;">min</span>
          <button class="btn-sm" onclick="endPowerPlay()" style="margin-left:auto;background:#fff;color:#000;font-size:9px;" title="End power play timer">End PP</button>
        </div>
        <!-- Quick Modes (v23.3) -->
        <div style="display:flex;gap:4px;margin:4px 0;">
          <button class="btn-sm" id="shotChartModeBtn" onclick="toggleShotChartMode()" title="Shot Chart Mode: Enable to quickly log shots by clicking on the rink. Automatically sets event type to Shot and creates shot events at click locations. Great for rapid shot tracking during fast-paced sequences." style="flex:1;font-size:9px;">üéØ Shot Mode</button>
          <button class="btn-sm" id="possessionModeBtn" onclick="togglePossessionMode()" title="Possession Mode: Track continuous possession chains. Automatically links events together and sets event type to Possession. Enables sequence mode to track the full possession sequence from start to finish." style="flex:1;font-size:9px;">üèí Poss Mode</button>
          <button class="btn-sm" onclick="undoLastEvent()" title="Undo last event (Ctrl+Shift+Z)" style="flex:1;font-size:9px;background:var(--warning);color:#000;">‚Ü©Ô∏è Undo</button>
          <button class="btn-sm" onclick="manualReindexEvents()" title="Re-sort events by time" style="flex:1;font-size:9px;">üî¢ Reindex</button>
        </div>
        <!-- Event Templates (v23.4) - Collapsible -->
        <div class="collapsible-section">
          <div class="collapsible-header" onclick="toggleCollapsible('eventTemplatesRow')">
            <span style="font-size:8px;color:var(--muted);">TEMPLATES:</span>
            <span class="collapsible-icon" id="eventTemplatesRowIcon">‚ñ∂</span>
          </div>
          <div id="eventTemplatesRow" class="collapsible-content" style="display:none;gap:4px;margin:4px 0;">
            <select id="eventTemplates" style="flex:1;font-size:9px;">
              <option value="">üìã Templates...</option>
              <option value="dumpAndChase">Dump & Chase</option>
              <option value="cyclePlay">Cycle Play</option>
              <option value="breakout">Breakout</option>
              <option value="forecheck">Forecheck</option>
              <option value="oddManRush">Odd-Man Rush</option>
            </select>
            <button class="btn-sm" onclick="applyTemplate()" title="Apply selected template" style="font-size:9px;">Apply</button>
            <button class="btn-sm" onclick="saveAsChainPreset()" title="Save current event as chain preset" style="font-size:9px;">üíæ Save</button>
          </div>
        </div>
        <!-- Validation Row (v23.4) -->
        <div style="display:flex;gap:4px;margin:4px 0;">
          <button class="btn-sm" onclick="validateAgainstGameData()" title="Validate vs fact_gameroster & dim_schedule" style="flex:1;font-size:9px;">üîç Validate</button>
        </div>
        <!-- Quick Chains (v23.4) - Multi-event sequences -->
        <div style="display:flex;gap:2px;margin:4px 0;flex-wrap:wrap;">
          <span style="font-size:8px;color:var(--muted);align-self:center;">Chains:</span>
          <button class="btn-sm" onclick="startQuickChain('controlledEntry')" title="Zone Entry ‚Üí Possession" style="font-size:8px;">Entry</button>
          <button class="btn-sm" onclick="startQuickChain('dumpIn')" title="Dump ‚Üí Forecheck" style="font-size:8px;">Dump</button>
          <button class="btn-sm" onclick="startQuickChain('shotSequence')" title="Shot ‚Üí Save ‚Üí Rebound" style="font-size:8px;">Shot+</button>
          <button class="btn-sm" onclick="startQuickChain('breakout')" title="Breakout ‚Üí Pass ‚Üí Exit" style="font-size:8px;">Break</button>
          <button class="btn-sm" onclick="startQuickChain('ppCycle')" title="PP Cycle ‚Üí Pass ‚Üí Shot" style="font-size:8px;">PP</button>
        </div>
        <!-- v23.5: Quick Queue - log time only, fill details later -->
        <div style="display:flex;gap:2px;margin:4px 0;flex-wrap:wrap;">
          <span style="font-size:8px;color:var(--warn);align-self:center;" title="Quick mark events, fill details later">Queue:</span>
          <button class="btn-sm" onclick="quickQueueEvent('Shot')" style="font-size:8px;background:var(--warn);color:#000;" title="Quick queue: Shot">Sh</button>
          <button class="btn-sm" onclick="quickQueueEvent('Pass')" style="font-size:8px;background:var(--warn);color:#000;" title="Quick queue: Pass">Pa</button>
          <button class="btn-sm" onclick="quickQueueEvent('Turnover')" style="font-size:8px;background:var(--warn);color:#000;" title="Quick queue: Turnover">TO</button>
          <button class="btn-sm" onclick="quickQueueEvent('Hit')" style="font-size:8px;background:var(--warn);color:#000;" title="Quick queue: Hit">Hi</button>
          <button class="btn-sm" onclick="quickQueueEvent('Zone_Entry_Exit')" style="font-size:8px;background:var(--warn);color:#000;" title="Quick queue: Zone Entry/Exit">ZE</button>
          <button class="btn-sm" onclick="clearEventQueue()" style="font-size:8px;" title="Clear queue">‚úï</button>
        </div>
        <!-- Event Details -->
        <div class="form-row">
          <div class="form-group"><label>Detail 1</label><select id="evtD1" onchange="onD1Change()"></select></div>
          <div class="form-group"><label>Detail 2</label><select id="evtD2"></select></div>
        </div>
        <!-- Quick Detail Buttons (v23.4) - changes based on event type -->
        <div id="quickDetailRow" style="display:flex;gap:2px;margin:4px 0;flex-wrap:wrap;"></div>
        <!-- Hidden selects for compatibility -->
        <select id="evtZone" style="display:none;"><option value="">--</option><option value="o">Offensive</option><option value="d">Defensive</option><option value="n">Neutral</option></select>
        <select id="evtSuccess" style="display:none;"><option value="">--</option><option value="s">Success</option><option value="u">Unsuccess</option></select>
        <div class="form-row tri">
          <div class="form-group">
            <label>Zone</label>
            <div style="display:flex;gap:2px;">
              <button class="btn-sm zone-btn" onclick="setZone('o')" data-zone="o" title="Offensive" style="flex:1;font-size:9px;">O</button>
              <button class="btn-sm zone-btn" onclick="setZone('n')" data-zone="n" title="Neutral" style="flex:1;font-size:9px;">N</button>
              <button class="btn-sm zone-btn" onclick="setZone('d')" data-zone="d" title="Defensive" style="flex:1;font-size:9px;">D</button>
            </div>
          </div>
          <div class="form-group">
            <label>Success</label>
            <div style="display:flex;gap:2px;">
              <button class="btn-sm success-btn" onclick="setSuccess('s')" data-success="s" title="Success" style="flex:1;font-size:9px;background:var(--success);color:#fff;">‚úì</button>
              <button class="btn-sm success-btn" onclick="setSuccess('u')" data-success="u" title="Unsuccess" style="flex:1;font-size:9px;background:var(--danger);color:#fff;">‚úó</button>
            </div>
          </div>
          <div class="form-group">
            <label>Strength <button class="btn-sm" onclick="autoStrength()" title="Auto-detect from slots">‚ö°</button></label>
            <select id="evtStrength"><option value="5v5">5v5</option><option value="5v4">5v4 PP</option><option value="4v5">4v5 PK</option><option value="4v4">4v4</option><option value="3v3">3v3</option><option value="ENG">ENG</option><option value="ENA">ENA</option></select>
          </div>
        </div>
        <div class="form-row">
          <div class="form-group"><label>Start Time</label><input type="text" id="evtStartTime" placeholder="MM:SS" oninput="autoFormatTime(this); onStartTimeChange()"></div>
          <div class="form-group"><label>End Time</label><input type="text" id="evtEndTime" placeholder="MM:SS (auto)" oninput="autoFormatTime(this)"></div>
        </div>
        <!-- Event Players -->
        <div class="section">
          <div class="section-title" style="display:flex;justify-content:space-between;align-items:center;">
            <span>Event Players (on puck)</span>
            <div style="display:flex;gap:2px;">
              <button class="btn-sm" onclick="addAllOnIce()" title="Add all on-ice players">+All</button>
              <button class="btn-sm" onclick="copyPlayersFromLast()" title="Copy players from last event">üìã</button>
              <button class="btn-sm" onclick="placeAllHere()" title="Place ALL players at last puck XY" style="background:var(--accent);color:#000;">üìç All Here</button>
              <button class="btn-sm" id="seqModeBtn" onclick="toggleSequenceMode()" title="Sequence Mode: Automatically links consecutive events together. When enabled, each new event links to the previous one, creating a play sequence. Useful for tracking multi-event plays like passes leading to shots, or zone entries leading to possession.">üîó</button>
            </div>
          </div>
          <div class="player-list" id="evtPlayers" ondragover="handleListDragOver(event)" ondragleave="handleListDragLeave(event)" ondrop="handleListDrop(event, 'evt')" style="max-height:150px;overflow-y:auto;"></div>
          <div class="quick-add" id="evtQuickAdd"></div>
          <!-- Jersey number input -->
          <div style="display:flex;gap:4px;margin-top:4px;">
            <input type="text" id="jerseyNumInput" placeholder="Jersey #" style="width:60px;font-size:10px;" onkeypress="if(event.key==='Enter'){quickAddByNumber(parseInt(this.value));this.value='';return false;}">
            <button class="btn-sm" onclick="quickAddByNumber(parseInt(document.getElementById('jerseyNumInput').value));document.getElementById('jerseyNumInput').value='';" title="Add by jersey #">+#</button>
          </div>
        </div>
        <div class="section" style="position:sticky;bottom:0;background:var(--bg);z-index:10;padding-top:4px;">
          <div class="section-title"><span>Opposing Players</span></div>
          <div class="player-list" id="oppPlayers" ondragover="handleListDragOver(event)" ondragleave="handleListDragLeave(event)" ondrop="handleListDrop(event, 'opp')" style="max-height:120px;overflow-y:auto;"></div>
          <div class="quick-add" id="oppQuickAdd"></div>
        </div>
        <!-- Player Details -->
        <div class="player-details" id="playerDetails" style="display:none;max-height:300px;overflow-y:auto;background:var(--card);padding:8px;border-radius:4px;margin-top:4px;">
          <h5 id="pdPlayerNum">#0 Player</h5>
          <div class="form-row">
            <!-- v16.02: Searchable play detail dropdowns using input with datalist -->
            <div class="form-group">
              <label>Play Detail 1</label>
              <input list="pdPlayD1List" id="pdPlayD1" style="width:100%;" onchange="updatePlayerDetail('playD1', this.value); updatePlayD2()" placeholder="Type to search...">
              <datalist id="pdPlayD1List"></datalist>
            </div>
            <div class="form-group">
              <label>Play Detail 2</label>
              <input list="pdPlayD2List" id="pdPlayD2" style="width:100%;" onchange="updatePlayerDetail('playD2', this.value)" placeholder="Type to search...">
              <datalist id="pdPlayD2List"></datalist>
            </div>
          </div>
          <div class="form-row">
            <div class="form-group"><label>Success <button class="btn-sm" onclick="derivePlayerSuccess()" title="Auto from event">‚ö°</button></label><select id="pdPlaySuccess" onchange="updatePlayerDetail('playSuccess', this.value)"><option value="">--</option><option value="s">S</option><option value="u">U</option></select></div>
            <div class="form-group"><label>Pressured By <button class="btn-sm" onclick="autoCalcPressure()" title="Auto from XY">‚ö°</button></label><select id="pdPressure" onchange="updatePlayerDetail('pressure', this.value)"><option value="">--</option></select></div>
          </div>
          <!-- v16: Side of Puck -->
          <div class="form-row">
            <div class="form-group">
              <label>Side of Puck <button class="btn-sm" onclick="autoSideOfPuck()" title="Auto-detect from zone">‚ö°</button></label>
              <select id="pdSideOfPuck" onchange="updatePlayerDetail('sideOfPuck', this.value)">
                <option value="">--</option>
                <option value="Offensive">Offensive</option>
                <option value="Defensive">Defensive</option>
              </select>
            </div>
            <div class="form-group"><label>&nbsp;</label><span style="font-size:8px;color:var(--muted);line-height:26px;">Relative to player's team</span></div>
          </div>
        </div>
        <!-- Linked Event & Highlight -->
        <div class="linked-event-bar" style="background:var(--card);padding:4px 8px;border-radius:4px;margin-top:6px;font-size:9px;display:flex;align-items:center;gap:8px;">
          <span style="color:var(--muted);">Link:</span>
          <select id="linkedEvtSelect" style="flex:1;" onchange="onLinkedEvtChange()">
            <option value="">-- None --</option>
          </select>
          <span id="linkedEvtInfo" style="color:var(--accent);font-size:8px;"></span>
          <label style="display:flex;align-items:center;gap:4px;cursor:pointer;margin-left:auto;">
            <input type="checkbox" id="isHighlight" onchange="toggleHighlightFields()"> ‚≠ê Highlight
          </label>
        </div>
        <!-- Video URL for highlights (v23.7) -->
        <div id="highlightVideoUrlRow" style="display:none;margin-top:4px;">
          <div class="form-group">
            <label style="font-size:8px;color:var(--muted);">YouTube URL for this highlight:</label>
            <input type="text" id="evtVideoUrl" placeholder="https://youtube.com/watch?v=..." style="width:100%;font-size:9px;">
          </div>
        </div>
        <!-- Quick Time Buttons (v5) + Time Nudge (v6) -->
        <div style="display:flex;gap:4px;margin-top:4px;align-items:center;flex-wrap:wrap;">
          <button class="btn-sm" onclick="copyClockToStart()" title="Copy clock to start time">‚è±Ô∏è‚ÜíStart</button>
          <button class="btn-sm" onclick="copyClockToEnd()" title="Copy clock to end time">‚è±Ô∏è‚ÜíEnd</button>
          <button class="btn-sm" onclick="copyLastEventTime()" title="Copy last event's end time">üìã Last</button>
          <!-- v6: Time nudge buttons with variable increment -->
          <span style="color:var(--muted);font-size:8px;margin-left:4px;">¬±</span>
          <input type="number" id="timeNudgeAmount" value="5" min="1" max="60" style="width:30px;font-size:9px;padding:2px;" title="Nudge seconds">
          <button class="btn-sm" onclick="nudgeStartTime(-1)" title="Subtract from start time">-S</button>
          <button class="btn-sm" onclick="nudgeStartTime(1)" title="Add to start time">+S</button>
          <button class="btn-sm" onclick="nudgeEndTime(-1)" title="Subtract from end time">-E</button>
          <button class="btn-sm" onclick="nudgeEndTime(1)" title="Add to end time">+E</button>
          <label style="display:flex;align-items:center;gap:4px;font-size:8px;margin-left:8px;cursor:pointer;" title="Skip confirmation popup">
            <input type="checkbox" id="skipConfirm"> Quick log
          </label>
          <label style="display:flex;align-items:center;gap:4px;font-size:8px;margin-left:auto;cursor:pointer;">
            <input type="checkbox" id="autoEditNext"> Auto-edit next
          </label>
        </div>
        <!-- Actions - v23.8: Sticky at bottom for visibility -->
        <div class="log-actions" style="position:sticky;bottom:0;background:var(--bg);z-index:20;padding-top:8px;border-top:2px solid var(--accent);margin-top:8px;">
          <button class="btn-success" onclick="logEvent()" style="font-size:12px;font-weight:bold;padding:8px 16px;flex:1;" title="Log current event (Enter key)">Log Event <kbd>Enter</kbd></button>
          <button onclick="clearEvent()" style="padding:8px 12px;">Clear <kbd>Esc</kbd></button>
          <button class="btn-sm" onclick="duplicateLastEvent()" title="Duplicate last event" style="padding:8px 12px;">üìã Dup</button>
          <button class="btn-sm" onclick="logEventDirect()" title="Log without confirmation (Shift+Enter)" style="padding:8px 12px;">‚ö° Quick</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Settings Modal -->
<div class="overlay" id="settingsModal">
  <div class="modal">
    <h3>‚öôÔ∏è Settings</h3>
    <div class="form-group" style="margin-bottom:8px;">
      <label>Supabase URL</label>
      <input type="text" id="sbUrl" placeholder="https://xxx.supabase.co" style="width:100%;">
    </div>
    <div class="form-group" style="margin-bottom:8px;">
      <label>Supabase Anon Key</label>
      <input type="password" id="sbKey" placeholder="eyJ..." style="width:100%;">
    </div>
    <div class="form-row">
      <div class="form-group"><label>Auto-save (sec)</label><input type="number" id="autoSaveInt" value="30"></div>
      <div class="form-group"><label>Pressure Distance (ft)</label><input type="number" id="pressureDist" value="10"></div>
    </div>
    <!-- v23.5: Per-period lengths -->
    <div style="margin:8px 0;">
      <label style="font-size:10px;color:var(--muted);display:block;margin-bottom:4px;">Period Lengths (minutes)</label>
      <div style="display:flex;gap:8px;">
        <div class="form-group" style="flex:1;">
          <label style="font-size:9px;">P1</label>
          <input type="number" id="periodLength1" value="18" min="5" max="25" style="width:100%;" onchange="updatePeriodLengthsFromUI()">
        </div>
        <div class="form-group" style="flex:1;">
          <label style="font-size:9px;">P2</label>
          <input type="number" id="periodLength2" value="18" min="5" max="25" style="width:100%;" onchange="updatePeriodLengthsFromUI()">
        </div>
        <div class="form-group" style="flex:1;">
          <label style="font-size:9px;">P3</label>
          <input type="number" id="periodLength3" value="18" min="5" max="25" style="width:100%;" onchange="updatePeriodLengthsFromUI()">
        </div>
        <div class="form-group" style="flex:1;">
          <label style="font-size:9px;">OT</label>
          <input type="number" id="periodLengthOT" value="5" min="3" max="20" style="width:100%;" onchange="updatePeriodLengthsFromUI()">
        </div>
      </div>
    </div>
    <!-- v23.8: Penalty Lengths -->
    <div style="margin:8px 0;">
      <label style="font-size:10px;color:var(--muted);display:block;margin-bottom:4px;">Penalty Lengths (minutes)</label>
      <div style="display:flex;gap:8px;">
        <div class="form-group" style="flex:1;">
          <label style="font-size:9px;">Minor</label>
          <input type="number" id="penaltyLengthMinor" value="2" min="1" max="10" style="width:100%;" onchange="updatePenaltyLengthsFromUI()">
        </div>
        <div class="form-group" style="flex:1;">
          <label style="font-size:9px;">Major</label>
          <input type="number" id="penaltyLengthMajor" value="5" min="1" max="10" style="width:100%;" onchange="updatePenaltyLengthsFromUI()">
        </div>
        <div class="form-group" style="flex:1;">
          <label style="font-size:9px;">Misconduct</label>
          <input type="number" id="penaltyLengthMisconduct" value="10" min="1" max="20" style="width:100%;" onchange="updatePenaltyLengthsFromUI()">
        </div>
      </div>
    </div>
    <!-- Hidden for backward compatibility -->
    <input type="hidden" id="periodLength" value="18">
    <input type="hidden" id="otLength" value="5">
    <div class="form-group" style="margin-bottom:8px;">
      <label>Save Location</label>
      <div class="save-location-box">
        <div class="folder-display">
          <div class="folder-path empty" id="saveFolderPath">No folder selected - using localStorage only</div>
          <div class="folder-actions">
            <button class="btn-sm btn-primary" onclick="promptForSaveDirectory()" title="Select folder for auto-saves and backups">üìÅ Choose</button>
            <button class="btn-sm" onclick="clearSaveFolder()" title="Clear selected folder">‚úï</button>
          </div>
        </div>
        <div class="folder-status" id="saveFolderStatus">
          üí° Select a folder to enable auto-saves and backups (saved to 'bkup' folder, keeps last 10)
        </div>
        <div style="margin-top:8px;display:flex;gap:4px;">
          <button class="btn-sm btn-success" onclick="manualSave()" id="quickSaveBtn" style="flex:1;">
            üíæ Save Now
          </button>
        </div>
      </div>
      <p style="font-size:8px;color:var(--muted);margin-top:4px;">
        <strong>Note:</strong> Game data auto-saves to browser storage every <span id="autoSaveDisplay">30</span>s. 
        Use "Quick Save" or "Export" to create an Excel file.
      </p>
      <div style="margin-top:8px;">
        <label style="display:flex;align-items:center;gap:6px;font-size:10px;cursor:pointer;">
          <input type="checkbox" id="exportJsonOnSave" ${localStorage.getItem('bs_exportJsonOnSave') === 'true' ? 'checked' : ''}>
          <span>Download JSON file on save/auto-save (includes all game data & settings)</span>
        </label>
        <p style="font-size:8px;color:var(--muted);margin-top:4px;margin-left:22px;">
          When enabled, each save will download a JSON file with complete game state, events, shifts, rosters, and settings.
        </p>
      </div>
    </div>
    <!-- v23.8: Data Import/Export Section -->
    <div style="margin-top:12px;padding-top:12px;border-top:1px solid var(--border);">
      <label style="font-size:11px;font-weight:600;color:var(--text);display:block;margin-bottom:8px;">üìä Data Import/Export</label>
      <div style="display:flex;flex-direction:column;gap:6px;">
        <div style="display:flex;gap:6px;flex-wrap:wrap;">
          <button class="btn-sm" onclick="exportSettings()" title="Export all settings, presets, chains" style="flex:1;min-width:120px;">üì§ Export Settings</button>
          <button class="btn-sm" onclick="document.getElementById('importSettingsFile').click()" title="Import settings from JSON" style="flex:1;min-width:120px;">üì• Import Settings</button>
          <input type="file" id="importSettingsFile" accept=".json" style="display:none;" onchange="importSettings(event)">
        </div>
        <div style="display:flex;gap:6px;flex-wrap:wrap;">
          <button class="btn-sm" onclick="document.getElementById('importRosterFile').click()" title="Import roster from Excel (.xlsx)" style="flex:1;min-width:120px;">üìã Import Roster</button>
          <input type="file" id="importRosterFile" accept=".xlsx,.xls,.csv" style="display:none;" onchange="importRosterFromFile(event)">
          <button class="btn-sm" onclick="showManualRosterEntry()" title="Manually enter roster" style="flex:1;min-width:120px;">‚úèÔ∏è Manual Roster</button>
        </div>
      </div>
      <p style="font-size:8px;color:var(--muted);margin-top:6px;">
        Export/import settings, presets, and chains. Import rosters from Excel or enter manually.
      </p>
    </div>
    <div style="margin-top:12px;padding-top:8px;border-top:1px solid var(--border);">
      <button class="btn-danger" onclick="clearAllData()" style="width:100%;">üóëÔ∏è Clear All Game Data</button>
      <p style="font-size:8px;color:var(--muted);margin-top:4px;">Removes all events, shifts, and saved data for current game</p>
    </div>
    <div class="modal-actions">
      <button onclick="testConn()" title="Test Supabase connection">Test Connection</button>
      <button class="btn-primary" onclick="saveSettings()">Save</button>
      <button onclick="closeSettings()">Cancel</button>
    </div>
  </div>
</div>

<!-- Help/Instructions Modal -->
<div class="overlay" id="helpModal">
  <div class="modal" style="min-width:700px;max-height:85vh;overflow-y:auto;">
    <h3>‚ùì Instructions & Hotkeys (v23.5)</h3>

    <!-- User Guide Link -->
    <div style="background:linear-gradient(90deg,var(--accent),var(--home));padding:10px 15px;border-radius:6px;margin-bottom:12px;display:flex;justify-content:space-between;align-items:center;">
      <div>
        <span style="font-size:12px;font-weight:bold;color:#000;">üìñ Complete User Guide Available</span>
        <p style="font-size:9px;color:#000;margin:2px 0 0 0;opacity:0.8;">Full documentation with workflows, tips & best practices</p>
      </div>
      <button class="btn-sm" onclick="window.open('TRACKER_USER_GUIDE_v23.5.md', '_blank')" style="background:#000;color:#fff;font-size:10px;">Open Guide</button>
    </div>

    <!-- Quick Feature Explanations -->
    <div style="background:var(--card);padding:12px;border-radius:6px;margin-bottom:12px;border-left:4px solid var(--accent);">
      <h4 style="color:var(--accent);margin:0 0 8px 0;font-size:12px;">üéØ Key Features Explained</h4>
      <div style="font-size:10px;line-height:1.6;">
        <p style="margin:4px 0;"><strong>üéØ Shot Mode:</strong> Enable to quickly log shots by clicking on the rink. Automatically sets event type to Shot and creates shot events at click locations. Great for rapid shot tracking during fast-paced sequences.</p>
        <p style="margin:4px 0;"><strong>üèí Possession Mode:</strong> Track continuous possession chains. Automatically links events together and sets event type to Possession. Enables sequence mode to track the full possession sequence from start to finish.</p>
        <p style="margin:4px 0;"><strong>üîó Sequence Mode:</strong> Automatically links consecutive events together. When enabled, each new event links to the previous one, creating a play sequence. Useful for tracking multi-event plays like passes leading to shots.</p>
        <p style="margin:4px 0;"><strong>ü•Ö Auto-Add Goalie:</strong> When enabled, automatically adds the opposing team's goalie as an opponent player when you log Shot, Goal, Save, or Rebound events. Saves time by not having to manually add the goalie each time.</p>
        <p style="margin:4px 0;"><strong>üìç Shot Chart Overlay:</strong> Display all tracked shots on the rink visualization. Goals appear in green, shots on goal in team colors. Helps visualize shot locations and patterns throughout the game.</p>
        <p style="margin:4px 0;"><strong>üîÑ Mirror Mode:</strong> Auto-flip XY coordinates for period 2 (when teams switch ends). No need to mentally flip coordinates when placing players/puck.</p>
        <p style="margin:4px 0;"><strong>üéØ Auto Zone:</strong> Automatically sets zone based on where you click on the rink. Click offensive end ‚Üí Zone = O, defensive end ‚Üí Zone = D.</p>
      </div>
    </div>
    
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;">
      <!-- Keyboard Shortcuts -->
      <div>
        <h4 style="color:var(--accent);margin-bottom:8px;font-size:12px;">‚å®Ô∏è Keyboard Shortcuts</h4>
        <table style="font-size:10px;width:100%;">
          <tr><td style="padding:2px 8px;"><kbd>Enter</kbd></td><td>Save current event</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Shift+Enter</kbd></td><td>Quick log (no confirmation)</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Escape</kbd></td><td>Cancel / Close modals</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>L</kbd></td><td>Log shift</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>E</kbd></td><td>End shift (set end time)</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Q</kbd></td><td>Quick line change</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Tab</kbd></td><td>Toggle Puck/Player mode</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>`</kbd></td><td>Switch to Puck XY mode</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>H</kbd> / <kbd>A</kbd></td><td>Set team Home/Away</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Shift+S</kbd></td><td>Swap Event/Opp Teams</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>1-6</kbd></td><td>Select Event Player 1-6</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Alt+1-6</kbd></td><td>Select Opp Player 1-6</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Backspace</kbd></td><td>Undo last XY point</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>[</kbd> / <kbd>]</kbd></td><td>Cycle prev/next player in XY mode</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>‚Üê</kbd> / <kbd>‚Üí</kbd></td><td>Navigate prev/next event when editing (works with XY editing)</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>?</kbd></td><td>Open this help</td></tr>
        </table>
        <h5 style="color:var(--accent);margin:8px 0 4px;font-size:10px;">Event Type Hotkeys:</h5>
        <div style="font-size:9px;color:var(--muted);">F=Faceoff, S=Shot, P=Pass, G=Goal, T=Turnover, Z=Zone, N=Penalty, X=Stoppage, O=Possession, V=Save, R=Rebound, D=DeadIce</div>
        <h5 style="color:var(--accent);margin:8px 0 4px;font-size:10px;">Zone / Success:</h5>
        <div style="font-size:9px;color:var(--muted);">Q=Offensive, W=Neutral, E=Defensive | Y=Success, U=Unsuccess</div>
      </div>
      
      <!-- Video Controls -->
      <div>
        <h4 style="color:var(--accent);margin-bottom:8px;font-size:12px;">üé¨ Video Controls</h4>
        <table style="font-size:10px;width:100%;">
          <tr><td style="padding:2px 8px;"><kbd>Space</kbd></td><td>Play/Pause</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>‚Üê</kbd> / <kbd>‚Üí</kbd></td><td>Seek ¬±1 second</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Shift+‚Üê/‚Üí</kbd></td><td>Seek ¬±10 seconds</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>‚Üë</kbd> / <kbd>‚Üì</kbd></td><td>Speed up/down</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>;</kbd> / <kbd>'</kbd></td><td>Frame back/forward</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>+</kbd> / <kbd>-</kbd></td><td>Zoom in/out</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>0</kbd></td><td>Reset zoom</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Ctrl+1-9</kbd></td><td>Switch video source</td></tr>
        </table>
        
        <h4 style="color:var(--accent);margin:12px 0 8px;font-size:12px;">üÜï v23.4 Features</h4>
        <div style="font-size:9px;line-height:1.5;color:var(--muted);">
          <p>‚Ä¢ <strong>Drag to Create</strong> - Drag on rink for pass/shot</p>
          <p>‚Ä¢ <strong>Smart XY Linking</strong> - Puck auto-links to players</p>
          <p>‚Ä¢ <strong>Quick Chains</strong> - Entry, Dump, Shot+, Break, PP</p>
          <p>‚Ä¢ <strong>üìç All Here</strong> - Place all players at puck</p>
          <p>‚Ä¢ <strong>Multi-Video</strong> - Ctrl+1-9 to switch sources</p>
        </div>
        
        <h4 style="color:var(--warn);margin:12px 0 8px;font-size:12px;">üöÄ v23.5 Speed Features</h4>
        <div style="font-size:9px;line-height:1.4;color:var(--muted);display:grid;grid-template-columns:1fr 1fr;gap:4px;">
          <p>‚Ä¢ <strong>üîÑ Mirror</strong> - Auto-flip XY for P2</p>
          <p>‚Ä¢ <strong>üéØ AutoZ</strong> - Zone from click position</p>
          <p>‚Ä¢ <strong>ü•Ö AutoG</strong> - Auto-add goalie on shots</p>
          <p>‚Ä¢ <strong>üî¢ Numpad</strong> - Use numpad for players</p>
          <p>‚Ä¢ <strong>Quick Queue</strong> - Mark now, fill later</p>
          <p>‚Ä¢ <strong>‚è∫ Macros</strong> - Record event sequences</p>
          <p>‚Ä¢ <strong>üìç Shots</strong> - Overlay on rink</p>
          <p>‚Ä¢ <strong>üì∫ Float</strong> - Draggable video</p>
          <p>‚Ä¢ <strong>üîç Gaps</strong> - Find missing events</p>
          <p>‚Ä¢ <strong>‚úÖ Check</strong> - Consistency checker</p>
          <p>‚Ä¢ <strong>EN-H/A</strong> - Empty net toggle</p>
          <p>‚Ä¢ <strong>Ice/Offside</strong> - One-click stoppages</p>
        </div>
      </div>
    </div>
    
    <hr style="margin:12px 0;border-color:var(--border);">
    
    <!-- Quick Guide -->
    <div>
      <h4 style="color:var(--accent);margin-bottom:8px;font-size:12px;">üìã Quick Workflow</h4>
      <div style="font-size:10px;display:grid;grid-template-columns:repeat(4,1fr);gap:8px;">
        <div style="background:var(--panel);padding:8px;border-radius:4px;text-align:center;">
          <div style="font-size:16px;">1Ô∏è‚É£</div>
          <div><strong>Load Video</strong></div>
          <div style="font-size:9px;color:var(--muted);">+ or üìÅ button</div>
        </div>
        <div style="background:var(--panel);padding:8px;border-radius:4px;text-align:center;">
          <div style="font-size:16px;">2Ô∏è‚É£</div>
          <div><strong>Set Markers</strong></div>
          <div style="font-size:9px;color:var(--muted);">P1üèí at puck drop</div>
        </div>
        <div style="background:var(--panel);padding:8px;border-radius:4px;text-align:center;">
          <div style="font-size:16px;">3Ô∏è‚É£</div>
          <div><strong>Track Events</strong></div>
          <div style="font-size:9px;color:var(--muted);">Type ‚Üí XY ‚Üí Enter</div>
        </div>
        <div style="background:var(--panel);padding:8px;border-radius:4px;text-align:center;">
          <div style="font-size:16px;">4Ô∏è‚É£</div>
          <div><strong>Export</strong></div>
          <div style="font-size:9px;color:var(--muted);">Download Excel</div>
        </div>
      </div>
    </div>
    
    <hr style="margin:12px 0;border-color:var(--border);">
    
    <!-- Video Timing -->
    <div>
      <h4 style="color:var(--accent);margin-bottom:8px;font-size:12px;">üé¨ Video & Time Sync</h4>
      <div style="font-size:10px;line-height:1.6;">
        <p><strong>Video Time Calculation:</strong></p>
        <ul style="margin:4px 0 4px 16px;">
          <li><strong>event_running_start</strong> = (period-1) √ó period_seconds + (period_seconds - time_remaining)</li>
          <li><strong>running_video_time</strong> = event_running_start + intermission_offset</li>
          <li>Period seconds = periodLength √ó 60 (default 18 min = 1080 sec for NORAD)</li>
        </ul>
        <p><strong>Stoppages:</strong> Stoppage events are tracked with duration. You do NOT need to cut 
           stoppages from video - the tracker calculates running time including them.</p>
        <p><strong>Shift Stoppage Time:</strong> Each shift automatically calculates total stoppage duration 
           from Stoppage/Clockstop events that occur within the shift time window.</p>
      </div>
    </div>
    
    <hr style="margin:12px 0;border-color:var(--border);">
    
    <!-- Highlights -->
    <div>
      <h4 style="color:var(--accent);margin-bottom:8px;font-size:12px;">‚≠ê Highlights & Video Clips</h4>
      <div style="font-size:10px;line-height:1.6;">
        <p><strong>Marking Highlights:</strong></p>
        <ul style="margin:4px 0 4px 16px;">
          <li>Press <kbd>H</kbd> while recording to mark as highlight</li>
          <li>Goals are automatically marked as highlights</li>
          <li>Double-click event ‚Üí Edit Highlight field</li>
        </ul>
        <p><strong>ETL Export:</strong></p>
        <ul style="margin:4px 0 4px 16px;">
          <li><code>is_highlight</code> column = 1 for highlights, 0 otherwise</li>
          <li>Use <code>running_video_time</code> to find clip start in video</li>
          <li>Clip duration = event duration or default (10 sec for goals)</li>
        </ul>
        <p><strong>Creating Highlight Reels:</strong></p>
        <ul style="margin:4px 0 4px 16px;">
          <li>Query: <code>SELECT * FROM fact_events WHERE is_highlight = 1 ORDER BY running_video_time</code></li>
          <li>Use video editor to extract clips at running_video_time timestamps</li>
        </ul>
      </div>
    </div>
    
    <hr style="margin:12px 0;border-color:var(--border);">
    
    <!-- Event Log -->
    <div>
      <h4 style="color:var(--accent);margin-bottom:8px;font-size:12px;">üìù Event Log Columns</h4>
      <div style="font-size:10px;display:grid;grid-template-columns:repeat(3,1fr);gap:4px;">
        <span><strong>Idx:</strong> Event index (1-based)</span>
        <span><strong>Link:</strong> Linked event index</span>
        <span><strong>Seq/Play:</strong> Sequence/Play index</span>
        <span><strong>Time:</strong> Period + game time</span>
        <span><strong>Type:</strong> Event type</span>
        <span><strong>Detail:</strong> Event detail 1</span>
        <span><strong>Zone:</strong> Off/Neu/Def</span>
        <span><strong>‚úì/‚úó:</strong> Success flag</span>
        <span><strong>Players:</strong> Player numbers</span>
        <span><strong>‚óè:</strong> Has XY data</span>
        <span><strong>‚≠ê:</strong> Highlight</span>
      </div>
      <p style="font-size:9px;color:var(--muted);margin-top:4px;">Double-click any event to quick edit (Type, Detail, Zone, Success, Linked, Highlight, Time)</p>
    </div>
    
    <div class="modal-actions" style="display:flex;justify-content:space-between;align-items:center;">
      <a href="TRACKER_USER_GUIDE_v23.5.md" download style="font-size:10px;color:var(--accent);">üì• Download Full User Guide (Markdown)</a>
      <button class="btn-primary" onclick="closeHelp()">Close</button>
    </div>
  </div>
</div>

<!-- Player Picker Modal -->
<div class="overlay" id="playerPickerModal">
  <div class="modal" style="min-width:400px;">
    <h3>üë§ Select Player</h3>
    <div class="form-row">
      <div class="form-group">
        <label>Team</label>
        <select id="pickerTeam" onchange="renderPlayerPicker()">
          <option value="home">Home</option>
          <option value="away">Away</option>
        </select>
      </div>
      <div class="form-group">
        <label>Role</label>
        <select id="pickerRole">
          <option value="event_team_player">Event Team</option>
          <option value="opp_team_player">Opposing Team</option>
        </select>
      </div>
    </div>
    <div id="playerPickerList" style="max-height:250px;overflow-y:auto;margin:8px 0;"></div>
    <div class="modal-actions">
      <button onclick="closePlayerPicker()">Cancel</button>
    </div>
  </div>
</div>

<!-- Verification Panel Modal -->
<div class="overlay" id="verifyModal">
  <div class="modal" style="min-width:600px;max-height:90vh;overflow-y:auto;">
    <h3>‚úÖ Verification Panel</h3>
    
    <!-- Tracked Goals (Blue) -->
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:12px;">
      <div style="background:rgba(59,130,246,0.2);border:2px solid var(--home);padding:12px;border-radius:4px;text-align:center;">
        <div style="font-size:24px;font-weight:bold;color:var(--home);" id="verifyHomeGoals">0</div>
        <div style="font-size:10px;color:var(--muted);">Tracked Home Goals</div>
        <div style="font-size:9px;color:var(--accent);margin-top:4px;" id="verifyHomeByPeriod">P1: 0 | P2: 0 | P3: 0</div>
      </div>
      <div style="background:rgba(239,68,68,0.2);border:2px solid var(--away);padding:12px;border-radius:4px;text-align:center;">
        <div style="font-size:24px;font-weight:bold;color:var(--away);" id="verifyAwayGoals">0</div>
        <div style="font-size:10px;color:var(--muted);">Tracked Away Goals</div>
        <div style="font-size:9px;color:var(--accent);margin-top:4px;" id="verifyAwayByPeriod">P1: 0 | P2: 0 | P3: 0</div>
      </div>
    </div>
    
    <!-- Official Score (Purple - Auto from dim_schedule) -->
    <div style="background:rgba(168,85,247,0.15);border:2px solid #a855f7;padding:12px;border-radius:4px;margin-bottom:12px;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <span style="font-size:11px;color:#a855f7;font-weight:bold;">üìä OFFICIAL SCORE (from dim_schedule)</span>
        <a id="noradGameLink" href="#" target="_blank" style="font-size:9px;color:var(--accent);">View on noradhockey.com ‚Üó</a>
      </div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;">
        <div style="text-align:center;">
          <div style="font-size:24px;font-weight:bold;color:#a855f7;" id="officialHomeGoalsDisplay">-</div>
          <div style="font-size:9px;color:var(--muted);" id="officialHomeByPeriod">P1: - | P2: - | P3: -</div>
        </div>
        <div style="text-align:center;">
          <div style="font-size:24px;font-weight:bold;color:#a855f7;" id="officialAwayGoalsDisplay">-</div>
          <div style="font-size:9px;color:var(--muted);" id="officialAwayByPeriod">P1: - | P2: - | P3: -</div>
        </div>
      </div>
      <input type="hidden" id="officialHomeGoals" value="0">
      <input type="hidden" id="officialAwayGoals" value="0">
    </div>
    
    <!-- Verification Result -->
    <div id="verifyResult" style="padding:12px;border-radius:4px;text-align:center;font-weight:bold;font-size:14px;margin-bottom:12px;"></div>
    
    <!-- Warnings -->
    <div id="verifyWarnings" style="display:none;background:rgba(245,158,11,0.2);border:1px solid var(--warn);padding:8px;border-radius:4px;margin-bottom:12px;font-size:10px;">
      <div style="font-weight:bold;color:var(--warn);margin-bottom:4px;">‚ö†Ô∏è WARNINGS</div>
      <div id="verifyWarningsList"></div>
    </div>
    
    <!-- Goal Breakdown -->
    <div style="margin-bottom:12px;">
      <div style="font-size:9px;color:var(--muted);margin-bottom:4px;">GOAL BREAKDOWN (Scorer #, Assist # from play_details or linked Pass events üîó)</div>
      <table style="width:100%;font-size:10px;border-collapse:collapse;">
        <thead><tr style="background:var(--card);">
          <th style="text-align:left;padding:4px;">P</th>
          <th style="text-align:left;padding:4px;">Time</th>
          <th style="text-align:left;padding:4px;">Team</th>
          <th style="text-align:left;padding:4px;">Scorer</th>
          <th style="text-align:left;padding:4px;">Assists</th>
          <th style="text-align:left;padding:4px;">‚úì</th>
        </tr></thead>
        <tbody id="verifyGoalsList"></tbody>
      </table>
    </div>
    
    <!-- Player Assist Counts -->
    <div style="margin-bottom:12px;">
      <div style="font-size:9px;color:var(--muted);margin-bottom:4px;">PLAYER ASSIST COUNTS (Tracked vs Roster)</div>
      <div style="max-height:200px;overflow-y:auto;border:1px solid var(--border);border-radius:4px;">
        <table style="width:100%;font-size:9px;border-collapse:collapse;">
          <thead><tr style="background:var(--card);position:sticky;top:0;">
            <th style="text-align:left;padding:4px;font-size:8px;">#</th>
            <th style="text-align:left;padding:4px;font-size:8px;">Name</th>
            <th style="text-align:left;padding:4px;font-size:8px;">Team</th>
            <th style="text-align:center;padding:4px;font-size:8px;">Tracked</th>
            <th style="text-align:center;padding:4px;font-size:8px;">Roster</th>
            <th style="text-align:center;padding:4px;font-size:8px;">Status</th>
          </tr></thead>
          <tbody id="verifyAssistCountsList"></tbody>
        </table>
      </div>
    </div>
    
    <div class="modal-actions">
      <button onclick="runVerification()" title="Run verification checks on goals and assists">üîÑ Verify</button>
      <button onclick="closeVerifyModal()" title="Close verification panel">Close</button>
    </div>
  </div>
</div>

<!-- Video Timing Modal -->
<div class="overlay" id="videoTimingModal">
  <div class="modal" style="min-width:500px;max-height:80vh;overflow-y:auto;">
    <h3>üé¨ Video Timing Setup</h3>
    <p style="font-size:10px;color:var(--muted);margin-bottom:12px;">Configure video offsets for accurate timestamp calculations</p>
    
    <!-- Basic Settings -->
    <div style="background:var(--card);padding:12px;border-radius:4px;margin-bottom:12px;">
      <h4 style="font-size:11px;color:var(--accent);margin-bottom:8px;">Basic Settings</h4>
      <div class="form-group">
        <label>Video Start Offset (sec)</label>
        <input type="number" id="vtVideoStartOffset" value="0" min="0" placeholder="Skip warmups etc" oninput="updateVideoTimingPreview()">
      </div>
      <div style="margin-top:8px;">
        <label style="font-size:10px;color:var(--muted);display:block;margin-bottom:4px;">Period Lengths (minutes) - synced with Settings</label>
        <div style="display:flex;gap:8px;">
          <div class="form-group" style="flex:1;">
            <label style="font-size:9px;">P1</label>
            <input type="number" id="vtPeriodLength1" value="18" min="5" max="25" style="width:100%;" oninput="syncPeriodLengthsFromVT()">
          </div>
          <div class="form-group" style="flex:1;">
            <label style="font-size:9px;">P2</label>
            <input type="number" id="vtPeriodLength2" value="18" min="5" max="25" style="width:100%;" oninput="syncPeriodLengthsFromVT()">
          </div>
          <div class="form-group" style="flex:1;">
            <label style="font-size:9px;">P3</label>
            <input type="number" id="vtPeriodLength3" value="18" min="5" max="25" style="width:100%;" oninput="syncPeriodLengthsFromVT()">
          </div>
          <div class="form-group" style="flex:1;">
            <label style="font-size:9px;">OT</label>
            <input type="number" id="vtPeriodLengthOT" value="5" min="3" max="20" style="width:100%;" oninput="syncPeriodLengthsFromVT()">
          </div>
        </div>
      </div>
      <div class="form-group" style="margin-top:8px;">
        <label>YouTube URL (optional)</label>
        <input type="text" id="vtYoutubeUrl" placeholder="https://youtube.com/watch?v=...">
      </div>
    </div>
    
    <!-- Intermissions -->
    <div style="background:var(--card);padding:12px;border-radius:4px;margin-bottom:12px;">
      <h4 style="font-size:11px;color:var(--accent);margin-bottom:8px;">Intermission Durations</h4>
      <p style="font-size:9px;color:var(--muted);margin-bottom:8px;">Enter actual video time of intermissions (not game clock)</p>
      <div class="form-row">
        <div class="form-group">
          <label>After Period 1 (sec)</label>
          <input type="number" id="vtIntermission1" value="900" min="0" placeholder="900 = 15 min" oninput="updateVideoTimingPreview()">
        </div>
        <div class="form-group">
          <label>After Period 2 (sec)</label>
          <input type="number" id="vtIntermission2" value="900" min="0" placeholder="900 = 15 min" oninput="updateVideoTimingPreview()">
        </div>
        <div class="form-group">
          <label>After Period 3 / OT (sec)</label>
          <input type="number" id="vtIntermission3" value="300" min="0" placeholder="300 = 5 min" oninput="updateVideoTimingPreview()">
        </div>
      </div>
    </div>
    
    <!-- Timeouts/Stoppages -->
    <div style="background:var(--card);padding:12px;border-radius:4px;margin-bottom:12px;">
      <h4 style="font-size:11px;color:var(--accent);margin-bottom:8px;">Timeouts & Extended Stoppages</h4>
      <p style="font-size:9px;color:var(--muted);margin-bottom:8px;">Add stoppages that add extra video time (injuries, TV timeouts, etc)</p>
      <div id="vtTimeoutsList" style="margin-bottom:8px;max-height:150px;overflow-y:auto;"></div>
      <div class="form-row" style="align-items:flex-end;">
        <div class="form-group" style="flex:0.5;">
          <label>Period</label>
          <select id="vtNewTimeoutPeriod"><option>1</option><option>2</option><option>3</option><option>OT</option></select>
        </div>
        <div class="form-group" style="flex:1;">
          <label>Game Time</label>
          <input type="text" id="vtNewTimeoutTime" placeholder="15:30">
        </div>
        <div class="form-group" style="flex:1;">
          <label>Duration (sec)</label>
          <input type="number" id="vtNewTimeoutDuration" value="60" min="1">
        </div>
        <button class="btn-sm btn-success" onclick="addVideoTimeout()" style="margin-bottom:4px;">+ Add</button>
      </div>
    </div>
    
    <!-- Video Management (v23.6) -->
    <div style="background:var(--card);padding:12px;border-radius:4px;margin-bottom:12px;border-top:2px solid var(--accent);">
      <h4 style="font-size:11px;color:var(--accent);margin-bottom:8px;">üìπ Video Management</h4>
      <p style="font-size:9px;color:var(--muted);margin-bottom:8px;">Store multiple video links for this game</p>
      <div id="videosList" style="margin-bottom:8px;max-height:200px;overflow-y:auto;"></div>
      <div class="form-row" style="align-items:flex-end;">
        <div class="form-group" style="flex:1;">
          <label>Video URL</label>
          <input type="text" id="newVideoUrl" placeholder="https://youtube.com/watch?v=...">
        </div>
        <div class="form-group" style="flex:0.5;">
          <label>Type</label>
          <select id="newVideoType">
            <option value="Full_Ice">Full Ice</option>
            <option value="Broadcast">Broadcast</option>
            <option value="Highlights">Highlights</option>
            <option value="Goalie">Goalie</option>
            <option value="Overhead">Overhead</option>
            <option value="Wide">Wide</option>
            <option value="Tight">Tight</option>
            <option value="Replay">Replay</option>
            <option value="Other">Other</option>
          </select>
        </div>
        <div class="form-group" style="flex:0.5;">
          <label>Category</label>
          <select id="newVideoCategory">
            <option value="">--</option>
            <option value="Goal">Goal</option>
            <option value="Save">Save</option>
            <option value="Hit">Hit</option>
            <option value="Fight">Fight</option>
            <option value="Breakaway">Breakaway</option>
            <option value="Penalty_Shot">Penalty Shot</option>
            <option value="Sequence">Sequence</option>
            <option value="Momentum">Momentum</option>
            <option value="Skill">Skill</option>
            <option value="Other">Other</option>
          </select>
        </div>
        <button class="btn-sm btn-success" onclick="addVideo()" style="margin-bottom:4px;">+ Add</button>
      </div>
      <div class="form-row">
        <div class="form-group" style="flex:1;">
          <label>Title (optional)</label>
          <input type="text" id="newVideoTitle" placeholder="e.g., Period 1 Highlights">
        </div>
        <div class="form-group" style="flex:0.5;">
          <label>Period</label>
          <select id="newVideoPeriod">
            <option value="">All</option>
            <option value="1">Period 1</option>
            <option value="2">Period 2</option>
            <option value="3">Period 3</option>
            <option value="4">OT</option>
          </select>
        </div>
      </div>
      <div class="form-row">
        <div class="form-group" style="flex:1;">
          <label>Start Time (optional)</label>
          <input type="text" id="newVideoStartTime" placeholder="00:00">
        </div>
        <div class="form-group" style="flex:1;">
          <label>End Time (optional)</label>
          <input type="text" id="newVideoEndTime" placeholder="20:00">
        </div>
      </div>
      <div class="form-group">
        <label>Description/Notes (optional)</label>
        <textarea id="newVideoNotes" rows="2" placeholder="Video description or notes"></textarea>
      </div>
    </div>
    
    <!-- Running Time Preview -->
    <div style="background:var(--panel);padding:12px;border-radius:4px;margin-bottom:12px;border:1px solid var(--accent);">
      <h4 style="font-size:11px;color:var(--accent);margin-bottom:8px;">‚è±Ô∏è Running Time Preview</h4>
      <div style="font-size:10px;display:grid;grid-template-columns:1fr 1fr;gap:4px;">
        <span>Period 1 Start:</span><span id="vtPreviewP1Start">0:00</span>
        <span>Period 1 End:</span><span id="vtPreviewP1End">18:00</span>
        <span>Period 2 Start:</span><span id="vtPreviewP2Start">33:00</span>
        <span>Period 2 End:</span><span id="vtPreviewP2End">51:00</span>
        <span>Period 3 Start:</span><span id="vtPreviewP3Start">66:00</span>
        <span>Period 3 End:</span><span id="vtPreviewP3End">84:00</span>
        <span>OT Start:</span><span id="vtPreviewOTStart">89:00</span>
        <span>OT End:</span><span id="vtPreviewOTEnd">94:00</span>
      </div>
    </div>
    
    <div class="modal-actions">
      <button class="btn-primary" onclick="saveVideoTiming()">üíæ Save</button>
      <button onclick="closeVideoTimingModal()">Cancel</button>
    </div>
  </div>
</div>

<!-- Load Existing Game Modal -->
<div class="overlay" id="loadGameModal">
  <div class="modal" style="min-width:500px;">
    <h3>üìÇ Load Existing Game</h3>
    <p style="font-size:10px;color:var(--muted);margin-bottom:12px;">Load tracked events from Supabase for editing</p>
    <div class="form-group" style="margin-bottom:8px;">
      <label>Select Game</label>
      <select id="loadGameSelect" style="width:100%;" onchange="previewLoadGame()"></select>
    </div>
    <div id="loadGamePreview" style="background:var(--card);padding:8px;border-radius:4px;font-size:10px;margin-bottom:8px;">
      <div>Events: <span id="loadPreviewEvents">--</span></div>
      <div>Shifts: <span id="loadPreviewShifts">--</span></div>
    </div>
    <div class="modal-actions">
      <button class="btn-primary" onclick="confirmLoadGame()">Load Game</button>
      <button onclick="closeLoadGameModal()">Cancel</button>
    </div>
  </div>
</div>
<div class="overlay" id="editModal">
  <div class="modal" style="min-width:650px;max-height:90vh;overflow-y:auto;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
      <button class="btn-sm" onclick="navEditEvent(-1)" title="Previous Event (‚Üê Arrow Left)">‚óÄ Prev <kbd style="font-size:8px;padding:1px 3px;">‚Üê</kbd></button>
      <h3 style="margin:0;">‚úèÔ∏è Event #<span id="editEvtIdx"></span> <span id="editHighlightBadge" style="color:gold;"></span></h3>
      <button class="btn-sm" onclick="navEditEvent(1)" title="Next Event (‚Üí Arrow Right)">Next ‚ñ∂ <kbd style="font-size:8px;padding:1px 3px;">‚Üí</kbd></button>
    </div>
    <div class="form-row">
      <div class="form-group"><label>Event Type</label><select id="editType" onchange="onEditTypeChange()"></select></div>
      <div class="form-group"><label>Team</label><select id="editTeam"><option value="home">Home</option><option value="away">Away</option></select></div>
    </div>
    <div class="form-row">
      <div class="form-group"><label>Detail 1</label><select id="editD1" onchange="onEditD1Change()"></select></div>
      <div class="form-group"><label>Detail 2</label><select id="editD2"></select></div>
    </div>
    <div class="form-row tri">
      <div class="form-group"><label>Zone <button class="btn-sm" onclick="autoEditZone()" title="Auto from XY">‚ö°</button></label><select id="editZone"><option value="">--</option><option value="o">O</option><option value="d">D</option><option value="n">N</option></select></div>
      <div class="form-group"><label>Success <button class="btn-sm" onclick="autoEditSuccess()" title="Auto from detail">‚ö°</button></label><select id="editSuccess"><option value="">--</option><option value="s">S</option><option value="u">U</option></select></div>
      <div class="form-group"><label>Strength <button class="btn-sm" onclick="autoEditStrength()" title="Auto from shift">‚ö°</button></label><select id="editStrength"><option value="5v5">5v5</option><option value="5v4">5v4</option><option value="4v5">4v5</option><option value="4v4">4v4</option><option value="3v3">3v3</option><option value="ENG">ENG</option></select></div>
    </div>
    <div class="form-row">
      <div class="form-group"><label>Start Time</label><input type="text" id="editStartTime" oninput="autoFormatTime(this)"></div>
      <div class="form-group"><label>End Time</label><input type="text" id="editEndTime" oninput="autoFormatTime(this)"></div>
    </div>
    <div class="form-row">
      <div class="form-group">
        <label style="display:flex;align-items:center;gap:4px;">
          <input type="checkbox" id="editHighlight" onchange="toggleEditHighlightFields()"> ‚≠ê Highlight (for video)
        </label>
      </div>
      <div class="form-group">
        <label>Linked Event #</label>
        <input type="number" id="editLinkedIdx" style="width:60px;" placeholder="--" title="Enter event # to link to">
      </div>
      <!-- v23.8: Assist to Goal link (for Pass events or events with assist markers) -->
      <div class="form-group" id="editAssistToGoalSection" style="display:none;">
        <label style="font-size:9px;">Assist to Goal #</label>
        <div style="display:flex;gap:4px;align-items:center;">
          <input type="number" id="editAssistToGoalIdx" style="width:60px;" placeholder="--" title="Enter goal event # this assists">
          <button class="btn-sm" onclick="openLinkAssistToGoalModal()" style="font-size:8px;padding:2px 6px;" title="Browse and select a goal to link this assist to">Browse</button>
        </div>
      </div>
    </div>
    <!-- Video URL for highlights (v23.7) -->
    <div id="editHighlightVideoUrlRow" style="display:none;margin-bottom:8px;">
      <div class="form-group">
        <label style="font-size:8px;color:var(--muted);">YouTube URL for this highlight:</label>
        <input type="text" id="editVideoUrl" placeholder="https://youtube.com/watch?v=..." style="width:100%;font-size:9px;">
      </div>
    </div>
    <div class="form-row" style="background:var(--panel);padding:4px 8px;border-radius:4px;margin-bottom:8px;">
      <!-- v23.8: Made event_id, sequence_key, and play_key editable -->
      <div class="form-group" style="margin-bottom:0;">
        <label style="font-size:8px;color:var(--muted);">Event ID</label>
        <input type="text" id="editEventId" style="width:100%;font-size:9px;font-family:monospace;padding:2px 4px;" placeholder="--" title="Event ID (editable)">
      </div>
      <div class="form-group" style="margin-bottom:0;">
        <label style="font-size:8px;color:var(--muted);">Event Index</label>
        <span id="editEventIndex" style="font-size:10px;color:var(--accent);">--</span>
      </div>
      <div class="form-group" style="margin-bottom:0;">
        <label style="font-size:8px;color:var(--muted);">Sequence Key</label>
        <input type="text" id="editSeqKey" style="width:100%;font-size:9px;padding:2px 4px;" placeholder="--" title="Sequence Key / Sequence ID (editable)">
      </div>
      <div class="form-group" style="margin-bottom:0;">
        <label style="font-size:8px;color:var(--muted);">Play Key</label>
        <input type="text" id="editPlayKey" style="width:100%;font-size:9px;padding:2px 4px;" placeholder="--" title="Play Key / Play ID (editable)">
      </div>
      <div class="form-group" style="margin-bottom:0;">
        <label style="font-size:8px;color:var(--muted);">Linked Chain</label>
        <span id="editLinkedChain" style="font-size:9px;color:var(--warn);">--</span>
      </div>
    </div>
    <div class="section-title" style="margin-top:8px;"><span>Players</span><button class="btn-sm" onclick="addPlayerToEdit()">+ Add</button></div>
    <div id="editPlayersContainer" style="max-height:200px;overflow-y:auto;"></div>
    <div class="section-title" style="margin-top:8px;"><span>Puck XY</span></div>
    <div id="editPuckXY" style="display:flex;flex-wrap:wrap;gap:4px;"></div>
    <div class="section-title" style="margin-top:8px;"><span>Edit XY on Rink</span></div>
    <svg id="editRinkSvg" viewBox="0 0 200 85" width="100%" style="cursor:crosshair;background:var(--card);border-radius:4px;max-height:150px;" onclick="handleEditRinkClick(event)">
      <!-- Ice surface -->
      <rect x="0" y="0" width="200" height="85" fill="#f0f9ff" rx="14" ry="14" stroke="#1e293b" stroke-width="0.5"/>
      
      <!-- Blue lines -->
      <line x1="75" y1="0" x2="75" y2="85" stroke="#1d4ed8" stroke-width="1.5"/>
      <line x1="125" y1="0" x2="125" y2="85" stroke="#1d4ed8" stroke-width="1.5"/>
      
      <!-- Red center line (dashed) -->
      <line x1="100" y1="0" x2="100" y2="85" stroke="#dc2626" stroke-width="0.8" stroke-dasharray="3,2"/>
      
      <!-- Goal lines -->
      <line x1="11" y1="0" x2="11" y2="85" stroke="#dc2626" stroke-width="0.5"/>
      <line x1="189" y1="0" x2="189" y2="85" stroke="#dc2626" stroke-width="0.5"/>
      
      <!-- Center circle -->
      <circle cx="100" cy="42.5" r="15" fill="none" stroke="#1d4ed8" stroke-width="0.5"/>
      <circle cx="100" cy="42.5" r="1" fill="#1d4ed8"/>
      
      <!-- Offensive zone faceoff circles (left) -->
      <circle cx="31" cy="22" r="15" fill="none" stroke="#dc2626" stroke-width="0.4"/>
      <circle cx="31" cy="22" r="1" fill="#dc2626"/>
      <circle cx="31" cy="63" r="15" fill="none" stroke="#dc2626" stroke-width="0.4"/>
      <circle cx="31" cy="63" r="1" fill="#dc2626"/>
      
      <!-- Offensive zone faceoff circles (right) -->
      <circle cx="169" cy="22" r="15" fill="none" stroke="#dc2626" stroke-width="0.4"/>
      <circle cx="169" cy="22" r="1" fill="#dc2626"/>
      <circle cx="169" cy="63" r="15" fill="none" stroke="#dc2626" stroke-width="0.4"/>
      <circle cx="169" cy="63" r="1" fill="#dc2626"/>
      
      <!-- Neutral zone dots -->
      <circle cx="80" cy="22" r="0.8" fill="#dc2626"/>
      <circle cx="80" cy="63" r="0.8" fill="#dc2626"/>
      <circle cx="120" cy="22" r="0.8" fill="#dc2626"/>
      <circle cx="120" cy="63" r="0.8" fill="#dc2626"/>
      
      <!-- Creases (simplified) -->
      <path d="M 11 38.5 L 15 38.5 A 4 4 0 0 1 15 46.5 L 11 46.5" fill="rgba(59,130,246,0.15)" stroke="#3b82f6" stroke-width="0.4"/>
      <path d="M 189 38.5 L 185 38.5 A 4 4 0 0 0 185 46.5 L 189 46.5" fill="rgba(59,130,246,0.15)" stroke="#3b82f6" stroke-width="0.4"/>
      
      <!-- Goals -->
      <rect x="7" y="39" width="4" height="7" fill="#222" stroke="#fff" stroke-width="0.3"/>
      <rect x="189" y="39" width="4" height="7" fill="#222" stroke="#fff" stroke-width="0.3"/>
      
      <!-- High danger zone (slot area) -->
      <path d="M 11 30 L 45 30 L 45 55 L 11 55 Z" fill="rgba(239,68,68,0.08)" stroke="none"/>
      <path d="M 189 30 L 155 30 L 155 55 L 189 55 Z" fill="rgba(239,68,68,0.08)" stroke="none"/>
      
      <!-- Zone labels -->
      <text x="43" y="82" font-size="3" fill="#64748b" text-anchor="middle">OFF</text>
      <text x="100" y="82" font-size="3" fill="#64748b" text-anchor="middle">NEU</text>
      <text x="157" y="82" font-size="3" fill="#64748b" text-anchor="middle">OFF</text>
      
      <g id="editRinkMarkers"></g>
    </svg>
    <div id="editXYControls" style="font-size:9px;color:var(--muted);margin-top:4px;">
      Editing: <select id="editXYTarget" onchange="renderEditRinkMarkers()" style="font-size:9px;"></select>
      <button class="btn-sm" onclick="addEditXYPoint()" title="Add XY point (click on rink)">+ Add Point</button>
    </div>
    <!-- Assists Management for Goals (v23.8) -->
    <div id="editAssistsSection" style="display:none;margin-top:8px;">
      <div class="section-title">
        <span>Assists</span>
        <button class="btn-sm" onclick="openAddAssistModal()" style="font-size:9px;" title="Add a new assist by linking a Pass event to this goal">+ Add Assist</button>
      </div>
      <div id="editAssistsList" style="max-height:150px;overflow-y:auto;background:var(--card);padding:6px;border-radius:4px;margin-top:6px;">
        <!-- Assists will be rendered here -->
      </div>
    </div>
    <!-- Net Location for Shots/Goals -->
    <div id="editNetSection" style="display:none;margin-top:8px;">
      <div class="section-title"><span>Net Location (Shot/Goal)</span></div>
      <div style="display:flex;gap:16px;align-items:center;">
        <svg id="editNetSvg" viewBox="0 0 72 48" width="160" style="cursor:crosshair;background:#1f2937;border-radius:4px;" onclick="handleEditNetClick(event)">
          <rect x="1" y="1" width="70" height="46" fill="#111" stroke="#fff" stroke-width="1"/>
          <line x1="1" y1="1" x2="71" y2="47" stroke="#444" stroke-width="0.5"/>
          <line x1="71" y1="1" x2="1" y2="47" stroke="#444" stroke-width="0.5"/>
          <line x1="36" y1="1" x2="36" y2="47" stroke="#444" stroke-width="0.5"/>
          <line x1="1" y1="24" x2="71" y2="24" stroke="#444" stroke-width="0.5"/>
          <text x="12" y="12" font-size="5" fill="#666">Top L</text>
          <text x="50" y="12" font-size="5" fill="#666">Top R</text>
          <text x="12" y="42" font-size="5" fill="#666">Low L</text>
          <text x="50" y="42" font-size="5" fill="#666">Low R</text>
          <text x="26" y="26" font-size="5" fill="#666">5-Hole</text>
          <g id="editNetMarker"></g>
        </svg>
        <div style="font-size:10px;">
          <div style="color:var(--muted);margin-bottom:4px;">Click to set location</div>
          <div>Current: <span id="editNetLocation" style="color:var(--accent);">--</span></div>
          <button class="btn-sm" onclick="clearEditNetXY()" style="margin-top:4px;" title="Clear net location">Clear</button>
        </div>
      </div>
    </div>
    <!-- v20.7: Insert/Delete actions -->
    <div style="display:flex;gap:4px;margin-top:8px;padding-top:8px;border-top:1px solid var(--border);">
      <button class="btn-sm" onclick="insertEventBefore()" title="Insert new event before this one" style="flex:1;background:var(--accent2);">‚ûï Insert Before</button>
      <button class="btn-sm" onclick="insertEventAfter()" title="Insert new event after this one" style="flex:1;background:var(--accent2);">‚ûï Insert After</button>
      <button class="btn-sm" onclick="duplicateEvent()" title="Duplicate this event" style="flex:1;">üìã Duplicate</button>
    </div>
    <div class="modal-actions">
      <button class="btn-danger" onclick="deleteEvent()" title="Delete this event">Delete</button>
      <button class="btn-primary" onclick="saveEditEvent()" title="Save changes to event">Save</button>
      <button onclick="closeEditModal()" title="Cancel editing">Cancel</button>
    </div>
  </div>
</div>

<!-- Net Location Modal -->
<div class="overlay" id="netModal">
  <div class="modal" style="min-width:200px;">
    <h3>ü•Ö Net Location</h3>
    <p style="font-size:9px;color:var(--muted);margin-bottom:8px;">Click where puck entered net</p>
    <svg id="netSvg" viewBox="0 0 72 48" width="200" style="cursor:crosshair;background:#222;border-radius:4px;" onclick="handleNetClick(event)">
      <!-- Net frame -->
      <rect x="1" y="1" width="70" height="46" fill="none" stroke="#fff" stroke-width="1"/>
      <!-- Net mesh -->
      <line x1="1" y1="1" x2="71" y2="47" stroke="#666" stroke-width="0.3"/>
      <line x1="71" y1="1" x2="1" y2="47" stroke="#666" stroke-width="0.3"/>
      <line x1="36" y1="1" x2="36" y2="47" stroke="#666" stroke-width="0.3"/>
      <line x1="1" y1="24" x2="71" y2="24" stroke="#666" stroke-width="0.3"/>
      <!-- Zones -->
      <text x="18" y="14" font-size="6" fill="#888">Top L</text>
      <text x="46" y="14" font-size="6" fill="#888">Top R</text>
      <text x="18" y="38" font-size="6" fill="#888">Low L</text>
      <text x="46" y="38" font-size="6" fill="#888">Low R</text>
      <text x="28" y="26" font-size="6" fill="#888">5-Hole</text>
      <!-- Marker layer -->
      <g id="netMarker"></g>
    </svg>
    <div class="modal-actions">
      <button onclick="clearNetXY()">Clear</button>
      <button class="btn-primary" onclick="closeNetModal()">Done</button>
    </div>
  </div>
</div>

<!-- Edit Shift Modal -->
<div class="overlay" id="editShiftModal">
  <div class="modal" style="min-width:500px;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
      <button class="btn-sm" onclick="navEditShift(-1)" title="Previous Shift (‚Üê)">‚óÄ Prev</button>
      <h3 style="margin:0;">‚úèÔ∏è Shift #<span id="editShiftIdx"></span></h3>
      <button class="btn-sm" onclick="navEditShift(1)" title="Next Shift (‚Üí)">Next ‚ñ∂</button>
    </div>
    <div class="form-row">
      <div class="form-group"><label>Period</label><select id="editShiftPeriod"><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="OT">OT</option></select></div>
      <div class="form-group"><label>Strength</label><input type="text" id="editShiftStrength" readonly></div>
    </div>
    <div class="form-row">
      <div class="form-group"><label>Start Time</label><input type="text" id="editShiftStartTime"></div>
      <div class="form-group"><label>End Time</label><input type="text" id="editShiftEndTime"></div>
    </div>
    <div class="form-row">
      <div class="form-group"><label>Start Type</label><select id="editShiftStartType"></select></div>
      <div class="form-group"><label>Stop Type</label><select id="editShiftStopType"></select></div>
    </div>
    <div class="section-title" style="margin-top:8px;"><span>Players on Ice</span></div>
    <div id="editShiftPlayersContainer" style="background:var(--card);padding:8px;border-radius:4px;"></div>
    <!-- v20.6: Insert/Delete actions -->
    <div style="display:flex;gap:4px;margin-top:8px;padding-top:8px;border-top:1px solid var(--border);">
      <button class="btn-sm" onclick="insertShiftBefore()" title="Insert new shift before this one" style="flex:1;background:var(--accent2);">‚ûï Insert Before</button>
      <button class="btn-sm" onclick="insertShiftAfter()" title="Insert new shift after this one" style="flex:1;background:var(--accent2);">‚ûï Insert After</button>
      <button class="btn-sm" onclick="duplicateShift()" title="Duplicate this shift" style="flex:1;">üìã Duplicate</button>
    </div>
    <div class="modal-actions">
      <button class="btn-danger" onclick="deleteShift()">Delete</button>
      <button class="btn-primary" onclick="saveEditShift()">Save</button>
      <button onclick="closeEditShiftModal()">Cancel</button>
    </div>
  </div>
</div>

<!-- XY Edit Modal -->
<div class="overlay" id="xyEditModal">
  <div class="modal" style="min-width:400px;">
    <h3>üìç Edit XY Position</h3>
    <p style="font-size:9px;color:var(--muted);margin-bottom:8px;">Click on rink to set position</p>
    <svg id="xyEditSvg" viewBox="0 0 200 85" width="350" style="cursor:crosshair;background:var(--card);border-radius:4px;" onclick="handleXYEditClick(event)">
      <rect x="0" y="0" width="200" height="85" fill="#f8fafc" rx="14" ry="14" stroke="#1e293b" stroke-width="1"/>
      <line x1="75" y1="0" x2="75" y2="85" stroke="#1d4ed8" stroke-width="1.5"/>
      <line x1="125" y1="0" x2="125" y2="85" stroke="#1d4ed8" stroke-width="1.5"/>
      <line x1="100" y1="0" x2="100" y2="85" stroke="#dc2626" stroke-width="1" stroke-dasharray="3,2"/>
      <line x1="11" y1="0" x2="11" y2="85" stroke="#dc2626" stroke-width="0.8"/>
      <line x1="189" y1="0" x2="189" y2="85" stroke="#dc2626" stroke-width="0.8"/>
      <circle cx="100" cy="42.5" r="15" fill="none" stroke="#1d4ed8" stroke-width="0.8"/>
      <circle cx="31" cy="22" r="15" fill="none" stroke="#dc2626" stroke-width="0.5"/>
      <circle cx="31" cy="63" r="15" fill="none" stroke="#dc2626" stroke-width="0.5"/>
      <circle cx="169" cy="22" r="15" fill="none" stroke="#dc2626" stroke-width="0.5"/>
      <circle cx="169" cy="63" r="15" fill="none" stroke="#dc2626" stroke-width="0.5"/>
      <g id="xyEditMarker"></g>
    </svg>
    <div class="modal-actions">
      <button class="btn-primary" onclick="closeXYEditModal()">Done</button>
    </div>
  </div>
</div>

<!-- Generic Dynamic Modal (v23.4) -->
<div class="overlay" id="genericModal" onclick="if(event.target===this)closeModal()">
  <div class="modal" id="genericModalContent" style="min-width:400px;">
    <!-- Content will be inserted dynamically -->
  </div>
</div>

<!-- Event Confirmation Modal (v23.3) -->
<div class="overlay" id="confirmEventModal">
  <div class="modal" style="min-width:450px;max-width:550px;">
    <h3>‚úì Confirm Event</h3>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:12px;">
      <div class="form-group">
        <label>Type</label>
        <select id="confirmType" onchange="onConfirmTypeChange()"></select>
      </div>
      <div class="form-group">
        <label>Team</label>
        <select id="confirmTeam">
          <option value="home">Home</option>
          <option value="away">Away</option>
        </select>
      </div>
      <div class="form-group">
        <label>Detail 1</label>
        <select id="confirmD1" onchange="onConfirmD1Change()"></select>
      </div>
      <div class="form-group">
        <label>Detail 2</label>
        <select id="confirmD2"></select>
      </div>
      <div class="form-group">
        <label>Zone</label>
        <select id="confirmZone">
          <option value="">--</option>
          <option value="o">Offensive</option>
          <option value="d">Defensive</option>
          <option value="n">Neutral</option>
        </select>
      </div>
      <div class="form-group">
        <label>Success</label>
        <select id="confirmSuccess">
          <option value="">--</option>
          <option value="s">Successful</option>
          <option value="u">Unsuccessful</option>
        </select>
      </div>
      <div class="form-group">
        <label>Start Time</label>
        <input type="text" id="confirmStartTime" placeholder="MM:SS" oninput="autoFormatTime(this)">
      </div>
      <div class="form-group">
        <label>End Time</label>
        <input type="text" id="confirmEndTime" placeholder="MM:SS" oninput="autoFormatTime(this)">
      </div>
    </div>
    <div style="display:flex;gap:8px;margin-bottom:8px;">
      <div class="form-group" style="flex:1;">
        <label>Strength</label>
        <select id="confirmStrength">
          <option value="5v5">5v5</option>
          <option value="5v4">5v4</option>
          <option value="4v5">4v5</option>
          <option value="4v4">4v4</option>
          <option value="3v3">3v3</option>
          <option value="ENG">ENG</option>
        </select>
      </div>
      <div class="form-group" style="flex:1;">
        <label>Linked Event #</label>
        <input type="number" id="confirmLinked" placeholder="--" style="width:60px;">
      </div>
      <div class="form-group" style="flex:1;display:flex;align-items:center;padding-top:14px;">
        <label style="display:flex;align-items:center;gap:4px;font-size:9px;">
          <input type="checkbox" id="confirmHighlight" onchange="toggleConfirmHighlightFields()"> ‚≠ê Highlight
        </div>
        <!-- Video URL for highlights (v23.7) -->
        <div id="confirmHighlightVideoUrlRow" style="display:none;margin-top:4px;">
          <div class="form-group">
            <label style="font-size:8px;color:var(--muted);">YouTube URL for this highlight:</label>
            <input type="text" id="confirmVideoUrl" placeholder="https://youtube.com/watch?v=..." style="width:100%;font-size:9px;">
          </div>
        </div>
        </label>
      </div>
    </div>
    <div style="background:var(--panel);padding:6px 8px;border-radius:4px;margin-bottom:8px;">
      <label style="font-size:9px;color:var(--accent);font-weight:bold;margin-bottom:4px;display:block;">üë• Players & Play Details</label>
      <div style="font-size:8px;color:var(--muted);margin-bottom:6px;">Edit play details (PD1, PD2, Success, Pressure) for each player:</div>
      <div id="confirmPlayers" style="font-size:10px;max-height:250px;overflow-y:auto;"></div>
    </div>
    <div class="modal-actions" style="justify-content:space-between;">
      <button onclick="closeConfirmModal()">Cancel</button>
      <div style="display:flex;gap:8px;">
        <button onclick="confirmAndContinue()" style="background:var(--accent);color:#000;">‚úì Log & Continue</button>
        <button onclick="confirmAndLog()" class="btn-primary">‚úì Log Event</button>
      </div>
    </div>
  </div>
</div>

<!-- All Shifts Modal -->
<div class="overlay" id="allShiftsModal">
  <div class="modal" style="min-width:600px;max-width:800px;">
    <h3>üìã All Shifts (<span id="allShiftsCount">0</span>)</h3>
    <div class="table-wrap" style="max-height:400px;overflow-y:auto;">
      <table style="width:100%;font-size:10px;border-collapse:collapse;">
        <thead style="position:sticky;top:0;background:var(--card);">
          <tr><th>#</th><th>Period</th><th>Start</th><th>End</th><th>Start Type</th><th>Stop Type</th><th>Strength</th></tr>
        </thead>
        <tbody id="allShiftsBody"></tbody>
      </table>
    </div>
    <div class="modal-actions">
      <button onclick="document.getElementById('allShiftsModal').classList.remove('show')">Close</button>
    </div>
  </div>
</div>

<!-- All Events Modal -->
<div class="overlay" id="allEventsModal">
  <div class="modal" style="min-width:700px;max-width:900px;">
    <h3>üìã All Events (<span id="allEventsCount">0</span>)</h3>
    <div class="table-wrap" style="max-height:400px;overflow-y:auto;">
      <table style="width:100%;font-size:10px;border-collapse:collapse;">
        <thead style="position:sticky;top:0;background:var(--card);">
          <tr><th>#</th><th>Period</th><th>Time</th><th>Team</th><th>Type</th><th>Detail</th><th>Players</th></tr>
        </thead>
        <tbody id="allEventsBody"></tbody>
      </table>
    </div>
    <div class="modal-actions">
      <button onclick="document.getElementById('allEventsModal').classList.remove('show')">Close</button>
    </div>
  </div>
</div>

<!-- Full Box Score Modal -->
<div class="overlay" id="boxScoreModal">
  <div class="modal" style="min-width:700px;max-width:900px;">
    <h3>üìä Full Box Score</h3>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-bottom:16px;">
      <div style="background:var(--card);padding:12px;border-radius:6px;text-align:center;">
        <div style="font-size:12px;color:var(--muted);" id="boxModalHome">HOME</div>
        <div style="font-size:32px;font-weight:bold;" id="boxModalHomeScore">0</div>
        <div style="font-size:10px;color:var(--muted);">SOG: <span id="boxModalHomeSOG">0</span> | FO: <span id="boxModalHomeFO">0</span></div>
      </div>
      <div style="background:var(--card);padding:12px;border-radius:6px;text-align:center;">
        <div style="font-size:12px;color:var(--muted);" id="boxModalAway">AWAY</div>
        <div style="font-size:32px;font-weight:bold;" id="boxModalAwayScore">0</div>
        <div style="font-size:10px;color:var(--muted);">SOG: <span id="boxModalAwaySOG">0</span> | FO: <span id="boxModalAwayFO">0</span></div>
      </div>
    </div>
    <div class="table-wrap" style="max-height:300px;overflow-y:auto;">
      <table style="width:100%;font-size:11px;border-collapse:collapse;">
        <thead style="position:sticky;top:0;background:var(--card);">
          <tr><th>#</th><th>Player</th><th>Pos</th><th>G</th><th>A</th><th>PTS</th><th>SOG</th><th>FO%</th><th>TOI</th><th>PIM</th></tr>
        </thead>
        <tbody id="boxModalBody"></tbody>
      </table>
    </div>
    <div class="modal-actions">
      <button onclick="document.getElementById('boxScoreModal').classList.remove('show')">Close</button>
    </div>
  </div>
</div>

<!-- Player Detail Modal -->
<div class="overlay" id="playerDetailModal">
  <div class="modal" style="min-width:400px;">
    <h3>üë§ <span id="playerDetailName">Player</span></h3>
    <div style="display:grid;grid-template-columns:repeat(4, 1fr);gap:8px;margin-bottom:16px;">
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:20px;font-weight:bold;" id="pdGoals">0</div>
        <div style="font-size:9px;color:var(--muted);">Goals</div>
      </div>
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:20px;font-weight:bold;" id="pdAssists">0</div>
        <div style="font-size:9px;color:var(--muted);">Assists</div>
      </div>
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:20px;font-weight:bold;" id="pdShots">0</div>
        <div style="font-size:9px;color:var(--muted);">SOG</div>
      </div>
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:20px;font-weight:bold;" id="pdFO">0%</div>
        <div style="font-size:9px;color:var(--muted);">FO%</div>
      </div>
    </div>
    <div style="display:grid;grid-template-columns:repeat(3, 1fr);gap:8px;margin-bottom:16px;">
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:16px;font-weight:bold;" id="pdTOI">--:--</div>
        <div style="font-size:9px;color:var(--muted);">TOI</div>
      </div>
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:16px;font-weight:bold;" id="pdHits">0</div>
        <div style="font-size:9px;color:var(--muted);">Hits</div>
      </div>
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:16px;font-weight:bold;" id="pdBlocks">0</div>
        <div style="font-size:9px;color:var(--muted);">Blocks</div>
      </div>
    </div>
    <div style="font-size:10px;color:var(--muted);margin-bottom:8px;">Recent Events:</div>
    <div id="pdRecentEvents" style="max-height:150px;overflow-y:auto;background:var(--card);border-radius:4px;padding:8px;font-size:9px;"></div>
    <div class="modal-actions">
      <button onclick="document.getElementById('playerDetailModal').classList.remove('show')">Close</button>
    </div>
  </div>
</div>

<!-- Toast -->
<div class="toast" id="toast"></div>

<script>
// ============================================================
// STATE
// ============================================================
const S = {
  sb: null, connected: false,
  saveDirectoryHandle: null, // v23.8: File System Access API directory handle
  maxBackups: 10, // v23.8: Maximum number of backup files to keep
  gameId: null, games: [], rosters: { home: [], away: [] },
  homeTeam: 'Home', awayTeam: 'Away', homeColor: '#3b82f6', awayColor: '#ef4444',
  homeLogo: null, awayLogo: null,
  teams: {},  // v15.01: Team data from dim_team
  // Reference data from Supabase
  playDetails1: [],  // dim_play_detail
  playDetails2: [],  // dim_play_detail_2
  eventDetails1: [], // dim_event_detail (v16.06)
  eventDetails2: [], // dim_event_detail_2 (v16.06)
  eventTypesDB: [],  // dim_event_type (v22.1)
  showAllEventTypes: false, // v22.1: Toggle for showing all event types
  playerRoles: [],   // dim_player_role
  period: 1, evtTeam: 'home', 
  // v23.5: Per-period lengths (NORAD default varies)
  periodLengths: { 1: 18, 2: 18, 3: 18, OT: 5 },
  // v23.8: Penalty lengths (configurable)
  penaltyLengths: { minor: 2, major: 5, misconduct: 10 },
  periodLength: 18, // Legacy - use getPeriodLength() instead
  homeAttacksRightP1: true, // v19: Configurable per game - which end home attacks in P1
  slots: { home: {F1:null,F2:null,F3:null,D1:null,D2:null,G:null,X:null}, away: {F1:null,F2:null,F3:null,D1:null,D2:null,G:null,X:null} },
  selectedSlot: null, events: [], shifts: [], evtIdx: 0, shiftIdx: 0,
  curr: { type: null, players: [], puckXY: [], netXY: null },
  selectedPlayer: null, xyMode: 'puck', xySlot: 1,
  editingEvtIdx: null, editingShiftIdx: null, lastEndTime: '18:00',
  editingXYType: null, editingXYIdx: null, editingXYPlayerIdx: null, // For XY editing in modal
  xyHistory: [], // For undo
  lastSave: null, saveTimer: null,
  linkedEventIdx: null, // For linked plays (e.g., Shot->Save sequences)
  assistToGoalIdx: null, // v23.8: For Pass events that assist a Goal (separate from linked events)
  // Video timing - variable intermissions and stoppages
  videoTiming: {
    videoStartOffset: 0,        // Seconds to skip at video start (pre-game, warmups)
    intermission1: 900,         // Seconds after P1 (default 15 min)
    intermission2: 900,         // Seconds after P2 (default 15 min)
    intermission3: 300,         // Seconds after P3 if OT (default 5 min)
    timeouts: [],               // Array of {period, gameTime, duration} objects
    youtubeUrl: ''              // Optional YouTube link for this game (legacy)
  },
  // v23.6: Video management - multiple videos per game
  videos: [],                   // Array of {id, url, type, video_id, title, description, start_time, end_time, period, notes}
  // v15.01: Video player state
  videoPlayer: {
    sources: [],                // Array of {id, name, type:'youtube'|'file', url, hotkey}
    currentSourceIdx: 0,
    isPlaying: false,
    currentTime: 0,
    speed: 1,
    autoSync: true,             // Auto-populate start/end times from video
    ytPlayer: null,             // YouTube IFrame API player instance
    gameMarkers: {              // Video timestamps for game events (in seconds)
      P1Start: null, P1End: null,
      P2Start: null, P2End: null,
      P3Start: null, P3End: null,
      OTStart: null, OTEnd: null,
      stoppages: []             // Array of {startTime, endTime, type, note}
    }
  }
};

// ============================================================
// v23.5: PERIOD LENGTH HELPERS
// ============================================================

/**
 * Get the length of a specific period in minutes
 * @param {number|string} period - Period number (1, 2, 3) or 'OT'
 * @returns {number} Period length in minutes
 */
function getPeriodLength(period) {
  const p = String(period).toUpperCase();
  if (p === 'OT' || p === '4') {
    return S.periodLengths?.OT || 5;
  }
  const num = parseInt(period) || 1;
  return S.periodLengths?.[num] || S.periodLength || 18;
}

/**
 * Get the length of a specific period in seconds
 */
function getPeriodLengthSeconds(period) {
  return getPeriodLength(period) * 60;
}

/**
 * Update periodLengths from UI inputs
 */
function updatePeriodLengthsFromUI() {
  S.periodLengths = {
    1: parseInt(document.getElementById('periodLength1')?.value) || 18,
    2: parseInt(document.getElementById('periodLength2')?.value) || 18,
    3: parseInt(document.getElementById('periodLength3')?.value) || 18,
    OT: parseInt(document.getElementById('periodLengthOT')?.value) || 5
  };
  // Keep legacy field in sync with P1 for compatibility
  S.periodLength = S.periodLengths[1];
  document.getElementById('periodLength').value = S.periodLength;
  
  // Update the period length indicator for current period
  updatePeriodLengthIndicator();
  
  // Update clock if it shows full period time
  const clock = document.getElementById('clock')?.value;
  if (clock) {
    const oldLen = parseInt(clock.split(':')[0]);
    if (oldLen >= 15 && oldLen <= 25) {
      // Looks like start of period - update to new length
      const currentLen = getPeriodLength(S.period);
      document.getElementById('clock').value = `${currentLen}:00`;
    }
  }
  
  toast('Period lengths updated', 'info');
}

/**
 * v23.8: Update penalty lengths from UI inputs
 */
function updatePenaltyLengthsFromUI() {
  S.penaltyLengths = {
    minor: parseInt(document.getElementById('penaltyLengthMinor')?.value) || 2,
    major: parseInt(document.getElementById('penaltyLengthMajor')?.value) || 5,
    misconduct: parseInt(document.getElementById('penaltyLengthMisconduct')?.value) || 10
  };
}

/**
 * Update the period length indicator in header
 */
function updatePeriodLengthIndicator() {
  const indicator = document.getElementById('periodLengthIndicator');
  if (indicator) {
    const currentLen = getPeriodLength(S.period);
    const lengths = S.periodLengths || { 1: 18, 2: 18, 3: 18, OT: 5 };
    
    // Show all period lengths if they differ
    const allSame = lengths[1] === lengths[2] && lengths[2] === lengths[3];
    if (allSame) {
      indicator.textContent = `(${currentLen}m)`;
      indicator.title = `All periods: ${lengths[1]}m, OT: ${lengths.OT}m`;
    } else {
      indicator.textContent = `(P${S.period}: ${currentLen}m)`;
      indicator.title = `P1: ${lengths[1]}m, P2: ${lengths[2]}m, P3: ${lengths[3]}m, OT: ${lengths.OT}m`;
    }
  }
}

/**
 * Update UI inputs from periodLengths
 */
function updatePeriodLengthsUI() {
  if (S.periodLengths) {
    document.getElementById('periodLength1').value = S.periodLengths[1] || 18;
    document.getElementById('periodLength2').value = S.periodLengths[2] || 18;
    document.getElementById('periodLength3').value = S.periodLengths[3] || 18;
    document.getElementById('periodLengthOT').value = S.periodLengths.OT || 5;
  }
  
  // v23.8: Load penalty lengths
  if (S.penaltyLengths) {
    document.getElementById('penaltyLengthMinor').value = S.penaltyLengths.minor || 2;
    document.getElementById('penaltyLengthMajor').value = S.penaltyLengths.major || 5;
    document.getElementById('penaltyLengthMisconduct').value = S.penaltyLengths.misconduct || 10;
  } else {
    // Initialize with defaults if not set
    S.penaltyLengths = { minor: 2, major: 5, misconduct: 10 };
    document.getElementById('penaltyLengthMinor').value = 2;
    document.getElementById('penaltyLengthMajor').value = 5;
    document.getElementById('penaltyLengthMisconduct').value = 10;
  }
  updatePeriodLengthIndicator();
}

/**
 * Get total elapsed time at start of a period (for video sync)
 * Accounts for variable period lengths and intermissions
 */
function getElapsedAtPeriodStart(period) {
  const p = parseInt(period) || 1;
  let elapsed = 0;
  
  for (let i = 1; i < p; i++) {
    elapsed += getPeriodLengthSeconds(i);
    // Add intermission after each period
    if (i === 1) elapsed += (S.videoTiming?.intermission1 || 900);
    if (i === 2) elapsed += (S.videoTiming?.intermission2 || 900);
    if (i === 3) elapsed += (S.videoTiming?.intermission3 || 300);
  }
  
  return elapsed;
}

// ============================================================
// DROPDOWN OPTIONS
// ============================================================
const LISTS = {
  eventTypes: ['Faceoff','Shot','Pass','Goal','Turnover','Zone_Entry_Exit','Penalty','Stoppage','Possession','Save','Rebound','DeadIce','Play','Intermission','Clockstop','Timeout'],
  hotkeys: { Faceoff:'F', Shot:'S', Pass:'P', Goal:'G', Turnover:'T', Zone_Entry_Exit:'Z', Penalty:'N', Stoppage:'X', Possession:'O', Save:'V', Rebound:'R', DeadIce:'D', Play:'Y', Intermission:'I', Clockstop:'C' },
  details: {
    Shot: { d1: ['Shot_OnNetSaved','Shot_Missed','Shot_Blocked','Shot_BlockedSameTeam','Shot_Deflected','Shot_OnNetGoal'], d2: ['Shot-Wrist','Shot-Slap','Shot-Backhand','Shot-Snap','Shot-WrapAround','Shot-Bat','Shot-Poke','Shot-OneTime','Shot-Tip','Shot-Deflection','Shot-Other'] },
    Pass: { d1: ['Pass_Completed','Pass_Missed','Pass_Deflected','Pass_Intercepted'], d2: ['Pass-Stretch','Pass-Rim/Wrap','Pass-Backhand','Pass-Forehand','Pass-Bank','Pass-Dump','Pass-Drop','Pass-OneTouch','Pass-Other'] },
    Goal: { d1: ['Goal_Scored','Goal_Shootout','Goal_PenaltyShot'], d2: ['Goal-Wrist','Goal-Slap','Goal-Backhand','Goal-Tip','Goal-Snap','Goal-WrapAround','Goal-Deflection','Goal-OneTime','Goal-Other'] },
    Faceoff: { d1: ['Faceoff_PeriodStart','Faceoff_GameStart','Faceoff_AfterGoal','Faceoff_AfterPenalty','Faceoff_AfterStoppage'], d2: [] },
    Turnover: { d1: ['Turnover_Giveaway','Turnover_Takeaway'], d2_Giveaway: ['Giveaway-Misplayed','Giveaway-BattleLost','Giveaway-PassIntercepted','Giveaway-Other'], d2_Takeaway: ['Takeaway-BattleWon','Takeaway-PokeCheck','Takeaway-PassIntercepted','Takeaway-Other'] },
    Zone_Entry_Exit: { d1: ['Zone_Entry','Zone_Exit','Zone_Keepin','Zone_EntryFailed','Zone_ExitFailed'], d2_Entry: ['ZoneEntry-Rush','ZoneEntry-Pass','ZoneEntry-DumpIn','ZoneEntry-Chip'], d2_Exit: ['ZoneExit-Rush','ZoneExit-Pass','ZoneExit-Clear','ZoneExit-Chip'] },
    Save: { d1: ['Save_Rebound','Save_Freeze','Save_Played'], d2: ['Save-Glove','Save-Blocker','Save-Pad','Save-Stick','Save-Butterfly','Save-Other'] },
    Stoppage: { d1: ['Stoppage_PeriodEnd','Stoppage_Play','Stoppage_Other','Stoppage_GameEnd'], d2_Play: ['Stoppage-Icing','Stoppage-Offsides','Stoppage-GoalieStoppage','Stoppage-PuckOut','Stoppage-Penalty','Stoppage-Goal'] },
    Penalty: { d1: ['Penalty_Minor','Penalty_Major','Penalty_Misconduct'], d2: ['Penalty-Tripping','Penalty-Hooking','Penalty-Slashing','Penalty-Interference','Penalty-Holding','Penalty-Roughing','Penalty-HighSticking','Penalty-CrossChecking','Penalty-Boarding','Penalty-Other'] },
    Possession: { d1: ['Breakaway','PuckRetrieval','PuckRecovery','Regroup','LoosePuck'], d2: [] },
    Rebound: { d1: ['Rebound_TeamRecovered','Rebound_OppRecovered','Rebound_ShotGenerated'], d2: [] },
    DeadIce: { d1: ['DeadIce_Icing','DeadIce_Offside','DeadIce_PuckOut','DeadIce_NetOff','DeadIce_Other'], d2: [] },
    Play: { d1: ['Play_Offensive','Play_Defensive'], d2_Offensive: ['Play-DriveMiddle','Play-DriveWide','Play-CrashNet','Play-Deke','Play-DumpChase','Play-Forecheck'], d2_Defensive: ['Play-PokeCheck','Play-Backcheck','Play-Contain','Play-BoxOut'] },
    Intermission: { d1: ['Intermission_Period1','Intermission_Period2','Intermission_Period3','Intermission_OT'], d2: [] },
    Clockstop: { d1: ['Clockstop_Injury','Clockstop_Equipment','Clockstop_IceRepair','Clockstop_Other'], d2: [] },
    Timeout: { d1: ['Timeout_Home','Timeout_Away'], d2: [] }
  },
  shiftStart: ['GameStart','PeriodStart','FaceoffAfterGoal','FaceoffAfterPenalty','OtherFaceoff','Stoppage','Intermission','OnTheFly'],
  shiftStop: ['','OnTheFly','PeriodEnd','Period End','GoalScored','Home Goal','Away Goal','Penalty','Stoppage','OtherFaceoff','Intermission','GameEnd','High Stick','Away Icing','Home Icing','Away Offside','Home Offside','Puck Out of Play','Away Goalie Stopped (after Home SOG)','Home Goalie Stopped (after Away SOG)'],
  playOffensive: ['Play-DriveMiddle','Play-DriveWide','Play-CrashNet','Play-Delay','Play-Deke','Play-DumpChase','Play-Forecheck','Play-Other'],
  playDefensive: ['Play-PokeCheck','Play-Backcheck','Play-Contain','Play-BoxOut','Play-Other'],
  // Events where puck XY = event_player_1 XY
  possessionEvents: ['Possession','Zone_Entry_Exit'],
  possessionDetails: ['ZoneEntry-Rush','ZoneExit-Rush','Breakaway','PuckRetrieval','PuckRecovery','Regroup'],
  // Suggested next events based on current event
  nextEventSuggestions: {
    'Faceoff': ['Pass', 'Possession', 'Turnover'],
    'Pass': ['Shot', 'Pass', 'Turnover', 'Zone_Entry_Exit'],
    'Shot': ['Save', 'Goal', 'Rebound'],
    'Save': ['Rebound', 'Pass', 'Stoppage'],
    'Goal': ['Faceoff', 'Stoppage'],
    'Rebound': ['Shot', 'Possession', 'Turnover'],
    'Zone_Entry_Exit': ['Pass', 'Shot', 'Possession'],
    'Turnover': ['Pass', 'Shot', 'Zone_Entry_Exit'],
    'Possession': ['Pass', 'Shot', 'Zone_Entry_Exit'],
    'Penalty': ['Faceoff', 'Stoppage'],
    'Stoppage': ['Faceoff', 'Intermission']
  },
  // Events that can be linked (sequence)
  linkedEvents: {
    'Shot': ['Pass', 'Rebound'], // Shot can link to preceding Pass or following Rebound
    'Goal': ['Shot', 'Pass'], // Goal links to Shot (the goal shot) or Pass (assist)
    'Save': ['Shot'], // Save links to Shot
    'Rebound': ['Shot', 'Save'] // Rebound links to Shot or Save
  },
  // v23.9: Video dim table options (hard-coded from dim_video_type and dim_highlight_category)
  // dim_video_type values
  videoTypes: ['Full_Ice', 'Broadcast', 'Highlights', 'Goalie', 'Overhead', 'Wide', 'Tight', 'Replay', 'Other'],
  // dim_highlight_category values (for highlight categorization)
  highlightCategories: ['Goal', 'Save', 'Hit', 'Fight', 'Breakaway', 'Penalty_Shot', 'Sequence', 'Momentum', 'Skill', 'Other'],
  // Video source/platform options
  videoSources: ['YouTube', 'Vimeo', 'Local', 'Stream', 'Other']
};

// ============================================================
// INIT
// ============================================================
async function init() {
  try {
    console.log('BenchSight v23.9 initializing...');
    loadSettings();
    loadAutoSettings(); // v23.8: Load auto-detection settings
    initCollapsibleSections(); // v23.9: Initialize collapsible sections
    setupRinkEventListeners(); // v23.4: Attach rink mouse handlers
    loadVideoSources(); // v23.4: Load saved video sources

    // Initialize connection status
    if (S.connected === undefined) S.connected = false;

    await tryConnect();
    buildUI();
    
    // Update connection status UI after buildUI creates the element
    updateConn(S.connected);
    
    restorePanelWidths(); // v23.8: Restore saved panel widths
    adjustLayoutForScreenSize(); // v23.8: Adjust for screen size
    initSaveFolderUI();  // Initialize save folder UI (after buildUI)
    loadFromStorage();
    setupKeys();
    setupTimeInputs(); // v5: Auto-format time inputs
    
    // v23.8: Load saved directory handle (non-blocking, don't fail if it errors)
    loadDirectoryHandle().catch(e => {
      console.error('Failed to load directory handle:', e);
      // Don't break initialization if this fails
    });
    
    startAutoSave();
    await loadGames();
    if (S.gameId) await selectGame(S.gameId);
    updateSaveIndicator();
    updateNextPlaySuggestions();
    updateZoneLabels();
    console.log('Ready:', S.events.length, 'events,', S.shifts.length, 'shifts');
  } catch (e) {
    console.error('Fatal error during initialization:', e);
    alert('Error initializing tracker. Check console for details. Error: ' + e.message);
  }
}

/**
 * v23.4: Attach event listeners to rink SVG
 */
function setupRinkEventListeners() {
  const svg = document.getElementById('rinkSvg');
  if (!svg) return;
  
  svg.addEventListener('mousedown', handleRinkMouseDown);
  svg.addEventListener('mousemove', (e) => {
    handleRinkMouseMove(e);
    handleRinkHover(e);
  });
  svg.addEventListener('mouseup', handleRinkMouseUp);
  svg.addEventListener('mouseleave', () => {
    hideXYTooltip();
    hideDragPreview();
  });
}

function loadSettings() {
  try {
    const s = JSON.parse(localStorage.getItem('bs_settings') || '{}');
    if (s.sbUrl) document.getElementById('sbUrl').value = s.sbUrl;
    if (s.sbKey) document.getElementById('sbKey').value = s.sbKey;
    if (s.autoSaveInt) document.getElementById('autoSaveInt').value = s.autoSaveInt;
    if (s.pressureDist) document.getElementById('pressureDist').value = s.pressureDist;
    if (s.xyHistCnt) document.getElementById('xyHistCnt').value = s.xyHistCnt;
    if (s.periodLength) {
      document.getElementById('periodLength').value = s.periodLength;
      S.periodLength = parseInt(s.periodLength);
    }
    if (s.otLength) document.getElementById('otLength').value = s.otLength;
    
    // v23.8: Load penalty lengths
    S.penaltyLengths = S.penaltyLengths || { minor: 2, major: 5, misconduct: 10 };
    if (s.penaltyLengthMinor !== undefined) {
      S.penaltyLengths.minor = parseInt(s.penaltyLengthMinor) || 2;
      const minorEl = document.getElementById('penaltyLengthMinor');
      if (minorEl) minorEl.value = S.penaltyLengths.minor;
    }
    if (s.penaltyLengthMajor !== undefined) {
      S.penaltyLengths.major = parseInt(s.penaltyLengthMajor) || 5;
      const majorEl = document.getElementById('penaltyLengthMajor');
      if (majorEl) majorEl.value = S.penaltyLengths.major;
    }
    if (s.penaltyLengthMisconduct !== undefined) {
      S.penaltyLengths.misconduct = parseInt(s.penaltyLengthMisconduct) || 10;
      const misconductEl = document.getElementById('penaltyLengthMisconduct');
      if (misconductEl) misconductEl.value = S.penaltyLengths.misconduct;
    }
  } catch(e) {}
}

function saveSettings() {
  const s = {
    sbUrl: document.getElementById('sbUrl').value,
    sbKey: document.getElementById('sbKey').value,
    autoSaveInt: document.getElementById('autoSaveInt').value,
    pressureDist: document.getElementById('pressureDist').value,
    xyHistCnt: document.getElementById('xyHistCnt').value,
    periodLength: document.getElementById('periodLength').value,
    otLength: document.getElementById('otLength').value,
    // v23.8: Save penalty lengths
    penaltyLengthMinor: document.getElementById('penaltyLengthMinor').value,
    penaltyLengthMajor: document.getElementById('penaltyLengthMajor').value,
    penaltyLengthMisconduct: document.getElementById('penaltyLengthMisconduct').value
  };
  localStorage.setItem('bs_settings', JSON.stringify(s));
  
  // v23.8: Save JSON export preference
  const exportJsonOnSaveEl = document.getElementById('exportJsonOnSave');
  if (exportJsonOnSaveEl) {
    localStorage.setItem('bs_exportJsonOnSave', exportJsonOnSaveEl.checked ? 'true' : 'false');
  }
  S.periodLength = parseInt(s.periodLength) || 18;
  
  // v23.8: Update penalty lengths
  S.penaltyLengths = {
    minor: parseInt(s.penaltyLengthMinor) || 2,
    major: parseInt(s.penaltyLengthMajor) || 5,
    misconduct: parseInt(s.penaltyLengthMisconduct) || 10
  };
  
  // Update clock to match period length
  if (S.period !== 'OT') {
    document.getElementById('clock').value = S.periodLength + ':00';
  }
  
  closeSettings();
  toast('Settings saved', 'success');
  tryConnect();
  startAutoSave();
}

async function tryConnect() {
  // v23.8: Ensure connected is initialized
  if (S.connected === undefined) S.connected = false;
  
  const sbUrlEl = document.getElementById('sbUrl');
  const sbKeyEl = document.getElementById('sbKey');
  if (!sbUrlEl || !sbKeyEl) {
    updateConn(false);
    return;
  }
  
  const url = sbUrlEl.value?.trim();
  const key = sbKeyEl.value?.trim();
  if (!url || !key) { 
    updateConn(false); 
    return; 
  }
  try {
    if (typeof supabase === 'undefined') {
      console.error('Supabase library not loaded');
      updateConn(false);
      return;
    }
    S.sb = supabase.createClient(url, key);
    // Try to query a table that exists
    const { data, error } = await S.sb.from('dim_schedule').select('game_id').limit(1);
    if (error) {
      console.error('Supabase query error:', error);
      // Provide helpful error messages
      if (error.message?.includes('permission denied') || error.code === '42501') {
        toast('RLS is blocking queries. Disable RLS in Supabase SQL Editor.', 'error');
      } else if (error.message?.includes('does not exist') || error.code === '42P01') {
        toast('Tables not found. Run upload.py --schema then upload.py', 'error');
      } else {
        toast('Connection error: ' + (error.message || error.code), 'error');
      }
      throw error;
    }
    S.connected = true;
    updateConn(true);
    
    // Load reference data (play details, player roles)
    await loadReferenceData();
  } catch(e) { 
    console.error('Connection failed:', e);
    S.sb = null; 
    S.connected = false; 
    updateConn(false); 
  }
}

/**
 * Load reference data from Supabase (dim tables)
 */
async function loadReferenceData() {
  if (!S.connected) return;
  
  try {
    // Load dim_play_detail
    const { data: pd1, error: e1 } = await S.sb.from('dim_play_detail')
      .select('play_detail_id,play_detail_name,play_category')
      .order('play_detail_name');
    
    if (!e1 && pd1) {
      S.playDetails1 = pd1.map(p => ({
        id: p.play_detail_id,
        name: p.play_detail_name,
        category: p.play_category
      }));
      console.log('Loaded', S.playDetails1.length, 'play details 1');
    }
    
    // Load dim_play_detail_2
    const { data: pd2, error: e2 } = await S.sb.from('dim_play_detail_2')
      .select('play_detail_2_id,play_detail_2_name,play_category')
      .order('play_detail_2_name');
    
    if (!e2 && pd2) {
      S.playDetails2 = pd2.map(p => ({
        id: p.play_detail_2_id,
        name: p.play_detail_2_name,
        category: p.play_category
      }));
      console.log('Loaded', S.playDetails2.length, 'play details 2');
    }
    
    // v16.06: Load dim_event_detail for event detail 1 dropdown
    const { data: ed1, error: e2a } = await S.sb.from('dim_event_detail')
      .select('event_detail_id,event_detail_code,event_detail_name,event_type')
      .order('event_type,event_detail_name');
    
    if (!e2a && ed1) {
      S.eventDetails1 = ed1.map(e => ({
        id: e.event_detail_id,
        code: e.event_detail_code || '',
        name: e.event_detail_name,
        eventType: e.event_type
      }));
      console.log('Loaded', S.eventDetails1.length, 'event details 1');
    }
    
    // v16.08: Load dim_event_detail_2 for event detail 2 dropdown
    // Note: category is "other" for most entries, so we filter by code prefix
    const { data: ed2, error: e2b } = await S.sb.from('dim_event_detail_2')
      .select('event_detail_2_id,event_detail_2_code,event_detail_2_name,category')
      .order('event_detail_2_code');
    
    if (!e2b && ed2) {
      S.eventDetails2 = ed2.map(e => ({
        id: e.event_detail_2_id,
        code: e.event_detail_2_code,  // e.g., "ZoneEntry_Rush"
        name: e.event_detail_2_name,   // e.g., "ZoneEntry Rush"
        category: e.category
      }));
      console.log('Loaded', S.eventDetails2.length, 'event details 2');
    }
    
    // v22.1: Load dim_event_type for event type buttons
    const { data: et, error: etErr } = await S.sb.from('dim_event_type')
      .select('event_type_id,event_type_code,event_type_name,event_category')
      .order('event_type_code');
    
    if (!etErr && et) {
      S.eventTypesDB = et.map(e => ({
        id: e.event_type_id,
        code: e.event_type_code,
        name: e.event_type_name,
        category: e.event_category
      }));
      console.log('Loaded', S.eventTypesDB.length, 'event types from dim_event_type');
      // Rebuild UI to use dynamic event types
      buildEventTypeButtons();
    }
    
    // Load dim_player_role
    const { data: roles, error: e3 } = await S.sb.from('dim_player_role')
      .select('role_id,role_code,role_name,role_type,sort_order')
      .order('sort_order');
    
    if (!e3 && roles) {
      S.playerRoles = roles.map(r => ({
        id: r.role_id,
        code: r.role_code,
        name: r.role_name,
        type: r.role_type,
        order: r.sort_order
      }));
      console.log('Loaded', S.playerRoles.length, 'player roles');
    }
    
    // v15.01: Load dim_team for colors and logos
    const { data: teams, error: e4 } = await S.sb.from('dim_team')
      .select('team_id,team_name,team_color1,team_color2,team_logo');
    
    if (!e4 && teams) {
      S.teams = {};
      teams.forEach(t => {
        S.teams[t.team_name] = {
          id: t.team_id,
          name: t.team_name,
          color1: t.team_color1 || '#3b82f6',
          color2: t.team_color2 || '#1e40af',
          logo: t.team_logo || null
        };
      });
      console.log('Loaded', Object.keys(S.teams).length, 'teams');
    }
    
  } catch(e) {
    console.error('Error loading reference data:', e);
  }
}

async function testConn() {
  await tryConnect();
  toast(S.connected ? '‚úÖ Connected to Supabase!' : '‚ùå Connection failed', S.connected ? 'success' : 'error');
}

function updateConn(on) {
  const el = document.getElementById('connStatus');
  if (!el) return; // v23.8: Guard if element doesn't exist
  el.textContent = on ? 'ONLINE' : 'OFFLINE';
  el.className = 'conn ' + (on ? 'on' : 'off');
}

function openSettings() {
  // v23.8: Ensure penalty lengths are initialized before showing modal
  if (!S.penaltyLengths) {
    S.penaltyLengths = { minor: 2, major: 5, misconduct: 10 };
  }
  updatePeriodLengthsUI(); // This will also update penalty lengths UI
  updateSaveFolderDisplay(); // v23.8: Update save folder display
  const modal = document.getElementById('settingsModal');
  if (modal) modal.classList.add('show');
}

function closeSettings() { 
  const modal = document.getElementById('settingsModal');
  if (modal) modal.classList.remove('show');
}
function openHelp() { 
  const modal = document.getElementById('helpModal');
  if (modal) modal.classList.add('show');
}
function closeHelp() { 
  const modal = document.getElementById('helpModal');
  if (modal) modal.classList.remove('show');
}

/**
 * Open the full user guide in a new tab
 */
function openUserGuide() {
  // Try to open the guide file
  const guideUrl = 'TRACKER_USER_GUIDE_v23.4.md';
  
  // Create a modal with the guide content if file not accessible
  const html = `
    <h3>üìñ BenchSight Tracker v23.4 User Guide</h3>
    <p style="font-size:11px;color:var(--muted);margin-bottom:12px;">
      The complete user guide covers all features in detail.
    </p>
    
    <div style="max-height:400px;overflow-y:auto;background:var(--panel);padding:12px;border-radius:4px;font-size:10px;line-height:1.6;">
      <h4 style="color:var(--accent);margin-bottom:8px;">üìã Table of Contents</h4>
      <ol style="margin-left:16px;">
        <li><strong>Quick Start</strong> - First time setup, basic workflow</li>
        <li><strong>Interface Overview</strong> - Layout diagram, color coding</li>
        <li><strong>Video Playback</strong> - Loading, controls, multi-source, clock sync</li>
        <li><strong>Event Tracking</strong> - Types, details, players, logging</li>
        <li><strong>XY Positioning</strong> - Modes, smart linking, drag creation</li>
        <li><strong>Shift Tracking</strong> - Recording, line presets</li>
        <li><strong>Workflow Automation</strong> - Chains, templates, auto-features</li>
        <li><strong>Data Management</strong> - Saving, export/import, rosters</li>
        <li><strong>Keyboard Shortcuts</strong> - Complete reference table</li>
        <li><strong>Tips & Best Practices</strong> - Workflows, troubleshooting</li>
      </ol>
      
      <h4 style="color:var(--accent);margin:16px 0 8px;">üé¨ Video Hotkeys (v23.4)</h4>
      <table style="width:100%;border-collapse:collapse;">
        <tr><td style="padding:2px 8px;border-bottom:1px solid var(--border);"><kbd>Space</kbd></td><td>Play/Pause</td></tr>
        <tr><td style="padding:2px 8px;border-bottom:1px solid var(--border);"><kbd>‚Üê</kbd> / <kbd>‚Üí</kbd></td><td>Seek ¬±1s</td></tr>
        <tr><td style="padding:2px 8px;border-bottom:1px solid var(--border);"><kbd>Shift+‚Üê/‚Üí</kbd></td><td>Seek ¬±10s</td></tr>
        <tr><td style="padding:2px 8px;border-bottom:1px solid var(--border);"><kbd>‚Üë</kbd> / <kbd>‚Üì</kbd></td><td>Speed up/down</td></tr>
        <tr><td style="padding:2px 8px;border-bottom:1px solid var(--border);"><kbd>;</kbd> / <kbd>'</kbd></td><td>Frame step</td></tr>
        <tr><td style="padding:2px 8px;border-bottom:1px solid var(--border);"><kbd>+</kbd> / <kbd>-</kbd></td><td>Zoom in/out</td></tr>
        <tr><td style="padding:2px 8px;"><kbd>Ctrl+1-9</kbd></td><td>Switch video source</td></tr>
      </table>
      
      <h4 style="color:var(--accent);margin:16px 0 8px;">‚ö° Quick Workflows</h4>
      <p><strong>Shot:</strong> Drag from shooter toward net ‚Üí Auto-creates shot with XY</p>
      <p><strong>Pass:</strong> Drag from passer to receiver ‚Üí Auto-creates pass with XY</p>
      <p><strong>Hit:</strong> Add players ‚Üí Click puck ‚Üí üìç All Here</p>
      <p><strong>Faceoff:</strong> Click faceoff dot ‚Üí Auto-positions players</p>
    </div>
    
    <div class="modal-actions" style="margin-top:12px;display:flex;justify-content:space-between;">
      <a href="TRACKER_USER_GUIDE_v23.4.md" download class="btn-sm" style="background:var(--accent);color:#000;text-decoration:none;padding:6px 12px;">üì• Download Guide (Markdown)</a>
      <button class="btn-primary" onclick="closeModal()">Close</button>
    </div>
  `;
  
  showModal(html);
}

// ============================================================
// VIDEO TIMING FUNCTIONS
// ============================================================
function openVideoTimingModal() {
  // Populate fields from S.videoTiming and S.periodLengths
  document.getElementById('vtVideoStartOffset').value = S.videoTiming.videoStartOffset || 0;
  
  // Populate per-period lengths
  document.getElementById('vtPeriodLength1').value = S.periodLengths?.[1] || 18;
  document.getElementById('vtPeriodLength2').value = S.periodLengths?.[2] || 18;
  document.getElementById('vtPeriodLength3').value = S.periodLengths?.[3] || 18;
  document.getElementById('vtPeriodLengthOT').value = S.periodLengths?.OT || 5;
  
  document.getElementById('vtIntermission1').value = S.videoTiming.intermission1 || 900;
  document.getElementById('vtIntermission2').value = S.videoTiming.intermission2 || 900;
  document.getElementById('vtIntermission3').value = S.videoTiming.intermission3 || 300;
  document.getElementById('vtYoutubeUrl').value = S.videoTiming.youtubeUrl || '';
  
  renderVideoTimeouts();
  renderVideos(); // v23.6: Render video list
  updateVideoTimingPreview();
  document.getElementById('videoTimingModal').classList.add('show');
}

function closeVideoTimingModal() {
  document.getElementById('videoTimingModal').classList.remove('show');
}

/**
 * Sync period lengths from Video Timing modal to Settings
 */
function syncPeriodLengthsFromVT() {
  S.periodLengths = {
    1: parseInt(document.getElementById('vtPeriodLength1')?.value) || 18,
    2: parseInt(document.getElementById('vtPeriodLength2')?.value) || 18,
    3: parseInt(document.getElementById('vtPeriodLength3')?.value) || 18,
    OT: parseInt(document.getElementById('vtPeriodLengthOT')?.value) || 5
  };
  S.periodLength = S.periodLengths[1];
  
  // Sync to Settings modal inputs
  document.getElementById('periodLength1').value = S.periodLengths[1];
  document.getElementById('periodLength2').value = S.periodLengths[2];
  document.getElementById('periodLength3').value = S.periodLengths[3];
  document.getElementById('periodLengthOT').value = S.periodLengths.OT;
  document.getElementById('periodLength').value = S.periodLength;
  
  updateVideoTimingPreview();
  updatePeriodLengthIndicator();
}

function renderVideoTimeouts() {
  const list = document.getElementById('vtTimeoutsList');
  if (!S.videoTiming.timeouts || S.videoTiming.timeouts.length === 0) {
    list.innerHTML = '<div style="font-size:9px;color:var(--muted);text-align:center;padding:8px;">No timeouts added</div>';
    return;
  }
  
  list.innerHTML = S.videoTiming.timeouts.map((t, i) => `
    <div style="display:flex;justify-content:space-between;align-items:center;padding:4px;background:var(--panel);border-radius:2px;margin:2px 0;font-size:10px;">
      <span>P${t.period} @ ${t.gameTime} - ${t.duration}s</span>
      <button class="btn-sm" onclick="removeVideoTimeout(${i})" style="padding:1px 4px;font-size:8px;">‚úï</button>
    </div>
  `).join('');
}

function addVideoTimeout() {
  const period = document.getElementById('vtNewTimeoutPeriod').value;
  const gameTime = document.getElementById('vtNewTimeoutTime').value;
  const duration = parseInt(document.getElementById('vtNewTimeoutDuration').value) || 60;
  
  if (!gameTime) {
    toast('Enter game time', 'error');
    return;
  }
  
  if (!S.videoTiming.timeouts) S.videoTiming.timeouts = [];
  S.videoTiming.timeouts.push({ period, gameTime, duration });
  
  // Sort by period then time
  S.videoTiming.timeouts.sort((a, b) => {
    if (a.period !== b.period) return a.period - b.period;
    return b.gameTime.localeCompare(a.gameTime); // Higher time = earlier in period
  });
  
  renderVideoTimeouts();
  updateVideoTimingPreview();
  
  // Clear inputs
  document.getElementById('vtNewTimeoutTime').value = '';
}

function removeVideoTimeout(idx) {
  S.videoTiming.timeouts.splice(idx, 1);
  renderVideoTimeouts();
  updateVideoTimingPreview();
}

// v23.6: Video management functions
function renderVideos() {
  const list = document.getElementById('videosList');
  if (!list) return;
  
  if (!S.videos || S.videos.length === 0) {
    list.innerHTML = '<div style="font-size:9px;color:var(--muted);text-align:center;padding:8px;">No videos added</div>';
    return;
  }
  
  list.innerHTML = S.videos.map((v, i) => {
    const videoId = v.video_id || extractYouTubeId(v.url) || 'N/A';
    const title = v.title || v.url || 'Untitled';
    const period = v.period ? `P${v.period}` : 'All';
    const timeRange = (v.start_time || v.end_time) ? `${v.start_time || '--'} - ${v.end_time || '--'}` : '';
    const category = v.category ? v.category.replace('_', ' ') : '';
    return `
      <div style="display:flex;justify-content:space-between;align-items:flex-start;padding:6px;background:var(--panel);border-radius:3px;margin:3px 0;font-size:9px;border-left:3px solid var(--accent);">
        <div style="flex:1;">
          <div style="font-weight:600;color:var(--accent);margin-bottom:2px;">${title}</div>
          <div style="color:var(--muted);font-size:8px;">
            <span>${v.type ? v.type.replace('_', ' ') : 'Full Ice'}</span>
            ${category ? `<span style="margin-left:6px;">${category}</span>` : ''}
            ${videoId !== 'N/A' ? `<span style="margin-left:6px;">ID: ${videoId}</span>` : ''}
            ${period !== 'All' ? `<span style="margin-left:6px;">${period}</span>` : ''}
            ${timeRange ? `<span style="margin-left:6px;">${timeRange}</span>` : ''}
          </div>
          ${v.notes ? `<div style="color:var(--muted);font-size:8px;margin-top:2px;font-style:italic;">${v.notes}</div>` : ''}
        </div>
        <button class="btn-sm" onclick="removeVideo(${i})" style="padding:2px 6px;font-size:8px;margin-left:8px;background:var(--danger);">‚úï</button>
      </div>
    `;
  }).join('');
}

function addVideo() {
  const url = document.getElementById('newVideoUrl').value.trim();
  if (!url) {
    toast('Enter a video URL', 'error');
    return;
  }
  
  const type = document.getElementById('newVideoType').value || 'Full_Ice';
  const category = document.getElementById('newVideoCategory').value || undefined;
  // Extract YouTube ID if URL is a YouTube link (regardless of video type)
  const videoId = extractYouTubeId(url) || null;
  const title = document.getElementById('newVideoTitle').value.trim() || undefined;
  const period = document.getElementById('newVideoPeriod').value || undefined;
  const startTime = document.getElementById('newVideoStartTime').value.trim() || undefined;
  const endTime = document.getElementById('newVideoEndTime').value.trim() || undefined;
  const notes = document.getElementById('newVideoNotes').value.trim() || undefined;
  
  if (!S.videos) S.videos = [];
  
  const newVideo = {
    id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
    url: url,
    type: type,
    category: category, // v23.9: Video category from dim table options
    video_id: videoId || undefined,
    title: title,
    description: undefined, // Not used in UI but kept for compatibility
    start_time: startTime,
    end_time: endTime,
    period: period ? parseInt(period) : undefined,
    notes: notes
  };
  
  S.videos.push(newVideo);
  renderVideos();
  autoSave();
  
  // Clear form
  document.getElementById('newVideoUrl').value = '';
  document.getElementById('newVideoTitle').value = '';
  document.getElementById('newVideoPeriod').value = '';
  document.getElementById('newVideoStartTime').value = '';
  document.getElementById('newVideoEndTime').value = '';
  document.getElementById('newVideoNotes').value = '';
  
  toast('Video added', 'success');
}

function removeVideo(idx) {
  if (!S.videos || idx < 0 || idx >= S.videos.length) return;
  S.videos.splice(idx, 1);
  renderVideos();
  autoSave();
  toast('Video removed', 'success');
}

function saveVideoTiming() {
  S.videoTiming.videoStartOffset = parseInt(document.getElementById('vtVideoStartOffset').value) || 0;
  
  // Save per-period lengths
  S.periodLengths = {
    1: parseInt(document.getElementById('vtPeriodLength1').value) || 18,
    2: parseInt(document.getElementById('vtPeriodLength2').value) || 18,
    3: parseInt(document.getElementById('vtPeriodLength3').value) || 18,
    OT: parseInt(document.getElementById('vtPeriodLengthOT').value) || 5
  };
  S.periodLength = S.periodLengths[1];
  
  S.videoTiming.intermission1 = parseInt(document.getElementById('vtIntermission1').value) || 900;
  S.videoTiming.intermission2 = parseInt(document.getElementById('vtIntermission2').value) || 900;
  S.videoTiming.intermission3 = parseInt(document.getElementById('vtIntermission3').value) || 300;
  S.videoTiming.youtubeUrl = document.getElementById('vtYoutubeUrl').value || '';
  
  // Sync to Settings modal
  updatePeriodLengthsUI();
  updatePeriodLengthIndicator();
  
  saveGameData();
  
  // v23.6: Videos are saved automatically when added/removed
  toast('Video timing saved', 'success');
  closeVideoTimingModal();
}

function updateVideoTimingPreview() {
  // Get per-period lengths
  const p1Sec = (parseInt(document.getElementById('vtPeriodLength1')?.value) || 18) * 60;
  const p2Sec = (parseInt(document.getElementById('vtPeriodLength2')?.value) || 18) * 60;
  const p3Sec = (parseInt(document.getElementById('vtPeriodLength3')?.value) || 18) * 60;
  const otSec = (parseInt(document.getElementById('vtPeriodLengthOT')?.value) || 5) * 60;
  
  const int1 = parseInt(document.getElementById('vtIntermission1').value) || 0;
  const int2 = parseInt(document.getElementById('vtIntermission2').value) || 0;
  const int3 = parseInt(document.getElementById('vtIntermission3').value) || 0;
  const offset = parseInt(document.getElementById('vtVideoStartOffset').value) || 0;
  
  const p1Start = offset;
  const p1End = p1Start + p1Sec;
  const p2Start = p1End + int1;
  const p2End = p2Start + p2Sec;
  const p3Start = p2End + int2;
  const p3End = p3Start + p3Sec;
  const otStart = p3End + int3;
  const otEnd = otStart + otSec;
  
  const fmt = (s) => `${Math.floor(s/60)}:${String(s%60).padStart(2,'0')}`;
  
  document.getElementById('vtPreviewP1Start').textContent = fmt(p1Start);
  document.getElementById('vtPreviewP1End').textContent = fmt(p1End);
  document.getElementById('vtPreviewP2Start').textContent = fmt(p2Start);
  document.getElementById('vtPreviewP2End').textContent = fmt(p2End);
  document.getElementById('vtPreviewP3Start').textContent = fmt(p3Start);
  document.getElementById('vtPreviewP3End').textContent = fmt(p3End);
  document.getElementById('vtPreviewOTStart').textContent = fmt(otStart);
  document.getElementById('vtPreviewOTEnd').textContent = fmt(otEnd);
}

/**
 * Calculate running video time for an event
 * @param {number} period - Period number (1, 2, 3, OT)
 * @param {string} gameTime - Game clock time (e.g., "15:30")
 * @returns {number} - Seconds from video start
 */
/**
 * Calculate adjusted video time for events
 * For events that are NOT faceoff, period start, or game start:
 * - Go back up to 10 seconds (clock counts down, so add seconds to time remaining = earlier in game)
 * - If there's a faceoff within that 10 second window, use that time instead
 * @param {number} period - Event period
 * @param {string} eventTime - Event time in MM:SS format (time remaining on clock)
 * @param {string} eventType - Event type
 * @returns {string} Adjusted time in MM:SS format, or original time if no adjustment needed
 */
function calculateAdjustedVideoTime(period, eventTime, eventType) {
  // Don't adjust faceoffs, period starts, or game starts
  if (eventType === 'Faceoff' || eventType === 'PeriodStart' || eventType === 'GameStart') {
    return eventTime;
  }
  
  if (!eventTime) return eventTime;
  
  // Parse event time to seconds (time remaining on clock)
  // Higher seconds = more time remaining = earlier in period
  const eventSeconds = parseTime(eventTime);
  
  // Maximum adjustment: 10 seconds back (add 10 seconds to time remaining = earlier)
  const maxAdjustment = 10;
  const earliestTime = eventSeconds + maxAdjustment; // Most time remaining = earliest
  
  // Find faceoffs in the same period that occurred before this event (within 10 seconds)
  // Faceoff must have MORE time remaining (higher seconds) = happened earlier
  const samePeriodFaceoffs = S.events
    .filter(e => e.period === period && e.type === 'Faceoff' && e.start_time)
    .map(e => ({ time: e.start_time, seconds: parseTime(e.start_time) }))
    .filter(fo => {
      // Faceoff happened before event: fo.seconds > eventSeconds (more time = earlier)
      // And within 10 seconds: fo.seconds <= earliestTime
      return fo.seconds > eventSeconds && fo.seconds <= earliestTime;
    })
    .sort((a, b) => a.seconds - b.seconds); // Closest to event first (least time difference)
  
  // If we found a faceoff within the window, use that time
  if (samePeriodFaceoffs.length > 0) {
    const faceoffTime = samePeriodFaceoffs[0].time;
    return faceoffTime;
  }
  
  // Otherwise, go back the full 10 seconds (add 10 to time remaining)
  const adjustedSeconds = Math.min(earliestTime, getPeriodLengthSeconds(period));
  const adjustedMin = Math.floor(adjustedSeconds / 60);
  const adjustedSec = adjustedSeconds % 60;
  return `${adjustedMin}:${String(adjustedSec).padStart(2, '0')}`;
}

function calculateRunningVideoTime(period, gameTime) {
  // v23.5: Use per-period lengths
  const currentPeriodSec = getPeriodLengthSeconds(period);
  const int1 = S.videoTiming.intermission1 || 0;
  const int2 = S.videoTiming.intermission2 || 0;
  const int3 = S.videoTiming.intermission3 || 0;
  const offset = S.videoTiming.videoStartOffset || 0;
  
  // Parse game time (MM:SS) - time remaining in period
  let timeRemaining = 0;
  if (gameTime) {
    const parts = gameTime.split(':');
    timeRemaining = parseInt(parts[0] || 0) * 60 + parseInt(parts[1] || 0);
  }
  
  // Calculate elapsed time in current period
  const elapsedInPeriod = currentPeriodSec - timeRemaining;
  
  // Calculate base running time (without timeouts)
  let runningTime = offset;
  
  if (period >= 1) {
    runningTime += elapsedInPeriod;
  }
  if (period >= 2) {
    runningTime += int1 + getPeriodLengthSeconds(1); // Full P1
  }
  if (period >= 3) {
    runningTime += int2 + getPeriodLengthSeconds(2); // Full P2
  }
  if (period >= 4) { // OT
    runningTime += int3 + getPeriodLengthSeconds(3); // Full P3
  }
  
  // Add timeout durations that occurred before this point
  const timeouts = S.videoTiming.timeouts || [];
  timeouts.forEach(t => {
    const tPeriod = t.period === 'OT' ? 4 : parseInt(t.period);
    if (tPeriod < period) {
      runningTime += t.duration;
    } else if (tPeriod === period) {
      // Timeout in same period - only add if it happened before current time
      // Higher gameTime = earlier in period
      if (t.gameTime > gameTime) {
        runningTime += t.duration;
      }
    }
  });
  
  return runningTime;
}

// ============================================================
// v23.4: VIDEO PLAYER CONTROLS
// ============================================================

// Video state
let currentVideoSource = null; // 'youtube' or 'local'
let ytPlayer = null; // YouTube player instance
let videoSyncEnabled = true;
let currentVideoZoom = 1;
let videoSources = []; // Multiple video sources with hotkeys

/**
 * Load a video from URL (YouTube or direct file)
 */
function loadVideo(url, name = 'Video') {
  if (!url) {
    toast('Enter a video URL', 'warning');
    return;
  }
  
  const youtubeId = extractYouTubeId(url);
  
  if (youtubeId) {
    loadYouTubeVideo(youtubeId);
    currentVideoSource = 'youtube';
  } else {
    loadLocalVideo(url);
    currentVideoSource = 'local';
  }
  
  // Hide placeholder
  document.getElementById('videoPlaceholder').style.display = 'none';
  
  toast(`Loaded: ${name}`, 'success');
}

/**
 * Extract YouTube video ID from URL
 */
function extractYouTubeId(url) {
  const patterns = [
    /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})/,
    /^([a-zA-Z0-9_-]{11})$/ // Direct ID
  ];
  
  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) return match[1];
  }
  return null;
}

/**
 * Load YouTube video using IFrame API
 */
function loadYouTubeVideo(videoId) {
  const container = document.getElementById('youtubePlayer');
  container.style.display = 'block';
  document.getElementById('localVideoPlayer').style.display = 'none';
  
  // Load YouTube API if not already loaded
  if (!window.YT) {
    const tag = document.createElement('script');
    tag.src = 'https://www.youtube.com/iframe_api';
    document.head.appendChild(tag);
    
    window.onYouTubeIframeAPIReady = () => {
      createYouTubePlayer(videoId);
    };
  } else {
    createYouTubePlayer(videoId);
  }
}

/**
 * Create YouTube player instance
 */
function createYouTubePlayer(videoId) {
  // Destroy existing player if any
  if (ytPlayer && ytPlayer.destroy) {
    ytPlayer.destroy();
  }
  
  const container = document.getElementById('youtubePlayer');
  container.innerHTML = '<div id="ytPlayerFrame"></div>';
  
  ytPlayer = new YT.Player('ytPlayerFrame', {
    height: '100%',
    width: '100%',
    videoId: videoId,
    playerVars: {
      'playsinline': 1,
      'enablejsapi': 1,
      'modestbranding': 1,
      'rel': 0
    },
    events: {
      'onReady': onYouTubePlayerReady,
      'onStateChange': onYouTubePlayerStateChange
    }
  });
}

function onYouTubePlayerReady(event) {
  console.log('YouTube player ready');
  startVideoTimeUpdate();
}

function onYouTubePlayerStateChange(event) {
  const playBtn = document.getElementById('videoPlayBtn');
  if (event.data === YT.PlayerState.PLAYING) {
    playBtn.textContent = '‚è∏';
  } else {
    playBtn.textContent = '‚ñ∂';
  }
}

/**
 * Load local/direct video file
 */
function loadLocalVideo(url) {
  const video = document.getElementById('localVideoPlayer');
  video.style.display = 'block';
  document.getElementById('youtubePlayer').style.display = 'none';
  
  video.src = url;
  video.load();
  
  video.onloadedmetadata = () => {
    console.log('Local video loaded, duration:', video.duration);
    startVideoTimeUpdate();
  };
  
  video.onplay = () => document.getElementById('videoPlayBtn').textContent = '‚è∏';
  video.onpause = () => document.getElementById('videoPlayBtn').textContent = '‚ñ∂';
}

/**
 * Load video from file input
 */
function loadVideoFromFile(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  const url = URL.createObjectURL(file);
  loadLocalVideo(url);
  toast(`Loaded: ${file.name}`, 'success');
}

/**
 * Play/Pause video
 */
function videoPlayPause() {
  if (currentVideoSource === 'youtube' && ytPlayer) {
    const state = ytPlayer.getPlayerState();
    if (state === YT.PlayerState.PLAYING) {
      ytPlayer.pauseVideo();
    } else {
      ytPlayer.playVideo();
    }
  } else if (currentVideoSource === 'local') {
    const video = document.getElementById('localVideoPlayer');
    if (video.paused) {
      video.play();
    } else {
      video.pause();
    }
  }
}

/**
 * Seek video by delta seconds
 */
function videoSeek(deltaSec) {
  if (currentVideoSource === 'youtube' && ytPlayer) {
    const current = ytPlayer.getCurrentTime();
    ytPlayer.seekTo(current + deltaSec, true);
  } else if (currentVideoSource === 'local') {
    const video = document.getElementById('localVideoPlayer');
    video.currentTime = Math.max(0, video.currentTime + deltaSec);
  }
}

/**
 * Seek to specific time in seconds
 */
function videoSeekTo(timeSec) {
  if (currentVideoSource === 'youtube' && ytPlayer) {
    ytPlayer.seekTo(timeSec, true);
  } else if (currentVideoSource === 'local') {
    const video = document.getElementById('localVideoPlayer');
    video.currentTime = timeSec;
  }
}

/**
 * Frame step (approximate - 1/30 sec)
 */
function videoFrameStep(frames) {
  const frameDuration = 1 / 30; // Assume 30fps
  videoSeek(frames * frameDuration);
}

/**
 * Set video playback speed
 */
function setVideoSpeed(speed) {
  if (currentVideoSource === 'youtube' && ytPlayer) {
    ytPlayer.setPlaybackRate(speed);
  } else if (currentVideoSource === 'local') {
    const video = document.getElementById('localVideoPlayer');
    video.playbackRate = speed;
  }
  
  // Update UI
  document.querySelectorAll('.speed-btn').forEach(btn => {
    btn.classList.toggle('active', parseFloat(btn.dataset.speed) === speed);
  });
  
  toast(`Speed: ${speed}x`, 'info');
}

/**
 * Get current video playback speed
 */
function getVideoSpeed() {
  if (currentVideoSource === 'youtube' && ytPlayer && ytPlayer.getPlaybackRate) {
    return ytPlayer.getPlaybackRate();
  } else if (currentVideoSource === 'local') {
    return document.getElementById('localVideoPlayer').playbackRate;
  }
  return 1;
}

/**
 * Toggle video section visibility
 */
function toggleVideoSection() {
  const section = document.getElementById('videoSection');
  const toggleBar = document.getElementById('videoToggleBar');
  
  if (section.style.display === 'none') {
    section.style.display = 'block';
    toggleBar.style.display = 'none';
  } else {
    section.style.display = 'none';
    toggleBar.style.display = 'flex';
  }
}

/**
 * Show video section
 */
function showVideoSection() {
  document.getElementById('videoSection').style.display = 'block';
  document.getElementById('videoToggleBar').style.display = 'none';
}

/**
 * Get current video time in seconds
 */
function getVideoCurrentTime() {
  if (currentVideoSource === 'youtube' && ytPlayer && ytPlayer.getCurrentTime) {
    return ytPlayer.getCurrentTime();
  } else if (currentVideoSource === 'local') {
    return document.getElementById('localVideoPlayer').currentTime;
  }
  return 0;
}

/**
 * Get video duration
 */
function getVideoDuration() {
  if (currentVideoSource === 'youtube' && ytPlayer && ytPlayer.getDuration) {
    return ytPlayer.getDuration();
  } else if (currentVideoSource === 'local') {
    return document.getElementById('localVideoPlayer').duration || 0;
  }
  return 0;
}

/**
 * Update video time display continuously
 */
function startVideoTimeUpdate() {
  setInterval(() => {
    const currentTime = getVideoCurrentTime();
    const duration = getVideoDuration();
    
    // Format time
    const formatTime = (sec) => {
      const h = Math.floor(sec / 3600);
      const m = Math.floor((sec % 3600) / 60);
      const s = Math.floor(sec % 60);
      return h > 0 
        ? `${h}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`
        : `${m}:${String(s).padStart(2,'0')}`;
    };
    
    // Update displays
    const videoTimeEl = document.getElementById('videoTime');
    if (videoTimeEl) {
      videoTimeEl.textContent = `${formatTime(currentTime)} / ${formatTime(duration)}`;
    }
    
    const miniTimeEl = document.getElementById('videoMiniTime');
    if (miniTimeEl) {
      miniTimeEl.textContent = formatTime(currentTime);
    }
    
    // Calculate and display game clock time
    if (videoSyncEnabled) {
      const gameTime = calculateGameTimeFromVideo(currentTime);
      const gameTimeEl = document.getElementById('gameTimeFromVideo');
      if (gameTimeEl && gameTime) {
        gameTimeEl.textContent = `P${gameTime.period} ${gameTime.clock}`;
      }
    }
  }, 250);
}

/**
 * Calculate game clock from video time
 */
function calculateGameTimeFromVideo(videoSec) {
  const offset = S.videoTiming?.videoStartOffset || 0;
  const int1 = S.videoTiming?.intermission1 || 900;
  const int2 = S.videoTiming?.intermission2 || 900;
  const int3 = S.videoTiming?.intermission3 || 300;
  
  // Use game markers if set
  const markers = S.videoPlayer?.gameMarkers || {};
  
  // v23.5: Get per-period lengths
  const p1Sec = getPeriodLengthSeconds(1);
  const p2Sec = getPeriodLengthSeconds(2);
  const p3Sec = getPeriodLengthSeconds(3);
  const otSec = getPeriodLengthSeconds('OT');
  
  // Determine which period we're in
  let period = 1;
  let periodSec = p1Sec;
  let periodStartVideo = markers.P1Start || offset;
  let periodEndVideo = markers.P1End || (offset + p1Sec);
  
  if (markers.P2Start && videoSec >= markers.P2Start) {
    period = 2;
    periodSec = p2Sec;
    periodStartVideo = markers.P2Start;
    periodEndVideo = markers.P2End || (markers.P2Start + p2Sec);
  }
  if (markers.P3Start && videoSec >= markers.P3Start) {
    period = 3;
    periodSec = p3Sec;
    periodStartVideo = markers.P3Start;
    periodEndVideo = markers.P3End || (markers.P3Start + p3Sec);
  }
  if (markers.OTStart && videoSec >= markers.OTStart) {
    period = 4;
    periodSec = otSec;
    periodStartVideo = markers.OTStart;
    periodEndVideo = markers.OTEnd || (markers.OTStart + otSec);
  }
  
  // Calculate time elapsed in current period
  const elapsedInPeriod = videoSec - periodStartVideo;
  const timeRemaining = Math.max(0, periodSec - elapsedInPeriod);
  
  const min = Math.floor(timeRemaining / 60);
  const sec = Math.floor(timeRemaining % 60);
  
  return {
    period: period === 4 ? 'OT' : period,
    clock: `${min}:${String(sec).padStart(2, '0')}`,
    elapsed: elapsedInPeriod
  };
}

/**
 * Capture start time from video to event/shift
 */
function captureStartTime() {
  const videoTime = getVideoCurrentTime();
  const gameTime = calculateGameTimeFromVideo(videoTime);
  
  if (gameTime) {
    document.getElementById('evtStartTime').value = gameTime.clock;
    
    // Also set period if different
    if (gameTime.period && gameTime.period !== S.period) {
      toast(`Note: Video is in P${gameTime.period}, tracker in P${S.period}`, 'warning');
    }
    
    toast(`Start: ${gameTime.clock} (P${gameTime.period})`, 'success');
  }
}

/**
 * Capture end time from video to event/shift
 */
function captureEndTime() {
  const videoTime = getVideoCurrentTime();
  const gameTime = calculateGameTimeFromVideo(videoTime);
  
  if (gameTime) {
    document.getElementById('evtEndTime').value = gameTime.clock;
    toast(`End: ${gameTime.clock} (P${gameTime.period})`, 'success');
  }
}

/**
 * Toggle video auto-sync
 */
function toggleVideoAutoSync() {
  videoSyncEnabled = document.getElementById('videoAutoSync').checked;
}

/**
 * Set game marker from current video position
 */
function setGameMarker(markerName) {
  const videoTime = getVideoCurrentTime();
  
  if (!S.videoPlayer) S.videoPlayer = { sources: [], gameMarkers: {} };
  if (!S.videoPlayer.gameMarkers) S.videoPlayer.gameMarkers = {};
  
  S.videoPlayer.gameMarkers[markerName] = videoTime;
  
  updateMarkerStatus();
  saveGameData();
  
  const formattedTime = formatVideoTime(videoTime);
  toast(`Marker set: ${markerName} @ ${formattedTime}`, 'success');
}

function formatVideoTime(sec) {
  const m = Math.floor(sec / 60);
  const s = Math.floor(sec % 60);
  return `${m}:${String(s).padStart(2, '0')}`;
}

/**
 * Update marker status display
 */
function updateMarkerStatus() {
  const markers = S.videoPlayer?.gameMarkers || {};
  const count = Object.keys(markers).length;
  
  const statusEl = document.getElementById('markerStatus');
  if (statusEl) {
    if (count === 0) {
      statusEl.textContent = 'No markers set';
    } else {
      const markerList = Object.entries(markers)
        .map(([k, v]) => `${k}:${formatVideoTime(v)}`)
        .join(' | ');
      statusEl.textContent = markerList;
    }
  }
}

/**
 * Jump to a specific game marker
 */
function jumpToMarker(markerName) {
  const time = S.videoPlayer?.gameMarkers?.[markerName];
  if (time !== undefined) {
    videoSeekTo(time);
    toast(`Jumped to ${markerName}`, 'info');
  }
}

/**
 * Add stoppage marker at current position
 */
function addStoppageMarker() {
  const videoTime = getVideoCurrentTime();
  const gameTime = calculateGameTimeFromVideo(videoTime);
  
  const name = prompt('Stoppage name (e.g., "Timeout", "Injury"):', 'Stoppage');
  if (!name) return;
  
  if (!S.videoTiming.timeouts) S.videoTiming.timeouts = [];
  
  S.videoTiming.timeouts.push({
    period: gameTime?.period || S.period,
    gameTime: gameTime?.clock || '10:00',
    duration: 60, // Default 1 minute
    name: name,
    videoTime: videoTime
  });
  
  saveGameData();
  toast(`Added stoppage: ${name}`, 'success');
}

// ============================================================
// v23.4: VIDEO ZOOM
// ============================================================

/**
 * Set video zoom level
 */
function setVideoZoom(zoom) {
  currentVideoZoom = zoom;
  
  const container = document.getElementById('videoPlayerContainer');
  const videoEl = currentVideoSource === 'youtube' 
    ? document.getElementById('youtubePlayer')
    : document.getElementById('localVideoPlayer');
  
  if (videoEl) {
    videoEl.style.transform = `scale(${zoom})`;
    videoEl.style.transformOrigin = 'center center';
  }
  
  toast(`Zoom: ${Math.round(zoom * 100)}%`, 'info');
}

/**
 * Zoom in
 */
function videoZoomIn() {
  setVideoZoom(Math.min(currentVideoZoom + 0.25, 3));
}

/**
 * Zoom out
 */
function videoZoomOut() {
  setVideoZoom(Math.max(currentVideoZoom - 0.25, 0.5));
}

/**
 * Reset zoom
 */
function videoZoomReset() {
  setVideoZoom(1);
}

// ============================================================
// v23.4: VIDEO SOURCE SWITCHING
// ============================================================

/**
 * Add a video source with hotkey
 */
function addVideoSource(name, url, hotkey) {
  const source = { 
    id: Date.now(), 
    name, 
    url, 
    hotkey,
    type: extractYouTubeId(url) ? 'youtube' : 'local'
  };
  videoSources.push(source);
  
  updateVideoSourcesUI();
  saveVideoSources();
  toast(`Added source: ${name} (${hotkey})`, 'success');
  
  return source;
}

/**
 * Switch to video source by hotkey
 */
function switchVideoByHotkey(key) {
  const source = videoSources.find(s => s.hotkey === key);
  if (source) {
    loadVideo(source.url, source.name);
    setActiveVideoSource(source.id);
    toast(`Switched to: ${source.name} (Ctrl+${key})`, 'info');
  }
}

/**
 * Switch video source from dropdown
 */
function switchVideoSource() {
  const select = document.getElementById('videoSourceSelect');
  const sourceId = select.value;
  
  if (!sourceId) return;
  
  const source = videoSources.find(s => s.id == sourceId);
  if (source) {
    loadVideo(source.url, source.name);
    setActiveVideoSource(source.id);
  }
}

/**
 * Set active video source indicator
 */
function setActiveVideoSource(sourceId) {
  // Update dropdown
  const select = document.getElementById('videoSourceSelect');
  if (select) select.value = sourceId;
  
  // Store active source
  S.activeVideoSourceId = sourceId;
}

/**
 * Update video sources dropdown
 */
function updateVideoSourcesUI() {
  const select = document.getElementById('videoSourceSelect');
  if (!select) return;
  
  select.innerHTML = '<option value="">-- Sources --</option>' +
    videoSources.map(s => 
      `<option value="${s.id}">${s.name} (${s.hotkey || '-'})</option>`
    ).join('');
  
  // Also update hotkey bar
  renderVideoHotkeyBar();
}

/**
 * Render video hotkey bar showing quick-switch buttons
 */
function renderVideoHotkeyBar() {
  const bar = document.getElementById('videoHotkeyBar');
  if (!bar) return;
  
  if (videoSources.length === 0) {
    bar.innerHTML = '<span style="font-size:8px;color:var(--muted);">No sources</span>';
    return;
  }
  
  bar.innerHTML = videoSources.map(s => {
    const isActive = S.activeVideoSourceId === s.id;
    const bg = isActive ? 'var(--accent)' : 'var(--panel)';
    const color = isActive ? '#000' : 'var(--text)';
    return `<button class="btn-sm" onclick="switchVideoByHotkey('${s.hotkey}')" 
      title="${s.name} (Ctrl+${s.hotkey})" 
      style="min-width:20px;padding:2px 4px;font-size:9px;font-weight:bold;background:${bg};color:${color};">
      ${s.hotkey}
    </button>`;
  }).join('');
}

/**
 * Show video sources manager modal
 */
function showVideoSourcesManager() {
  const sourcesHtml = videoSources.length === 0 
    ? '<p style="color:var(--muted);font-size:11px;text-align:center;">No video sources added yet</p>'
    : `<table style="width:100%;font-size:11px;border-collapse:collapse;">
        <thead><tr style="background:var(--panel);"><th>Key</th><th>Name</th><th>Type</th><th></th></tr></thead>
        <tbody>
          ${videoSources.map(s => `
            <tr>
              <td style="padding:4px;text-align:center;"><kbd>${s.hotkey || '-'}</kbd></td>
              <td style="padding:4px;">${s.name}</td>
              <td style="padding:4px;">${s.type || 'local'}</td>
              <td style="padding:4px;">
                <button class="btn-sm btn-danger" onclick="removeVideoSource(${s.id})" style="padding:1px 4px;font-size:8px;">‚úï</button>
              </td>
            </tr>
          `).join('')}
        </tbody>
      </table>`;
  
  const html = `
    <h3>üé¨ Video Sources</h3>
    <p style="font-size:10px;color:var(--muted);margin-bottom:10px;">
      Press Ctrl+hotkey (Ctrl+1 to Ctrl+9) to instantly switch between video feeds
    </p>
    <div style="max-height:200px;overflow-y:auto;margin-bottom:15px;">
      ${sourcesHtml}
    </div>
    <div style="border-top:1px solid var(--border);padding-top:10px;">
      <button class="btn-sm btn-primary" onclick="closeModal();showAddVideoModal();" style="width:100%;">+ Add New Source</button>
    </div>
    <div style="margin-top:10px;text-align:right;">
      <button class="btn-sm" onclick="closeModal()">Close</button>
    </div>
  `;
  
  showModal(html);
}

/**
 * Remove a video source
 */
function removeVideoSource(id) {
  videoSources = videoSources.filter(s => s.id !== id);
  updateVideoSourcesUI();
  saveVideoSources();
  toast('Video source removed', 'info');
  
  // Refresh modal if open
  if (document.getElementById('genericModal').classList.contains('show')) {
    showVideoSourcesManager();
  }
}

/**
 * Show add video modal
 */
function showAddVideoModal() {
  const html = `
    <h3>üé¨ Add Video Source</h3>
    <div class="form-group" style="margin-bottom:8px;">
      <label>Video Name</label>
      <input type="text" id="addVideoName" placeholder="e.g., Main Camera, Overhead" style="width:100%;">
    </div>
    <div class="form-group" style="margin-bottom:8px;">
      <label>URL or YouTube Link</label>
      <input type="text" id="addVideoUrl" placeholder="https://youtube.com/watch?v=... or video file URL" style="width:100%;">
    </div>
    <div style="margin-bottom:8px;">
      <label style="font-size:10px;">Or load local file:</label>
      <input type="file" id="addVideoFile" accept="video/*" onchange="handleVideoFileSelect(event)" style="font-size:10px;">
    </div>
    <div class="form-group" style="margin-bottom:8px;">
      <label>Hotkey (1-9)</label>
      <input type="text" id="addVideoHotkey" placeholder="e.g., 1" maxlength="1" style="width:50px;">
    </div>
    <div class="modal-actions">
      <button class="btn-primary" onclick="confirmAddVideo()">Add Video</button>
      <button onclick="closeModal()">Cancel</button>
    </div>
  `;
  
  showModal(html);
}

function handleVideoFileSelect(event) {
  const file = event.target.files[0];
  if (file) {
    document.getElementById('addVideoUrl').value = URL.createObjectURL(file);
    if (!document.getElementById('addVideoName').value) {
      document.getElementById('addVideoName').value = file.name;
    }
  }
}

function confirmAddVideo() {
  const name = document.getElementById('addVideoName').value || 'Video';
  const url = document.getElementById('addVideoUrl').value;
  const hotkey = document.getElementById('addVideoHotkey').value;
  
  if (!url) {
    toast('Enter a video URL or select a file', 'warning');
    return;
  }
  
  // Add to sources list
  const sourceId = Date.now();
  const source = { 
    id: sourceId, 
    name, 
    url, 
    hotkey: hotkey || null,
    type: extractYouTubeId(url) ? 'youtube' : 'local'
  };
  videoSources.push(source);
  
  // Load the video
  loadVideo(url, name);
  setActiveVideoSource(sourceId);
  
  // Update UI
  updateVideoSourcesUI();
  saveVideoSources();
  
  closeModal();
  showVideoSection();
  
  toast(`Added: ${name}${hotkey ? ` (Ctrl+${hotkey} to switch)` : ''}`, 'success');
}

/**
 * Save video sources to localStorage
 */
function saveVideoSources() {
  localStorage.setItem('benchsight_videoSources', JSON.stringify(videoSources));
}

/**
 * Load video sources from localStorage
 */
function loadVideoSources() {
  try {
    const saved = localStorage.getItem('benchsight_videoSources');
    if (saved) {
      videoSources = JSON.parse(saved);
      updateVideoSourcesUI();
    }
  } catch (e) {
    console.error('Error loading video sources:', e);
  }
}

// ============================================================
// v23.4: VIDEO SCRUB BAR
// ============================================================

/**
 * Render video scrub bar with event markers
 */
function renderVideoScrubBar() {
  const container = document.getElementById('videoScrubBar');
  if (!container) return;
  
  const duration = getVideoDuration();
  if (!duration) return;
  
  // Get events and convert to video times
  const eventMarkers = S.events.map(evt => {
    const videoTime = calculateRunningVideoTime(
      evt.period === 'OT' ? 4 : parseInt(evt.period) || 1,
      evt.start_time
    );
    return {
      time: videoTime,
      type: evt.type,
      idx: evt.idx
    };
  }).filter(m => m.time <= duration);
  
  // Render scrub bar with markers
  container.innerHTML = `
    <div style="position:relative;height:20px;background:var(--panel);border-radius:3px;cursor:pointer;" onclick="handleScrubClick(event)">
      <div id="scrubProgress" style="position:absolute;height:100%;background:var(--accent);opacity:0.3;border-radius:3px;width:0%;"></div>
      ${eventMarkers.map(m => {
        const pct = (m.time / duration) * 100;
        const color = m.type === 'Goal' ? '#22c55e' : m.type === 'Shot' ? '#ef4444' : '#3b82f6';
        return `<div style="position:absolute;left:${pct}%;width:3px;height:100%;background:${color};" title="${m.type} #${m.idx}"></div>`;
      }).join('')}
    </div>
  `;
}

function handleScrubClick(event) {
  const rect = event.currentTarget.getBoundingClientRect();
  const pct = (event.clientX - rect.left) / rect.width;
  const duration = getVideoDuration();
  videoSeekTo(pct * duration);
}

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  // v23.9: XY tracking hotkeys
  if (e.key === 'p' || e.key === 'P') {
    if (e.ctrlKey || e.metaKey) {
      e.preventDefault();
      setXYMode('puck');
      toast('Switched to Puck XY mode', 'info');
      return;
    }
  }
  if (e.key === 'y' || e.key === 'Y') {
    if (e.ctrlKey || e.metaKey) {
      e.preventDefault();
      setXYMode('player');
      toast('Switched to Player XY mode', 'info');
      return;
    }
  }
  // Number keys 1-9 to select player by number for XY tracking
  if ((e.key >= '1' && e.key <= '9') && (e.ctrlKey || e.metaKey) && S.xyMode === 'player') {
    e.preventDefault();
    const num = parseInt(e.key);
    const player = S.curr.players.find(p => p.num == num);
    if (player) {
      selectXYPlayer(num);
    } else {
      toast(`Player #${num} not found`, 'error');
    }
    return;
  }
  
  // Don't trigger if typing in input (unless arrow keys in edit modal)
  const inInput = e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA';
  
  // Arrow keys work in modals for navigation
  if (document.getElementById('editModal').classList.contains('show')) {
    if (e.key === 'ArrowLeft') { navEditEvent(-1); e.preventDefault(); return; }
    if (e.key === 'ArrowRight') { navEditEvent(1); e.preventDefault(); return; }
  }
  if (document.getElementById('editShiftModal').classList.contains('show')) {
    if (e.key === 'ArrowLeft') { navEditShift(-1); e.preventDefault(); return; }
    if (e.key === 'ArrowRight') { navEditShift(1); e.preventDefault(); return; }
  }
  
  if (inInput) return;
  
  switch(e.key) {
    case '?': openHelp(); break;
    case 'Escape': 
      closeSettings(); closeHelp(); 
      document.querySelectorAll('.overlay.show').forEach(m => m.classList.remove('show'));
      break;
    
    // Event type hotkeys
    case 'f': case 'F': setEvtType('Faceoff'); break;
    case 's': case 'S': setEvtType('Shot'); break;
    case 'p': case 'P': setEvtType('Pass'); break;
    case 'g': case 'G': setEvtType('Goal'); break;
    case 't': case 'T': setEvtType('Turnover'); break;
    case 'z': case 'Z': setEvtType('Zone_Entry_Exit'); break;
    case 'n': case 'N': setEvtType('Penalty'); break;
    case 'x': case 'X': setEvtType('Stoppage'); break;
    case 'o': case 'O': setEvtType('Possession'); break;
    case 'v': case 'V': setEvtType('Save'); break;
    case 'r': case 'R': setEvtType('Rebound'); break;
    case 'd': case 'D': setEvtType('DeadIce'); break;
    
    // Quick actions
    case 'h': case 'H': document.getElementById('evtHighlight').checked = !document.getElementById('evtHighlight').checked; break;
    case 'l': case 'L': logEvent(); break;  // Log current event
    case 'Enter': logEvent(); break;  // Also log with Enter
    
    // Team toggle - removed 1/2, now use H/A (v16.06)
    // 1-6 handled in setupKeys() for player selection
    
    // Zone
    case 'q': setZone('o'); break;  // Offensive
    case 'w': setZone('n'); break;  // Neutral
    case 'e': setZone('d'); break;  // Defensive
    
    // Success
    case 'y': case 'Y': document.getElementById('evtSuccess').value = 's'; break;
    case 'u': case 'U': document.getElementById('evtSuccess').value = 'u'; break;
    
    // Period
    case '!': setPeriod(1); break;
    case '@': setPeriod(2); break;
    case '#': setPeriod(3); break;
    case '$': setPeriod('OT'); break;
    
    // Undo XY
    case 'Backspace': undoLastXY(); break;
    
    // Shift actions
    case '[': logShift(); toast('Shift logged', 'success'); break;
    case ']': 
      document.getElementById('shiftStart').value = document.getElementById('clock').value;
      toast('Shift start set', 'info'); 
      break;
    
    // Edit last event
    case 'i': case 'I': 
      if (S.events.length > 0) editEvent(S.events.length - 1);
      break;
    
    // Quick nav
    case ',': if (S.events.length > 0) editEvent(0); break;  // First event
    case '.': if (S.events.length > 0) editEvent(S.events.length - 1); break;  // Last event
    
    // v23.4: Video controls
    case ' ': // Space = play/pause
      e.preventDefault();
      videoPlayPause();
      break;
    case 'ArrowLeft':
      e.preventDefault();
      videoSeek(e.shiftKey ? -10 : -1); // Shift+Left = -10s
      break;
    case 'ArrowRight':
      e.preventDefault();
      videoSeek(e.shiftKey ? 10 : 1); // Shift+Right = +10s
      break;
    case 'ArrowUp':
      e.preventDefault();
      setVideoSpeed(Math.min(2, (getVideoSpeed() || 1) + 0.25));
      break;
    case 'ArrowDown':
      e.preventDefault();
      setVideoSpeed(Math.max(0.25, (getVideoSpeed() || 1) - 0.25));
      break;
    case ';': // Frame back
      videoFrameStep(-1);
      break;
    case "'": // Frame forward
      videoFrameStep(1);
      break;
    case '+': case '=':
      videoZoomIn();
      break;
    case '-': case '_':
      videoZoomOut();
      break;
    case '0':
      videoZoomReset();
      break;
  }
  
  // Video source switching: Ctrl+1-9 (avoids conflict with player 1-6)
  if (!inInput && e.key >= '1' && e.key <= '9' && e.ctrlKey && !e.altKey) {
    e.preventDefault(); // Prevent browser tab switching
    switchVideoByHotkey(e.key);
  }
});

// ============================================================
// v23.5: WORKFLOW IMPROVEMENTS
// ============================================================

// --- 1. QUICK REPLAY (rewind 5s on pause) ---
let quickReplayEnabled = true;
let wasPlayingBeforePause = false;

function videoPlayPauseWithReplay() {
  const isPlaying = currentVideoSource === 'youtube' 
    ? (ytPlayer && ytPlayer.getPlayerState() === YT.PlayerState.PLAYING)
    : (currentVideoSource === 'local' && !document.getElementById('localVideoPlayer').paused);
  
  if (isPlaying && quickReplayEnabled) {
    // Pausing - rewind 5s for context
    videoSeek(-5);
  }
  videoPlayPause();
}

function toggleQuickReplay() {
  quickReplayEnabled = !quickReplayEnabled;
  toast(`Quick replay: ${quickReplayEnabled ? 'ON' : 'OFF'}`, 'info');
}

// --- 2. EVENT SUGGESTIONS ---
const EVENT_SUGGESTIONS = {
  'Goal': ['Faceoff'],
  'Shot': ['Save', 'Rebound', 'Goal'],
  'Save': ['Rebound', 'Possession', 'Pass'],
  'Rebound': ['Shot', 'Goal', 'Possession'],
  'Faceoff': ['Pass', 'Possession', 'Shot'],
  'Pass': ['Shot', 'Pass', 'Possession'],
  'Turnover': ['Possession', 'Shot', 'Pass'],
  'Zone_Entry_Exit': ['Pass', 'Shot', 'Possession'],
  'Possession': ['Pass', 'Shot', 'Zone_Entry_Exit'],
  'Penalty': ['Faceoff'],
  'Stoppage': ['Faceoff']
};

let suggestionsEnabled = true;

function getSuggestedEvents() {
  if (!suggestionsEnabled || S.events.length === 0) return [];
  
  const lastEvent = S.events[S.events.length - 1];
  return EVENT_SUGGESTIONS[lastEvent.type] || [];
}

function renderEventSuggestions() {
  const container = document.getElementById('eventSuggestions');
  if (!container) return;
  
  const suggestions = getSuggestedEvents();
  if (suggestions.length === 0) {
    container.innerHTML = '';
    return;
  }
  
  container.innerHTML = `
    <span style="font-size:8px;color:var(--muted);">Next:</span>
    ${suggestions.map(s => `
      <button class="btn-sm" onclick="setEvtType('${s}')" 
        style="padding:2px 6px;font-size:9px;background:var(--panel);border:1px dashed var(--accent);">
        ${s.replace('_', ' ').substring(0, 6)}
      </button>
    `).join('')}
  `;
}

function toggleSuggestions() {
  suggestionsEnabled = !suggestionsEnabled;
  toast(`Suggestions: ${suggestionsEnabled ? 'ON' : 'OFF'}`, 'info');
  renderEventSuggestions();
}

// --- 3. POSSESSION TRACKER ---
let possessionTeam = null;
let possessionStartTime = null;
let possessionTimers = { home: 0, away: 0 };
let possessionInterval = null;

function setPossession(team) {
  if (possessionTeam === team) {
    // Toggle off
    stopPossessionTimer();
    possessionTeam = null;
    updatePossessionDisplay();
    return;
  }
  
  // Stop current timer if any
  if (possessionTeam) {
    stopPossessionTimer();
  }
  
  // Start new possession
  possessionTeam = team;
  possessionStartTime = Date.now();
  startPossessionTimer();
  updatePossessionDisplay();
}

function startPossessionTimer() {
  if (possessionInterval) clearInterval(possessionInterval);
  possessionInterval = setInterval(() => {
    if (possessionTeam) {
      possessionTimers[possessionTeam] += 0.1;
      updatePossessionDisplay();
    }
  }, 100);
}

function stopPossessionTimer() {
  if (possessionInterval) {
    clearInterval(possessionInterval);
    possessionInterval = null;
  }
}

function resetPossessionTimers() {
  possessionTimers = { home: 0, away: 0 };
  possessionTeam = null;
  stopPossessionTimer();
  updatePossessionDisplay();
}

function updatePossessionDisplay() {
  const display = document.getElementById('possessionDisplay');
  if (!display) return;
  
  const total = possessionTimers.home + possessionTimers.away;
  const homePct = total > 0 ? Math.round((possessionTimers.home / total) * 100) : 50;
  const awayPct = 100 - homePct;
  
  const homeActive = possessionTeam === 'home' ? 'font-weight:bold;' : '';
  const awayActive = possessionTeam === 'away' ? 'font-weight:bold;' : '';
  
  display.innerHTML = `
    <span style="color:var(--home);${homeActive}">${homePct}%</span>
    <div style="flex:1;height:6px;background:var(--away);border-radius:3px;margin:0 4px;overflow:hidden;">
      <div style="width:${homePct}%;height:100%;background:var(--home);"></div>
    </div>
    <span style="color:var(--away);${awayActive}">${awayPct}%</span>
  `;
}

function formatPossessionTime(sec) {
  const m = Math.floor(sec / 60);
  const s = Math.floor(sec % 60);
  return `${m}:${String(s).padStart(2, '0')}`;
}

// --- 4. PENALTY BOX MANAGER ---
let activePenalties = [];

function addPenalty(team, playerNum, minutes, startTime) {
  const penalty = {
    id: Date.now(),
    team,
    playerNum,
    minutes: minutes || 2,
    startTime: startTime || document.getElementById('clock').value,
    startTimestamp: Date.now()
  };
  activePenalties.push(penalty);
  updatePenaltyBox();
  startPenaltyCountdown();
}

function removePenalty(id) {
  activePenalties = activePenalties.filter(p => p.id !== id);
  updatePenaltyBox();
}

function startPenaltyCountdown() {
  // Update every second
  setInterval(updatePenaltyBox, 1000);
}

function updatePenaltyBox() {
  const container = document.getElementById('penaltyBoxDisplay');
  if (!container) return;
  
  if (activePenalties.length === 0) {
    container.innerHTML = '<span style="font-size:9px;color:var(--muted);">No penalties</span>';
    return;
  }
  
  const now = Date.now();
  
  container.innerHTML = activePenalties.map(p => {
    const elapsed = (now - p.startTimestamp) / 1000;
    const remaining = Math.max(0, (p.minutes * 60) - elapsed);
    const remainMin = Math.floor(remaining / 60);
    const remainSec = Math.floor(remaining % 60);
    const color = p.team === 'home' ? 'var(--home)' : 'var(--away)';
    
    // Auto-remove expired penalties
    if (remaining <= 0) {
      setTimeout(() => removePenalty(p.id), 100);
      return '';
    }
    
    return `
      <div style="display:inline-flex;align-items:center;gap:4px;background:${color};color:#fff;padding:2px 6px;border-radius:3px;font-size:9px;">
        <span>#${p.playerNum}</span>
        <span style="font-family:monospace;">${remainMin}:${String(remainSec).padStart(2,'0')}</span>
        <button onclick="removePenalty(${p.id})" style="background:none;border:none;color:#fff;cursor:pointer;font-size:8px;">‚úï</button>
      </div>
    `;
  }).join('');
  
  // Update strength indicator
  updateStrengthFromPenalties();
}

function updateStrengthFromPenalties() {
  const homePens = activePenalties.filter(p => p.team === 'home').length;
  const awayPens = activePenalties.filter(p => p.team === 'away').length;
  
  const homeStr = 5 - Math.min(homePens, 2);
  const awayStr = 5 - Math.min(awayPens, 2);
  
  const strengthEl = document.getElementById('qsStrength');
  if (strengthEl) {
    strengthEl.textContent = `${homeStr}v${awayStr}`;
    strengthEl.className = 'value strength-indicator';
    if (homeStr > awayStr) strengthEl.classList.add('pp');
    else if (awayStr > homeStr) strengthEl.classList.add('pk');
    else strengthEl.classList.add('even');
  }
}

// --- 5. STICKY RECENT PLAYERS ---
let recentPlayers = [];
const MAX_RECENT_PLAYERS = 8;

function addToRecentPlayers(player) {
  if (!player || !player.num) return;
  
  // Remove if already exists
  recentPlayers = recentPlayers.filter(p => 
    !(p.num === player.num && p.team === player.team)
  );
  
  // Add to front
  recentPlayers.unshift({
    num: player.num,
    name: player.name,
    team: player.team
  });
  
  // Limit size
  if (recentPlayers.length > MAX_RECENT_PLAYERS) {
    recentPlayers = recentPlayers.slice(0, MAX_RECENT_PLAYERS);
  }
  
  renderRecentPlayers();
}

function renderRecentPlayers() {
  const container = document.getElementById('recentPlayersBar');
  if (!container) return;
  
  if (recentPlayers.length === 0) {
    container.innerHTML = '<span style="font-size:8px;color:var(--muted);">Recent players appear here</span>';
    return;
  }
  
  container.innerHTML = recentPlayers.map(p => {
    const color = p.team === 'home' ? 'var(--home)' : 'var(--away)';
    return `
      <button class="btn-sm" onclick="quickAddRecentPlayer(${p.num}, '${p.team}')"
        style="padding:2px 6px;font-size:9px;border-left:3px solid ${color};">
        #${p.num}
      </button>
    `;
  }).join('');
}

function quickAddRecentPlayer(num, team) {
  const roster = team === 'home' ? S.homeRoster : S.awayRoster;
  const player = roster.find(p => p.num == num);
  if (player) {
    addEventPlayer({ ...player, team });
    toast(`Added #${num}`, 'success');
  }
}

// --- 6. QUICK NOTES ---
function addQuickNote() {
  const note = prompt('Add note to current event:');
  if (note) {
    S.curr.note = note;
    toast('Note added', 'success');
  }
}

function showEventNotes(idx) {
  const evt = S.events[idx];
  if (evt && evt.note) {
    alert(`Event #${idx + 1} Note:\n${evt.note}`);
  }
}

// --- 7. MULTI-LEVEL UNDO ---
const undoStack = [];
const MAX_UNDO = 20;

function pushUndoState(action) {
  undoStack.push({
    action,
    events: JSON.parse(JSON.stringify(S.events)),
    shifts: JSON.parse(JSON.stringify(S.shifts)),
    timestamp: Date.now()
  });
  
  if (undoStack.length > MAX_UNDO) {
    undoStack.shift();
  }
  
  updateUndoButton();
}

function undo() {
  if (undoStack.length === 0) {
    toast('Nothing to undo', 'warning');
    return;
  }
  
  const state = undoStack.pop();
  S.events = state.events;
  S.shifts = state.shifts;
  
  renderEvents();
  renderShifts();
  updateQuickStats();
  
  toast(`Undone: ${state.action}`, 'info');
  updateUndoButton();
}

function updateUndoButton() {
  const btn = document.getElementById('undoBtn');
  if (btn) {
    btn.disabled = undoStack.length === 0;
    btn.title = undoStack.length > 0 
      ? `Undo: ${undoStack[undoStack.length - 1].action} (${undoStack.length})`
      : 'Nothing to undo';
  }
}

// --- 8. BATCH EDIT ---
let selectedEventIds = [];
let batchSelectMode = false;

function toggleBatchSelectMode() {
  batchSelectMode = !batchSelectMode;
  selectedEventIds = [];
  
  document.getElementById('batchSelectBtn').classList.toggle('active', batchSelectMode);
  
  if (batchSelectMode) {
    toast('Click events to select. Click again to apply changes.', 'info');
  } else {
    renderEvents();
  }
}

function toggleEventSelection(idx) {
  if (!batchSelectMode) return false;
  
  const eventIdx = selectedEventIds.indexOf(idx);
  if (eventIdx >= 0) {
    selectedEventIds.splice(eventIdx, 1);
  } else {
    selectedEventIds.push(idx);
  }
  
  renderEvents();
  return true; // Prevent normal click behavior
}

function applyBatchEdit() {
  if (selectedEventIds.length === 0) {
    toast('No events selected', 'warning');
    return;
  }
  
  const html = `
    <h3>üìù Batch Edit (${selectedEventIds.length} events)</h3>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
      <div class="form-group">
        <label>Zone</label>
        <select id="batchZone">
          <option value="">-- No change --</option>
          <option value="o">Offensive</option>
          <option value="n">Neutral</option>
          <option value="d">Defensive</option>
        </select>
      </div>
      <div class="form-group">
        <label>Success</label>
        <select id="batchSuccess">
          <option value="">-- No change --</option>
          <option value="s">Success</option>
          <option value="u">Unsuccess</option>
        </select>
      </div>
      <div class="form-group">
        <label>Highlight</label>
        <select id="batchHighlight">
          <option value="">-- No change --</option>
          <option value="true">Yes ‚≠ê</option>
          <option value="false">No</option>
        </select>
      </div>
      <div class="form-group">
        <label>Team</label>
        <select id="batchTeam">
          <option value="">-- No change --</option>
          <option value="home">Home</option>
          <option value="away">Away</option>
        </select>
      </div>
    </div>
    <div class="modal-actions">
      <button class="btn-primary" onclick="confirmBatchEdit()">Apply to ${selectedEventIds.length} Events</button>
      <button onclick="closeModal();toggleBatchSelectMode();">Cancel</button>
    </div>
  `;
  
  showModal(html);
}

function confirmBatchEdit() {
  const zone = document.getElementById('batchZone').value;
  const success = document.getElementById('batchSuccess').value;
  const highlight = document.getElementById('batchHighlight').value;
  const team = document.getElementById('batchTeam').value;
  
  pushUndoState('Batch edit');
  
  selectedEventIds.forEach(idx => {
    const evt = S.events.find(e => e.idx === idx);
    if (evt) {
      if (zone) evt.zone = zone;
      if (success) evt.success = success === 's';
      if (highlight !== '') evt.isHighlight = highlight === 'true';
      if (team) evt.team = team;
    }
  });
  
  closeModal();
  toggleBatchSelectMode();
  renderEvents();
  toast(`Updated ${selectedEventIds.length} events`, 'success');
}

// --- 9. GOAL REVIEW MODE ---
function startGoalReview(idx) {
  const evt = S.events.find(e => e.idx === idx);
  if (!evt || evt.type !== 'Goal') {
    toast('Select a goal event first', 'warning');
    return;
  }
  
  // Find video time for goal
  const videoTime = calculateRunningVideoTime(
    evt.period === 'OT' ? 4 : parseInt(evt.period) || 1,
    evt.start_time
  );
  
  // Seek to 10 seconds before goal
  videoSeekTo(Math.max(0, videoTime - 10));
  setVideoSpeed(0.5);
  
  toast('Goal review: Playing at 0.5x from 10s before', 'info');
  
  // Highlight related events
  highlightGoalSequence(idx);
}

function highlightGoalSequence(goalIdx) {
  // Find events within 30 seconds before goal
  const goal = S.events.find(e => e.idx === goalIdx);
  if (!goal) return;
  
  const goalTime = parseGameTime(goal.start_time);
  const relatedEvents = S.events.filter(e => {
    if (e.period !== goal.period) return false;
    const evtTime = parseGameTime(e.start_time);
    const diff = goalTime - evtTime; // Positive = before goal
    return diff >= 0 && diff <= 30;
  });
  
  // Mark these in UI
  relatedEvents.forEach(e => {
    const row = document.querySelector(`[data-evt-idx="${e.idx}"]`);
    if (row) row.classList.add('goal-sequence');
  });
}

function parseGameTime(timeStr) {
  if (!timeStr) return 0;
  const parts = timeStr.split(':');
  return parseInt(parts[0] || 0) * 60 + parseInt(parts[1] || 0);
}

// --- 10. KEYBOARD-ONLY XY MODE (WASD) ---
let keyboardXYMode = false;
let keyboardXYPosition = { x: 100, y: 42.5 }; // Center of rink

function toggleKeyboardXYMode() {
  keyboardXYMode = !keyboardXYMode;
  
  if (keyboardXYMode) {
    toast('Keyboard XY: WASD to move, Enter to place', 'info');
    showKeyboardCursor();
  } else {
    hideKeyboardCursor();
  }
}

function showKeyboardCursor() {
  let cursor = document.getElementById('keyboardXYCursor');
  if (!cursor) {
    cursor = document.createElement('div');
    cursor.id = 'keyboardXYCursor';
    cursor.style.cssText = `
      position: absolute;
      width: 12px;
      height: 12px;
      border: 2px solid var(--accent);
      border-radius: 50%;
      pointer-events: none;
      z-index: 100;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 8px var(--accent);
    `;
    document.querySelector('.rink-wrap').appendChild(cursor);
  }
  updateKeyboardCursor();
  cursor.style.display = 'block';
}

function hideKeyboardCursor() {
  const cursor = document.getElementById('keyboardXYCursor');
  if (cursor) cursor.style.display = 'none';
}

function updateKeyboardCursor() {
  const cursor = document.getElementById('keyboardXYCursor');
  if (!cursor) return;
  
  const svg = document.getElementById('rinkSvg');
  const rect = svg.getBoundingClientRect();
  
  // Convert SVG coords to screen coords
  const scaleX = rect.width / 200;
  const scaleY = rect.height / 85;
  
  cursor.style.left = `${keyboardXYPosition.x * scaleX}px`;
  cursor.style.top = `${keyboardXYPosition.y * scaleY}px`;
}

function moveKeyboardXY(dx, dy) {
  keyboardXYPosition.x = Math.max(0, Math.min(200, keyboardXYPosition.x + dx));
  keyboardXYPosition.y = Math.max(0, Math.min(85, keyboardXYPosition.y + dy));
  updateKeyboardCursor();
}

function placeKeyboardXY() {
  if (!keyboardXYMode) return;
  
  // Simulate click at current position
  handleXYPlacement(keyboardXYPosition.x, keyboardXYPosition.y);
  toast(`Placed at (${Math.round(keyboardXYPosition.x)}, ${Math.round(keyboardXYPosition.y)})`, 'success');
}

// Add keyboard handlers for WASD
document.addEventListener('keydown', (e) => {
  if (!keyboardXYMode) return;
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') return;
  
  const step = e.shiftKey ? 10 : 3;
  
  switch(e.key.toLowerCase()) {
    case 'w': moveKeyboardXY(0, -step); e.preventDefault(); break;
    case 'a': moveKeyboardXY(-step, 0); e.preventDefault(); break;
    case 's': moveKeyboardXY(0, step); e.preventDefault(); break;
    case 'd': moveKeyboardXY(step, 0); e.preventDefault(); break;
    case 'enter': placeKeyboardXY(); e.preventDefault(); break;
    case 'escape': toggleKeyboardXYMode(); e.preventDefault(); break;
  }
});

// --- 11. EVENT QUEUE (quick log, fill later) ---
let eventQueue = [];

function quickQueueEvent(type) {
  const videoTime = getVideoCurrentTime();
  const gameTime = calculateGameTimeFromVideo(videoTime);
  
  const evt = {
    id: Date.now(),
    type,
    period: gameTime?.period || S.period,
    start_time: gameTime?.clock || document.getElementById('clock').value,
    videoTime,
    team: document.getElementById('evtTeam').value,
    queued: true
  };
  
  eventQueue.push(evt);
  renderEventQueue();
  toast(`Queued: ${type}`, 'info');
}

function renderEventQueue() {
  const container = document.getElementById('eventQueueDisplay');
  if (!container) return;
  
  if (eventQueue.length === 0) {
    container.innerHTML = '';
    return;
  }
  
  container.innerHTML = `
    <div style="font-size:9px;color:var(--warn);margin-bottom:4px;">
      üìã Queue (${eventQueue.length}) - click to complete
    </div>
    ${eventQueue.map((e, i) => `
      <button class="btn-sm" onclick="processQueuedEvent(${i})"
        style="padding:2px 6px;font-size:9px;background:var(--warn);color:#000;margin:1px;">
        ${e.type.substring(0,4)} P${e.period} ${e.start_time}
      </button>
    `).join('')}
  `;
}

function processQueuedEvent(idx) {
  const evt = eventQueue[idx];
  if (!evt) return;
  
  // Load into current event form
  setEvtType(evt.type);
  document.getElementById('evtStartTime').value = evt.start_time;
  document.getElementById('evtTeam').value = evt.team;
  S.period = evt.period;
  document.querySelector('.period-btn.active')?.classList.remove('active');
  document.querySelector(`.period-btn[onclick*="${evt.period}"]`)?.classList.add('active');
  
  // Seek video to that time
  if (evt.videoTime) {
    videoSeekTo(evt.videoTime);
  }
  
  // Remove from queue
  eventQueue.splice(idx, 1);
  renderEventQueue();
  
  toast('Complete the event details and log', 'info');
}

function clearEventQueue() {
  if (eventQueue.length === 0) return;
  if (confirm(`Clear ${eventQueue.length} queued events?`)) {
    eventQueue = [];
    renderEventQueue();
  }
}

// --- 12. LIVE STATS OVERLAY ---
function toggleStatsOverlay() {
  let overlay = document.getElementById('liveStatsOverlay');
  
  if (overlay) {
    overlay.style.display = overlay.style.display === 'none' ? 'block' : 'none';
    return;
  }
  
  // Create overlay
  overlay = document.createElement('div');
  overlay.id = 'liveStatsOverlay';
  overlay.style.cssText = `
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(0,0,0,0.8);
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 10px;
    color: #fff;
    z-index: 50;
    pointer-events: none;
  `;
  
  document.getElementById('videoPlayerContainer').appendChild(overlay);
  updateStatsOverlay();
  
  // Update every second
  setInterval(updateStatsOverlay, 1000);
}

function updateStatsOverlay() {
  const overlay = document.getElementById('liveStatsOverlay');
  if (!overlay || overlay.style.display === 'none') return;
  
  const homeShots = S.events.filter(e => e.type === 'Shot' && e.team === 'home').length;
  const awayShots = S.events.filter(e => e.type === 'Shot' && e.team === 'away').length;
  const homeGoals = S.events.filter(e => e.type === 'Goal' && e.team === 'home').length;
  const awayGoals = S.events.filter(e => e.type === 'Goal' && e.team === 'away').length;
  
  overlay.innerHTML = `
    <div style="display:grid;grid-template-columns:1fr auto 1fr;gap:4px;text-align:center;">
      <span style="color:var(--home);">${S.homeTeam || 'HOME'}</span>
      <span></span>
      <span style="color:var(--away);">${S.awayTeam || 'AWAY'}</span>
      <span style="font-size:16px;font-weight:bold;">${homeGoals}</span>
      <span style="font-size:12px;">SCORE</span>
      <span style="font-size:16px;font-weight:bold;">${awayGoals}</span>
      <span>${homeShots}</span>
      <span style="font-size:8px;">SOG</span>
      <span>${awayShots}</span>
    </div>
  `;
}

// Hook into logEventDirect to track recent players and suggestions
const originalLogEventDirectV25 = typeof logEventDirect === 'function' ? logEventDirect : null;

// --- Initialize new features ---
function initV25Features() {
  renderEventSuggestions();
  renderRecentPlayers();
  renderEventQueue();
  updatePenaltyBox();
  updatePossessionDisplay();
  updateUndoButton();
  
  // Add CSS for goal sequence highlighting
  const style = document.createElement('style');
  style.textContent = `
    .goal-sequence { background: rgba(34, 197, 94, 0.2) !important; }
    .batch-selected { background: rgba(59, 130, 246, 0.3) !important; outline: 2px solid var(--accent); }
  `;
  document.head.appendChild(style);
}

// Call on init
setTimeout(initV25Features, 500);

// ============================================================
// v23.5: SPEED & WORKFLOW FEATURES
// ============================================================

// --- 1. MIRROR MODE (Auto-flip XY for period 2) ---
let mirrorModeEnabled = true;

function toggleMirrorMode() {
  mirrorModeEnabled = !mirrorModeEnabled;
  toast(`Mirror Mode: ${mirrorModeEnabled ? 'ON' : 'OFF'}`, 'info');
  updateMirrorModeIndicator();
}

function updateMirrorModeIndicator() {
  const btn = document.getElementById('mirrorModeBtn');
  if (btn) btn.classList.toggle('active', mirrorModeEnabled);
}

function shouldMirrorXY() {
  if (!mirrorModeEnabled) return false;
  // Mirror in periods 2, 4 (OT if even periods played)
  const period = S.period;
  return period === 2 || period === '2';
}

function applyMirror(x, y) {
  if (shouldMirrorXY()) {
    return { x: 200 - x, y: 85 - y }; // Flip both axes
  }
  return { x, y };
}

// --- 2. AUTO ZONE FROM XY ---
let autoZoneEnabled = true;
let autoPressureEnabled = true;
let autoSuccessEnabled = true;
let autoSideOfPuckEnabled = true;

/**
 * v23.9: Toggle collapsible section
 */
function toggleCollapsible(sectionId) {
  const content = document.getElementById(sectionId);
  const icon = document.getElementById(sectionId + 'Icon');
  if (!content) return;
  
  const isVisible = content.classList.contains('show') || content.style.display !== 'none';
  if (isVisible) {
    content.classList.remove('show');
    content.style.display = 'none';
    if (icon) icon.textContent = '‚ñ∂';
  } else {
    content.classList.add('show');
    // Check if content should be flex (has flex in style attribute or class)
    if (content.style.cssText.includes('display:flex') || content.style.cssText.includes('flex') || content.classList.contains('flex')) {
      content.style.display = 'flex';
    } else {
      content.style.display = 'block';
    }
    if (icon) icon.textContent = '‚ñº';
  }
}

/**
 * v23.9: Initialize collapsible sections - start collapsed
 */
function initCollapsibleSections() {
  // Start with sections collapsed (not shown)
  const sections = ['quickFaceoffRow', 'quickStoppageRow', 'quickPenaltyRow', 'eventTemplatesRow', 'linePresetsBar'];
  sections.forEach(id => {
    const content = document.getElementById(id);
    const icon = document.getElementById(id + 'Icon');
    if (content) {
      content.classList.remove('show');
      if (icon) icon.textContent = '‚ñ∂';
    }
  });
}

/**
 * v23.9: Get players from shift at a specific time
 */
function getPlayersFromShiftAtTime(timeStr, period) {
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'getPlayersFromShiftAtTime:5204',message:'Function entry',data:{timeStr,period,shiftsCount:S.shifts?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
  // #endregion
  if (!timeStr || !period) return null;
  
  const shift = S.shifts.find(s => {
    if (s.period !== period) return false;
    if (!s.start_time || !s.end_time) return false;
    const timeMatch = isTimeBetween(timeStr, s.start_time, s.end_time);
    // #region agent log
    if (S.shifts.indexOf(s) < 3) { // Log first 3 shifts for debugging
      fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'getPlayersFromShiftAtTime:5210',message:'Checking shift',data:{timeStr,period,shiftPeriod:s.period,shiftStartTime:s.start_time,shiftEndTime:s.end_time,timeMatch,shiftHomeCount:Object.values(s.home||{}).filter(Boolean).length,shiftAwayCount:Object.values(s.away||{}).filter(Boolean).length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
    }
    // #endregion
    return timeMatch;
  });
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'getPlayersFromShiftAtTime:5213',message:'After finding shift',data:{shiftFound:!!shift,shiftPeriod:shift?.period,shiftStartTime:shift?.start_time,shiftEndTime:shift?.end_time,shiftHomeKeys:shift?.home?Object.keys(shift.home):[],shiftAwayKeys:shift?.away?Object.keys(shift.away):[]},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
  // #endregion
  if (!shift) return null;
  
  // Return players from this shift
  const players = [];
  ['F1','F2','F3','D1','D2','G','X'].forEach(pos => {
    if (shift.home?.[pos]?.num) {
      players.push({
        num: shift.home[pos].num,
        name: shift.home[pos].name || '',
        team: 'home',
        role: `event_team_player_${players.filter(p => p.team === 'home').length + 1}`,
        xy: [],
        playD1: '', playD2: '', playSuccess: '', pressure: '', sideOfPuck: ''
      });
    }
    if (shift.away?.[pos]?.num) {
      players.push({
        num: shift.away[pos].num,
        name: shift.away[pos].name || '',
        team: 'away',
        role: `opp_team_player_${players.filter(p => p.team === 'away').length + 1}`,
        xy: [],
        playD1: '', playD2: '', playSuccess: '', pressure: '', sideOfPuck: ''
      });
    }
  });
  
  return { shift, players };
}

/**
 * v23.9: When start time changes, get players from shift at that time
 */
function onStartTimeChange() {
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onStartTimeChange:5246',message:'Function entry',data:{timeStr:document.getElementById('evtStartTime')?.value,period:S.period,shiftsCount:S.shifts?.length||0,rostersHome:S.rosters?.home?.length||0,rostersAway:S.rosters?.away?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
  // #endregion
  const timeStr = document.getElementById('evtStartTime').value;
  const period = S.period;
  
  if (!timeStr || timeStr.length < 4) {
    // Time not valid yet, but don't clear slots - user might still be typing
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onStartTimeChange:5250',message:'Early return - time too short',data:{timeStr,timeStrLength:timeStr?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
    // #endregion
    return;
  }
  
  const result = getPlayersFromShiftAtTime(timeStr, period);
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onStartTimeChange:5255',message:'After getPlayersFromShiftAtTime',data:{resultFound:!!result,shiftFound:!!result?.shift,playersCount:result?.players?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
  // #endregion
  if (result && result.shift) {
    const shift = result.shift;
    
    // Populate slots from shift with correct positions
    // Clear existing slots first
    S.slots.home = { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null };
    S.slots.away = { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null };
    
    // Populate home team slots from shift (preserve positions)
    if (shift.home) {
      ['F1', 'F2', 'F3', 'D1', 'D2', 'G', 'X'].forEach(pos => {
        const p = shift.home[pos];
        if (p?.num) {
          // Find player in roster to get full details
          const rosterPlayer = S.rosters?.home?.find(rp => String(rp.num) === String(p.num));
          if (rosterPlayer) {
            S.slots.home[pos] = {
              num: rosterPlayer.num,
              name: rosterPlayer.name,
              pos: rosterPlayer.pos || pos
            };
          } else {
            // Fallback to shift data
            S.slots.home[pos] = {
              num: p.num,
              name: p.name || `#${p.num}`,
              pos: pos
            };
          }
        }
      });
    }
    
    // Populate away team slots from shift (preserve positions)
    if (shift.away) {
      ['F1', 'F2', 'F3', 'D1', 'D2', 'G', 'X'].forEach(pos => {
        const p = shift.away[pos];
        if (p?.num) {
          // Find player in roster to get full details
          const rosterPlayer = S.rosters?.away?.find(rp => String(rp.num) === String(p.num));
          if (rosterPlayer) {
            S.slots.away[pos] = {
              num: rosterPlayer.num,
              name: rosterPlayer.name,
              pos: rosterPlayer.pos || pos
            };
          } else {
            // Fallback to shift data
            S.slots.away[pos] = {
              num: p.num,
              name: p.name || `#${p.num}`,
              pos: pos
            };
          }
        }
      });
    }
    
    // Count how many players were populated
    const homeCount = Object.values(S.slots.home).filter(Boolean).length;
    const awayCount = Object.values(S.slots.away).filter(Boolean).length;
    
    // #region agent log
    const slotsHomeDetails = Object.entries(S.slots.home).filter(([k,v])=>v).map(([k,v])=>({pos:k,num:v.num,name:v.name}));
    const slotsAwayDetails = Object.entries(S.slots.away).filter(([k,v])=>v).map(([k,v])=>({pos:k,num:v.num,name:v.name}));
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onStartTimeChange:5329',message:'After populating slots',data:{homeCount,awayCount,evtTeam:S.evtTeam,slotsHomeDetails,slotsAwayDetails,rostersHomeCount:S.rosters?.home?.length||0,rostersAwayCount:S.rosters?.away?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
    // #endregion
    if (homeCount > 0 || awayCount > 0) {
      renderQuickAdd();
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onStartTimeChange:5336',message:'After renderQuickAdd call',data:{homeCount,awayCount},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
      // #endregion
      toast(`Players from shift at ${timeStr} available (${homeCount + awayCount} players)`, 'success');
    } else {
      toast(`No shift found at ${timeStr} in period ${period}`, 'warning');
    }
  } else {
    // No shift found at this time
    console.log('No shift found at time:', timeStr, 'period:', period);
    toast(`No shift found at ${timeStr} in period ${period}`, 'warning');
  }
}

function toggleAutoZone() {
  autoZoneEnabled = !autoZoneEnabled;
  toast(`Auto Zone: ${autoZoneEnabled ? 'ON' : 'OFF'}`, 'info');
  saveAutoSettings();
}

function toggleAutoPressure() {
  autoPressureEnabled = !autoPressureEnabled;
  toast(`Auto Pressure: ${autoPressureEnabled ? 'ON' : 'OFF'}`, 'info');
  saveAutoSettings();
  if (autoPressureEnabled) autoDetectAllPressure();
}

function toggleAutoSuccess() {
  autoSuccessEnabled = !autoSuccessEnabled;
  toast(`Auto Success: ${autoSuccessEnabled ? 'ON' : 'OFF'}`, 'info');
  saveAutoSettings();
  if (autoSuccessEnabled) autoDetectAllSuccess();
}

function toggleAutoSideOfPuck() {
  autoSideOfPuckEnabled = !autoSideOfPuckEnabled;
  toast(`Auto Side of Puck: ${autoSideOfPuckEnabled ? 'ON' : 'OFF'}`, 'info');
  saveAutoSettings();
  if (autoSideOfPuckEnabled) autoDetectAllSideOfPuck();
}

function saveAutoSettings() {
  localStorage.setItem('benchsight_autoZone', autoZoneEnabled);
  localStorage.setItem('benchsight_autoPressure', autoPressureEnabled);
  localStorage.setItem('benchsight_autoSuccess', autoSuccessEnabled);
  localStorage.setItem('benchsight_autoSideOfPuck', autoSideOfPuckEnabled);
}

function loadAutoSettings() {
  const savedZone = localStorage.getItem('benchsight_autoZone');
  const savedPressure = localStorage.getItem('benchsight_autoPressure');
  const savedSuccess = localStorage.getItem('benchsight_autoSuccess');
  const savedSide = localStorage.getItem('benchsight_autoSideOfPuck');
  
  if (savedZone !== null) autoZoneEnabled = savedZone === 'true';
  if (savedPressure !== null) autoPressureEnabled = savedPressure === 'true';
  if (savedSuccess !== null) autoSuccessEnabled = savedSuccess === 'true';
  if (savedSide !== null) autoSideOfPuckEnabled = savedSide === 'true';
}

function getZoneFromXY(x) {
  // Rink is 200 units wide
  // Home attacks right in P1 (default)
  const homeAttacksRight = S.homeAttacksRightP1 !== false;
  const isHome = S.evtTeam === 'home';
  const mirrorPeriod = shouldMirrorXY();
  
  let attacksRight = (isHome === homeAttacksRight);
  if (mirrorPeriod) attacksRight = !attacksRight;
  
  if (attacksRight) {
    // Offensive = right side (x > 140), Defensive = left (x < 60)
    if (x > 140) return 'o';
    if (x < 60) return 'd';
    return 'n';
  } else {
    // Offensive = left side (x < 60), Defensive = right (x > 140)
    if (x < 60) return 'o';
    if (x > 140) return 'd';
    return 'n';
  }
}

function autoSetZoneFromXY(x) {
  if (!autoZoneEnabled) return;
  if (typeof getZoneFromXY !== 'function') return;
  const zone = getZoneFromXY(x);
  if (zone) {
    if (typeof setZone === 'function') setZone(zone);
    // Also update zone display
    if (typeof updateZoneDisplay === 'function') updateZoneDisplay();
  }
}

// --- 3. GOALIE AUTO-ADD ---
let goalieAutoAddEnabled = true;

function toggleGoalieAutoAdd() {
  goalieAutoAddEnabled = !goalieAutoAddEnabled;
  toast(`Goalie Auto-Add: ${goalieAutoAddEnabled ? 'ON' : 'OFF'}`, 'info');
}

function autoAddGoalie() {
  if (!goalieAutoAddEnabled) return;
  
  const evtTypeEl = document.getElementById('evtType');
  if (!evtTypeEl) return;
  const evtType = evtTypeEl.value;
  if (!['Shot', 'Goal', 'Save', 'Rebound'].includes(evtType)) return;
  
  // Find opposing goalie
  const oppTeam = S.evtTeam === 'home' ? 'away' : 'home';
  const roster = S.rosters?.[oppTeam] || [];
  const goalie = roster.find(p => p.pos === 'G' || p.position === 'G' || p.position === 'Goalie');
  
  if (goalie) {
    // Check if already added
    const alreadyAdded = S.curr.players?.some(p => p.num == goalie.num && p.team === oppTeam);
    if (!alreadyAdded) {
      addEventPlayer({ ...goalie, team: oppTeam, role: 'opp_team_player_1' });
    }
  }
}

// --- 4. QUICK STRENGTH BUTTONS ---
function setStrength(strength) {
  document.getElementById('evtStrength').value = strength;
  
  // Update button states
  document.querySelectorAll('.strength-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.strength === strength);
  });
  
  toast(`Strength: ${strength}`, 'info');
}

// --- 5. ENHANCED FACEOFF PRESETS ---
function setupFaceoffWithPlayers(dotName, homeCenter, awayCenter) {
  // Set faceoff type
  setEvtType('Faceoff');
  
  // Position at dot
  if (typeof positionAtFaceoffDot === 'function') {
    const dot = FACEOFF_DOTS?.find(d => d.name === dotName);
    if (dot) {
      handleFaceoffDotClick(dot);
    }
  }
  
  // Add centers if provided
  if (homeCenter) {
    const homePlayer = S.homeRoster.find(p => p.num == homeCenter);
    if (homePlayer) addEventPlayer({ ...homePlayer, team: 'home' });
  }
  if (awayCenter) {
    const awayPlayer = S.awayRoster.find(p => p.num == awayCenter);
    if (awayPlayer) addEventPlayer({ ...awayPlayer, team: 'away', role: 'opp_team_player_1' });
  }
}

// --- 6. GAP FINDER ---
function findEventGaps() {
  const events = S.events || [];
  if (events.length < 2) {
    toast('Need at least 2 events to find gaps', 'warning');
    return;
  }
  
  const gaps = [];
  const minGapSeconds = 60; // Report gaps > 1 minute
  
  for (let i = 1; i < events.length; i++) {
    const prev = events[i - 1];
    const curr = events[i];
    
    if (prev.period !== curr.period) continue;
    
    const prevTime = parseGameTime(prev.start_time);
    const currTime = parseGameTime(curr.start_time);
    const gapSec = prevTime - currTime; // Clock counts down
    
    if (gapSec > minGapSeconds) {
      gaps.push({
        period: curr.period,
        from: curr.start_time,
        to: prev.start_time,
        duration: gapSec,
        afterEvent: i - 1
      });
    }
  }
  
  if (gaps.length === 0) {
    toast('No significant gaps found!', 'success');
    return;
  }
  
  // Show gaps
  const html = `
    <h3>üîç Event Gaps Found (>${minGapSeconds}s)</h3>
    <div style="max-height:300px;overflow-y:auto;">
      <table style="width:100%;font-size:10px;border-collapse:collapse;">
        <thead>
          <tr style="background:var(--panel);">
            <th style="padding:4px;">Period</th>
            <th style="padding:4px;">From</th>
            <th style="padding:4px;">To</th>
            <th style="padding:4px;">Gap</th>
            <th style="padding:4px;">Action</th>
          </tr>
        </thead>
        <tbody>
          ${gaps.map(g => `
            <tr>
              <td style="padding:4px;text-align:center;">P${g.period}</td>
              <td style="padding:4px;text-align:center;">${g.from}</td>
              <td style="padding:4px;text-align:center;">${g.to}</td>
              <td style="padding:4px;text-align:center;color:var(--warn);">${Math.floor(g.duration / 60)}:${String(g.duration % 60).padStart(2, '0')}</td>
              <td style="padding:4px;text-align:center;">
                <button class="btn-sm" onclick="jumpToGap(${g.period}, '${g.from}')" style="font-size:8px;">Go</button>
              </td>
            </tr>
          `).join('')}
        </tbody>
      </table>
    </div>
    <div style="margin-top:10px;font-size:9px;color:var(--muted);">
      Found ${gaps.length} gap(s). Click "Go" to seek video to that time.
    </div>
    <div class="modal-actions">
      <button onclick="closeModal()">Close</button>
    </div>
  `;
  
  showModal(html);
}

function jumpToGap(period, time) {
  const videoTime = calculateRunningVideoTime(period, time);
  videoSeekTo(videoTime);
  closeModal();
  toast(`Jumped to P${period} ${time}`, 'info');
}

// --- 7. DUPLICATE DETECTION ---
let duplicateCheckEnabled = true;

function checkForDuplicate() {
  if (!duplicateCheckEnabled || S.events.length === 0) return null;
  
  const curr = S.curr;
  const type = document.getElementById('evtType').value;
  const time = document.getElementById('evtStartTime').value;
  const team = document.getElementById('evtTeam').value;
  
  if (!type || !time) return null;
  
  // Look for similar event in last 10 events
  const recent = S.events.slice(-10);
  
  for (const evt of recent) {
    if (evt.type !== type) continue;
    if (evt.team !== team) continue;
    if (evt.period !== S.period) continue;
    
    // Check if time is within 5 seconds
    const evtTimeSec = parseGameTime(evt.start_time);
    const currTimeSec = parseGameTime(time);
    
    if (Math.abs(evtTimeSec - currTimeSec) <= 5) {
      return evt;
    }
  }
  
  return null;
}

function warnIfDuplicate() {
  const dup = checkForDuplicate();
  if (dup) {
    const idx = S.events.indexOf(dup);
    toast(`‚ö†Ô∏è Similar to event #${idx + 1} (${dup.type} @ ${dup.start_time})`, 'warning');
    return true;
  }
  return false;
}

// --- 8. AUTO-LINK SUGGESTIONS ---
function suggestEventLink() {
  const type = document.getElementById('evtType').value;
  if (!type || S.events.length === 0) return;
  
  // Types that should link to previous
  const linkTypes = {
    'Save': ['Shot'],
    'Rebound': ['Shot', 'Save'],
    'Goal': ['Shot', 'Rebound'],
    'Turnover': ['Pass', 'Possession'],
    'Possession': ['Turnover', 'Faceoff', 'Save']
  };
  
  const shouldLinkTo = linkTypes[type];
  if (!shouldLinkTo) return;
  
  // Find last event of matching type
  for (let i = S.events.length - 1; i >= Math.max(0, S.events.length - 5); i--) {
    const evt = S.events[i];
    if (shouldLinkTo.includes(evt.type) && evt.period === S.period) {
      // Suggest link
      const linkEl = document.getElementById('evtLinked');
      if (linkEl && !linkEl.value) {
        linkEl.value = i + 1;
        toast(`Auto-linked to #${i + 1} (${evt.type})`, 'info');
      }
      return;
    }
  }
}

// --- 9. SHIFT LENGTH ALERT ---
let shiftAlertThreshold = 45; // seconds
let shiftCriticalThreshold = 60;
let shiftAlertInterval = null;

function startShiftAlerts() {
  if (shiftAlertInterval) clearInterval(shiftAlertInterval);
  
  shiftAlertInterval = setInterval(() => {
    checkShiftLengths();
  }, 5000);
}

function checkShiftLengths() {
  // Find active shifts (started but not ended)
  const currentTime = document.getElementById('clock').value;
  const currentTimeSec = parseGameTime(currentTime);
  
  S.shifts?.forEach((shift, idx) => {
    if (shift.end_time) return; // Already ended
    if (shift.period !== S.period) return;
    
    const startSec = parseGameTime(shift.start_time);
    const duration = startSec - currentTimeSec;
    
    if (duration >= shiftCriticalThreshold) {
      // Critical - highlight in red
      highlightShift(idx, 'critical');
    } else if (duration >= shiftAlertThreshold) {
      // Warning - highlight in yellow
      highlightShift(idx, 'warning');
    }
  });
}

function highlightShift(idx, level) {
  const row = document.querySelector(`[data-shift-idx="${idx}"]`);
  if (row) {
    row.classList.remove('shift-warning', 'shift-critical');
    row.classList.add(`shift-${level}`);
  }
}

// --- 10. NUMPAD MODE ---
let numpadModeEnabled = false;

function toggleNumpadMode() {
  numpadModeEnabled = !numpadModeEnabled;
  toast(`Numpad Mode: ${numpadModeEnabled ? 'ON - Use numpad for players' : 'OFF'}`, 'info');
}

// Numpad handler (separate from main keyboard)
document.addEventListener('keydown', (e) => {
  if (!numpadModeEnabled) return;
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') return;
  
  // Numpad keys
  const numpadMap = {
    'Numpad1': 1, 'Numpad2': 2, 'Numpad3': 3,
    'Numpad4': 4, 'Numpad5': 5, 'Numpad6': 6,
    'Numpad7': 7, 'Numpad8': 8, 'Numpad9': 9,
    'Numpad0': 10
  };
  
  if (numpadMap[e.code]) {
    e.preventDefault();
    const slot = numpadMap[e.code];
    
    if (e.shiftKey) {
      // Opponent player
      selectEventPlayerSlot('opp', Math.min(slot, 6));
    } else {
      // Event player
      selectEventPlayerSlot('evt', Math.min(slot, 6));
    }
  }
  
  // NumpadEnter = log event
  if (e.code === 'NumpadEnter') {
    e.preventDefault();
    logEvent();
  }
  
  // NumpadAdd = highlight
  if (e.code === 'NumpadAdd') {
    e.preventDefault();
    document.getElementById('evtHighlight').checked = true;
  }
});

// --- 11. ICING/OFFSIDE QUICK BUTTONS ---
function quickIcing(team) {
  setEvtType('Stoppage');
  document.getElementById('evtD1').value = 'Stoppage_Icing';
  document.getElementById('evtTeam').value = team;
  toast('Icing - ready to log', 'info');
}

function quickOffside() {
  setEvtType('Stoppage');
  document.getElementById('evtD1').value = 'Stoppage_Offside';
  toast('Offside - ready to log', 'info');
}

// --- 12. EMPTY NET TOGGLE ---
let emptyNetTeam = null;

function toggleEmptyNet(team) {
  if (emptyNetTeam === team) {
    emptyNetTeam = null;
    toast('Empty net cleared', 'info');
  } else {
    emptyNetTeam = team;
    toast(`Empty net: ${team.toUpperCase()}`, 'warn');
  }
  updateEmptyNetIndicator();
}

function updateEmptyNetIndicator() {
  const indicator = document.getElementById('emptyNetIndicator');
  if (indicator) {
    if (emptyNetTeam) {
      indicator.textContent = `EN: ${emptyNetTeam.toUpperCase()}`;
      indicator.style.display = 'inline';
      indicator.style.color = emptyNetTeam === 'home' ? 'var(--home)' : 'var(--away)';
    } else {
      indicator.style.display = 'none';
    }
  }
}

// --- Hook into setEvtType to auto-add goalie and suggest links ---
const originalSetEvtType = typeof setEvtType === 'function' ? setEvtType : null;
if (originalSetEvtType) {
  setEvtType = function(type) {
    originalSetEvtType(type);
    
    // Auto-add goalie
    setTimeout(() => {
      autoAddGoalie();
      suggestEventLink();
    }, 100);
  };
}

// --- Hook into handleXYPlacement to auto-set zone ---
function enhanceXYPlacement(x, y) {
  // Apply mirror
  const mirrored = applyMirror(x, y);
  
  // Auto-set zone
  autoSetZoneFromXY(mirrored.x);
  
  return mirrored;
}

// --- Initialize shift alerts ---
setTimeout(startShiftAlerts, 1000);

// --- Add CSS for shift alerts ---
const shiftAlertStyle = document.createElement('style');
shiftAlertStyle.textContent = `
  .shift-warning { background: rgba(245, 158, 11, 0.3) !important; }
  .shift-critical { background: rgba(239, 68, 68, 0.4) !important; animation: pulse 0.5s infinite; }
  @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
  .mode-btn.active { background: var(--accent) !important; color: #000 !important; }
`;
document.head.appendChild(shiftAlertStyle);

// ============================================================
// v23.5: ADDITIONAL SPEED FEATURES
// ============================================================

// --- 13. SMART DEFAULTS (Learn patterns) ---
let eventPatterns = {};

function learnEventPattern() {
  const type = document.getElementById('evtType').value;
  const d1 = document.getElementById('evtD1').value;
  const d2 = document.getElementById('evtD2').value;
  const zone = document.getElementById('evtZone').value;
  
  if (!type) return;
  
  if (!eventPatterns[type]) {
    eventPatterns[type] = { d1: {}, d2: {}, zone: {} };
  }
  
  // Count occurrences
  if (d1) eventPatterns[type].d1[d1] = (eventPatterns[type].d1[d1] || 0) + 1;
  if (d2) eventPatterns[type].d2[d2] = (eventPatterns[type].d2[d2] || 0) + 1;
  if (zone) eventPatterns[type].zone[zone] = (eventPatterns[type].zone[zone] || 0) + 1;
}

function applySmartDefaults(type) {
  const pattern = eventPatterns[type];
  if (!pattern) return;
  
  // Find most common d1
  const topD1 = Object.entries(pattern.d1).sort((a, b) => b[1] - a[1])[0];
  if (topD1 && topD1[1] >= 3) {
    document.getElementById('evtD1').value = topD1[0];
  }
  
  // Find most common zone
  const topZone = Object.entries(pattern.zone).sort((a, b) => b[1] - a[1])[0];
  if (topZone && topZone[1] >= 3) {
    setZone(topZone[0]);
  }
}

// --- 14. EVENT MACROS ---
let eventMacros = [];
let recordingMacro = false;
let currentMacroEvents = [];

function startRecordingMacro() {
  recordingMacro = true;
  currentMacroEvents = [];
  toast('Recording macro... Log events, then click Stop', 'info');
  updateMacroRecordingUI();
}

function stopRecordingMacro() {
  recordingMacro = false;
  
  if (currentMacroEvents.length === 0) {
    toast('No events recorded', 'warning');
    updateMacroRecordingUI();
    return;
  }
  
  const name = prompt(`Name this macro (${currentMacroEvents.length} events):`);
  if (name) {
    eventMacros.push({
      name,
      events: currentMacroEvents,
      created: new Date().toISOString()
    });
    saveMacros();
    toast(`Macro "${name}" saved`, 'success');
  }
  
  currentMacroEvents = [];
  updateMacroRecordingUI();
}

function recordEventForMacro(evt) {
  if (!recordingMacro) return;
  
  currentMacroEvents.push({
    type: evt.type,
    detail1: evt.detail1 || evt.detail,
    detail2: evt.detail2,
    zone: evt.zone,
    success: evt.success,
    playerCount: (evt.players || []).length
  });
}

function playMacro(macroIdx) {
  const macro = eventMacros[macroIdx];
  if (!macro) return;
  
  toast(`Playing macro: ${macro.name}`, 'info');
  
  macro.events.forEach((evt, i) => {
    setTimeout(() => {
      setEvtType(evt.type);
      if (evt.detail1) document.getElementById('evtD1').value = evt.detail1;
      if (evt.detail2) document.getElementById('evtD2').value = evt.detail2;
      if (evt.zone) setZone(evt.zone);
      
      toast(`Macro step ${i + 1}/${macro.events.length}: ${evt.type}`, 'info');
    }, i * 500);
  });
}

function saveMacros() {
  localStorage.setItem('benchsight_macros', JSON.stringify(eventMacros));
}

function loadMacros() {
  const saved = localStorage.getItem('benchsight_macros');
  if (saved) {
    try {
      eventMacros = JSON.parse(saved);
    } catch (e) {
      eventMacros = [];
    }
  }
}

function updateMacroRecordingUI() {
  const btn = document.getElementById('macroRecordBtn');
  if (btn) {
    btn.textContent = recordingMacro ? '‚èπ Stop' : '‚è∫ Rec';
    btn.style.background = recordingMacro ? 'var(--danger)' : '';
  }
}

function showMacroManager() {
  loadMacros();
  
  const html = `
    <h3>üé¨ Event Macros</h3>
    <div style="margin-bottom:10px;">
      <button class="btn-sm" id="macroRecordBtn" onclick="${recordingMacro ? 'stopRecordingMacro()' : 'startRecordingMacro()'}">
        ${recordingMacro ? '‚èπ Stop Recording' : '‚è∫ Record New'}
      </button>
    </div>
    <div style="max-height:250px;overflow-y:auto;">
      ${eventMacros.length === 0 ? '<p style="color:var(--muted);">No macros saved</p>' : 
        eventMacros.map((m, i) => `
          <div style="display:flex;justify-content:space-between;align-items:center;padding:6px;background:var(--panel);margin:4px 0;border-radius:4px;">
            <span><strong>${m.name}</strong> (${m.events.length} events)</span>
            <div>
              <button class="btn-sm" onclick="playMacro(${i})" style="font-size:9px;">‚ñ∂ Play</button>
              <button class="btn-sm" onclick="deleteMacro(${i})" style="font-size:9px;background:var(--danger);">‚úï</button>
            </div>
          </div>
        `).join('')
      }
    </div>
    <div class="modal-actions">
      <button onclick="closeModal()">Close</button>
    </div>
  `;
  
  showModal(html);
}

function deleteMacro(idx) {
  if (confirm(`Delete macro "${eventMacros[idx].name}"?`)) {
    eventMacros.splice(idx, 1);
    saveMacros();
    showMacroManager();
  }
}

// Load macros on init
setTimeout(loadMacros, 100);

// --- 15. SHOT CHART OVERLAY ---
let shotChartOverlayEnabled = false;

function toggleShotChartOverlay() {
  shotChartOverlayEnabled = !shotChartOverlayEnabled;
  
  if (shotChartOverlayEnabled) {
    renderShotChartOverlay();
    toast('Shot chart overlay ON', 'info');
  } else {
    clearShotChartOverlay();
    toast('Shot chart overlay OFF', 'info');
  }
}

function renderShotChartOverlay() {
  clearShotChartOverlay();
  
  const svg = document.getElementById('rinkSvg');
  if (!svg) return;
  
  // Get all shots and goals with XY
  const shots = (S.events || []).filter(e => 
    ['Shot', 'Goal'].includes(e.type) && e.puckXY && e.puckXY.length > 0
  );
  
  shots.forEach(shot => {
    const xy = shot.puckXY[0];
    const isGoal = shot.type === 'Goal';
    const color = shot.team === 'home' ? 'var(--home)' : 'var(--away)';
    
    const marker = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    marker.setAttribute('cx', xy.x);
    marker.setAttribute('cy', xy.y);
    marker.setAttribute('r', isGoal ? 4 : 3);
    marker.setAttribute('fill', isGoal ? '#22c55e' : color);
    marker.setAttribute('stroke', '#fff');
    marker.setAttribute('stroke-width', '1');
    marker.setAttribute('opacity', '0.7');
    marker.setAttribute('class', 'shot-overlay-marker');
    marker.setAttribute('data-event-idx', S.events.indexOf(shot));
    
    // Tooltip
    marker.setAttribute('title', `${shot.type} #${S.events.indexOf(shot) + 1}`);
    
    svg.appendChild(marker);
  });
}

function clearShotChartOverlay() {
  document.querySelectorAll('.shot-overlay-marker').forEach(el => el.remove());
}

// Update overlay when events change
function refreshShotChartOverlay() {
  if (shotChartOverlayEnabled) {
    renderShotChartOverlay();
  }
}

// --- 16. PROGRESS ESTIMATOR ---
function getProgressEstimate() {
  const events = S.events || [];
  const period = S.period;
  
  // Estimate based on typical event count per period
  const eventsPerPeriod = 50; // Rough estimate
  const totalPeriods = 3;
  
  const periodEvents = events.filter(e => e.period == period).length;
  const completedPeriods = (parseInt(period) || 1) - 1;
  
  const estimatedTotal = eventsPerPeriod * totalPeriods;
  const currentCount = events.length;
  
  // Time-based estimate
  const currentTime = document.getElementById('clock').value;
  const timeParts = currentTime.split(':').map(Number);
  const timeRemaining = timeParts[0] * 60 + timeParts[1];
  const periodLengthSec = getPeriodLengthSeconds(period);
  const timeElapsed = periodLengthSec - timeRemaining;
  const periodProgress = timeElapsed / periodLengthSec;
  
  const overallProgress = (completedPeriods + periodProgress) / totalPeriods;
  
  return {
    events: currentCount,
    estimated: estimatedTotal,
    progress: Math.round(overallProgress * 100),
    periodEvents,
    period
  };
}

function updateProgressBar() {
  const progress = getProgressEstimate();
  const bar = document.getElementById('progressBar');
  if (bar) {
    bar.innerHTML = `
      <div style="display:flex;align-items:center;gap:4px;font-size:9px;">
        <span>${progress.events} events</span>
        <div style="flex:1;height:4px;background:var(--border);border-radius:2px;min-width:60px;">
          <div style="width:${progress.progress}%;height:100%;background:var(--accent);border-radius:2px;"></div>
        </div>
        <span>~${progress.progress}%</span>
      </div>
    `;
  }
}

// --- 17. FLOATING VIDEO ---
let floatingVideoEnabled = false;

function toggleFloatingVideo() {
  floatingVideoEnabled = !floatingVideoEnabled;
  
  const container = document.getElementById('videoSection');
  if (!container) return;
  
  if (floatingVideoEnabled) {
    container.style.cssText = `
      position: fixed !important;
      top: 60px;
      right: 20px;
      width: 400px;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
      border-radius: 8px;
      resize: both;
      overflow: auto;
    `;
    toast('Floating video ON - drag to move', 'info');
    makeVideoDraggable();
  } else {
    container.style.cssText = '';
    toast('Floating video OFF', 'info');
  }
}

function makeVideoDraggable() {
  const container = document.getElementById('videoSection');
  if (!container) return;
  
  let isDragging = false;
  let startX, startY, startLeft, startTop;
  
  const header = container.querySelector('.video-header') || container;
  
  header.style.cursor = 'move';
  
  header.addEventListener('mousedown', (e) => {
    if (e.target.tagName === 'BUTTON' || e.target.tagName === 'SELECT') return;
    isDragging = true;
    startX = e.clientX;
    startY = e.clientY;
    startLeft = container.offsetLeft;
    startTop = container.offsetTop;
  });
  
  document.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    container.style.left = `${startLeft + dx}px`;
    container.style.top = `${startTop + dy}px`;
    container.style.right = 'auto';
  });
  
  document.addEventListener('mouseup', () => {
    isDragging = false;
  });
}

// --- 18. QUICK EVENT BUTTONS (Most common) ---
function addQuickEventButtons() {
  // Count most common event types
  const typeCounts = {};
  (S.events || []).forEach(e => {
    typeCounts[e.type] = (typeCounts[e.type] || 0) + 1;
  });
  
  const topTypes = Object.entries(typeCounts)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5)
    .map(([type]) => type);
  
  return topTypes;
}

// --- 19. PERIOD PROGRESS RING ---
function renderPeriodProgress() {
  const ring = document.getElementById('periodProgressRing');
  if (!ring) return;
  
  const currentTime = document.getElementById('clock').value;
  const timeParts = currentTime.split(':').map(Number);
  const timeRemaining = timeParts[0] * 60 + timeParts[1];
  const periodLengthSec = getPeriodLengthSeconds(S.period);
  const progress = 1 - (timeRemaining / periodLengthSec);
  
  // SVG ring
  const radius = 12;
  const circumference = 2 * Math.PI * radius;
  const offset = circumference * (1 - progress);
  
  ring.innerHTML = `
    <svg width="30" height="30" style="transform:rotate(-90deg);">
      <circle cx="15" cy="15" r="${radius}" fill="none" stroke="var(--border)" stroke-width="3"/>
      <circle cx="15" cy="15" r="${radius}" fill="none" stroke="var(--accent)" stroke-width="3"
        stroke-dasharray="${circumference}" stroke-dashoffset="${offset}"/>
    </svg>
  `;
}

// --- 20. CONSISTENCY CHECKER ---
function runConsistencyCheck() {
  const issues = [];
  
  S.events?.forEach((evt, idx) => {
    // Shot without save/goal following
    if (evt.type === 'Shot') {
      const next = S.events[idx + 1];
      if (next && !['Save', 'Goal', 'Rebound', 'Stoppage'].includes(next.type)) {
        issues.push({
          idx,
          type: 'warning',
          msg: `Shot #${idx + 1} not followed by Save/Goal/Rebound`
        });
      }
    }
    
    // Goal without shot before
    if (evt.type === 'Goal') {
      const prev = S.events[idx - 1];
      if (prev && !['Shot', 'Rebound'].includes(prev.type)) {
        issues.push({
          idx,
          type: 'warning',
          msg: `Goal #${idx + 1} not preceded by Shot/Rebound`
        });
      }
    }
    
    // Penalty without faceoff after
    if (evt.type === 'Penalty') {
      const next = S.events[idx + 1];
      if (next && next.type !== 'Faceoff' && next.type !== 'Stoppage') {
        issues.push({
          idx,
          type: 'info',
          msg: `Penalty #${idx + 1} not followed by Faceoff`
        });
      }
    }
    
    // Event without players
    if (['Shot', 'Pass', 'Goal', 'Faceoff'].includes(evt.type)) {
      if (!evt.players || evt.players.length === 0) {
        issues.push({
          idx,
          type: 'error',
          msg: `${evt.type} #${idx + 1} has no players`
        });
      }
    }
  });
  
  if (issues.length === 0) {
    toast('No consistency issues found!', 'success');
    return;
  }
  
  const html = `
    <h3>‚ö†Ô∏è Consistency Check (${issues.length} issues)</h3>
    <div style="max-height:300px;overflow-y:auto;">
      ${issues.map(i => `
        <div style="padding:6px;margin:4px 0;background:${
          i.type === 'error' ? 'rgba(239,68,68,0.2)' : 
          i.type === 'warning' ? 'rgba(245,158,11,0.2)' : 
          'rgba(59,130,246,0.2)'
        };border-radius:4px;font-size:10px;display:flex;justify-content:space-between;align-items:center;">
          <span>${i.msg}</span>
          <button class="btn-sm" onclick="editEvent(${i.idx});closeModal();" style="font-size:8px;">Fix</button>
        </div>
      `).join('')}
    </div>
    <div class="modal-actions">
      <button onclick="closeModal()">Close</button>
    </div>
  `;
  
  showModal(html);
}

// ============================================================
// v23.5: HOOK UPDATES
// ============================================================

// Update logEventDirect hook to include new features
const hookLogEventDirect = () => {
  // This runs after each event is logged
  learnEventPattern();
  
  if (recordingMacro && S.events.length > 0) {
    recordEventForMacro(S.events[S.events.length - 1]);
  }
  
  refreshShotChartOverlay();
  updateProgressBar();
};

// Add to existing logEventDirect hook chain
const existingLogHook = logEventDirect;
logEventDirect = function() {
  existingLogHook.apply(this, arguments);
  hookLogEventDirect();
};

// ============================================================
// AUTO-SAVE
// ============================================================
function startAutoSave() {
  if (S.saveTimer) clearInterval(S.saveTimer);
  const interval = (parseInt(document.getElementById('autoSaveInt').value) || 30) * 1000;
  S.saveTimer = setInterval(autoSave, interval);
}

function autoSave() {
  if (!S.gameId) return;
  const key = `bs_${S.gameId}`;
  const data = { 
    events: S.events, 
    shifts: S.shifts, 
    evtIdx: S.evtIdx, 
    shiftIdx: S.shiftIdx, 
    videoTiming: S.videoTiming,  // Save video timing per game
    videos: S.videos || [],      // v23.6: Video management
    periodLength: S.periodLength, // Legacy
    periodLengths: S.periodLengths, // v23.5: Period-specific lengths
    homeAttacksRightP1: S.homeAttacksRightP1, // v19: Zone orientation per game
    savedAt: new Date().toISOString() 
  };
  localStorage.setItem(key, JSON.stringify(data));
  S.lastSave = new Date();
  updateSaveIndicator('saved');
  setTimeout(() => updateSaveIndicator(), 2000);
  
  // v23.8: Save to file system if directory is set (fire and forget - async)
  if (S.saveDirectoryHandle) {
    saveToFileSystem(data).catch(e => {
      console.error('Failed to save to file system:', e);
    });
    createBackup(data).catch(e => {
      console.error('Failed to create backup:', e);
    });
  }
  
  // v23.8: Optionally export JSON file on save (legacy behavior)
  const exportJsonOnSave = localStorage.getItem('bs_exportJsonOnSave') === 'true';
  if (exportJsonOnSave && !S.saveDirectoryHandle) {
    exportGameDataAsJson();
  }
}

/**
 * v23.8: Prompt user to select a save directory
 */
async function promptForSaveDirectory() {
  // Check if File System Access API is supported
  if (!('showDirectoryPicker' in window)) {
    toast('File System Access API not supported in this browser. Using localStorage only.', 'warning');
    updateSaveFolderDisplay();
    return;
  }
  
  try {
    const handle = await window.showDirectoryPicker({
      mode: 'readwrite',
      startIn: 'documents'
    });
    
    S.saveDirectoryHandle = handle;
    
    // Store directory handle in IndexedDB for persistence
    await storeDirectoryHandle(handle);
    
    updateSaveFolderDisplay();
    toast('Save directory selected. Auto-saves will be saved to this location.', 'success');
  } catch (e) {
    if (e.name !== 'AbortError') {
      console.error('Error selecting directory:', e);
      toast('Failed to select save directory. Using localStorage only.', 'warning');
    }
    // User cancelled - that's okay, we'll use localStorage
    updateSaveFolderDisplay();
  }
}

/**
 * v23.8: Update the save folder display in settings
 */
function updateSaveFolderDisplay() {
  const folderPathEl = document.getElementById('saveFolderPath');
  const folderStatusEl = document.getElementById('saveFolderStatus');
  const quickSaveBtn = document.getElementById('quickSaveBtn');
  
  if (folderPathEl) {
    if (S.saveDirectoryHandle) {
      try {
        // File System Access API doesn't expose the full path for security reasons
        // We can only show the directory name
        folderPathEl.textContent = `Selected: ${S.saveDirectoryHandle.name || 'Folder'} (auto-saves enabled)`;
        folderPathEl.classList.remove('empty');
        folderPathEl.style.color = 'var(--success)';
      } catch (e) {
        folderPathEl.textContent = 'Folder selected (auto-saves enabled)';
        folderPathEl.classList.remove('empty');
        folderPathEl.style.color = 'var(--success)';
      }
    } else {
      folderPathEl.textContent = 'No folder selected - using localStorage only';
      folderPathEl.classList.add('empty');
      folderPathEl.style.color = 'var(--muted)';
    }
  }
  
  if (folderStatusEl) {
    if (S.saveDirectoryHandle) {
      folderStatusEl.textContent = '‚úÖ Auto-saves enabled. Files saved to selected folder, backups in "bkup" subfolder (keeps last 10).';
      folderStatusEl.style.color = 'var(--success)';
    } else {
      folderStatusEl.textContent = 'üí° Select a folder to enable auto-saves and backups (saved to "bkup" folder, keeps last 10)';
      folderStatusEl.style.color = 'var(--muted)';
    }
  }
  
  if (quickSaveBtn) {
    quickSaveBtn.disabled = !S.saveDirectoryHandle;
  }
}

/**
 * v23.8: Clear the selected save folder
 */
function clearSaveFolder() {
  if (!confirm('Clear selected save folder? Auto-saves will use localStorage only.')) return;
  
  S.saveDirectoryHandle = null;
  
  // Remove from IndexedDB
  if ('indexedDB' in window) {
    indexedDB.open('benchsight_save', 1).onsuccess = (e) => {
      const db = e.target.result;
      const transaction = db.transaction(['handles'], 'readwrite');
      transaction.objectStore('handles').delete('saveDirectory');
    };
  }
  
  updateSaveFolderDisplay();
  toast('Save folder cleared. Using localStorage only.', 'info');
}

/**
 * v23.8: Store directory handle in IndexedDB
 */
async function storeDirectoryHandle(handle) {
  try {
    if (!('indexedDB' in window)) return;
    
    const db = await new Promise((resolve, reject) => {
      const request = indexedDB.open('benchsight_save', 1);
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve(request.result);
      request.onupgradeneeded = (e) => {
        const db = e.target.result;
        if (!db.objectStoreNames.contains('handles')) {
          db.createObjectStore('handles');
        }
      };
    });
    
    const transaction = db.transaction(['handles'], 'readwrite');
    await transaction.objectStore('handles').put(handle, 'saveDirectory');
  } catch (e) {
    console.error('Failed to store directory handle:', e);
  }
}

/**
 * v23.8: Load directory handle from IndexedDB
 */
async function loadDirectoryHandle() {
  try {
    if (!('indexedDB' in window)) return;
    
    const db = await new Promise((resolve, reject) => {
      const request = indexedDB.open('benchsight_save', 1);
      request.onerror = () => {
        console.error('IndexedDB open error:', request.error);
        resolve(null); // Don't reject, just return null
      };
      request.onsuccess = () => resolve(request.result);
      request.onupgradeneeded = (e) => {
        try {
          const db = e.target.result;
          if (!db.objectStoreNames.contains('handles')) {
            db.createObjectStore('handles');
          }
        } catch (err) {
          console.error('Error creating object store:', err);
        }
      };
    });
    
    if (!db) return;
    
    const transaction = db.transaction(['handles'], 'readonly');
    const request = transaction.objectStore('handles').get('saveDirectory');
    
    await new Promise((resolve) => {
      request.onsuccess = () => {
        try {
          if (request.result) {
            // Verify the handle is still valid
            S.saveDirectoryHandle = request.result;
          }
        } catch (e) {
          console.error('Error setting directory handle:', e);
        }
        resolve();
      };
      request.onerror = () => {
        console.error('Error reading directory handle:', request.error);
        resolve(); // Don't reject
      };
    });
  } catch (e) {
    console.error('Failed to load directory handle:', e);
    // Don't throw - this is non-critical
  }
}

/**
 * v23.8: Save game data to file system
 */
async function saveToFileSystem(data) {
  if (!S.saveDirectoryHandle || !S.gameId) return;
  
  try {
    // Create comprehensive game data object
    const gameData = {
      exportDate: new Date().toISOString(),
      version: '23.8',
      gameId: S.gameId,
      
      // Game metadata
      homeTeam: S.homeTeam,
      awayTeam: S.awayTeam,
      homeColor: S.homeColor,
      awayColor: S.awayColor,
      homeLogo: S.homeLogo,
      awayLogo: S.awayLogo,
      
      // Rosters
      rosters: {
        home: S.rosters?.home || [],
        away: S.rosters?.away || []
      },
      
      // Game data
      events: data.events,
      shifts: data.shifts,
      evtIdx: data.evtIdx,
      shiftIdx: data.shiftIdx,
      
      // Video data
      videos: data.videos || [],
      videoTiming: data.videoTiming,
      
      // Game settings
      periodLengths: data.periodLengths || S.periodLengths,
      penaltyLengths: S.penaltyLengths,
      homeAttacksRightP1: data.homeAttacksRightP1,
      
      // Application settings
      settings: JSON.parse(localStorage.getItem('bs_settings') || '{}'),
      
      // Custom presets
      customChainPresets: customChainPresets || [],
      linePresets: S.linePresets || {},
      
      // Current state
      currentPeriod: S.period,
      currentTeam: S.evtTeam,
      slots: S.slots,
      
      savedAt: data.savedAt
    };
    
    const gameName = `${S.homeTeam || 'Home'}_vs_${S.awayTeam || 'Away'}`.replace(/[^a-zA-Z0-9_]/g, '_');
    const fileName = `benchsight_game_${gameName}_${S.gameId}.json`;
    
    // Write main save file
    const fileHandle = await S.saveDirectoryHandle.getFileHandle(fileName, { create: true });
    const writable = await fileHandle.createWritable();
    await writable.write(JSON.stringify(gameData, null, 2));
    await writable.close();
  } catch (e) {
    console.error('Error saving to file system:', e);
    throw e;
  }
}

/**
 * v23.8: Create backup in bkup folder
 */
async function createBackup(data) {
  if (!S.saveDirectoryHandle || !S.gameId) return;
  
  try {
    // Get or create bkup folder
    let backupDir;
    try {
      backupDir = await S.saveDirectoryHandle.getDirectoryHandle('bkup', { create: true });
    } catch (e) {
      console.error('Failed to create backup directory:', e);
      return;
    }
    
    // Create comprehensive game data (same as saveToFileSystem)
    const gameData = {
      exportDate: new Date().toISOString(),
      version: '23.8',
      gameId: S.gameId,
      homeTeam: S.homeTeam,
      awayTeam: S.awayTeam,
      homeColor: S.homeColor,
      awayColor: S.awayColor,
      homeLogo: S.homeLogo,
      awayLogo: S.awayLogo,
      rosters: {
        home: S.rosters?.home || [],
        away: S.rosters?.away || []
      },
      events: data.events,
      shifts: data.shifts,
      evtIdx: data.evtIdx,
      shiftIdx: data.shiftIdx,
      videos: data.videos || [],
      videoTiming: data.videoTiming,
      periodLengths: data.periodLengths || S.periodLengths,
      penaltyLengths: S.penaltyLengths,
      homeAttacksRightP1: data.homeAttacksRightP1,
      settings: JSON.parse(localStorage.getItem('bs_settings') || '{}'),
      customChainPresets: customChainPresets || [],
      linePresets: S.linePresets || {},
      currentPeriod: S.period,
      currentTeam: S.evtTeam,
      slots: S.slots,
      savedAt: data.savedAt
    };
    
    const gameName = `${S.homeTeam || 'Home'}_vs_${S.awayTeam || 'Away'}`.replace(/[^a-zA-Z0-9_]/g, '_');
    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
    const backupFileName = `benchsight_game_${gameName}_${S.gameId}_${timestamp}.json`;
    
    // Write backup file
    const backupHandle = await backupDir.getFileHandle(backupFileName, { create: true });
    const writable = await backupHandle.createWritable();
    await writable.write(JSON.stringify(gameData, null, 2));
    await writable.close();
    
    // Rotate backups (keep only last N backups)
    await rotateBackups(backupDir, gameName, S.gameId);
  } catch (e) {
    console.error('Error creating backup:', e);
    // Don't throw - backup failure shouldn't break auto-save
  }
}

/**
 * v23.8: Rotate backups to keep only the last N files
 */
async function rotateBackups(backupDir, gameName, gameId) {
  try {
    const prefix = `benchsight_game_${gameName}_${gameId}_`;
    const backups = [];
    
    // List all backup files for this game
    for await (const [name, handle] of backupDir.entries()) {
      if (name.startsWith(prefix) && name.endsWith('.json')) {
        const file = await handle.getFile();
        backups.push({
          name,
          handle,
          date: file.lastModified
        });
      }
    }
    
    // Sort by date (newest first)
    backups.sort((a, b) => b.date - a.date);
    
    // Delete old backups beyond maxBackups
    if (backups.length > S.maxBackups) {
      const toDelete = backups.slice(S.maxBackups);
      for (const backup of toDelete) {
        try {
          await backupDir.removeEntry(backup.name);
        } catch (e) {
          console.error(`Failed to delete old backup ${backup.name}:`, e);
        }
      }
    }
  } catch (e) {
    console.error('Error rotating backups:', e);
  }
}

/**
 * v23.8: Export complete game data and settings as JSON file
 */
function exportGameDataAsJson() {
  if (!S.gameId) return;
  
  const gameData = {
    exportDate: new Date().toISOString(),
    version: '23.8',
    gameId: S.gameId,
    
    // Game metadata
    homeTeam: S.homeTeam,
    awayTeam: S.awayTeam,
    homeColor: S.homeColor,
    awayColor: S.awayColor,
    homeLogo: S.homeLogo,
    awayLogo: S.awayLogo,
    
    // Rosters
    rosters: {
      home: S.rosters?.home || [],
      away: S.rosters?.away || []
    },
    
    // Game data
    events: S.events,
    shifts: S.shifts,
    evtIdx: S.evtIdx,
    shiftIdx: S.shiftIdx,
    
    // Video data
    videos: S.videos || [],
    videoTiming: S.videoTiming,
    
    // Game settings
    periodLengths: S.periodLengths,
    penaltyLengths: S.penaltyLengths,
    homeAttacksRightP1: S.homeAttacksRightP1,
    
    // Application settings
    settings: JSON.parse(localStorage.getItem('bs_settings') || '{}'),
    
    // Custom presets
    customChainPresets: customChainPresets || [],
    linePresets: S.linePresets || {},
    
    // Current state
    currentPeriod: S.period,
    currentTeam: S.evtTeam,
    slots: S.slots,
    
    savedAt: new Date().toISOString()
  };
  
  const blob = new Blob([JSON.stringify(gameData, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  const gameName = `${S.homeTeam || 'Home'}_vs_${S.awayTeam || 'Away'}`.replace(/[^a-zA-Z0-9_]/g, '_');
  a.download = `benchsight_game_${gameName}_${S.gameId}_${new Date().toISOString().slice(0,19).replace(/:/g, '-')}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function saveGameData() {
  autoSave(); // Trigger save immediately
}

function updateSaveIndicator(status) {
  const el = document.getElementById('saveInd');
  if (status === 'saving') { el.textContent = 'Saving...'; el.className = 'save-ind saving'; }
  else if (status === 'saved') { el.textContent = 'Saved ‚úì'; el.className = 'save-ind saved'; }
  else if (S.lastSave) {
    const ago = Math.round((new Date() - S.lastSave) / 1000);
    el.textContent = ago < 60 ? `${ago}s ago` : `${Math.round(ago/60)}m ago`;
    el.className = 'save-ind';
  } else { el.textContent = '--'; el.className = 'save-ind'; }
}

function loadFromStorage() {
  try {
    const last = localStorage.getItem('bs_lastGame');
    if (last) S.gameId = parseInt(last);
    
    // Check for saved game data
    if (S.gameId) {
      const key = `bs_${S.gameId}`;
      const saved = localStorage.getItem(key);
      if (saved) {
        const data = JSON.parse(saved);
        if (data.events?.length || data.shifts?.length) {
          // Show resume prompt
          showResumePrompt(data);
        }
      }
    }
  } catch(e) { console.log('Error loading from storage:', e); }
}

function showResumePrompt(data) {
  const evtCount = data.events?.length || 0;
  const shiftCount = data.shifts?.length || 0;
  const savedAt = data.savedAt ? new Date(data.savedAt).toLocaleString() : 'unknown';
  
  // Create resume modal dynamically
  const modal = document.createElement('div');
  modal.className = 'overlay show';
  modal.id = 'resumeModal';
  modal.onclick = function(e) {
    if (e.target === modal) closeResumeModal();
  };
  modal.innerHTML = `
    <div class="modal" style="min-width:350px;">
      <h3>üìÇ Resume Session?</h3>
      <p style="font-size:12px;color:var(--muted);margin:12px 0;">Found saved data for this game:</p>
      <div style="background:var(--card);padding:12px;border-radius:4px;margin:12px 0;">
        <div style="display:flex;justify-content:space-between;margin:4px 0;"><span>Events:</span><strong>${evtCount}</strong></div>
        <div style="display:flex;justify-content:space-between;margin:4px 0;"><span>Shifts:</span><strong>${shiftCount}</strong></div>
        <div style="display:flex;justify-content:space-between;margin:4px 0;"><span>Saved:</span><strong>${savedAt}</strong></div>
      </div>
      <div class="modal-actions">
        <button class="btn-success" onclick="handleResumeClick()">Resume</button>
        <button class="btn-danger" onclick="handleStartNewClick()">Start New</button>
      </div>
    </div>
  `;
  document.body.appendChild(modal);
}

function resumeSession() {
  const key = `bs_${S.gameId}`;
  const saved = localStorage.getItem(key);
  if (saved) {
    const data = JSON.parse(saved);
    S.events = data.events || [];
    S.shifts = data.shifts || [];
    S.evtIdx = data.evtIdx || S.events.length;
    S.shiftIdx = data.shiftIdx || S.shifts.length;
    S.lastSave = data.savedAt ? new Date(data.savedAt) : null;
    
    // v19: Restore zone orientation
    if (data.homeAttacksRightP1 !== undefined) {
      S.homeAttacksRightP1 = data.homeAttacksRightP1;
    }
    if (data.periodLength) {
      S.periodLength = data.periodLength;
    }
    // v23.5: Load period-specific lengths
    if (data.periodLengths) {
      S.periodLengths = data.periodLengths;
      updatePeriodLengthsUI();
    }
    if (data.videoTiming) {
      S.videoTiming = data.videoTiming;
    }
    // v23.6: Restore videos
    if (data.videos) {
      S.videos = data.videos;
    } else {
      S.videos = [];
    }
    
    // Update zone labels with restored orientation
    updateZoneLabels();
    
    // Update flip button visual
    const btn = document.getElementById('flipZonesBtn');
    if (btn) {
      btn.style.background = S.homeAttacksRightP1 ? '#374151' : '#7c3aed';
    }
    
    toast(`Restored ${S.events.length} events, ${S.shifts.length} shifts`, 'success');
    
    // v23.8: Process all goals to detect and link assists after resuming
    if (S.events && S.events.length > 0) {
      processAllGoalsForAssists();
    }
    
    renderAll();
    updateSaveIndicator();
    updateNextPlaySuggestions();
  }
  // Note: closeResumeModal() is called from button onclick
}

function startNewSession() {
  S.events = [];
  S.shifts = [];
  S.evtIdx = 0;
  S.shiftIdx = 0;
  S.lastSave = null;
  
  // Clear saved data
  if (S.gameId) {
    const key = `bs_${S.gameId}`;
    localStorage.removeItem(key);
  }
  
  toast('Starting new session', 'success');
  renderAll();
  closeResumeModal();
}

function handleResumeClick() {
  try {
    resumeSession();
  } catch(e) {
    console.error('Error in resumeSession:', e);
  }
  closeResumeModal();
}

function handleStartNewClick() {
  try {
    startNewSession();
  } catch(e) {
    console.error('Error in startNewSession:', e);
  }
  closeResumeModal();
}

function closeResumeModal() {
  const modal = document.getElementById('resumeModal');
  if (modal) {
    modal.classList.remove('show');
    setTimeout(() => {
      if (modal && modal.parentNode) {
        modal.remove();
      }
    }, 300); // Remove after fade-out animation
  }
}

function manualSave() {
  if (!S.gameId) { toast('No game loaded', 'error'); return; }
  updateSaveIndicator('saving');
  autoSave();
  
  // v23.8: Always export JSON on manual save (in addition to auto-save behavior)
  const exportJsonOnSave = localStorage.getItem('bs_exportJsonOnSave') === 'true';
  if (exportJsonOnSave && !S.saveDirectoryHandle) {
    // autoSave() already exports if enabled, but we can show a message
    toast('Game saved to localStorage and JSON exported!', 'success');
  } else if (S.saveDirectoryHandle) {
    toast('Game saved to localStorage and file system!', 'success');
  } else {
    toast('Game saved!', 'success');
  }
}

function clearSavedData() {
  if (!S.gameId) return;
  if (!confirm('Clear all saved data for this game? This cannot be undone.')) return;
  
  const key = `bs_${S.gameId}`;
  localStorage.removeItem(key);
  S.events = [];
  S.shifts = [];
  S.evtIdx = 0;
  S.shiftIdx = 0;
  
  toast('Saved data cleared', 'success');
  renderAll();
}

// ============================================================
// BUILD UI
// ============================================================
function buildUI() {
  console.log('buildUI called');
  // v23.8: Ensure evtTypeGrid exists before building buttons
  const grid = document.getElementById('evtTypeGrid');
  if (!grid) {
    console.error('evtTypeGrid not found in DOM! Retrying...');
    setTimeout(buildUI, 100); // Retry after DOM is ready
    return;
  }
  
  console.log('Building event type buttons...');
  // v22.1: Use dynamic event types from Supabase, with "Show More" toggle
  buildEventTypeButtons();
  
  try {
    const shiftStartEl = document.getElementById('shiftStartType');
    const shiftStopEl = document.getElementById('shiftStopType');
    if (shiftStartEl && typeof LISTS !== 'undefined' && LISTS && LISTS.shiftStart) {
      shiftStartEl.innerHTML = LISTS.shiftStart.map(t => `<option value="${t}">${t}</option>`).join('');
    }
    if (shiftStopEl && typeof LISTS !== 'undefined' && LISTS && LISTS.shiftStop) {
      shiftStopEl.innerHTML = LISTS.shiftStop.map(t => `<option value="${t}">${t}</option>`).join('');
    }
  } catch(e) {
    console.error('Error building shift types:', e);
  }
  
  ['home','away'].forEach(team => {
    document.getElementById(`${team}F`).innerHTML = ['F1','F2','F3'].map(p => `<div class="slot" data-team="${team}" data-pos="${p}" onclick="selectSlot(this)"><span class="num">${p}</span></div>`).join('');
    document.getElementById(`${team}D`).innerHTML = ['D1','D2'].map(p => `<div class="slot" data-team="${team}" data-pos="${p}" onclick="selectSlot(this)"><span class="num">${p}</span></div>`).join('');
    document.getElementById(`${team}G`).innerHTML = ['G','X'].map(p => `<div class="slot" data-team="${team}" data-pos="${p}" onclick="selectSlot(this)"><span class="num">${p}</span></div>`).join('');
  });
  
  // v23.3: Setup drag and drop for shift slots
  setupSlotDragDrop();
  
  // Edit type dropdown - use dynamic types if available
  buildEditTypeDropdown();
  
  renderXYSlots();
}

// v22.1: Build event type buttons dynamically from dim_event_type
function buildEventTypeButtons() {
  try {
    const grid = document.getElementById('evtTypeGrid');
    if (!grid) {
      console.error('evtTypeGrid element not found!');
      // Retry after a short delay
      setTimeout(buildEventTypeButtons, 100);
      return;
    }
    
    // Main types always shown (common event types) - ALWAYS use these as fallback
    const mainTypeCodes = ['Faceoff','Shot','Pass','Goal','Turnover','Zone_Entry_Exit','Stoppage','Penalty','Possession','Save','Rebound','Play'];
    
    // Get types from Supabase or fall back to LISTS.eventTypes
    let allTypes = [];
    try {
      if (S && S.eventTypesDB && Array.isArray(S.eventTypesDB) && S.eventTypesDB.length > 0) {
        allTypes = S.eventTypesDB.map(e => (e && e.code) ? e.code : e).filter(Boolean);
      } else if (typeof LISTS !== 'undefined' && LISTS && LISTS.eventTypes && Array.isArray(LISTS.eventTypes) && LISTS.eventTypes.length > 0) {
        allTypes = LISTS.eventTypes;
      }
    } catch(e) {
      console.warn('Error getting event types:', e);
    }
    
    // Always fallback to mainTypeCodes if we don't have types
    if (allTypes.length === 0) {
      console.log('Using fallback event types');
      allTypes = mainTypeCodes;
    }
    
    // Separate main and extra types
    const mainTypes = allTypes.filter(t => mainTypeCodes.includes(t));
    const extraTypes = allTypes.filter(t => !mainTypeCodes.includes(t));
    
    // ALWAYS render main types - use mainTypeCodes if mainTypes is empty
    const typesToRender = mainTypes.length > 0 ? mainTypes : mainTypeCodes;
    
    // Build main type buttons
    let html = '';
    try {
      html = typesToRender.map(t => {
        const displayName = String(t).replace('_Entry_Exit', '');
        let hotkey = '';
        try {
          if (typeof LISTS !== 'undefined' && LISTS && LISTS.hotkeys && LISTS.hotkeys[t]) {
            hotkey = LISTS.hotkeys[t];
          }
        } catch(e) {}
        const tooltip = `Set event type: ${displayName}${hotkey ? ` (Press ${hotkey})` : ''}`;
        return `<button class="evt-btn" data-type="${t}" onclick="setEvtType('${t}')" title="${tooltip}">${displayName}${hotkey ? `<kbd>${hotkey}</kbd>` : ''}</button>`;
      }).join('');
    } catch(e) {
      console.error('Error building button HTML:', e);
      // Fallback: simple buttons without hotkeys
      html = typesToRender.map(t => {
        const displayName = String(t).replace('_Entry_Exit', '');
        return `<button class="evt-btn" data-type="${t}" onclick="setEvtType('${t}')">${displayName}</button>`;
      }).join('');
    }
    
    // Add "Show More" button if there are extra types
    if (extraTypes.length > 0) {
      const showAll = (S && S.showAllEventTypes) ? S.showAllEventTypes : false;
      html += `<button class="evt-btn" id="showMoreTypesBtn" onclick="toggleMoreEventTypes()" style="background:var(--surface);border:1px dashed var(--muted);" title="Show/hide additional event types">
        ${showAll ? '‚óÄ Less' : 'More ‚ñ∂'}
      </button>`;
      
      // Add extra types (hidden by default)
      html += `<div id="extraEventTypes" style="display:${showAll ? 'contents' : 'none'};">`;
      try {
        html += extraTypes.map(t => {
          let hotkey = '';
          try {
            if (typeof LISTS !== 'undefined' && LISTS && LISTS.hotkeys && LISTS.hotkeys[t]) {
              hotkey = LISTS.hotkeys[t];
            }
          } catch(e) {}
          return `<button class="evt-btn" data-type="${t}" onclick="setEvtType('${t}')">${t}${hotkey ? `<kbd>${hotkey}</kbd>` : ''}</button>`;
        }).join('');
      } catch(e) {
        html += extraTypes.map(t => {
          const tooltip = `Set event type: ${t}`;
          return `<button class="evt-btn" data-type="${t}" onclick="setEvtType('${t}')" title="${tooltip}">${t}</button>`;
        }).join('');
      }
      html += '</div>';
    }
    
    // Set the HTML
    grid.innerHTML = html;
    console.log('Event type buttons rendered:', typesToRender.length, 'main types');
  } catch(e) {
    console.error('Fatal error in buildEventTypeButtons:', e);
    // Last resort: render basic buttons
    const grid = document.getElementById('evtTypeGrid');
    if (grid) {
      const mainTypeCodes = ['Faceoff','Shot','Pass','Goal','Turnover','Zone_Entry_Exit','Stoppage','Penalty','Possession','Save','Rebound','Play'];
      grid.innerHTML = mainTypeCodes.map(t => {
        const displayName = t.replace('_Entry_Exit', '');
        return `<button class="evt-btn" data-type="${t}" onclick="setEvtType('${t}')">${displayName}</button>`;
      }).join('');
    }
  }
}

// v22.1: Toggle showing all event types
function toggleMoreEventTypes() {
  S.showAllEventTypes = !S.showAllEventTypes;
  buildEventTypeButtons();
}

// v22.1: Build edit type dropdown with dynamic types
function buildEditTypeDropdown() {
  const dropdown = document.getElementById('editType');
  
  // Get types from Supabase or fall back to LISTS.eventTypes
  const types = S.eventTypesDB.length > 0 
    ? S.eventTypesDB.map(e => e.code) 
    : LISTS.eventTypes;
  
  dropdown.innerHTML = types.map(t => `<option value="${t}">${t}</option>`).join('');
}

// ============================================================
// GAMES & ROSTERS - SUPABASE CONNECTED
// ============================================================
async function loadGames() {
  console.log('loadGames called, S.connected:', S.connected);
  if (S.connected) {
    try {
      console.log('Loading ALL games from dim_schedule...');
      
      // Load ALL games from dim_schedule (not just tracked)
      // Paginate through in case there are many games
      let allGames = [];
      let offset = 0;
      const pageSize = 1000;
      let hasMore = true;
      
      while (hasMore && offset < 50000) {
        console.log(`  Fetching page at offset ${offset}...`);
        const { data, error } = await S.sb.from('dim_schedule')
          .select('game_id,date,home_team_name,away_team_name')
          .order('date', {ascending: false})
          .range(offset, offset + pageSize - 1);
        
        if (error) {
          console.error('Error at offset', offset, ':', error);
          toast('Error loading games: ' + (error.message || error.code), 'error');
          break;
        }
        
        console.log(`  Got ${data?.length || 0} games`);
        
        if (!data || data.length === 0) {
          hasMore = false;
        } else {
          allGames = allGames.concat(data);
          console.log(`  Page ${offset/pageSize + 1}: ${data.length} games (total: ${allGames.length})`);
          offset += pageSize;
          if (data.length < pageSize) hasMore = false;
        }
      }
      
      console.log('Total games from schedule:', allGames.length);
      
      // Dedupe by game_id (in case of any duplicates)
      const gameMap = new Map();
      allGames.forEach(g => {
        if (!gameMap.has(g.game_id)) {
          gameMap.set(g.game_id, {
            game_id: g.game_id,
            game_date: g.date?.split('T')[0] || g.date,
            home_team_name: g.home_team_name,
            away_team_name: g.away_team_name,
            home_team_color: '#3b82f6',
            away_team_color: '#ef4444'
          });
        }
      });
      
      S.games = Array.from(gameMap.values()).sort((a, b) => {
        // Sort by date descending, then by game_id descending
        if (a.game_date !== b.game_date) return b.game_date.localeCompare(a.game_date);
        return b.game_id - a.game_id;
      });
      
      console.log('Final games list:', S.games.length, 'games');
      
      toast(`${S.games.length} games loaded`, 'success');
    } catch(e) { 
      console.error('Failed to load games from Supabase:', e);
      toast('Failed to load games: ' + e.message, 'error');
      S.games = []; 
    }
  } else { 
    S.games = []; 
    toast('Connect to Supabase to load games', 'info');
  }
  
  renderGameSelect(S.games);
  if (S.gameId) document.getElementById('gameSelect').value = S.gameId;
}

function renderGameSelect(games) {
  const sel = document.getElementById('gameSelect');
  sel.innerHTML = '<option value="">-- Select Game (' + games.length + ') --</option>' + games.slice(0, 100).map(g => 
    `<option value="${g.game_id}">${g.game_id}: ${g.home_team_name} vs ${g.away_team_name} (${g.game_date})</option>`
  ).join('');
}

function filterGames(query) {
  if (!query) {
    renderGameSelect(S.games);
    return;
  }
  const q = query.toLowerCase();
  const filtered = S.games.filter(g => 
    g.game_id.toString().includes(q) ||
    g.home_team_name?.toLowerCase().includes(q) ||
    g.away_team_name?.toLowerCase().includes(q) ||
    g.game_date?.includes(q)
  );
  renderGameSelect(filtered);
}

async function selectGame(gid) {
  if (!gid) return;
  S.gameId = parseInt(gid);
  localStorage.setItem('bs_lastGame', gid);
  
  // v23.8: Don't prompt for save directory automatically (requires user gesture)
  // User can select it manually from Settings if desired
  
  const g = S.games.find(x => x.game_id == gid);
  if (!g) { toast('Game not found', 'error'); return; }
  
  S.homeTeam = g.home_team_name; S.awayTeam = g.away_team_name;
  
  // v15.01: Use cached team data if available, otherwise load from Supabase
  const homeTeamData = S.teams[g.home_team_name];
  const awayTeamData = S.teams[g.away_team_name];
  
  if (homeTeamData && awayTeamData) {
    S.homeColor = homeTeamData.color1 || '#3b82f6';
    S.awayColor = awayTeamData.color1 || '#ef4444';
    S.homeLogo = homeTeamData.logo || null;
    S.awayLogo = awayTeamData.logo || null;
  } else if (S.connected) {
    try {
      const { data: teamData } = await S.sb.from('dim_team')
        .select('team_name,team_color1,team_logo')
        .in('team_name', [g.home_team_name, g.away_team_name]);
      
      if (teamData?.length) {
        const homeTeam = teamData.find(t => t.team_name === g.home_team_name);
        const awayTeam = teamData.find(t => t.team_name === g.away_team_name);
        S.homeColor = homeTeam?.team_color1 || '#3b82f6';
        S.awayColor = awayTeam?.team_color1 || '#ef4444';
        S.homeLogo = homeTeam?.team_logo || null;
        S.awayLogo = awayTeam?.team_logo || null;
      }
    } catch(e) { console.log('Failed to load team colors:', e); }
  }
  console.log('Team colors:', S.homeColor, S.awayColor);
  
  // Update UI with team names (not just Home/Away)
  document.getElementById('homeLbl').textContent = S.homeTeam;
  document.getElementById('awayLbl').textContent = S.awayTeam;
  document.getElementById('evtHomeLbl').textContent = S.homeTeam;
  document.getElementById('evtAwayLbl').textContent = S.awayTeam;
  document.getElementById('homeDot').style.background = S.homeColor;
  document.getElementById('awayDot').style.background = S.awayColor;
  document.documentElement.style.setProperty('--home', S.homeColor);
  document.documentElement.style.setProperty('--away', S.awayColor);
  
  // Update filter dropdown with team names
  const filterTeamSel = document.getElementById('filterEvtTeam');
  if (filterTeamSel) {
    filterTeamSel.innerHTML = `<option value="">All</option><option value="home">${S.homeTeam}</option><option value="away">${S.awayTeam}</option>`;
  }
  
  // v15.01: Update team logos if elements exist
  const homeLogoEl = document.getElementById('homeLogoImg');
  const awayLogoEl = document.getElementById('awayLogoImg');
  if (homeLogoEl) homeLogoEl.src = S.homeLogo || '';
  if (awayLogoEl) awayLogoEl.src = S.awayLogo || '';
  
  // Update zone labels on rink (based on current period)
  updateZoneLabels();
  
  await loadRosters(gid);
  loadGameData(gid);
  renderAll();
  toast(`Loaded: ${S.homeTeam} vs ${S.awayTeam}`, 'success');
}

async function loadRosters(gid) {
  if (!S.connected) { 
    generateDemoRosters(); 
    toast('Demo rosters loaded (not connected)', 'info');
    return;
  }
  
  try {
    // Query fact_gameroster for this game
    // Note: player_rating not in table, will be null
    const { data, error } = await S.sb.from('fact_gameroster')
      .select('player_id,player_game_number,player_full_name,player_position,team_venue')
      .eq('game_id', gid)
      .order('player_game_number');
    
    if (error) {
      console.error('Roster query error:', error);
      throw error;
    }
    
    console.log('Raw roster data for game', gid, ':', data?.length, 'players');
    
    if (!data || data.length === 0) {
      // Try alternate column names
      console.log('No data with standard columns, trying alternate...');
      const { data: altData, error: altErr } = await S.sb.from('fact_gameroster')
        .select('*')
        .eq('game_id', gid)
        .limit(50);
      
      if (altErr) throw altErr;
      
      if (altData?.length > 0) {
        console.log('Alt data columns:', Object.keys(altData[0]));
        
        // Try to map alternate column names
        const homeMap = new Map();
        const awayMap = new Map();
        
        altData.forEach(p => {
          const venue = p.team_venue || p.venue || p.team || '';
          const isHome = venue.toLowerCase().includes('home');
          const map = isHome ? homeMap : awayMap;
          const playerId = p.player_id || p.id || '';
          
          if (!map.has(playerId)) {
            map.set(playerId, {
              id: playerId,
              num: String(p.player_game_number || p.jersey_number || p.number || '?'),
              name: p.player_full_name || p.full_name || p.name || 'Unknown',
              pos: normalizePosition(p.player_position || p.position),
              rating: p.player_rating || p.rating || null
            });
          }
        });
        
        S.rosters = {
          home: Array.from(homeMap.values()).sort((a,b) => parseInt(a.num) - parseInt(b.num)),
          away: Array.from(awayMap.values()).sort((a,b) => parseInt(a.num) - parseInt(b.num))
        };
      } else {
        console.log('No roster data found for game', gid);
        generateDemoRosters();
        toast('No roster data - using demo', 'warning');
        return;
      }
    } else {
      // Standard processing - v15: Case-insensitive team_venue check
      const homeMap = new Map();
      const awayMap = new Map();
      
      data.forEach(p => {
        const venue = (p.team_venue || '').toLowerCase();
        const map = venue === 'home' ? homeMap : awayMap;
        if (!map.has(p.player_id)) {
          map.set(p.player_id, { 
            id: p.player_id, 
            num: String(p.player_game_number), 
            name: p.player_full_name, 
            pos: normalizePosition(p.player_position),
            rating: null  // Not in fact_gameroster
          });
        }
      });
      
      S.rosters = { 
        home: Array.from(homeMap.values()).sort((a,b) => parseInt(a.num) - parseInt(b.num)),
        away: Array.from(awayMap.values()).sort((a,b) => parseInt(a.num) - parseInt(b.num))
      };
    }
    
    console.log('Final rosters:', S.rosters.home.length, 'home,', S.rosters.away.length, 'away');
    
    if (S.rosters.home.length === 0 && S.rosters.away.length === 0) {
      toast('No players found for this game', 'warning');
      generateDemoRosters();
    } else {
      toast(`Loaded ${S.rosters.home.length + S.rosters.away.length} players`, 'success');
    }
  } catch(e) { 
    console.error('Failed to load rosters:', e);
    toast('Roster load failed: ' + e.message, 'error');
    generateDemoRosters(); 
  }
}

function generateDemoRosters() {
  S.rosters = {
    home: Array.from({length:12}, (_,i) => ({id:'H'+(i+1), num:String(i+1), name:'Home'+i, pos:i<6?'F':i<10?'D':'G'})),
    away: Array.from({length:12}, (_,i) => ({id:'A'+(i+1), num:String(i+11), name:'Away'+i, pos:i<6?'F':i<10?'D':'G'}))
  };
}

/**
 * Normalize position string to F/D/G format
 * @param {string} pos - Raw position string from database
 * @returns {string} - Normalized position (F, D, or G)
 */
function normalizePosition(pos) {
  if (!pos) return 'F';
  const p = String(pos).toLowerCase().trim();
  if (p === 'g' || p === 'goal' || p === 'goalie' || p === 'goalkeeper' || p === 'goaltender') return 'G';
  if (p === 'd' || p === 'def' || p === 'defense' || p === 'defenseman' || p === 'defenceman') return 'D';
  return 'F'; // Forward by default
}

function loadGameData(gid) {
  try {
    const saved = localStorage.getItem(`bs_${gid}`);
    if (saved) {
      const d = JSON.parse(saved);
      S.events = d.events || []; 
      S.shifts = d.shifts || [];
      S.evtIdx = d.evtIdx || S.events.length; 
      S.shiftIdx = d.shiftIdx || S.shifts.length;
      
      // Restore video timing if saved
      if (d.videoTiming) {
        S.videoTiming = { ...S.videoTiming, ...d.videoTiming };
      }
      // v23.6: Restore videos if saved
      if (d.videos) {
        S.videos = d.videos;
      } else {
        S.videos = [];
      }
      if (d.periodLength) {
        S.periodLength = d.periodLength;
      }
    } else {
      S.events = []; S.shifts = []; S.evtIdx = 0; S.shiftIdx = 0;
      // Reset video timing to defaults for new game
      S.videoTiming = {
        videoStartOffset: 0,
        intermission1: 900,
        intermission2: 900,
        timeouts: [],
        youtubeUrl: ''
      };
      S.videos = []; // v23.6: Initialize videos array
    }
    
    // v23.8: Process all goals to detect and link assists after loading
    if (S.events && S.events.length > 0) {
      processAllGoalsForAssists();
    }
  } catch(e) { 
    S.events = []; S.shifts = []; S.evtIdx = 0; S.shiftIdx = 0; 
  }
}

// ============================================================
// ZONE AUTO-CALCULATION (switches by period)
// ============================================================
function calculateZone() {
  // Get event_player_1's last XY position
  const evtP1 = S.curr.players.find(p => p.role === 'event_team_player_1');
  if (!evtP1?.xy?.length) return '';
  
  const lastXY = evtP1.xy[evtP1.xy.length - 1];
  if (!lastXY) return '';
  
  // NHL Rink: 200 wide
  // Blue lines at x=75 and x=125 (correct NHL dimensions)
  // 0-75 = left zone, 75-125 = neutral, 125-200 = right zone
  // Use S.homeAttacksRightP1 to determine initial orientation
  // Odd periods (1, 3, OT): Use P1 setting
  // Even periods (2): Flip from P1 setting
  const x = lastXY.x;
  const isOddPeriod = S.period === 1 || S.period === 3 || S.period === 'OT';
  
  // Determine which end is offensive for each team based on configurable setting
  const homeOffensiveRight = isOddPeriod ? S.homeAttacksRightP1 : !S.homeAttacksRightP1;
  
  if (S.evtTeam === 'home') {
    if (homeOffensiveRight) {
      if (x > 125) return 'o';      // Home offensive (right in odd periods)
      else if (x < 75) return 'd';  // Home defensive (left in odd periods)
      else return 'n';
    } else {
      if (x < 75) return 'o';       // Home offensive (left in even periods)
      else if (x > 125) return 'd'; // Home defensive (right in even periods)
      else return 'n';
    }
  } else {
    // Away team is opposite
    if (homeOffensiveRight) {
      if (x < 75) return 'o';       // Away offensive (left in odd periods)
      else if (x > 125) return 'd'; // Away defensive (right in odd periods)
      else return 'n';
    } else {
      if (x > 125) return 'o';      // Away offensive (right in even periods)
      else if (x < 75) return 'd';  // Away defensive (left in even periods)
      else return 'n';
    }
  }
}

function updateZoneLabels() {
  // Update zone labels on rink based on period and configurable setting
  const isOddPeriod = S.period === 1 || S.period === 3 || S.period === 'OT';
  const homeOffensiveRight = isOddPeriod ? S.homeAttacksRightP1 : !S.homeAttacksRightP1;
  const homeShort = (S.homeTeam || 'HOME').toUpperCase().slice(0,6);
  const awayShort = (S.awayTeam || 'AWAY').toUpperCase().slice(0,6);
  
  if (homeOffensiveRight) {
    // Home attacks right
    document.getElementById('leftZoneLbl').textContent = awayShort + ' OFF';
    document.getElementById('rightZoneLbl').textContent = homeShort + ' OFF';
  } else {
    // Home attacks left
    document.getElementById('leftZoneLbl').textContent = homeShort + ' OFF';
    document.getElementById('rightZoneLbl').textContent = awayShort + ' OFF';
  }
}

/**
 * v16: Update team logos in UI
 */
function updateTeamLogos() {
  // Update existing logo img elements
  const homeLogoImg = document.getElementById('homeLogoImg');
  const awayLogoImg = document.getElementById('awayLogoImg');
  
  if (homeLogoImg) {
    if (S.homeLogo) {
      homeLogoImg.src = S.homeLogo;
      homeLogoImg.alt = S.homeTeam;
      homeLogoImg.style.display = 'inline';
    } else {
      homeLogoImg.style.display = 'none';
    }
  }
  
  if (awayLogoImg) {
    if (S.awayLogo) {
      awayLogoImg.src = S.awayLogo;
      awayLogoImg.alt = S.awayTeam;
      awayLogoImg.style.display = 'inline';
    } else {
      awayLogoImg.style.display = 'none';
    }
  }
  
  // Update team dots with team colors
  const homeDot = document.getElementById('homeDot');
  const awayDot = document.getElementById('awayDot');
  if (homeDot) homeDot.style.backgroundColor = S.homeColor || '#3b82f6';
  if (awayDot) awayDot.style.backgroundColor = S.awayColor || '#ef4444';
}

function updateZoneDisplay() {
  const zone = document.getElementById('evtZone').value || calculateZone();
  const el = document.getElementById('zoneDisplay');
  if (zone) {
    const labels = { o: 'OFFENSIVE', d: 'DEFENSIVE', n: 'NEUTRAL' };
    el.innerHTML = `<span class="zone-ind ${zone}">${labels[zone]}</span>`;
  } else { el.innerHTML = ''; }
}

// ============================================================
// SUCCESS AUTO-DERIVATION
// ============================================================
function deriveSuccess() {
  const type = S.curr.type;
  const d1 = document.getElementById('evtD1').value;
  
  // Auto-derive based on event type and detail
  if (type === 'Shot') {
    if (d1.includes('OnNet') || d1.includes('Goal')) return 's';
    if (d1.includes('Missed') || d1.includes('Blocked')) return 'u';
  }
  if (type === 'Pass') {
    if (d1.includes('Completed')) return 's';
    if (d1.includes('Missed') || d1.includes('Intercepted')) return 'u';
  }
  if (type === 'Zone_Entry_Exit') {
    if (d1.includes('Failed')) return 'u';
    if (d1.includes('Entry') || d1.includes('Exit') || d1.includes('Keepin')) return 's';
  }
  if (type === 'Turnover') {
    if (d1.includes('Takeaway')) return 's';
    if (d1.includes('Giveaway')) return 'u';
  }
  if (type === 'Goal') return 's';
  if (type === 'Save') return 's';
  
  return '';
}

/**
 * v16.06: Auto-derive play success for all players based on event success
 * Event team player 1 gets the event success
 * Opposing players get inverse if applicable
 */
function derivePlayerSuccess() {
  const evtSuccess = document.getElementById('evtSuccess').value;
  if (!evtSuccess) return;
  
  S.curr.players.forEach(p => {
    if (p.role === 'event_player_1') {
      // Primary player gets event success
      p.playSuccess = evtSuccess;
    } else if (p.role?.startsWith('event')) {
      // Secondary event players - often also successful if event was
      p.playSuccess = evtSuccess;
    } else if (p.role?.startsWith('opp')) {
      // Opponent players - inverse success for turnovers
      const type = S.curr.type;
      if (type === 'Turnover') {
        p.playSuccess = evtSuccess === 's' ? 'u' : 's';
      }
    }
  });
  
  renderQuickAdd();
  toast('Play success auto-derived from event success', 'info');
}

/**
 * v23.8: Auto-detect success for all players
 */
function autoDetectAllSuccess() {
  if (!autoSuccessEnabled) return;
  const evtSuccess = document.getElementById('evtSuccess').value || deriveSuccess();
  if (!evtSuccess) return;
  
  S.curr.players.forEach(p => {
    if (p.role === 'event_player_1' || p.role === 'event_team_player_1') {
      p.playSuccess = evtSuccess;
    } else if (p.role?.startsWith('event')) {
      p.playSuccess = evtSuccess;
    } else if (p.role?.startsWith('opp')) {
      const type = S.curr.type;
      if (type === 'Turnover') {
        p.playSuccess = evtSuccess === 's' ? 'u' : 's';
      }
    }
  });
  
  // Update quick add display if function exists
  if (typeof renderQuickAdd === 'function') renderQuickAdd();
}

/**
 * v16.06: Auto-calc pressure for selected player
 */
function autoCalcPressure() {
  detectPressure();
  if (S.selectedPlayer) {
    const pressureSel = document.getElementById('pdPressure');
    if (pressureSel && S.selectedPlayer.pressure) {
      pressureSel.value = S.selectedPlayer.pressure;
      toast(`Pressure set to #${S.selectedPlayer.pressure}`, 'info');
    } else {
      toast('No opponent within pressure distance', 'warning');
    }
  }
}

// ============================================================
// PRESSURE AUTO-DETECTION
// ============================================================
function detectPressure() {
  const pressureDist = parseInt(document.getElementById('pressureDist').value) || 10;
  const pixelsPerFoot = 1; // Adjust based on rink scale (200px = 200ft)
  const threshold = pressureDist * pixelsPerFoot;
  
  // For each event player, check distance to opposing players
  const evtPlayers = S.curr.players.filter(p => p.role?.startsWith('event'));
  const oppPlayers = S.curr.players.filter(p => p.role?.startsWith('opp'));
  
  evtPlayers.forEach(ep => {
    if (!ep.xy?.length) return;
    const epPos = ep.xy[ep.xy.length - 1];
    
    let closestOpp = null;
    let closestDist = Infinity;
    
    oppPlayers.forEach(op => {
      if (!op.xy?.length) return;
      const opPos = op.xy[op.xy.length - 1];
      
      const dist = Math.sqrt(Math.pow(epPos.x - opPos.x, 2) + Math.pow(epPos.y - opPos.y, 2));
      if (dist <= threshold && dist < closestDist) {
        closestDist = dist;
        closestOpp = op;
      }
    });
    
    // v16.06: Auto-set pressure if closest opponent is within threshold
    if (closestOpp) {
      ep.pressure = closestOpp.num;
    }
  });
  
  // Update pressure dropdown if a player is selected
  if (S.selectedPlayer && S.selectedPlayer.role?.startsWith('event')) {
    const pressureSel = document.getElementById('pdPressure');
    if (pressureSel && S.selectedPlayer.pressure) {
      pressureSel.value = S.selectedPlayer.pressure;
    }
  }
}

/**
 * v23.8: Auto-detect pressure for all event players
 */
function autoDetectAllPressure() {
  if (!autoPressureEnabled) return;
  detectPressure();
  if (typeof renderQuickAdd === 'function') renderQuickAdd();
}

// ============================================================
// RENDER FUNCTIONS
// ============================================================
function renderAll() {
  renderSlots(); 
  renderRosters(); 
  renderQuickAdd(); 
  renderEvents(); 
  renderMarkers(); 
  updateScores(); 
  updateZoneDisplay(); 
  renderShiftLog(); 
  updateBoxScore();
  updateNextPlaySuggestions();
  updateZoneLabels();
}

function renderShiftLog() {
  const body = document.getElementById('shiftLogBody');
  if (!body) return;
  
  // v6: Filter by period
  let filteredShifts = S.shifts;
  if (S.shiftLogFilter && S.shiftLogFilter !== 'all') {
    filteredShifts = S.shifts.filter(s => String(s.period) === S.shiftLogFilter);
  }
  
  // v23.8: Filter by player search (number or name)
  if (S.shiftLogPlayerFilter) {
    const search = S.shiftLogPlayerFilter.toLowerCase();
    filteredShifts = filteredShifts.filter(shift => {
      // Check home team players
      const homeMatch = shift.home && Object.values(shift.home).some(p => {
        if (!p || !p.num) return false;
        const numMatch = String(p.num).toLowerCase().includes(search);
        const nameMatch = (p.name || '').toLowerCase().includes(search);
        return numMatch || nameMatch;
      });
      
      // Check away team players
      const awayMatch = shift.away && Object.values(shift.away).some(p => {
        if (!p || !p.num) return false;
        const numMatch = String(p.num).toLowerCase().includes(search);
        const nameMatch = (p.name || '').toLowerCase().includes(search);
        return numMatch || nameMatch;
      });
      
      return homeMatch || awayMatch;
    });
  }
  
  // v6: Show up to 50 shifts (scrollable) in ASCENDING order (oldest to newest)
  const displayShifts = filteredShifts.slice(-50);
  const startIdx = filteredShifts.length - displayShifts.length;
  
  body.innerHTML = displayShifts.map((s, i) => {
    const actualIdx = S.shifts.indexOf(s); // Get actual index in full array
    const stoppageTime = s.stoppageTime || 0;
    const stoppageDisplay = stoppageTime > 0 ? `<span style="color:var(--warn);font-size:7px;">${stoppageTime}s</span>` : '';
    
    // Count players
    const homeCount = ['F1','F2','F3','D1','D2','X'].filter(p => s.home?.[p]?.num).length;
    const awayCount = ['F1','F2','F3','D1','D2','X'].filter(p => s.away?.[p]?.num).length;
    const strength = s.strength || `${homeCount}v${awayCount}`;
    
    // Click to edit shift
    return `<div class="log-item" style="grid-template-columns: 20px 20px 32px 32px 35px 40px 20px;font-size:8px;cursor:pointer;" onclick="editShift(${actualIdx})" title="Shift #${actualIdx+1} | ${strength} | Stoppage: ${stoppageTime}s | Click to edit">
      <span>${actualIdx + 1}</span>
      <span>P${s.period}</span>
      <span>${s.start_time}</span>
      <span>${s.end_time}</span>
      <span style="color:var(--accent);">${strength}</span>
      <span style="overflow:hidden;text-overflow:ellipsis;font-size:7px;">${s.stop_type || ''}</span>
      ${stoppageDisplay}
    </div>`;
  }).join('') || '<div style="color:var(--muted);font-size:8px;padding:4px;">No shifts</div>';
}

/**
 * v23.8: Handle shift click - populate players if adding event, edit if Ctrl+click or already editing
 */
function handleShiftClick(idx, event) {
  // Ctrl+click or Cmd+click = edit shift
  if (event.ctrlKey || event.metaKey || S.editingEvtIdx !== null) {
    editShift(idx);
    return;
  }
  
  // Regular click = populate players from shift (when adding new event)
  populatePlayersFromShift(idx);
}

/**
 * v23.8: Populate current event players from a shift
 */
function populatePlayersFromShift(shiftIdx) {
  const shift = S.shifts[shiftIdx];
  if (!shift) {
    toast('Shift not found', 'error');
    return;
  }
  
  // Clear current players (user will select which ones to add)
  S.curr.players = [];
  
  // Populate slots from shift (this makes players available in quick add buttons)
  // Clear existing slots first
  S.slots.home = { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null };
  S.slots.away = { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null };
  
  // Populate home team slots from shift
  if (shift.home) {
    ['F1', 'F2', 'F3', 'D1', 'D2', 'G', 'X'].forEach(pos => {
      const p = shift.home[pos];
      if (p?.num) {
        // Find player in roster to get full details
        const rosterPlayer = S.rosters?.home?.find(rp => String(rp.num) === String(p.num));
        if (rosterPlayer) {
          S.slots.home[pos] = {
            num: rosterPlayer.num,
            name: rosterPlayer.name,
            pos: rosterPlayer.pos || pos
          };
        } else {
          // Fallback to shift data
          S.slots.home[pos] = {
            num: p.num,
            name: p.name || `#${p.num}`,
            pos: pos
          };
        }
      }
    });
  }
  
  // Populate away team slots from shift
  if (shift.away) {
    ['F1', 'F2', 'F3', 'D1', 'D2', 'G', 'X'].forEach(pos => {
      const p = shift.away[pos];
      if (p?.num) {
        // Find player in roster to get full details
        const rosterPlayer = S.rosters?.away?.find(rp => String(rp.num) === String(p.num));
        if (rosterPlayer) {
          S.slots.away[pos] = {
            num: rosterPlayer.num,
            name: rosterPlayer.name,
            pos: rosterPlayer.pos || pos
          };
        } else {
          // Fallback to shift data
          S.slots.away[pos] = {
            num: p.num,
            name: p.name || `#${p.num}`,
            pos: pos
          };
        }
      }
    });
  }
  
  // Set event team based on shift (default to home, or use current team)
  if (shift.team) {
    S.evtTeam = shift.team;
    const teamSel = document.getElementById('evtTeam');
    if (teamSel) teamSel.value = shift.team;
    if (typeof updateEvtTeamUI === 'function') updateEvtTeamUI();
  }
  
  // Set period if not already set
  if (shift.period && !S.period) {
    S.period = shift.period;
    document.querySelectorAll('.period-btn').forEach(btn => {
      btn.classList.remove('active');
      if (btn.dataset.p == shift.period) btn.classList.add('active');
    });
  }
  
  // Set strength from shift
  if (shift.strength) {
    const strengthEl = document.getElementById('evtStrength');
    if (strengthEl) strengthEl.value = shift.strength;
  }
  
  // Update slots display and quick add buttons
  if (typeof renderSlots === 'function') renderSlots();
  if (typeof renderQuickAdd === 'function') renderQuickAdd();
  if (typeof renderCurrentPlayers === 'function') renderCurrentPlayers();
  if (typeof onSlotsChanged === 'function') onSlotsChanged(); // Update strength display
  
  // v23.8: Update box score and scores to show stats up to this shift
  const shiftEndTime = shift.end_time || shift.start_time;
  const shiftPeriod = shift.period;
  
  // Helper function to parse time string to seconds
  const parseTimeToSeconds = (timeStr) => {
    if (!timeStr) return 0;
    const parts = String(timeStr).split(':');
    if (parts.length !== 2) return 0;
    const min = parseInt(parts[0]) || 0;
    const sec = parseInt(parts[1]) || 0;
    return min * 60 + sec;
  };
  
  // Helper function to compare times (handles period differences)
  const isEventBeforeShift = (evt) => {
    if (!evt.start_time && !evt.time) return false;
    
    const evtPeriod = evt.period;
    const evtTime = evt.start_time || evt.time;
    
    // If event is in an earlier period, include it
    if (evtPeriod < shiftPeriod) return true;
    
    // If event is in a later period, exclude it
    if (evtPeriod > shiftPeriod) return false;
    
    // Same period - compare times
    const evtSeconds = parseTimeToSeconds(evtTime);
    const shiftSeconds = parseTimeToSeconds(shiftEndTime);
    
    return evtSeconds <= shiftSeconds;
  };
  
  // Find all events that occurred before or at the shift end time
  const eventsBeforeShift = S.events.filter(isEventBeforeShift);
  
  // Find the event with the highest array index (most recent) that meets criteria
  let cutoffEventIdx = null;
  if (eventsBeforeShift.length > 0) {
    // Get the actual array index in S.events for each event
    const eventIndices = eventsBeforeShift.map(e => S.events.indexOf(e)).filter(idx => idx !== -1);
    
    if (eventIndices.length > 0) {
      cutoffEventIdx = Math.max(...eventIndices);
    }
  }
  
  // Update box score and scores with the cutoff (use array index)
  // This shows stats only up to the point in time when this shift ended
  updateBoxScore(cutoffEventIdx);
  updateScores(cutoffEventIdx);
  
  const homeCount = Object.values(S.slots.home).filter(Boolean).length;
  const awayCount = Object.values(S.slots.away).filter(Boolean).length;
  toast(`Loaded ${homeCount + awayCount} players from shift #${shiftIdx + 1} - click to add to event`, 'success');
}

function editShift(idx) {
  if (idx === null || idx === undefined || idx < 0 || idx >= S.shifts.length) {
    toast('Invalid shift index', 'error');
    return;
  }
  
  S.editingShiftIdx = idx;
  const shift = S.shifts[idx];
  if (!shift) {
    toast('Shift not found', 'error');
    return;
  }
  
  // Populate dropdowns first
  const startTypeEl = document.getElementById('editShiftStartType');
  const stopTypeEl = document.getElementById('editShiftStopType');
  
  if (startTypeEl) {
    startTypeEl.innerHTML = LISTS.shiftStart.map(t => 
      `<option value="${t}" ${shift.start_type === t ? 'selected' : ''}>${t}</option>`
    ).join('');
  }
  
  if (stopTypeEl) {
    stopTypeEl.innerHTML = LISTS.shiftStop.map(t => 
      `<option value="${t}" ${shift.stop_type === t ? 'selected' : ''}>${t}</option>`
    ).join('');
  }
  
  // Populate edit shift modal
  const idxEl = document.getElementById('editShiftIdx');
  if (idxEl) idxEl.textContent = idx + 1;
  
  const periodEl = document.getElementById('editShiftPeriod');
  if (periodEl) periodEl.value = shift.period;
  
  const startTimeEl = document.getElementById('editShiftStartTime');
  if (startTimeEl) startTimeEl.value = shift.start_time || '';
  
  const endTimeEl = document.getElementById('editShiftEndTime');
  if (endTimeEl) endTimeEl.value = shift.end_time || '';
  
  const strengthEl = document.getElementById('editShiftStrength');
  if (strengthEl) strengthEl.value = shift.strength || '5v5';
  
  // Render players
  renderEditShiftPlayers(shift);
  
  const modal = document.getElementById('editShiftModal');
  if (modal) {
    modal.classList.add('show');
  } else {
    console.error('editShiftModal not found');
    toast('Shift edit modal not found', 'error');
  }
  
  // v23.8: Update box score to show stats up to this shift
  const shiftEndTime = shift.end_time || shift.start_time;
  const shiftPeriod = shift.period;
  
  // Helper function to parse time string to seconds
  const parseTimeToSeconds = (timeStr) => {
    if (!timeStr) return 0;
    const parts = String(timeStr).split(':');
    if (parts.length !== 2) return 0;
    const min = parseInt(parts[0]) || 0;
    const sec = parseInt(parts[1]) || 0;
    return min * 60 + sec;
  };
  
  // Helper function to compare times (handles period differences)
  const isEventBeforeShift = (evt) => {
    if (!evt.start_time && !evt.time) return false;
    
    const evtPeriod = evt.period;
    const evtTime = evt.start_time || evt.time;
    
    // If event is in an earlier period, include it
    if (evtPeriod < shiftPeriod) return true;
    
    // If event is in a later period, exclude it
    if (evtPeriod > shiftPeriod) return false;
    
    // Same period - compare times
    const evtSeconds = parseTimeToSeconds(evtTime);
    const shiftSeconds = parseTimeToSeconds(shiftEndTime);
    
    return evtSeconds <= shiftSeconds;
  };
  
  // Find all events that occurred before or at the shift end time
  const eventsBeforeShift = S.events.filter(isEventBeforeShift);
  
  // Find the event with the highest array index (most recent) that meets criteria
  let cutoffEventIdx = null;
  if (eventsBeforeShift.length > 0) {
    // Get the actual array index in S.events for each event
    const eventIndices = eventsBeforeShift.map(e => S.events.indexOf(e)).filter(idx => idx !== -1);
    
    if (eventIndices.length > 0) {
      cutoffEventIdx = Math.max(...eventIndices);
    }
  }
  
  // Update box score and scores with the cutoff (use array index)
  // This shows stats only up to the point in time when this shift ended
  updateBoxScore(cutoffEventIdx);
  updateScores(cutoffEventIdx);
}

function deriveShiftStartType(idx) {
  // Auto-derive start type from previous event/shift
  if (idx === 0) return 'GameStart';
  
  const prevShift = S.shifts[idx - 1];
  if (prevShift?.stop_type === 'GoalScored') return 'FaceoffAfterGoal';
  if (prevShift?.stop_type === 'Penalty') return 'FaceoffAfterPenalty';
  if (prevShift?.stop_type === 'PeriodEnd') return 'PeriodStart';
  if (prevShift?.stop_type === 'Intermission') return 'PeriodStart';
  
  // Check last event
  const lastEvt = S.events.filter(e => e.period === S.period).slice(-1)[0];
  if (lastEvt?.type === 'Goal') return 'FaceoffAfterGoal';
  if (lastEvt?.type === 'Penalty') return 'FaceoffAfterPenalty';
  if (lastEvt?.type === 'Stoppage') return 'Stoppage';
  
  return 'OnTheFly';
}

function deriveShiftStopType() {
  // Auto-derive stop type from last event in shift
  const lastEvt = S.events.filter(e => e.period === S.period).slice(-1)[0];
  if (!lastEvt) return 'OnTheFly';
  
  if (lastEvt.type === 'Goal' && lastEvt.detail1 === 'Goal_Scored') return 'GoalScored';
  if (lastEvt.type === 'Penalty') return 'Penalty';
  if (lastEvt.type === 'Stoppage') return 'Stoppage';
  if (lastEvt.type === 'Intermission') return 'Intermission';
  
  return 'OnTheFly';
}

function saveEditShift() {
  if (S.editingShiftIdx === null) return;
  const shift = S.shifts[S.editingShiftIdx];
  
  shift.period = parseInt(document.getElementById('editShiftPeriod').value);
  shift.start_time = document.getElementById('editShiftStartTime').value;
  shift.end_time = document.getElementById('editShiftEndTime').value;
  shift.start_type = document.getElementById('editShiftStartType').value;
  shift.stop_type = document.getElementById('editShiftStopType').value;
  
  closeEditShiftModal();
  renderShiftLog();
  autoSave();
  toast('Shift updated', 'success');
}

function deleteShift() {
  if (S.editingShiftIdx === null) return;
  if (!confirm('Delete this shift?')) return;
  
  S.shifts.splice(S.editingShiftIdx, 1);
  closeEditShiftModal();
  renderShiftLog();
  autoSave();
  toast('Shift deleted', 'success');
}

/**
 * v20.6: Insert a new shift BEFORE the current one
 */
function insertShiftBefore() {
  if (S.editingShiftIdx === null) return;
  
  const currentShift = S.shifts[S.editingShiftIdx];
  const prevShift = S.editingShiftIdx > 0 ? S.shifts[S.editingShiftIdx - 1] : null;
  
  // Create new shift with interpolated times
  const newShift = {
    period: currentShift.period,
    start_time: prevShift ? prevShift.end_time : currentShift.start_time,
    end_time: currentShift.start_time,
    start_type: prevShift ? deriveShiftStartType(S.editingShiftIdx) : 'OnTheFly',
    stop_type: 'OnTheFly',
    strength: '5v5',
    home: { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null },
    away: { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null }
  };
  
  // Insert at position
  S.shifts.splice(S.editingShiftIdx, 0, newShift);
  
  // Update current index to point to newly inserted shift
  const newIdx = S.editingShiftIdx;
  S.editingShiftIdx = null; // Clear to allow re-edit
  
  closeEditShiftModal();
  renderShiftLog();
  autoSave();
  toast(`Inserted shift #${newIdx + 1}`, 'success');
  
  // Open the new shift for editing
  setTimeout(() => editShift(newIdx), 100);
}

/**
 * v20.6: Insert a new shift AFTER the current one
 */
function insertShiftAfter() {
  if (S.editingShiftIdx === null) return;
  
  const currentShift = S.shifts[S.editingShiftIdx];
  const nextShift = S.editingShiftIdx < S.shifts.length - 1 ? S.shifts[S.editingShiftIdx + 1] : null;
  
  // Create new shift with interpolated times
  const newShift = {
    period: currentShift.period,
    start_time: currentShift.end_time,
    end_time: nextShift ? nextShift.start_time : currentShift.end_time,
    start_type: deriveShiftStartType(S.editingShiftIdx + 1),
    stop_type: 'OnTheFly',
    strength: '5v5',
    home: { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null },
    away: { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null }
  };
  
  // Insert after current position
  const insertIdx = S.editingShiftIdx + 1;
  S.shifts.splice(insertIdx, 0, newShift);
  
  S.editingShiftIdx = null; // Clear to allow re-edit
  
  closeEditShiftModal();
  renderShiftLog();
  autoSave();
  toast(`Inserted shift #${insertIdx + 1}`, 'success');
  
  // Open the new shift for editing
  setTimeout(() => editShift(insertIdx), 100);
}

/**
 * v20.6: Duplicate the current shift
 */
function duplicateShift() {
  if (S.editingShiftIdx === null) return;
  
  const currentShift = S.shifts[S.editingShiftIdx];
  
  // Deep clone the shift
  const newShift = JSON.parse(JSON.stringify(currentShift));
  
  // Insert after current position
  const insertIdx = S.editingShiftIdx + 1;
  S.shifts.splice(insertIdx, 0, newShift);
  
  S.editingShiftIdx = null;
  
  closeEditShiftModal();
  renderShiftLog();
  autoSave();
  toast(`Duplicated shift ‚Üí #${insertIdx + 1}`, 'success');
  
  // Open the new shift for editing
  setTimeout(() => editShift(insertIdx), 100);
}

/**
 * v20.6: Add a new shift at the end of the list
 */
function addNewShift() {
  const lastShift = S.shifts.length > 0 ? S.shifts[S.shifts.length - 1] : null;
  
  // Create new shift
  const newShift = {
    period: lastShift ? lastShift.period : S.period || 1,
    start_time: lastShift ? lastShift.end_time : '20:00',
    end_time: '',
    start_type: lastShift ? deriveShiftStartType(S.shifts.length) : 'GameStart',
    stop_type: '',
    strength: '5v5',
    home: { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null },
    away: { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null }
  };
  
  // Add to end
  S.shifts.push(newShift);
  const newIdx = S.shifts.length - 1;
  
  renderShiftLog();
  autoSave();
  toast(`Added shift #${newIdx + 1}`, 'success');
  
  // Open the new shift for editing
  setTimeout(() => editShift(newIdx), 100);
}

function closeEditShiftModal() {
  document.getElementById('editShiftModal').classList.remove('show');
  S.editingShiftIdx = null;
}

function showAllShifts() {
  // Show all shifts modal
  const body = document.getElementById('allShiftsBody');
  body.innerHTML = S.shifts.map((s, i) => `
    <tr onclick="editShift(${i})" style="cursor:pointer;">
      <td>${i + 1}</td>
      <td>P${s.period}</td>
      <td>${s.start_time}</td>
      <td>${s.end_time}</td>
      <td>${s.start_type}</td>
      <td>${s.stop_type}</td>
      <td>${s.strength || '-'}</td>
    </tr>
  `).join('') || '<tr><td colspan="7">No shifts</td></tr>';
  
  document.getElementById('allShiftsModal').classList.add('show');
}

function showAllEvents() {
  // Show all events modal
  const body = document.getElementById('allEventsBody');
  body.innerHTML = S.events.map((e, i) => `
    <tr onclick="editEvent(${i})" style="cursor:pointer;">
      <td>${i + 1}</td>
      <td>P${e.period}</td>
      <td>${e.start_time || e.time}</td>
      <td>${e.team === 'home' ? S.homeTeam : S.awayTeam}</td>
      <td>${e.type}</td>
      <td>${e.detail1 || ''}</td>
      <td>${e.players?.map(p => p.num).join(',') || ''}</td>
    </tr>
  `).join('') || '<tr><td colspan="7">No events</td></tr>';
  
  document.getElementById('allEventsModal').classList.add('show');
}

/**
 * v23.8: Update box score with optional cutoff index (for time-based stats when editing)
 * @param {number|null} cutoffIdx - Only count events up to this index (inclusive). If null, count all events.
 */
function updateBoxScore(cutoffIdx = null) {
  // Update team names
  document.getElementById('teamSumHome').textContent = S.homeTeam?.slice(0,8) || 'HOME';
  document.getElementById('teamSumAway').textContent = S.awayTeam?.slice(0,8) || 'AWAY';
  
  // v7: Calculate player stats - ONLY count event_player_1 for most stats
  const playerStats = {};
  
  // Initialize players from rosters with their correct team
  [...(S.rosters?.home || [])].forEach(p => {
    if (p?.num && !playerStats[p.num]) {
      playerStats[p.num] = { 
        num: p.num, name: p.name?.split(' ').pop() || p.name, team: 'home',
        goals: 0, assists: 0, shots: 0, faceoffs: 0, foWins: 0, foLosses: 0, pim: 0, penalties: 0
      };
    }
  });
  [...(S.rosters?.away || [])].forEach(p => {
    if (p?.num && !playerStats[p.num]) {
      playerStats[p.num] = { 
        num: p.num, name: p.name?.split(' ').pop() || p.name, team: 'away',
        goals: 0, assists: 0, shots: 0, faceoffs: 0, foWins: 0, foLosses: 0, pim: 0, penalties: 0
      };
    }
  });
  
  // Filter events up to cutoff index
  // cutoffIdx is the maximum event index (inclusive) to count
  const eventsToCount = cutoffIdx !== null && cutoffIdx !== undefined
    ? S.events.filter((e, arrayIdx) => {
        // Get the event's index - try idx property first, fallback to array index
        const eventIdx = (e.idx !== undefined && e.idx !== null) ? e.idx : arrayIdx;
        return eventIdx !== -1 && eventIdx <= cutoffIdx;
      })
    : S.events;
  
  eventsToCount.forEach(evt => {
    // v7: ONLY count event_player_1 for goals, shots
    const player1 = evt.players?.find(p => 
      p.role === 'event_team_player_1' || p.role === 'event_player_1'
    );
    const oppPlayer1 = evt.players?.find(p => 
      p.role === 'opp_team_player_1' || p.role === 'opp_player_1'
    );
    
    // Initialize player1 stats if needed
    if (player1?.num && !playerStats[player1.num]) {
      playerStats[player1.num] = { 
        num: player1.num, name: player1.name?.split(' ').pop() || player1.name, team: evt.team,
        goals: 0, assists: 0, shots: 0, faceoffs: 0, foWins: 0, foLosses: 0, pim: 0, penalties: 0
      };
    }
    
    if (player1?.num) {
      const ps = playerStats[player1.num];
      // Goals - only event_player_1 on Goal events where detail1 = Goal_Scored
      if (evt.type === 'Goal' && (evt.detail1 === 'Goal_Scored' || evt.detail1 === 'Goal_Shootout' || evt.detail1 === 'Goal_PenaltyShot')) ps.goals++;
      // v15.01: SOG - only shots that reached the net (Shot_OnNetSaved, Shot_OnNetGoal) or Goals
      const d1 = (evt.detail1 || '').toLowerCase();
      if (d1.includes('shot_onnetsaved') || d1.includes('shot_onnetgoal') || d1.includes('goal_scored') || d1.includes('goal_shootout') || d1.includes('goal_penaltyshot')) {
        ps.shots++;
      }
      // v7: Faceoffs - event_player_1 gets FO WIN
      if (evt.type === 'Faceoff') { ps.faceoffs++; ps.foWins++; }
      
      // v23.8: Penalties - only event_player_1 (the player who took the penalty)
      if (evt.type === 'Penalty' && player1?.num === p.num) {
        ps.penalties++;
        // Extract penalty minutes from detail1 using configurable lengths
        const detail1 = (evt.detail1 || '').toLowerCase();
        const penaltyLengths = S.penaltyLengths || { minor: 2, major: 5, misconduct: 10 };
        if (detail1.includes('major') || detail1.includes('fighting')) {
          ps.pim += penaltyLengths.major || 5;
        } else if (detail1.includes('misconduct') || detail1.includes('game')) {
          ps.pim += penaltyLengths.misconduct || 10;
        } else {
          // Default minor penalty - use configurable length
          ps.pim += penaltyLengths.minor || 2;
        }
      }
    }
    
    // v7: Faceoff LOSS for opp_player_1
    if (evt.type === 'Faceoff' && oppPlayer1?.num) {
      if (!playerStats[oppPlayer1.num]) {
        const oppTeam = evt.team === 'home' ? 'away' : 'home';
        playerStats[oppPlayer1.num] = { 
          num: oppPlayer1.num, name: oppPlayer1.name?.split(' ').pop() || oppPlayer1.name, team: oppTeam,
          goals: 0, assists: 0, shots: 0, faceoffs: 0, foWins: 0, foLosses: 0, pim: 0, penalties: 0
        };
      }
      playerStats[oppPlayer1.num].faceoffs++;
      playerStats[oppPlayer1.num].foLosses++;
    }
    
    // v7: Assists - check for '%assist%' in play_detail_1 or play_detail_2
    evt.players?.forEach(p => {
      if (!p?.num) return;
      const pd1 = (p.playD1 || '').toLowerCase();
      const pd2 = (p.playD2 || '').toLowerCase();
      if (pd1.includes('assist') || pd2.includes('assist')) {
        if (!playerStats[p.num]) {
          playerStats[p.num] = { 
            num: p.num, name: p.name?.split(' ').pop() || p.name, team: evt.team,
            goals: 0, assists: 0, shots: 0, faceoffs: 0, foWins: 0, foLosses: 0, pim: 0, penalties: 0
          };
        }
        playerStats[p.num].assists++;
      }
    });
    
    // v23.8: Also count assists from linked Pass events (assistToGoalIdx)
    // This ensures assists from auto-detected or manually linked Pass events are counted
    if (evt.type === 'Pass' && evt.assistToGoalIdx !== null && evt.assistToGoalIdx !== undefined) {
      // Verify the goal exists and is a valid goal
      const goalEvent = S.events.find(e => e.idx === evt.assistToGoalIdx && e.type === 'Goal' && e.detail1 === 'Goal_Scored');
        if (goalEvent) {
          const passPlayer = evt.players?.find(p => 
            p.role === 'event_team_player_1' || p.role === 'event_player_1'
          );
          if (passPlayer?.num) {
            // Check if already counted for THIS goal via play_detail markers in goal event
            // (to avoid double-counting the same assist)
            const alreadyCountedForThisGoal = (goalEvent.players || []).some(gp => 
              String(gp.num) === String(passPlayer.num) && 
              ((gp.playD1 || '').toLowerCase().includes('assist') || (gp.playD2 || '').toLowerCase().includes('assist'))
            );
            
            // Always count linked Pass events as assists (the link itself is proof of assist)
            // Only skip if we've already counted this player for this specific goal
            if (!alreadyCountedForThisGoal) {
              if (!playerStats[passPlayer.num]) {
                playerStats[passPlayer.num] = { 
                  num: passPlayer.num, name: passPlayer.name?.split(' ').pop() || passPlayer.name, team: evt.team,
                  goals: 0, assists: 0, shots: 0, faceoffs: 0, foWins: 0, foLosses: 0, pim: 0, penalties: 0
                };
              }
              playerStats[passPlayer.num].assists++;
            }
          }
        }
    }
    
    // v23.8: Penalties - only event_player_1 (the player who took the penalty)
    if (evt.type === 'Penalty' && player1?.num) {
      if (!playerStats[player1.num].penalties) {
        playerStats[player1.num].penalties = 0;
        playerStats[player1.num].pim = 0;
      }
      playerStats[player1.num].penalties++;
      // Extract penalty minutes from detail1
      const detail1 = (evt.detail1 || '').toLowerCase();
      if (detail1.includes('major') || detail1.includes('fighting')) {
        playerStats[player1.num].pim += 5;
      } else if (detail1.includes('misconduct') || detail1.includes('game')) {
        playerStats[player1.num].pim += 10;
      } else {
        // Default minor penalty = 2 minutes
        playerStats[player1.num].pim += 2;
      }
    }
  });
  
  // v7: Organize by team, sort by points
  const homePlayers = Object.values(playerStats)
    .filter(p => p.team === 'home' && (p.goals > 0 || p.assists > 0 || p.shots > 0 || p.faceoffs > 0))
    .sort((a, b) => (b.goals + b.assists) - (a.goals + a.assists) || b.goals - a.goals);
  const awayPlayers = Object.values(playerStats)
    .filter(p => p.team === 'away' && (p.goals > 0 || p.assists > 0 || p.shots > 0 || p.faceoffs > 0))
    .sort((a, b) => (b.goals + b.assists) - (a.goals + a.assists) || b.goals - a.goals);
  
  // Render player box score organized by team
  const tbody = document.getElementById('playerBoxBody');
  let html = '';
  
  // Home players section
  if (homePlayers.length > 0) {
    html += `<tr style="background:rgba(59,130,246,0.15);"><td colspan="6" style="font-size:9px;color:var(--home);font-weight:bold;">${S.homeTeam || 'HOME'}</td></tr>`;
    html += homePlayers.slice(0, 5).map(p => {
      const foPct = p.faceoffs > 0 ? `${p.foWins}/${p.faceoffs}` : '-';
      return `<tr onclick="showPlayerDetail('${p.num}')" style="cursor:pointer;">
        <td>${p.num}</td>
        <td style="max-width:50px;overflow:hidden;text-overflow:ellipsis;">${p.name}</td>
        <td style="font-weight:${p.goals>0?'bold':'normal'};">${p.goals}</td>
        <td>${p.assists}</td>
        <td>${p.shots}</td>
        <td style="font-size:9px;">${foPct}</td>
      </tr>`;
    }).join('');
  }
  
  // Away players section
  if (awayPlayers.length > 0) {
    html += `<tr style="background:rgba(239,68,68,0.15);"><td colspan="6" style="font-size:9px;color:var(--away);font-weight:bold;">${S.awayTeam || 'AWAY'}</td></tr>`;
    html += awayPlayers.slice(0, 5).map(p => {
      const foPct = p.faceoffs > 0 ? `${p.foWins}/${p.faceoffs}` : '-';
      return `<tr onclick="showPlayerDetail('${p.num}')" style="cursor:pointer;">
        <td>${p.num}</td>
        <td style="max-width:50px;overflow:hidden;text-overflow:ellipsis;">${p.name}</td>
        <td style="font-weight:${p.goals>0?'bold':'normal'};">${p.goals}</td>
        <td>${p.assists}</td>
        <td>${p.shots}</td>
        <td style="font-size:9px;">${foPct}</td>
      </tr>`;
    }).join('');
  }
  
  tbody.innerHTML = html || '<tr><td colspan="6" style="color:var(--muted);">No stats yet</td></tr>';
  
  // v16: Team SOG totals - only shots that reached the net (Shot_OnNetSaved, Shot_OnNetGoal) or Goals
  // SOG = event_player_1 events where event_detail = "shot_onnetsaved" OR "shot_onnetgoal" OR goal
  const isSOG = (e) => {
    const d1 = (e.detail1 || '').toLowerCase();
    return d1.includes('shot_onnetsaved') || d1.includes('shot_onnetgoal') || 
           d1.includes('goal_scored') || d1.includes('goal_shootout') || d1.includes('goal_penaltyshot');
  };
  const isGoal = (e) => {
    const d1 = (e.detail1 || '').toLowerCase();
    return e.type === 'Goal' && (d1.includes('goal_scored') || d1.includes('goal_shootout') || d1.includes('goal_penaltyshot'));
  };
  const homeGoals = S.events.filter(e => isGoal(e) && e.team === 'home').length;
  const awayGoals = S.events.filter(e => isGoal(e) && e.team === 'away').length;
  const homeShots = S.events.filter(e => isSOG(e) && e.team === 'home').length;
  const awayShots = S.events.filter(e => isSOG(e) && e.team === 'away').length;
  
  document.getElementById('teamSumHomeScore').textContent = homeGoals;
  document.getElementById('teamSumAwayScore').textContent = awayGoals;
  document.getElementById('teamSumHomeSOG').textContent = homeShots;
  document.getElementById('teamSumAwaySOG').textContent = awayShots;
  
  // v16.02: Update center box score (below events)
  const centerBoxHome = document.getElementById('centerBoxHome');
  const centerBoxAway = document.getElementById('centerBoxAway');
  if (centerBoxHome) centerBoxHome.textContent = S.homeTeam?.slice(0,8) || 'HOME';
  if (centerBoxAway) centerBoxAway.textContent = S.awayTeam?.slice(0,8) || 'AWAY';
  const centerBoxHomeScore = document.getElementById('centerBoxHomeScore');
  const centerBoxAwayScore = document.getElementById('centerBoxAwayScore');
  if (centerBoxHomeScore) centerBoxHomeScore.textContent = homeGoals;
  if (centerBoxAwayScore) centerBoxAwayScore.textContent = awayGoals;
  const centerBoxHomeSOG = document.getElementById('centerBoxHomeSOG');
  const centerBoxAwaySOG = document.getElementById('centerBoxAwaySOG');
  if (centerBoxHomeSOG) centerBoxHomeSOG.textContent = homeShots;
  if (centerBoxAwaySOG) centerBoxAwaySOG.textContent = awayShots;
  
  // Also update header score
  document.getElementById('scoreH').textContent = homeGoals;
  document.getElementById('scoreA').textContent = awayGoals;
}

function showPlayerDetail(num) {
  // Calculate player stats
  const playerStats = calculatePlayerStats();
  const ps = playerStats[num];
  if (!ps) { toast('Player not found', 'error'); return; }
  
  document.getElementById('playerDetailName').textContent = `#${ps.num} ${ps.name}`;
  document.getElementById('pdGoals').textContent = ps.goals;
  document.getElementById('pdAssists').textContent = ps.assists;
  document.getElementById('pdShots').textContent = ps.shots;
  document.getElementById('pdFO').textContent = ps.faceoffs ? Math.round(ps.foWins / ps.faceoffs * 100) + '%' : '-';
  document.getElementById('pdTOI').textContent = formatTOI(ps.toi || 0);
  document.getElementById('pdHits').textContent = ps.hits || 0;
  document.getElementById('pdBlocks').textContent = ps.blocks || 0;
  
  // Recent events for this player
  const recentEvts = S.events.filter(e => e.players?.some(p => p.num === num)).slice(-10);
  document.getElementById('pdRecentEvents').innerHTML = recentEvts.map(e => {
    const role = e.players.find(p => p.num === num)?.role || '';
    return `<div style="padding:2px 0;border-bottom:1px solid var(--border);">P${e.period} ${e.start_time || e.time} - ${e.type} (${role.replace('_team_player_','')})</div>`;
  }).join('') || '<div style="color:var(--muted);">No events</div>';
  
  document.getElementById('playerDetailModal').classList.add('show');
}

function showFullBoxScore() {
  const playerStats = calculatePlayerStats();
  
  // v16: Team totals - only count Goal_Scored for goals, proper SOG calculation
  const isGoal = (e) => {
    const d1 = (e.detail1 || '').toLowerCase();
    return e.type === 'Goal' && (d1.includes('goal_scored') || d1.includes('goal_shootout') || d1.includes('goal_penaltyshot'));
  };
  const isSOG = (e) => {
    const d1 = (e.detail1 || '').toLowerCase();
    return d1.includes('shot_onnetsaved') || d1.includes('shot_onnetgoal') || 
           d1.includes('goal_scored') || d1.includes('goal_shootout') || d1.includes('goal_penaltyshot');
  };
  const homeGoals = S.events.filter(e => isGoal(e) && e.team === 'home').length;
  const awayGoals = S.events.filter(e => isGoal(e) && e.team === 'away').length;
  const homeShots = S.events.filter(e => isSOG(e) && e.team === 'home').length;
  const awayShots = S.events.filter(e => isSOG(e) && e.team === 'away').length;
  const homeFO = S.events.filter(e => e.type === 'Faceoff' && e.team === 'home' && (e.success === 's' || e.success === 'Y')).length;
  const awayFO = S.events.filter(e => e.type === 'Faceoff' && e.team === 'away' && (e.success === 's' || e.success === 'Y')).length;
  
  document.getElementById('boxModalHome').textContent = S.homeTeam;
  document.getElementById('boxModalAway').textContent = S.awayTeam;
  document.getElementById('boxModalHomeScore').textContent = homeGoals;
  document.getElementById('boxModalAwayScore').textContent = awayGoals;
  document.getElementById('boxModalHomeSOG').textContent = homeShots;
  document.getElementById('boxModalAwaySOG').textContent = awayShots;
  document.getElementById('boxModalHomeFO').textContent = homeFO;
  document.getElementById('boxModalAwayFO').textContent = awayFO;
  
  // v23.9: Organize player table by team, then by position (F/D/G), then by points
  const allStats = Object.values(playerStats);
  
  // Helper function to group and sort by position
  const groupByPosition = (teamStats) => {
    const byPos = { F: [], D: [], G: [] };
    teamStats.forEach(p => {
      const pos = (p.pos || 'F').toUpperCase();
      if (pos === 'F' || pos === 'FORWARD') byPos.F.push(p);
      else if (pos === 'D' || pos === 'DEFENSE' || pos === 'DEFENSEMAN') byPos.D.push(p);
      else if (pos === 'G' || pos === 'GOALIE' || pos === 'GOALTENDER') byPos.G.push(p);
      else byPos.F.push(p); // Default to forward
    });
    
    // Sort each position group by points
    ['F', 'D', 'G'].forEach(pos => {
      byPos[pos].sort((a, b) => 
        (b.goals + b.assists) - (a.goals + a.assists) || b.goals - a.goals
      );
    });
    
    return byPos;
  };
  
  const homeStats = allStats.filter(p => p.team === 'home');
  const awayStats = allStats.filter(p => p.team === 'away');
  const homeByPos = groupByPosition(homeStats);
  const awayByPos = groupByPosition(awayStats);
  
  // Build table HTML with team headers and position sections
  let tableHtml = '';
  
  // Position labels
  const posLabels = { F: 'Forwards', D: 'Defense', G: 'Goalies' };
  
  // Home team section
  if (homeStats.length > 0) {
    tableHtml += `<tr style="background:var(--home);color:#fff;"><td colspan="10" style="padding:4px 8px;font-weight:bold;">${S.homeTeam || 'HOME'}</td></tr>`;
    
    // Forwards
    if (homeByPos.F.length > 0) {
      tableHtml += `<tr style="background:rgba(202,5,39,0.1);"><td colspan="10" style="padding:2px 8px;font-size:10px;font-weight:bold;color:var(--muted);">${posLabels.F}</td></tr>`;
      tableHtml += homeByPos.F.map(p => {
        const foPct = p.faceoffs ? Math.round(p.foWins / p.faceoffs * 100) : '-';
        return `<tr onclick="showPlayerDetail('${p.num}')" style="cursor:pointer;border-left:3px solid var(--home);">
          <td>${p.num}</td>
          <td>${p.name}</td>
          <td>F</td>
          <td style="font-weight:${p.goals>0?'bold':'normal'};">${p.goals}</td>
          <td>${p.assists}</td>
          <td style="font-weight:bold;">${p.goals + p.assists}</td>
          <td>${p.shots}</td>
          <td>${foPct}${foPct !== '-' ? '%' : ''}</td>
          <td>${formatTOI(p.toi || 0)}</td>
          <td>${p.pim || 0}</td>
        </tr>`;
      }).join('');
    }
    
    // Defense
    if (homeByPos.D.length > 0) {
      tableHtml += `<tr style="background:rgba(202,5,39,0.1);"><td colspan="10" style="padding:2px 8px;font-size:10px;font-weight:bold;color:var(--muted);">${posLabels.D}</td></tr>`;
      tableHtml += homeByPos.D.map(p => {
        const foPct = p.faceoffs ? Math.round(p.foWins / p.faceoffs * 100) : '-';
        return `<tr onclick="showPlayerDetail('${p.num}')" style="cursor:pointer;border-left:3px solid var(--home);">
          <td>${p.num}</td>
          <td>${p.name}</td>
          <td>D</td>
          <td style="font-weight:${p.goals>0?'bold':'normal'};">${p.goals}</td>
          <td>${p.assists}</td>
          <td style="font-weight:bold;">${p.goals + p.assists}</td>
          <td>${p.shots}</td>
          <td>${foPct}${foPct !== '-' ? '%' : ''}</td>
          <td>${formatTOI(p.toi || 0)}</td>
          <td>${p.pim || 0}</td>
        </tr>`;
      }).join('');
    }
    
    // Goalies
    if (homeByPos.G.length > 0) {
      tableHtml += `<tr style="background:rgba(202,5,39,0.1);"><td colspan="10" style="padding:2px 8px;font-size:10px;font-weight:bold;color:var(--muted);">${posLabels.G}</td></tr>`;
      tableHtml += homeByPos.G.map(p => {
        const foPct = p.faceoffs ? Math.round(p.foWins / p.faceoffs * 100) : '-';
        return `<tr onclick="showPlayerDetail('${p.num}')" style="cursor:pointer;border-left:3px solid var(--home);">
          <td>${p.num}</td>
          <td>${p.name}</td>
          <td>G</td>
          <td style="font-weight:${p.goals>0?'bold':'normal'};">${p.goals}</td>
          <td>${p.assists}</td>
          <td style="font-weight:bold;">${p.goals + p.assists}</td>
          <td>${p.shots}</td>
          <td>${foPct}${foPct !== '-' ? '%' : ''}</td>
          <td>${formatTOI(p.toi || 0)}</td>
          <td>${p.pim || 0}</td>
        </tr>`;
      }).join('');
    }
  }
  
  // Away team section
  if (awayStats.length > 0) {
    tableHtml += `<tr style="background:var(--away);color:#fff;"><td colspan="10" style="padding:4px 8px;font-weight:bold;">${S.awayTeam || 'AWAY'}</td></tr>`;
    
    // Forwards
    if (awayByPos.F.length > 0) {
      tableHtml += `<tr style="background:rgba(156,71,228,0.1);"><td colspan="10" style="padding:2px 8px;font-size:10px;font-weight:bold;color:var(--muted);">${posLabels.F}</td></tr>`;
      tableHtml += awayByPos.F.map(p => {
        const foPct = p.faceoffs ? Math.round(p.foWins / p.faceoffs * 100) : '-';
        return `<tr onclick="showPlayerDetail('${p.num}')" style="cursor:pointer;border-left:3px solid var(--away);">
          <td>${p.num}</td>
          <td>${p.name}</td>
          <td>F</td>
          <td style="font-weight:${p.goals>0?'bold':'normal'};">${p.goals}</td>
          <td>${p.assists}</td>
          <td style="font-weight:bold;">${p.goals + p.assists}</td>
          <td>${p.shots}</td>
          <td>${foPct}${foPct !== '-' ? '%' : ''}</td>
          <td>${formatTOI(p.toi || 0)}</td>
          <td>${p.pim || 0}</td>
        </tr>`;
      }).join('');
    }
    
    // Defense
    if (awayByPos.D.length > 0) {
      tableHtml += `<tr style="background:rgba(156,71,228,0.1);"><td colspan="10" style="padding:2px 8px;font-size:10px;font-weight:bold;color:var(--muted);">${posLabels.D}</td></tr>`;
      tableHtml += awayByPos.D.map(p => {
        const foPct = p.faceoffs ? Math.round(p.foWins / p.faceoffs * 100) : '-';
        return `<tr onclick="showPlayerDetail('${p.num}')" style="cursor:pointer;border-left:3px solid var(--away);">
          <td>${p.num}</td>
          <td>${p.name}</td>
          <td>D</td>
          <td style="font-weight:${p.goals>0?'bold':'normal'};">${p.goals}</td>
          <td>${p.assists}</td>
          <td style="font-weight:bold;">${p.goals + p.assists}</td>
          <td>${p.shots}</td>
          <td>${foPct}${foPct !== '-' ? '%' : ''}</td>
          <td>${formatTOI(p.toi || 0)}</td>
          <td>${p.pim || 0}</td>
        </tr>`;
      }).join('');
    }
    
    // Goalies
    if (awayByPos.G.length > 0) {
      tableHtml += `<tr style="background:rgba(156,71,228,0.1);"><td colspan="10" style="padding:2px 8px;font-size:10px;font-weight:bold;color:var(--muted);">${posLabels.G}</td></tr>`;
      tableHtml += awayByPos.G.map(p => {
        const foPct = p.faceoffs ? Math.round(p.foWins / p.faceoffs * 100) : '-';
        return `<tr onclick="showPlayerDetail('${p.num}')" style="cursor:pointer;border-left:3px solid var(--away);">
          <td>${p.num}</td>
          <td>${p.name}</td>
          <td>G</td>
          <td style="font-weight:${p.goals>0?'bold':'normal'};">${p.goals}</td>
          <td>${p.assists}</td>
          <td style="font-weight:bold;">${p.goals + p.assists}</td>
          <td>${p.shots}</td>
          <td>${foPct}${foPct !== '-' ? '%' : ''}</td>
          <td>${formatTOI(p.toi || 0)}</td>
          <td>${p.pim || 0}</td>
        </tr>`;
      }).join('');
    }
  }
  
  document.getElementById('boxModalBody').innerHTML = tableHtml || '<tr><td colspan="10">No stats</td></tr>';
  
  document.getElementById('boxScoreModal').classList.add('show');
}

/**
 * v23.8: Calculate player stats with optional cutoff index (for time-based stats when editing)
 * @param {number|null} cutoffIdx - Only count events up to this index (inclusive). If null, count all events.
 * @param {number|null} shiftCutoffIdx - Only count shifts up to this index (inclusive). If null, count all shifts.
 */
function calculatePlayerStats(cutoffIdx = null, shiftCutoffIdx = null) {
  const stats = {};
  
  // Initialize from rosters
  [...S.rosters.home, ...S.rosters.away].forEach(p => {
    stats[p.num] = {
      num: p.num,
      name: p.name,
      team: S.rosters.home.includes(p) ? 'home' : 'away',
      pos: p.pos || 'F', // Include position for grouping
      goals: 0, assists: 0, shots: 0, faceoffs: 0, foWins: 0, foLosses: 0, hits: 0, blocks: 0, toi: 0, pim: 0, penalties: 0
    };
  });
  
  // Filter events up to cutoff index
  const eventsToCount = cutoffIdx !== null 
    ? S.events.filter(e => e.idx <= cutoffIdx)
    : S.events;
  
  // v6: Calculate from events - only count event_player_1 for most stats
  eventsToCount.forEach(evt => {
      evt.players?.forEach(p => {
      if (!stats[p.num]) {
        // Try to get position from roster
        const rosterPlayer = [...S.rosters.home, ...S.rosters.away].find(rp => String(rp.num) === String(p.num));
        stats[p.num] = { num: p.num, name: p.name, team: evt.team, pos: rosterPlayer?.pos || 'F', goals: 0, assists: 0, shots: 0, faceoffs: 0, foWins: 0, foLosses: 0, hits: 0, blocks: 0, toi: 0, pim: 0, penalties: 0 };
      }
      const ps = stats[p.num];
      
      // Goals - only event_player_1 is the scorer
      if (evt.type === 'Goal' && evt.detail1 === 'Goal_Scored' && p.role === 'event_player_1') {
        ps.goals++;
      }
      
      // v6: Assists - check for '%assist%' in play_detail1 or play_detail2, or linked Pass events
      if (evt.type === 'Goal' && evt.detail1 === 'Goal_Scored') {
        const pd1Lower = (p.playD1 || '').toLowerCase();
        const pd2Lower = (p.playD2 || '').toLowerCase();
        if (pd1Lower.includes('assist') || pd2Lower.includes('assist')) {
          ps.assists++;
        }
      }
      
      // v23.8: Also count assists from linked Pass events (assistToGoalIdx)
      // This captures assists that were auto-detected or manually linked
      if (evt.type === 'Pass' && evt.assistToGoalIdx !== null && evt.assistToGoalIdx !== undefined) {
        // Verify the goal exists and is a valid goal
        const goalEvent = S.events.find(e => e.idx === evt.assistToGoalIdx && e.type === 'Goal' && e.detail1 === 'Goal_Scored');
        if (goalEvent && (p.role === 'event_player_1' || p.role === 'event_team_player_1')) {
          // Check if already counted for THIS goal via play_detail markers in goal event
          // (to avoid double-counting the same assist)
          const alreadyCountedForThisGoal = (goalEvent.players || []).some(gp => 
            String(gp.num) === String(p.num) && 
            ((gp.playD1 || '').toLowerCase().includes('assist') || (gp.playD2 || '').toLowerCase().includes('assist'))
          );
          
          // Always count linked Pass events as assists (the link itself is proof of assist)
          // Only skip if we've already counted this player for this specific goal
          if (!alreadyCountedForThisGoal) {
            ps.assists++;
          }
        }
      }
      
      // Shots - only event_player_1
      if ((evt.type === 'Shot' || evt.type === 'Goal') && p.role === 'event_player_1') {
        ps.shots++;
      }
      
      // v6: Faceoffs - event_player_1 = FO taken for event team
      // FO win = event_player_1 when event success = 's' 
      // FO loss = opp_player_1 on same event (they lost)
      if (evt.type === 'Faceoff') {
        if (p.role === 'event_player_1') {
          ps.faceoffs++;
          if (evt.success === 's' || evt.success === 'Y' || evt.success === true) {
            ps.foWins++;
          } else {
            ps.foLosses++;
          }
        }
        // The opp_player_1 on a faceoff = the opposing center who took the draw
        if (p.role === 'opp_player_1') {
          ps.faceoffs++;
          if (evt.success === 's' || evt.success === 'Y' || evt.success === true) {
            // Event team won, so opp lost
            ps.foLosses++;
          } else {
            // Event team lost, so opp won
            ps.foWins++;
          }
        }
      }
      
      // Hits - only event_player_1
      if (evt.type === 'Hit' && p.role === 'event_player_1') ps.hits++;
      
      // Blocks - opponent blocked the shot
      if (evt.detail1?.includes('Blocked') && p.role?.startsWith('opp')) ps.blocks++;
      
      // v23.8: Penalties - only event_player_1 (the player who took the penalty)
      if (evt.type === 'Penalty' && p.role === 'event_player_1') {
        ps.penalties++;
        // Extract penalty minutes from detail1 using configurable lengths
        const detail1 = (evt.detail1 || '').toLowerCase();
        const penaltyLengths = S.penaltyLengths || { minor: 2, major: 5, misconduct: 10 };
        if (detail1.includes('major') || detail1.includes('fighting')) {
          ps.pim += penaltyLengths.major || 5;
        } else if (detail1.includes('misconduct') || detail1.includes('game')) {
          ps.pim += penaltyLengths.misconduct || 10;
        } else {
          // Default minor penalty - use configurable length
          ps.pim += penaltyLengths.minor || 2;
        }
      }
    });
  });
  
  // Filter shifts up to cutoff index
  const shiftsToCount = shiftCutoffIdx !== null
    ? S.shifts.filter(s => {
        const shiftIdx = S.shifts.indexOf(s);
        return shiftIdx <= shiftCutoffIdx;
      })
    : S.shifts;
  
  // Calculate TOI from shifts
  shiftsToCount.forEach(shift => {
    const duration = parseTime(shift.start_time) - parseTime(shift.end_time);
    if (duration <= 0) return;
    
    ['home', 'away'].forEach(team => {
      ['F1','F2','F3','D1','D2','G','X'].forEach(pos => {
        const p = shift[team]?.[pos];
        if (p?.num && stats[p.num]) {
          stats[p.num].toi += duration;
        }
      });
    });
  });
  
  return stats;
}

function parseTime(timeStr) {
  if (!timeStr) return 0;
  const [min, sec] = timeStr.split(':').map(Number);
  return (min || 0) * 60 + (sec || 0);
}

/**
 * v23.8: Show detailed player stats modal
 */
function showPlayerDetail(playerNum) {
  const stats = calculatePlayerStats();
  const player = stats[playerNum];
  
  if (!player) {
    toast(`Player #${playerNum} not found`, 'error');
    return;
  }
  
  // Get player's full name from roster
  const rosterPlayer = [...S.rosters.home, ...S.rosters.away].find(p => String(p.num) === String(playerNum));
  const fullName = rosterPlayer?.name || player.name || `Player #${playerNum}`;
  const team = player.team === 'home' ? (S.homeTeam || 'HOME') : (S.awayTeam || 'AWAY');
  const teamColor = player.team === 'home' ? 'var(--home)' : 'var(--away)';
  
  // Calculate additional stats
  const points = player.goals + player.assists;
  const foPct = player.faceoffs > 0 ? Math.round((player.foWins / player.faceoffs) * 100) : 0;
  const toiFormatted = formatTOI(player.toi || 0);
  
  // Get all events for this player
  const playerEvents = S.events.filter(e => {
    return e.players?.some(p => String(p.num) === String(playerNum));
  });
  
  // Get goals
  const goals = playerEvents.filter(e => 
    e.type === 'Goal' && 
    e.detail1 === 'Goal_Scored' && 
    e.players?.find(p => String(p.num) === String(playerNum) && p.role === 'event_player_1')
  );
  
  // Get assists (from play_detail and linked Pass events)
  const assists = [];
  const goalEvents = S.events.filter(e => e.type === 'Goal' && e.detail1 === 'Goal_Scored');
  goalEvents.forEach(goal => {
    // Check if player has assist marker in goal event
    const assistInGoal = goal.players?.find(p => 
      String(p.num) === String(playerNum) && 
      ((p.playD1 || '').toLowerCase().includes('assist') || (p.playD2 || '').toLowerCase().includes('assist'))
    );
    if (assistInGoal) {
      assists.push({ goal, type: 'play_detail', period: goal.period, time: goal.start_time });
    }
    
    // Check if player has linked Pass event that assists this goal
    const passEvents = S.events.filter(e => 
      e.type === 'Pass' && 
      e.assistToGoalIdx === goal.idx &&
      e.players?.find(p => String(p.num) === String(playerNum) && (p.role === 'event_player_1' || p.role === 'event_team_player_1'))
    );
    passEvents.forEach(pass => {
      assists.push({ goal, pass, type: 'linked_pass', period: goal.period, time: goal.start_time });
    });
  });
  
  // Get penalties
  const penalties = playerEvents.filter(e => 
    e.type === 'Penalty' && 
    e.players?.find(p => String(p.num) === String(playerNum) && p.role === 'event_player_1')
  );
  
  // Get shifts for this player
  const playerShifts = S.shifts.filter(shift => {
    const team = player.team === 'home' ? shift.home : shift.away;
    return ['F1', 'F2', 'F3', 'D1', 'D2', 'G', 'X'].some(pos => 
      team?.[pos]?.num === String(playerNum)
    );
  });
  
  const html = `
    <div style="background:var(--card);padding:12px;border-radius:6px;margin-bottom:12px;border-left:4px solid ${teamColor};">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <div>
          <h4 style="font-size:16px;color:${teamColor};margin:0;">#${player.num} ${fullName}</h4>
          <div style="font-size:11px;color:var(--muted);">${team}</div>
        </div>
        <div style="text-align:right;">
          <div style="font-size:24px;font-weight:bold;color:${teamColor};">${points}</div>
          <div style="font-size:10px;color:var(--muted);">Points</div>
        </div>
      </div>
    </div>
    
    <!-- Key Stats Grid -->
    <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-bottom:16px;">
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:20px;font-weight:bold;color:var(--accent);">${player.goals || 0}</div>
        <div style="font-size:9px;color:var(--muted);">Goals</div>
      </div>
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:20px;font-weight:bold;color:var(--accent);">${player.assists || 0}</div>
        <div style="font-size:9px;color:var(--muted);">Assists</div>
      </div>
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:20px;font-weight:bold;color:var(--accent);">${toiFormatted}</div>
        <div style="font-size:9px;color:var(--muted);">TOI</div>
      </div>
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:20px;font-weight:bold;color:var(--accent);">${player.pim || 0}</div>
        <div style="font-size:9px;color:var(--muted);">PIM</div>
      </div>
    </div>
    
    <!-- Detailed Stats Table -->
    <div style="margin-bottom:16px;">
      <h4 style="font-size:12px;color:var(--accent);margin-bottom:8px;">üìä Detailed Stats</h4>
      <table style="width:100%;font-size:11px;border-collapse:collapse;">
        <tbody>
          <tr style="border-bottom:1px solid var(--border);">
            <td style="padding:6px;color:var(--muted);">Goals</td>
            <td style="padding:6px;font-weight:bold;text-align:right;">${player.goals || 0}</td>
          </tr>
          <tr style="border-bottom:1px solid var(--border);">
            <td style="padding:6px;color:var(--muted);">Assists</td>
            <td style="padding:6px;font-weight:bold;text-align:right;">${player.assists || 0}</td>
          </tr>
          <tr style="border-bottom:1px solid var(--border);">
            <td style="padding:6px;color:var(--muted);">Points</td>
            <td style="padding:6px;font-weight:bold;text-align:right;">${points}</td>
          </tr>
          <tr style="border-bottom:1px solid var(--border);">
            <td style="padding:6px;color:var(--muted);">Shots on Goal</td>
            <td style="padding:6px;font-weight:bold;text-align:right;">${player.shots || 0}</td>
          </tr>
          <tr style="border-bottom:1px solid var(--border);">
            <td style="padding:6px;color:var(--muted);">Faceoffs</td>
            <td style="padding:6px;font-weight:bold;text-align:right;">${player.faceoffs || 0} (${player.foWins || 0}W-${player.foLosses || 0}L)</td>
          </tr>
          <tr style="border-bottom:1px solid var(--border);">
            <td style="padding:6px;color:var(--muted);">Faceoff %</td>
            <td style="padding:6px;font-weight:bold;text-align:right;">${foPct}%</td>
          </tr>
          <tr style="border-bottom:1px solid var(--border);">
            <td style="padding:6px;color:var(--muted);">Time on Ice</td>
            <td style="padding:6px;font-weight:bold;text-align:right;">${toiFormatted}</td>
          </tr>
          <tr style="border-bottom:1px solid var(--border);">
            <td style="padding:6px;color:var(--muted);">Penalties</td>
            <td style="padding:6px;font-weight:bold;text-align:right;">${player.penalties || 0}</td>
          </tr>
          <tr style="border-bottom:1px solid var(--border);">
            <td style="padding:6px;color:var(--muted);">Penalty Minutes</td>
            <td style="padding:6px;font-weight:bold;text-align:right;">${player.pim || 0}</td>
          </tr>
          <tr style="border-bottom:1px solid var(--border);">
            <td style="padding:6px;color:var(--muted);">Hits</td>
            <td style="padding:6px;font-weight:bold;text-align:right;">${player.hits || 0}</td>
          </tr>
          <tr style="border-bottom:1px solid var(--border);">
            <td style="padding:6px;color:var(--muted);">Blocks</td>
            <td style="padding:6px;font-weight:bold;text-align:right;">${player.blocks || 0}</td>
          </tr>
          <tr>
            <td style="padding:6px;color:var(--muted);">Shifts</td>
            <td style="padding:6px;font-weight:bold;text-align:right;">${playerShifts.length}</td>
          </tr>
        </tbody>
      </table>
    </div>
    
    <!-- Goals List -->
    ${goals.length > 0 ? `
      <div style="margin-bottom:16px;">
        <h4 style="font-size:12px;color:var(--accent);margin-bottom:8px;">‚öΩ Goals (${goals.length})</h4>
        <div style="max-height:150px;overflow-y:auto;background:var(--card);padding:8px;border-radius:4px;">
          ${goals.map(g => {
            const scorer = g.players?.find(p => p.role === 'event_player_1');
            return `<div style="padding:4px;border-bottom:1px solid var(--border);font-size:10px;">
              <strong>P${g.period} @ ${g.start_time}</strong> - ${g.team === 'home' ? (S.homeTeam || 'HOME') : (S.awayTeam || 'AWAY')}
            </div>`;
          }).join('')}
        </div>
      </div>
    ` : ''}
    
    <!-- Assists List -->
    ${assists.length > 0 ? `
      <div style="margin-bottom:16px;">
        <h4 style="font-size:12px;color:var(--accent);margin-bottom:8px;">üéØ Assists (${assists.length})</h4>
        <div style="max-height:150px;overflow-y:auto;background:var(--card);padding:8px;border-radius:4px;">
          ${assists.map(a => {
            const goalScorer = a.goal.players?.find(p => p.role === 'event_player_1');
            return `<div style="padding:4px;border-bottom:1px solid var(--border);font-size:10px;">
              <strong>P${a.period} @ ${a.time}</strong> - Assisted goal by #${goalScorer?.num || '?'} ${goalScorer?.name || ''}
              ${a.type === 'linked_pass' ? ' üîó' : ''}
            </div>`;
          }).join('')}
        </div>
      </div>
    ` : ''}
    
    <!-- Penalties List -->
    ${penalties.length > 0 ? `
      <div style="margin-bottom:16px;">
        <h4 style="font-size:12px;color:var(--accent);margin-bottom:8px;">‚ö†Ô∏è Penalties (${penalties.length})</h4>
        <div style="max-height:150px;overflow-y:auto;background:var(--card);padding:8px;border-radius:4px;">
          ${penalties.map(p => {
            const penaltyType = p.detail1?.replace('Penalty_', '') || 'Penalty';
            return `<div style="padding:4px;border-bottom:1px solid var(--border);font-size:10px;">
              <strong>P${p.period} @ ${p.start_time}</strong> - ${penaltyType}
            </div>`;
          }).join('')}
        </div>
      </div>
    ` : ''}
  `;
  
  document.getElementById('playerDetailTitle').textContent = `üìä #${player.num} ${fullName}`;
  document.getElementById('playerDetailContent').innerHTML = html;
  document.getElementById('playerDetailModal').classList.add('show');
}

/**
 * v23.8: Show all events for a specific player in a modal
 * Used when clicking on player warnings or player names in verification panel
 */
function showPlayerEvents(playerNum, playerName = '') {
  // Get all events where this player appears (as event or opp player)
  const playerEvents = S.events.filter(e => {
    return e.players?.some(p => String(p.num) === String(playerNum));
  });
  
  if (playerEvents.length === 0) {
    toast(`No events found for #${playerNum} ${playerName}`, 'info');
    return;
  }
  
  // Get player info from roster
  const rosterPlayer = [...S.rosters.home, ...S.rosters.away].find(p => String(p.num) === String(playerNum));
  const fullName = rosterPlayer?.name || playerName || `Player #${playerNum}`;
  const team = rosterPlayer ? (S.rosters.home.includes(rosterPlayer) ? 'home' : 'away') : 'unknown';
  const teamColor = team === 'home' ? 'var(--home)' : 'var(--away)';
  
  // Create modal
  const modal = document.createElement('div');
  modal.className = 'overlay show';
  modal.id = 'playerEventsModal';
  modal.onclick = function(e) {
    if (e.target === modal) {
      document.getElementById('playerEventsModal')?.remove();
    }
  };
  
  // Sort events by period and time (most recent first)
  const sortedEvents = [...playerEvents].sort((a, b) => {
    const periodA = (a.period === 'OT' || a.period === 'ot') ? 4 : parseInt(a.period) || 1;
    const periodB = (b.period === 'OT' || b.period === 'ot') ? 4 : parseInt(b.period) || 1;
    if (periodA !== periodB) return periodB - periodA; // Most recent period first
    // Helper to parse time
    const parseTime = (t) => {
      if (!t) return 0;
      const parts = String(t).split(':').map(Number);
      return (parts[0] || 0) * 60 + (parts[1] || 0);
    };
    const timeA = parseTime(a.start_time || a.time || '');
    const timeB = parseTime(b.start_time || b.time || '');
    return timeB - timeA; // Descending time within period (most recent first)
  });
  
  modal.innerHTML = `
    <div class="modal" style="min-width:800px;max-width:1000px;max-height:85vh;overflow-y:auto;">
      <h3 style="color:${teamColor};">üë§ #${playerNum} ${fullName} - All Events (${playerEvents.length})</h3>
      <p style="font-size:10px;color:var(--muted);margin-bottom:12px;">
        Click any event to edit it. Shows all events where this player appears as event or opponent player.
      </p>
      <table style="width:100%;font-size:10px;border-collapse:collapse;">
        <thead>
          <tr style="background:var(--card);border-bottom:2px solid var(--border);">
            <th style="padding:6px;text-align:left;">#</th>
            <th style="padding:6px;text-align:left;">P</th>
            <th style="padding:6px;text-align:left;">Time</th>
            <th style="padding:6px;text-align:left;">Type</th>
            <th style="padding:6px;text-align:left;">Detail</th>
            <th style="padding:6px;text-align:left;">Role</th>
            <th style="padding:6px;text-align:left;">Team</th>
            <th style="padding:6px;text-align:left;">Zone</th>
            <th style="padding:6px;text-align:left;">Players</th>
          </tr>
        </thead>
        <tbody>
          ${sortedEvents.map(evt => {
            const evtIdx = S.events.indexOf(evt);
            const playerInEvent = evt.players?.find(p => String(p.num) === String(playerNum));
            const role = playerInEvent?.role || 'Unknown';
            const roleLabel = role.replace('event_team_player_', 'E').replace('opp_team_player_', 'O').replace('event_player_', 'E').replace('opp_player_', 'O');
            const allPlayers = (evt.players || []).map(p => `#${p.num}`).join(', ') || '-';
            
            return `
              <tr onclick="editEvent(${evtIdx});document.getElementById('playerEventsModal')?.remove();" style="cursor:pointer;border-bottom:1px solid var(--border);" onmouseover="this.style.background='var(--card)'" onmouseout="this.style.background='transparent'">
                <td style="padding:6px;font-weight:600;color:var(--accent);">${evtIdx + 1}</td>
                <td style="padding:6px;">P${evt.period}</td>
                <td style="padding:6px;font-family:monospace;">${evt.start_time || evt.time || '--'}</td>
                <td style="padding:6px;font-weight:600;">${evt.type || '-'}</td>
                <td style="padding:6px;color:var(--muted);">${evt.detail1 || '-'}</td>
                <td style="padding:6px;font-weight:600;color:${teamColor};">${roleLabel}</td>
                <td style="padding:6px;color:${evt.team === 'home' ? 'var(--home)' : 'var(--away)'};">${evt.team === 'home' ? (S.homeTeam || 'HOME') : (S.awayTeam || 'AWAY')}</td>
                <td style="padding:6px;">${evt.zone || '-'}</td>
                <td style="padding:6px;font-size:9px;">${allPlayers}</td>
              </tr>
            `;
          }).join('')}
        </tbody>
      </table>
      <div class="modal-actions" style="margin-top:15px;">
        <button onclick="document.getElementById('playerEventsModal')?.remove()" title="Close modal">Close</button>
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
}

function formatTOI(seconds) {
  if (!seconds) return '--:--';
  const min = Math.floor(seconds / 60);
  const sec = Math.floor(seconds % 60);
  return `${min}:${sec.toString().padStart(2, '0')}`;
}

function updateNextPlaySuggestions() {
  const lastEvt = S.events[S.events.length - 1];
  const suggestions = lastEvt ? (LISTS.nextEventSuggestions[lastEvt.type] || []) : ['Faceoff'];
  
  document.getElementById('nextPlaySuggestions').innerHTML = suggestions.map(t => 
    `<button class="btn-sm" onclick="selectNextEvent('${t}')" style="margin:0 2px;">${t}</button>`
  ).join('');
  
  // Update linked event dropdown
  updateLinkedEventsDropdown();
  
  // v23.3: Highlight suggested event buttons
  highlightSuggestedEvent();
  
  // v23.3: If sequence mode is on, auto-link to last event
  if (sequenceModeActive && lastEvt) {
    S.linkedEventIdx = lastEvt.idx;
    const linkedEl = document.getElementById('linkedEvt');
    if (linkedEl) linkedEl.value = lastEvt.idx + 1;
    document.getElementById('evtStartTime').value = lastEvt.start_time || lastEvt.end_time || '';
  }
}

function selectNextEvent(type) {
  // Get the last event to carry over data
  const lastEvt = S.events[S.events.length - 1];
  
  // Set the event type
  setEvtType(type);
  
  // Carry over all player data if appropriate
  if (lastEvt) {
    // Carry over all players on ice (keep XY positions)
    if (LISTS.linkedEvents[type]?.includes(lastEvt.type)) {
      // Auto-link
      S.linkedEventIdx = lastEvt.idx;
      document.getElementById('linkedEvtSelect').value = lastEvt.idx;
      
      // Copy players with XY
      S.curr.players = lastEvt.players.map(p => ({
        ...p,
        xy: [...(p.xy || [])] // Clone XY array
      }));
      
      // Copy puck XY
      if (lastEvt.puckXY?.length) {
        S.curr.puckXY = [...lastEvt.puckXY];
      }
      
      // Copy zone and time
      document.getElementById('evtZone').value = lastEvt.zone || '';
      document.getElementById('evtStartTime').value = lastEvt.start_time || lastEvt.end_time || '';
    }
    
    // Special cases for role swaps (Shot‚ÜíSave: shooter becomes opp)
    if (type === 'Save' && lastEvt.type === 'Shot') {
      S.curr.players = lastEvt.players.map(p => ({
        ...p,
        role: p.role?.startsWith('event') ? p.role.replace('event', 'opp') : p.role.replace('opp', 'event'),
        xy: [...(p.xy || [])]
      }));
      // Swap event team
      S.evtTeam = S.evtTeam === 'home' ? 'away' : 'home';
      updateEvtTeamUI();
    }
  }
  
  renderQuickAdd();
  renderMarkers();
  toast(`${type} - data carried over`, 'success');
}

function updateEvtTeamUI() {
  document.querySelectorAll('.team-toggle button').forEach(b => b.classList.remove('active'));
  document.querySelector(`.team-toggle .${S.evtTeam}`).classList.add('active');
}

function updateLinkedEventsDropdown() {
  const sel = document.getElementById('linkedEvtSelect');
  if (!sel) return;
  
  // Show last 10 events for linking
  const recentEvents = S.events.slice(-10).reverse();
  sel.innerHTML = '<option value="">-- None --</option>' + recentEvents.map(e => {
    const time = e.start_time || e.time || '';
    const players = e.players?.map(p => p.num).join(',') || '';
    return `<option value="${e.idx}">#${e.idx + 1} ${e.type} ${time} [${players}]</option>`;
  }).join('');
  
  // Auto-suggest link based on current event type
  if (S.curr.type && recentEvents.length) {
    const lastEvt = recentEvents[0];
    const canLink = LISTS.linkedEvents[S.curr.type];
    if (canLink && canLink.includes(lastEvt.type)) {
      sel.value = lastEvt.idx;
      S.linkedEventIdx = lastEvt.idx;
      document.getElementById('linkedEvtInfo').textContent = `‚Üê Auto-linked to ${lastEvt.type}`;
      // Apply linked data
      applyLinkedEventData();
    } else {
      document.getElementById('linkedEvtInfo').textContent = '';
    }
  }
}

function onLinkedEvtChange() {
  const val = document.getElementById('linkedEvtSelect').value;
  S.linkedEventIdx = val ? parseInt(val) : null;
  if (S.linkedEventIdx) {
    applyLinkedEventData();
  }
}

// ============================================================
// AUTO BUTTONS
// ============================================================
function autoZone() {
  const zone = calculateZone();
  if (zone) {
    document.getElementById('evtZone').value = zone;
    toast(`Zone: ${zone === 'o' ? 'Offensive' : zone === 'd' ? 'Defensive' : 'Neutral'}`, 'success');
  } else {
    toast('Add player XY to auto-detect zone', 'error');
  }
}

function autoSuccess() {
  const success = deriveSuccess();
  if (success) {
    document.getElementById('evtSuccess').value = success;
    toast(`Success: ${success === 's' ? 'Successful' : 'Unsuccessful'}`, 'success');
  } else {
    toast('Select event type and detail first', 'error');
  }
}

/**
 * v16: Auto-calculate side of puck based on zone and player team
 */
function autoSideOfPuck() {
  if (!S.selectedPlayer) {
    toast('Select a player first', 'error');
    return;
  }
  
  const zone = document.getElementById('evtZone').value;
  if (!zone) {
    toast('Set zone first', 'error');
    return;
  }
  
  // Determine if player is on event team or opponent
  const isEventTeam = S.selectedPlayer.role?.startsWith('event');
  const eventTeam = S.evtTeam; // 'home' or 'away'
  const playerTeam = isEventTeam ? eventTeam : (eventTeam === 'home' ? 'away' : 'home');
  
  // Calculate side of puck relative to player's team
  // If player is home and zone is offensive (attacking their opponent's goal), they're offensive
  // Zone is always from the event team's perspective
  let sideOfPuck;
  if (playerTeam === eventTeam) {
    // Same team as event - zone matches directly
    sideOfPuck = zone === 'o' ? 'Offensive' : (zone === 'd' ? 'Defensive' : '');
  } else {
    // Opponent team - zone is inverted
    sideOfPuck = zone === 'o' ? 'Defensive' : (zone === 'd' ? 'Offensive' : '');
  }
  
  if (sideOfPuck) {
    document.getElementById('pdSideOfPuck').value = sideOfPuck;
    updatePlayerDetail('sideOfPuck', sideOfPuck);
    toast(`Side of puck: ${sideOfPuck}`, 'success');
  } else {
    toast('Could not determine side (neutral zone)', 'info');
  }
}

/**
 * v23.8: Auto-detect side of puck for all players
 */
function autoDetectAllSideOfPuck() {
  if (!autoSideOfPuckEnabled) return;
  const zone = document.getElementById('evtZone').value;
  if (!zone || zone === 'n') return; // Need zone and not neutral
  
  const eventTeam = S.evtTeam;
  
  S.curr.players.forEach(p => {
    const isEventTeam = p.role?.startsWith('event');
    const playerTeam = isEventTeam ? eventTeam : (eventTeam === 'home' ? 'away' : 'home');
    
    let sideOfPuck;
    if (playerTeam === eventTeam) {
      sideOfPuck = zone === 'o' ? 'Offensive' : (zone === 'd' ? 'Defensive' : '');
    } else {
      sideOfPuck = zone === 'o' ? 'Defensive' : (zone === 'd' ? 'Offensive' : '');
    }
    
    if (sideOfPuck) {
      p.sideOfPuck = sideOfPuck;
    }
  });
  
  if (typeof renderQuickAdd === 'function') renderQuickAdd();
}

function autoStrength() {
  const strength = deriveStrength();
  if (strength) {
    document.getElementById('evtStrength').value = strength;
    toast(`Strength: ${strength}`, 'success');
  } else {
    toast('Fill player slots first', 'error');
  }
}

function updatePlayD2() {
  // Update Play Detail 2 dropdown based on Play Detail 1
  if (!S.selectedPlayer) return;
  
  const d1 = document.getElementById('pdPlayD1').value;
  // v15.02: Use S.playDetails2 from dim_play_detail_2 for second dropdown
  // These are independent of the first dropdown selection
  const pd2Opts = S.playDetails2?.length > 0 
    ? S.playDetails2.map(p => p.name) 
    : [];
  
  // v16.02: Use datalist for searchable dropdown
  document.getElementById('pdPlayD2List').innerHTML = pd2Opts.map(o => `<option value="${o}">`).join('');
}

function deriveStrength() {
  // Count players on ice (excluding empty slots)
  const homeOnIce = Object.values(S.slots.home).filter(Boolean).length;
  const awayOnIce = Object.values(S.slots.away).filter(Boolean).length;
  
  // Check for goalie
  const homeHasGoalie = !!S.slots.home.G;
  const awayHasGoalie = !!S.slots.away.G;
  
  // Calculate skaters
  const homeSkaters = homeOnIce - (homeHasGoalie ? 1 : 0);
  const awaySkaters = awayOnIce - (awayHasGoalie ? 1 : 0);
  
  // Empty net situations
  if (!homeHasGoalie && homeOnIce >= 5) return 'ENA'; // Empty net away (extra attacker for home)
  if (!awayHasGoalie && awayOnIce >= 5) return 'ENH'; // Empty net home
  
  // Standard situations
  if (homeSkaters === 5 && awaySkaters === 5) return '5v5';
  if (homeSkaters === 5 && awaySkaters === 4) return '5v4';
  if (homeSkaters === 4 && awaySkaters === 5) return '4v5';
  if (homeSkaters === 4 && awaySkaters === 4) return '4v4';
  if (homeSkaters === 5 && awaySkaters === 3) return '5v3';
  if (homeSkaters === 3 && awaySkaters === 5) return '3v5';
  if (homeSkaters === 3 && awaySkaters === 3) return '3v3';
  
  return `${homeSkaters}v${awaySkaters}`;
}

function renderSlots() {
  ['home','away'].forEach(team => {
    ['F1','F2','F3','D1','D2','G','X'].forEach(pos => {
      const el = document.querySelector(`.slot[data-team="${team}"][data-pos="${pos}"]`);
      if (!el) return;
      const p = S.slots[team][pos];
      if (p) { 
        el.innerHTML = `<span class="clear-x" onclick="event.stopPropagation();clearSlot('${team}','${pos}')" title="Remove ${p.name}">‚úï</span><span class="num">${p.num}</span><span class="name">${p.name}</span>`; 
        el.classList.add('filled');
        el.draggable = true;
      }
      else { 
        el.innerHTML = `<span class="num">${pos}</span>`; 
        el.classList.remove('filled'); 
        el.draggable = false;
      }
    });
  });
}

// ============================================================
// SLOT DRAG AND DROP
// ============================================================
let draggedSlot = null;

function setupSlotDragDrop() {
  document.querySelectorAll('.slot').forEach(slot => {
    slot.addEventListener('dragstart', handleSlotDragStart);
    slot.addEventListener('dragend', handleSlotDragEnd);
    slot.addEventListener('dragover', handleSlotDragOver);
    slot.addEventListener('dragleave', handleSlotDragLeave);
    slot.addEventListener('drop', handleSlotDrop);
  });
}

function handleSlotDragStart(e) {
  const team = this.dataset.team;
  const pos = this.dataset.pos;
  if (!S.slots[team][pos]) return; // Can't drag empty slot
  
  draggedSlot = { team, pos, player: S.slots[team][pos] };
  this.classList.add('dragging');
  e.dataTransfer.effectAllowed = 'move';
  e.dataTransfer.setData('text/plain', JSON.stringify(draggedSlot));
}

function handleSlotDragEnd(e) {
  this.classList.remove('dragging');
  document.querySelectorAll('.slot').forEach(s => s.classList.remove('drag-over'));
  draggedSlot = null;
}

function handleSlotDragOver(e) {
  e.preventDefault();
  if (!draggedSlot) return;
  e.dataTransfer.dropEffect = 'move';
  this.classList.add('drag-over');
}

function handleSlotDragLeave(e) {
  this.classList.remove('drag-over');
}

function handleSlotDrop(e) {
  e.preventDefault();
  this.classList.remove('drag-over');
  
  if (!draggedSlot) return;
  
  const targetTeam = this.dataset.team;
  const targetPos = this.dataset.pos;
  const sourceTeam = draggedSlot.team;
  const sourcePos = draggedSlot.pos;
  
  // Get what's in the target slot (if anything)
  const targetPlayer = S.slots[targetTeam][targetPos];
  
  // Swap the players
  S.slots[targetTeam][targetPos] = draggedSlot.player;
  S.slots[sourceTeam][sourcePos] = targetPlayer; // Will be null if target was empty
  
  renderSlots();
  renderRosters();
  renderQuickAdd();
  onSlotsChanged();
  
  // Show feedback
  if (sourceTeam !== targetTeam) {
    toast(`Moved #${draggedSlot.player.num} to ${targetTeam.toUpperCase()} ${targetPos}`, 'info');
  }
}

function renderRosters() {
  ['home','away'].forEach(team => {
    const onIce = Object.values(S.slots[team]).filter(Boolean).map(p => p.num);
    const roster = S.rosters[team];
    
    // Group by position
    const groups = { F: [], D: [], G: [] };
    roster.forEach(p => {
      const pos = (p.pos || 'F').toUpperCase();
      if (pos === 'G') groups.G.push(p);
      else if (pos === 'D' || pos === 'LD' || pos === 'RD') groups.D.push(p);
      else groups.F.push(p);
    });
    
    // Render grouped roster
    let html = '';
    ['F', 'D', 'G'].forEach(grp => {
      if (groups[grp].length === 0) return;
      html += `<div class="roster-group"><span class="roster-group-label">${grp === 'F' ? 'Forwards' : grp === 'D' ? 'Defense' : 'Goalie'}</span>`;
      html += groups[grp].map(p => {
        const used = onIce.includes(p.num);
        const lastName = getLastName(p.name);
        const rating = p.rating ? `<span class="rating">${p.rating}</span>` : '';
        return `<button class="roster-btn ${used?'on-ice':''}" onclick="assignPlayer('${team}','${p.num}')"><span class="num">${p.num}</span><span class="name">${lastName}</span>${rating}</button>`;
      }).join('');
      html += '</div>';
    });
    
    document.getElementById(`${team}Roster`).innerHTML = html;
  });
}

function getLastName(fullName) {
  if (!fullName) return '?';
  const parts = fullName.trim().split(' ');
  return parts[parts.length - 1];
}

function renderQuickAdd() {
  // #region agent log
  const slotsHomeValues = Object.values(S.slots?.home||{}).filter(Boolean).map(p=>({num:p.num,name:p.name}));
  const slotsAwayValues = Object.values(S.slots?.away||{}).filter(Boolean).map(p=>({num:p.num,name:p.name}));
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'renderQuickAdd:9557',message:'Function entry',data:{evtTeam:S.evtTeam,slotsHomeCount:Object.values(S.slots?.home||{}).filter(Boolean).length,slotsAwayCount:Object.values(S.slots?.away||{}).filter(Boolean).length,slotsHomeValues,slotsAwayValues,rostersHomeCount:S.rosters?.home?.length||0,rostersAwayCount:S.rosters?.away?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
  // #endregion
  const evtTeam = S.evtTeam;
  const oppTeam = evtTeam === 'home' ? 'away' : 'home';
  const onIce = num => Object.values(S.slots[evtTeam]||{}).some(p => String(p?.num) === String(num));
  const oppOnIce = num => Object.values(S.slots[oppTeam]||{}).some(p => String(p?.num) === String(num));
  const inEvt = num => S.curr.players.some(p => p.num === num);
  
  // #region agent log
  const evtTeamSlotsNums = Object.values(S.slots[evtTeam]||{}).filter(Boolean).map(p=>String(p.num));
  const oppTeamSlotsNums = Object.values(S.slots[oppTeam]||{}).filter(Boolean).map(p=>String(p.num));
  const logDataSetup = {evtTeam,oppTeam,evtTeamSlotsNums,oppTeamSlotsNums,rostersEvtTeamExists:!!S.rosters[evtTeam],rostersOppTeamExists:!!S.rosters[oppTeam]};
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'renderQuickAdd:9563',message:'onIce/oppOnIce setup',data:logDataSetup,timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
  // #endregion
  
  // v23.4: Get recent players for highlighting
  const recentPlayers = getRecentPlayers();
  const isRecent = num => recentPlayers.includes(num);
  
  // Event quick add - players on ice for event team (recent players first)
  // #region agent log
  const evtRosterNums = S.rosters[evtTeam]?.map(p=>String(p.num))||[];
  const logData1 = {evtTeam,rostersEvtTeamLength:S.rosters[evtTeam]?.length||0,evtRosterNums,evtTeamSlotsNums};
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'renderQuickAdd:9571',message:'Before filtering evtOnIcePlayers',data:logData1,timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
  // #endregion
  const evtOnIcePlayers = S.rosters[evtTeam]?.filter(p => onIce(p.num)) || [];
  // #region agent log
  const evtOnIceNums = evtOnIcePlayers.map(p=>String(p.num));
  const matchedPlayersData = evtOnIcePlayers.map(p=>({num:p.num,name:p.name,onIceResult:onIce(p.num)}));
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'renderQuickAdd:9573',message:'After filtering evtOnIcePlayers',data:{evtOnIcePlayersCount:evtOnIcePlayers.length,evtOnIceNums,matchedPlayers:matchedPlayersData},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
  // #endregion
  const evtSorted = [...evtOnIcePlayers].sort((a, b) => {
    const aRecent = isRecent(a.num) ? 0 : 1;
    const bRecent = isRecent(b.num) ? 0 : 1;
    return aRecent - bRecent;
  });
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'renderQuickAdd:9576',message:'Before rendering evtQuickAdd',data:{evtSortedCount:evtSorted.length,evtQuickAddElementExists:!!document.getElementById('evtQuickAdd')},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
  // #endregion
  const evtQuickAddEl = document.getElementById('evtQuickAdd');
  if (evtQuickAddEl) {
    evtQuickAddEl.innerHTML = evtSorted
      .map(p => `<button class="${inEvt(p.num)?'in-evt':''} ${isRecent(p.num)?'recent':''}" onclick="togglePlayer('${p.num}','evt')" title="${p.name}${isRecent(p.num)?' (recent)':''}">${p.num}</button>`).join('');
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'renderQuickAdd:9580',message:'After rendering evtQuickAdd',data:{evtQuickAddInnerHTMLLength:evtQuickAddEl.innerHTML.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
    // #endregion
  }
  
  // Opp quick add (recent players first)
  // #region agent log
  const oppRosterNums = S.rosters[oppTeam]?.map(p=>String(p.num))||[];
  const oppTeamSlotsNumsForCheck = Object.values(S.slots[oppTeam]||{}).filter(Boolean).map(p=>String(p.num));
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'renderQuickAdd:9585',message:'Before filtering oppOnIcePlayers',data:{oppTeam,rostersOppTeamLength:S.rosters[oppTeam]?.length||0,oppRosterNums,oppTeamSlotsNumsForCheck},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
  // #endregion
  const oppOnIcePlayers = S.rosters[oppTeam]?.filter(p => oppOnIce(p.num)) || [];
  // #region agent log
  const oppOnIceNums = oppOnIcePlayers.map(p=>String(p.num));
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'renderQuickAdd:9587',message:'After filtering oppOnIcePlayers',data:{oppOnIcePlayersCount:oppOnIcePlayers.length,oppOnIceNums},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
  // #endregion
  const oppSorted = [...oppOnIcePlayers].sort((a, b) => {
    const aRecent = isRecent(a.num) ? 0 : 1;
    const bRecent = isRecent(b.num) ? 0 : 1;
    return aRecent - bRecent;
  });
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'renderQuickAdd:9589',message:'Before rendering oppQuickAdd',data:{oppSortedCount:oppSorted.length,oppQuickAddElementExists:!!document.getElementById('oppQuickAdd')},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
  // #endregion
  const oppQuickAddEl = document.getElementById('oppQuickAdd');
  if (oppQuickAddEl) {
    oppQuickAddEl.innerHTML = oppSorted
      .map(p => `<button class="${inEvt(p.num)?'in-evt':''} ${isRecent(p.num)?'recent':''}" onclick="togglePlayer('${p.num}','opp')" title="${p.name}${isRecent(p.num)?' (recent)':''}">${p.num}</button>`).join('');
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'renderQuickAdd:9593',message:'After rendering oppQuickAdd',data:{oppQuickAddInnerHTMLLength:oppQuickAddEl.innerHTML.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
    // #endregion
  }
  
  // Event players display
  const evtPs = S.curr.players.filter(p => p.role?.startsWith('event'));
  document.getElementById('evtPlayers').innerHTML = evtPs.map((p, idx) => {
    const sel = S.selectedPlayer?.num === p.num;
    const xyCount = p.xy?.length || 0;
    const suClass = p.playSuccess ? (p.playSuccess === 's' ? 's' : 'u') : '';
    const roleLabel = p.roleNum || '?';
    return `<span class="player-chip evt ${sel?'selected':''}" draggable="true" data-num="${p.num}" data-role="evt" data-idx="${idx}" onclick="selectPlayer('${p.num}')" ondragstart="handlePlayerDragStart(event)" ondragend="handlePlayerDragEnd(event)" ondragover="handlePlayerDragOver(event)" ondrop="handlePlayerDrop(event)"><span class="role-num">E${roleLabel}</span><span class="num">${p.num}</span>${p.name}${xyCount?`<span style="color:var(--accent);font-size:7px;">‚óè${xyCount}</span>`:''}${p.playSuccess?`<span class="su ${suClass}">${p.playSuccess}</span>`:''}<span class="remove" onclick="event.stopPropagation();removePlayer('${p.num}')">‚úï</span></span>`;
  }).join('') || '<span style="color:var(--muted);font-size:8px;">Click players below</span>';
  
  // Opp players display
  const oppPs = S.curr.players.filter(p => p.role?.startsWith('opp'));
  document.getElementById('oppPlayers').innerHTML = oppPs.map((p, idx) => {
    const sel = S.selectedPlayer?.num === p.num;
    const xyCount = p.xy?.length || 0;
    const suClass = p.playSuccess ? (p.playSuccess === 's' ? 's' : 'u') : '';
    const roleLabel = p.roleNum || '?';
    return `<span class="player-chip opp ${sel?'selected':''}" draggable="true" data-num="${p.num}" data-role="opp" data-idx="${idx}" onclick="selectPlayer('${p.num}')" ondragstart="handlePlayerDragStart(event)" ondragend="handlePlayerDragEnd(event)" ondragover="handlePlayerDragOver(event)" ondrop="handlePlayerDrop(event)"><span class="role-num">O${roleLabel}</span><span class="num">${p.num}</span>${p.name}${xyCount?`<span style="color:var(--accent);font-size:7px;">‚óè${xyCount}</span>`:''}${p.playSuccess?`<span class="su ${suClass}">${p.playSuccess}</span>`:''}<span class="remove" onclick="event.stopPropagation();removePlayer('${p.num}')">‚úï</span></span>`;
  }).join('') || '<span style="color:var(--muted);font-size:8px;">Click players below</span>';
  
  // Player selector for XY - v23.4: Always show when players exist, clearer options
  const sel = document.getElementById('xyPlayerSel');
  if (S.curr.players.length > 0) {
    sel.style.display = 'inline-block';
    const puckOption = S.xyMode === 'puck' 
      ? '<option value="" selected>üèí Puck mode</option>'
      : '<option value="">üèí Switch to Puck</option>';
    sel.innerHTML = puckOption + 
      S.curr.players.map(p => {
        const xyCount = p.xy?.length || 0;
        const selected = S.selectedPlayer?.num === p.num;
        return `<option value="${p.num}" ${selected?'selected':''}>#${p.num} ${p.name}${xyCount ? ` (${xyCount}pt)` : ''}</option>`;
      }).join('');
  } else { 
    sel.style.display = 'none'; 
  }
  
  // Player details panel
  const pdEl = document.getElementById('playerDetails');
  if (S.selectedPlayer) {
    pdEl.style.display = 'block';
    document.getElementById('pdPlayerNum').textContent = '#' + S.selectedPlayer.num + ' ' + S.selectedPlayer.name;
    // v15.01: Use S.playDetails1 from dim_play_detail for first dropdown
    const pd1Opts = S.playDetails1?.length > 0 
      ? S.playDetails1.map(p => p.name) 
      : (document.getElementById('evtZone').value === 'd' ? LISTS.playDefensive : LISTS.playOffensive);
    // v16.02: Use datalist for searchable dropdowns
    document.getElementById('pdPlayD1List').innerHTML = pd1Opts.map(o => `<option value="${o}">`).join('');
    document.getElementById('pdPlayD1').value = S.selectedPlayer.playD1 || '';
    // v15.01: Use S.playDetails2 from dim_play_detail_2 for second dropdown
    const pd2Opts = S.playDetails2?.length > 0 
      ? S.playDetails2.map(p => p.name) 
      : [];
    document.getElementById('pdPlayD2List').innerHTML = pd2Opts.map(o => `<option value="${o}">`).join('');
    document.getElementById('pdPlayD2').value = S.selectedPlayer.playD2 || '';
    document.getElementById('pdPlaySuccess').value = S.selectedPlayer.playSuccess || '';
    // v16: Side of puck dropdown
    document.getElementById('pdSideOfPuck').value = S.selectedPlayer.sideOfPuck || '';
    
    // Pressure dropdown - opposing players
    const oppTeam = S.evtTeam === 'home' ? 'away' : 'home';
    const oppInEvt = S.curr.players.filter(p => p.role?.startsWith('opp'));
    document.getElementById('pdPressure').innerHTML = '<option value="">--</option>' + oppInEvt.map(p => `<option value="${p.num}" ${S.selectedPlayer.pressure===p.num?'selected':''}>#${p.num}</option>`).join('');
  } else { pdEl.style.display = 'none'; }
}

function renderXYSlots() {
  const el = document.getElementById('xySlots');
  const max = 6;
  let data = S.xyMode === 'puck' ? S.curr.puckXY : (S.selectedPlayer?.xy || []);
  el.innerHTML = Array.from({length: max}, (_, i) => {
    const has = data[i];
    const active = S.xySlot === i + 1;
    return `<button class="xy-slot ${has?'has':''} ${active?'active':''}" onclick="setXYSlot(${i+1})" title="Slot ${i+1}${has?' (filled)':' (empty)'}">${i+1}</button>`;
  }).join('');
  
  // v23.4: Update slot indicator
  const indicator = document.getElementById('xySlotIndicator');
  if (indicator) {
    const filledCount = data.filter(Boolean).length;
    indicator.textContent = filledCount > 0 ? `(${filledCount} pts)` : '‚Üí click rink';
  }
}

function renderEvents() {
  const body = document.getElementById('evtListBody');
  if (!body) {
    console.error('evtListBody element not found!');
    return;
  }
  
  // v20.4: Populate filter dropdowns with current values
  populateEventFilterDropdowns();
  
  // v16.04: Debug - log event periods
  console.log('renderEvents called');
  console.log('  S.events count:', S.events?.length || 0);
  console.log('  S.eventLogFilter:', S.eventLogFilter);
  
  // v15.02: Period filter
  let filteredEvents = S.events || [];
  const periodFilter = (S.eventLogFilter || 'all').toLowerCase();
  
  if (periodFilter && periodFilter !== 'all') {
    filteredEvents = filteredEvents.filter(e => {
      const evtPeriod = String(e.period || '').toLowerCase();
      if (periodFilter === 'ot') {
        return evtPeriod === 'ot' || evtPeriod === '4' || parseInt(evtPeriod) > 3;
      }
      return evtPeriod === periodFilter;
    });
  }
  
  // v20.4: Apply advanced filters
  const f = S.eventFilters || {};
  
  if (f.type) {
    filteredEvents = filteredEvents.filter(e => e.type === f.type);
  }
  if (f.detail1) {
    filteredEvents = filteredEvents.filter(e => (e.detail1 || e.detail) === f.detail1);
  }
  if (f.detail2) {
    filteredEvents = filteredEvents.filter(e => e.detail2 === f.detail2);
  }
  if (f.playDetail1) {
    filteredEvents = filteredEvents.filter(e => {
      const p1 = (e.players || []).find(p => p.role?.startsWith('event') || !p.role?.startsWith('opp'));
      return p1?.playD1 === f.playDetail1;
    });
  }
  if (f.playDetail2) {
    filteredEvents = filteredEvents.filter(e => {
      const p1 = (e.players || []).find(p => p.role?.startsWith('event') || !p.role?.startsWith('opp'));
      return p1?.playD2 === f.playDetail2;
    });
  }
  if (f.team) {
    filteredEvents = filteredEvents.filter(e => e.team === f.team);
  }
  // v23.8: Filter by player search (number or name)
  if (f.playerSearch) {
    const search = f.playerSearch.toLowerCase();
    filteredEvents = filteredEvents.filter(e => {
      // Check if any player in the event matches the search
      return (e.players || []).some(p => {
        const numMatch = String(p.num || '').toLowerCase().includes(search);
        const nameMatch = (p.name || '').toLowerCase().includes(search);
        return numMatch || nameMatch;
      });
    });
  }
  // v23.8: Handle event index filter with "show X before/after" option
  if (f.eventIdx !== null && f.eventIdx !== undefined) {
    const targetIdx = f.eventIdx - 1; // Convert to 0-based index
    const targetEvent = S.events[targetIdx];
    if (targetEvent) {
      const eventsBefore = f.eventsBefore || 0;
      const eventsAfter = f.eventsAfter || 0;
      const startIdx = Math.max(0, targetIdx - eventsBefore);
      const endIdx = Math.min(S.events.length, targetIdx + 1 + eventsAfter); // Include the target event + events after
      filteredEvents = S.events.slice(startIdx, endIdx);
      // Mark the target event for highlighting
      window.highlightEventIdx = targetIdx;
    } else {
      filteredEvents = [];
    }
  }
  if (f.linkedIdx !== null && f.linkedIdx !== undefined) {
    filteredEvents = filteredEvents.filter(e => e.linkedEventIdx !== null && e.linkedEventIdx + 1 === f.linkedIdx);
  }
  if (f.shiftIdx !== null && f.shiftIdx !== undefined) {
    filteredEvents = filteredEvents.filter(e => e.shiftIdx === f.shiftIdx || e.shift_index === f.shiftIdx);
  }
  
  // Debug log
  console.log('  After filters: ' + filteredEvents.length + ' events to display');
  
  body.innerHTML = filteredEvents.map((e) => {
    const i = S.events.indexOf(e); // Get actual index in full array
    
    // Get event players and opp players
    const evtPlayers = (e.players || []).filter(p => p.role?.startsWith('event') || !p.role?.startsWith('opp'));
    const oppPlayers = (e.players || []).filter(p => p.role?.startsWith('opp'));
    
    const evtPlayerStr = evtPlayers.map(p => p.num).join(',') || '-';
    const oppPlayerStr = oppPlayers.map(p => p.num).join(',') || '-';
    
    // Get primary player info
    const primaryPlayer = evtPlayers[0];
    const primaryPD1 = primaryPlayer?.playD1?.replace('Play-','').replace(/_/g,' ').substring(0,10) || '';
    const primaryPD2 = primaryPlayer?.playD2?.replace('Play-','').replace(/_/g,' ').substring(0,10) || '';
    const primarySuccess = primaryPlayer?.playSuccess || '';
    
    // Other display values
    const hasXY = e.puckXY?.length || e.players?.some(p => p.xy?.length);
    const timeDisplay = e.start_time || e.time || '';
    const highlight = e.isHighlight ? '‚≠ê' : '';
    const linked = e.linkedEventIdx !== null && e.linkedEventIdx !== undefined ? e.linkedEventIdx + 1 : '';
    const detail = e.detail1 || e.detail || '';
    const detail2 = e.detail2 || '';
    const zone = e.zone ? e.zone.substring(0,1).toUpperCase() : '';
    const success = e.success === true || e.success === 1 || e.success === 's' || e.success === 'Y' ? '‚úì' : 
                   (e.success === false || e.success === 0 || e.success === 'u' || e.success === 'N' ? '‚úó' : '');
    const team = e.team === 'home' ? 'H' : 'A';
    const shiftIdx = e.shiftIdx || e.shift_index || '';
    
    // Calculate PIM (Penalty In Minutes) for penalty events based on detail1
    let pim = '';
    if (e.type === 'Penalty') {
      const penaltyLengths = S.penaltyLengths || { minor: 2, major: 5, misconduct: 10 };
      const d1 = (e.detail1 || '').toLowerCase();
      // Check for Penalty_Minor, Penalty_Major, Penalty_Misconduct
      if (d1 === 'penalty_minor' || d1.includes('penalty_minor')) {
        pim = penaltyLengths.minor || 2;
      } else if (d1 === 'penalty_major' || d1.includes('penalty_major')) {
        pim = penaltyLengths.major || 5;
      } else if (d1 === 'penalty_misconduct' || d1.includes('penalty_misconduct')) {
        pim = penaltyLengths.misconduct || 10;
      }
      pim = pim ? String(pim) : '';
    }
    
    // Build title for hover
    const hoverTitle = [
      'Event #' + (i+1),
      'Type: ' + e.type,
      'Detail: ' + detail + (detail2 ? ' / ' + detail2 : ''),
      'Team: ' + e.team,
      'Shift: ' + (shiftIdx || 'none'),
      'Event Players: ' + (evtPlayers.map(p => '#' + p.num + ' ' + p.name).join(', ') || 'none'),
      'Opp Players: ' + (oppPlayers.map(p => '#' + p.num + ' ' + p.name).join(', ') || 'none'),
      primaryPlayer ? 'P1 Play: ' + primaryPD1 + (primaryPD2 ? ' / ' + primaryPD2 : '') + ' ' + primarySuccess : '',
      e.linkedEventIdx != null ? 'Linked to #' + (e.linkedEventIdx + 1) : '',
      hasXY ? 'Has XY: Yes' : '',
      'Click to edit | Ctrl+Click to filter'
    ].filter(Boolean).join('\\n');
    
    // v20.4: Expanded columns - #, Sh, Lnk, Time, T, Type, Detail1, Detail2, Z, S, EvtP, OppP, PD1, PD2, PS, XY, star
    // v23.5: Add batch-selected class and goal review button
    // v23.8: Highlight the target event when showing events before
    const isTargetEvent = window.highlightEventIdx !== undefined && i === window.highlightEventIdx;
    const isBatchSelected = batchSelectMode && selectedEventIds.includes(i);
    const batchClass = isBatchSelected ? ' batch-selected' : '';
    const targetClass = isTargetEvent ? ' event-highlight' : '';
    const goalReviewBtn = e.type === 'Goal' ? '<span class="goal-review" onclick="event.stopPropagation();startGoalReview(' + i + ')" title="Review goal sequence">üé¨</span>' : '';
    
    // v23.5: Handle batch select click
    // v23.8: Ctrl+Click to filter to show X events before/after
    const clickHandler = batchSelectMode 
      ? 'toggleEventSelection(' + i + ')' 
      : 'handleEventClick(event, ' + i + ')';
    
    // v23.8: Move buttons (up/down)
    const canMoveUp = i > 0;
    const canMoveDown = i < S.events.length - 1;
    const moveButtons = '<div class="evt-move-btns" onclick="event.stopPropagation();">' +
      '<button onclick="moveEventUp(' + i + ')" ' + (canMoveUp ? '' : 'disabled') + ' title="Move event up">‚ñ≤</button>' +
      '<button onclick="moveEventDown(' + i + ')" ' + (canMoveDown ? '' : 'disabled') + ' title="Move event down">‚ñº</button>' +
      '</div>';
    
    // Calculate adjusted video time display
    const adjustedTimeDisplay = e.adjustedVideoTime && e.adjustedVideoTime !== e.start_time 
      ? 'P' + e.period + ' ' + e.adjustedVideoTime 
      : '';
    const adjustedTimeStyle = adjustedTimeDisplay 
      ? 'color:var(--accent);font-weight:bold;' 
      : 'color:var(--muted);';
    
    return '<div class="evt-item' + batchClass + targetClass + '" data-evt-idx="' + i + '" onclick="' + clickHandler + '" ondblclick="quickEditEvent(' + i + ')" title="' + hoverTitle + '">' +
      moveButtons +
      '<span class="idx">' + (i+1) + '</span>' +
      '<span class="seq" title="Shift #' + shiftIdx + '">' + shiftIdx + '</span>' +
      '<span class="link" title="Linked Event #' + linked + '">' + linked + '</span>' +
      '<span class="time">P' + e.period + ' ' + timeDisplay + '</span>' +
      '<span class="time" title="Adjusted Video Time" style="' + adjustedTimeStyle + '">' + (adjustedTimeDisplay || '--') + '</span>' +
      '<span class="team">' + team + '</span>' +
      '<span class="type">' + e.type + '</span>' +
      '<span class="pim" title="Penalty In Minutes" style="' + (pim ? 'color:var(--danger);font-weight:bold;' : 'color:var(--muted);') + '">' + pim + '</span>' +
      '<span class="detail" title="' + detail + '">' + detail.substring(0,12) + '</span>' +
      '<span class="detail" title="' + detail2 + '">' + detail2.substring(0,12) + '</span>' +
      '<span class="zone">' + zone + '</span>' +
      '<span class="success">' + success + '</span>' +
      '<span class="evtp" title="Event Players: ' + evtPlayers.map(p => p.num + ':' + p.name).join(', ') + '">' + evtPlayerStr + '</span>' +
      '<span class="oppp" title="Opp Players: ' + oppPlayers.map(p => p.num + ':' + p.name).join(', ') + '">' + oppPlayerStr + '</span>' +
      '<span class="pd1" title="' + primaryPD1 + '">' + primaryPD1.substring(0,8) + '</span>' +
      '<span class="pd1" title="' + primaryPD2 + '">' + primaryPD2.substring(0,8) + '</span>' +
      '<span class="psucc">' + primarySuccess + '</span>' +
      '<span class="xy-dot" title="' + (hasXY ? 'Has XY data (puck or players)' : 'No XY data') + '" style="' + (hasXY ? 'color:var(--accent);font-weight:bold;' : 'color:var(--muted);') + '">' + (hasXY?'üìç':'‚óã') + '</span>' +
      '<span class="hl">' + highlight + goalReviewBtn + '</span>' +
    '</div>';
  }).join('') || '<div style="color:var(--muted);padding:10px;text-align:center;font-size:10px;">No events to display</div>';
  
  // v23.8: Clear highlight after rendering
  if (window.highlightEventIdx !== undefined) {
    window.highlightEventIdx = undefined;
  }
  
  // Debug log
  console.log('  renderEvents complete. Filtered count:', filteredEvents.length);
  
  // v23.4: Update timeline scrub
  renderTimeline();
}

/**
 * v23.8: Handle event click - Ctrl+Click to filter, regular click to edit
 */
function handleEventClick(event, idx) {
  // Ctrl+Click (or Cmd+Click on Mac) to filter to show X events before/after
  if (event.ctrlKey || event.metaKey) {
    event.preventDefault();
    event.stopPropagation();
    
    // Get the current filter values for events before/after
    const eventsBefore = parseInt(document.getElementById('filterEventsBefore')?.value || '0') || 0;
    const eventsAfter = parseInt(document.getElementById('filterEventsAfter')?.value || '0') || 0;
    
    // Set the event index filter
    S.eventFilters.eventIdx = idx + 1; // Convert to 1-based for display
    S.eventFilters.eventsBefore = eventsBefore;
    S.eventFilters.eventsAfter = eventsAfter;
    
    // Update the filter input field
    const filterEvtIdxEl = document.getElementById('filterEvtIdx');
    if (filterEvtIdxEl) {
      filterEvtIdxEl.value = idx + 1;
    }
    
    // Apply filters and re-render
    renderEvents();
    
    toast(`Filtered to event #${idx + 1} (${eventsBefore} before, ${eventsAfter} after)`, 'info');
  } else {
    // Regular click - edit the event
    editEvent(idx);
  }
}

// Quick inline edit for event
function quickEditEvent(idx) {
  const evt = S.events[idx];
  
  // Build edit options
  const fields = [
    { name: 'Type', key: 'type', value: evt.type },
    { name: 'Detail 1', key: 'detail1', value: evt.detail1 || evt.detail || '' },
    { name: 'Detail 2', key: 'detail2', value: evt.detail2 || '' },
    { name: 'Linked Index', key: 'linkedEventIdx', value: evt.linkedEventIdx || '' },
    { name: 'Zone (Off/Neu/Def)', key: 'zone', value: evt.zone || '' },
    { name: 'Success (Y/N)', key: 'success', value: evt.success === true ? 'Y' : evt.success === false ? 'N' : '' },
    { name: 'Start Time', key: 'start_time', value: evt.start_time || '' },
    { name: 'Highlight (Y/N)', key: 'isHighlight', value: evt.isHighlight ? 'Y' : 'N' },
  ];
  
  const choice = prompt(
    `Quick Edit Event #${idx+1}\nEnter field number to edit:\n` +
    fields.map((f, i) => `${i+1}. ${f.name}: ${f.value}`).join('\n') +
    '\n\n(or 0 to cancel)'
  );
  
  if (!choice || choice === '0') return;
  
  const fieldIdx = parseInt(choice) - 1;
  if (fieldIdx < 0 || fieldIdx >= fields.length) {
    toast('Invalid selection', 'error');
    return;
  }
  
  const field = fields[fieldIdx];
  const newValue = prompt(`${field.name}:`, field.value);
  
  if (newValue !== null) {
    if (field.key === 'linkedEventIdx') {
      evt.linkedEventIdx = newValue ? parseInt(newValue) : null;
    } else if (field.key === 'success') {
      evt.success = newValue.toUpperCase() === 'Y' ? true : newValue.toUpperCase() === 'N' ? false : null;
    } else if (field.key === 'isHighlight') {
      evt.isHighlight = newValue.toUpperCase() === 'Y';
    } else if (field.key === 'detail1') {
      evt.detail1 = newValue;
      evt.detail = newValue; // Also update legacy field
    } else {
      evt[field.key] = newValue;
    }
    saveGameData();
    renderEvents();
    toast(`Updated ${field.name}`, 'success');
  }
}

function renderMarkers() {
  const layer = document.getElementById('markers');
  layer.innerHTML = '';
  const histCnt = parseInt(document.getElementById('xyHistCnt').value) || 5;
  
  // Historical events
  const recent = S.events.slice(-histCnt);
  recent.forEach((evt, ei) => {
    const opacity = 0.2 + (ei / histCnt) * 0.6;
    const extraData = { evtNum: evt.idx, evtType: evt.type };
    if (evt.puckXY?.length) drawPath(evt.puckXY, '#000', '#fff', opacity, layer, null, false, extraData);
    evt.players?.forEach(p => {
      if (p.xy?.length) {
        // v23.8: Use home/away team colors - ensure team is set correctly
        // Fallback: determine team from role if team is missing
        let playerTeam = p.team;
        if (!playerTeam) {
          // Infer team from role or event team
          if (p.role?.startsWith('event')) {
            playerTeam = evt.team || 'home';
          } else if (p.role?.startsWith('opp')) {
            playerTeam = evt.team === 'home' ? 'away' : 'home';
          } else {
            playerTeam = evt.team || 'home';
          }
        }
        const color = playerTeam === 'home' ? S.homeColor : S.awayColor;
        drawPath(p.xy, color, '#fff', opacity, layer, p.num, false, { ...extraData, playerName: p.name, playerNum: p.num });
      }
    });
  });
  
  // Current event
  if (S.curr.puckXY?.length) drawPath(S.curr.puckXY, '#00d4aa', '#fff', 1, layer, 'üèí', true);
  S.curr.players?.forEach(p => {
    if (p.xy?.length) {
      // v23.8: Use home/away team colors - ensure team is set correctly
      // Fallback: determine team from role if team is missing
      let playerTeam = p.team;
      if (!playerTeam) {
        // Infer team from role or event team
        if (p.role?.startsWith('event')) {
          playerTeam = S.evtTeam || 'home';
        } else if (p.role?.startsWith('opp')) {
          playerTeam = S.evtTeam === 'home' ? 'away' : 'home';
        } else {
          playerTeam = S.evtTeam || 'home';
        }
      }
      const color = playerTeam === 'home' ? S.homeColor : S.awayColor;
      const sel = S.selectedPlayer?.num === p.num;
      drawPath(p.xy, color, sel ? '#fff' : '#000', 1, layer, p.num, true, { playerName: p.name, playerNum: p.num });
    }
  });
}

function drawPath(points, fill, stroke, opacity, layer, label, current, extraData = {}) {
  if (!points?.length) return;
  
  // v16.06: Convert center-relative coords to SVG coords for display
  // Stored: (0,0) = center ice. SVG: (100, 42.5) = center ice
  const toSvg = (pt) => ({
    x: pt.x + 100,
    y: pt.y + 42.5,
    seq: pt.seq,
    origX: pt.x,  // Keep original for tooltip
    origY: pt.y
  });
  
  const sorted = [...points].map(toSvg).sort((a,b) => a.seq - b.seq);
  
  for (let i = 0; i < sorted.length - 1; i++) {
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', sorted[i].x); line.setAttribute('y1', sorted[i].y);
    line.setAttribute('x2', sorted[i+1].x); line.setAttribute('y2', sorted[i+1].y);
    line.setAttribute('stroke', fill); line.setAttribute('stroke-width', current ? 1 : 0.5);
    line.setAttribute('stroke-dasharray', current ? 'none' : '2,1'); line.setAttribute('opacity', opacity * 0.7);
    layer.appendChild(line);
  }
  
  sorted.forEach((pt, i) => {
    const last = i === sorted.length - 1;
    // v16.06: Reduced marker size - current last=2.5, current other=1.5, history last=2, history other=1.2
    const r = current ? (last ? 2.5 : 1.5) : (last ? 2 : 1.2);
    const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    c.setAttribute('cx', pt.x); c.setAttribute('cy', pt.y); c.setAttribute('r', r);
    c.setAttribute('fill', fill); c.setAttribute('stroke', stroke);
    c.setAttribute('stroke-width', last ? 0.5 : 0.3); c.setAttribute('opacity', opacity);
    
    // v23.3: Make last marker of current players clickable to select them
    // Other markers: pointer-events:none to click through
    if (current && last && extraData.playerNum) {
      c.style.pointerEvents = 'auto';
      c.style.cursor = 'pointer';
      c.onclick = (e) => {
        e.stopPropagation();
        selectPlayer(extraData.playerNum);
        toast(`Selected #${extraData.playerNum}`, 'info');
      };
    } else {
      c.style.pointerEvents = 'none';
    }
    
    // Add data attributes for tooltip - use center-relative coords
    c.dataset.x = Math.round(pt.origX * 10) / 10;
    c.dataset.y = Math.round(pt.origY * 10) / 10;
    if (label === 'üèí') {
      c.dataset.type = 'puck';
    } else if (label && !isNaN(parseInt(label))) {
      c.dataset.type = 'player';
      c.dataset.num = label;
      c.dataset.name = extraData.playerName || '';
    } else if (extraData.evtNum) {
      c.dataset.type = 'history';
      c.dataset.evtnum = extraData.evtNum;
      c.dataset.evttype = extraData.evtType || '';
    }
    
    layer.appendChild(c);
    
    if (last && label) {
      const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      t.setAttribute('x', pt.x); t.setAttribute('y', pt.y + 1);
      t.setAttribute('fill', stroke); t.setAttribute('font-size', current ? '3.5' : '3');
      t.setAttribute('font-weight', 'bold'); t.setAttribute('text-anchor', 'middle');
      t.setAttribute('dominant-baseline', 'middle'); t.setAttribute('opacity', opacity);
      t.textContent = label;
      t.style.pointerEvents = 'none'; // Let events pass through to circle
      layer.appendChild(t);
    }
  });
}

/**
 * v23.8: Update scores with optional cutoff index (for time-based stats when viewing shifts/events)
 * @param {number|null} cutoffIdx - Only count events up to this index (inclusive). If null, count all events.
 */
function updateScores(cutoffIdx = null) {
  // Filter events up to cutoff index
  // cutoffIdx is the maximum array index (inclusive) to count
  const eventsToCount = cutoffIdx !== null && cutoffIdx !== undefined
    ? S.events.filter((e, arrayIdx) => arrayIdx <= cutoffIdx)
    : S.events;

  const goals = eventsToCount.filter(e => e.type === 'Goal' && e.detail1?.includes('Scored'));
  document.getElementById('scoreH').textContent = goals.filter(e => e.team === 'home').length;
  document.getElementById('scoreA').textContent = goals.filter(e => e.team === 'away').length;
  updateQuickStats(cutoffIdx); // v5
}

/**
 * v23.8: Update quick stats bar with optional cutoff index
 * @param {number|null} cutoffIdx - Only count events up to this index (inclusive). If null, count all events.
 */
function updateQuickStats(cutoffIdx = null) {
  // Filter events up to cutoff index
  // cutoffIdx is the maximum array index (inclusive) to count
  const eventsToCount = cutoffIdx !== null && cutoffIdx !== undefined
    ? S.events.filter((e, arrayIdx) => arrayIdx <= cutoffIdx)
    : S.events;
  
  // Event & shift counts
  document.getElementById('qsEvents').textContent = eventsToCount.length;
  document.getElementById('qsShifts').textContent = S.shifts.length;
  
  // v16: SOG (shots on goal) - only shots that reached the net or goals
  const isSOG = (e) => {
    const d1 = (e.detail1 || '').toLowerCase();
    return d1.includes('shot_onnetsaved') || d1.includes('shot_onnetgoal') || 
           d1.includes('goal_scored') || d1.includes('goal_shootout') || d1.includes('goal_penaltyshot');
  };
  const homeSOG = eventsToCount.filter(e => isSOG(e) && e.team === 'home').length;
  const awaySOG = eventsToCount.filter(e => isSOG(e) && e.team === 'away').length;
  document.getElementById('qsSOG').textContent = `${homeSOG}-${awaySOG}`;
  
  // Faceoffs
  const faceoffs = eventsToCount.filter(e => e.type === 'Faceoff');
  const homeFO = faceoffs.filter(e => e.team === 'home' && e.success === 's').length;
  const awayFO = faceoffs.filter(e => e.team === 'away' && e.success === 's').length;
  document.getElementById('qsFO').textContent = `${homeFO}-${awayFO}`;
  
  // Penalties
  const penalties = eventsToCount.filter(e => e.type === 'Penalty');
  const homePEN = penalties.filter(e => e.team === 'home').length;
  const awayPEN = penalties.filter(e => e.team === 'away').length;
  document.getElementById('qsPEN').textContent = `${homePEN}-${awayPEN}`;
  
  // Current strength from slots
  const homeCount = ['F1','F2','F3','D1','D2','X'].filter(p => S.slots.home?.[p]?.num).length;
  const awayCount = ['F1','F2','F3','D1','D2','X'].filter(p => S.slots.away?.[p]?.num).length;
  const strength = `${homeCount}v${awayCount}`;
  const strengthEl = document.getElementById('qsStrength');
  strengthEl.textContent = strength;
  strengthEl.className = 'value strength-indicator';
  if (homeCount > awayCount) strengthEl.classList.add('pp');
  else if (homeCount < awayCount) strengthEl.classList.add('pk');
  else strengthEl.classList.add('even');
}

// ============================================================
// SLOTS & ROSTERS
// ============================================================
function selectSlot(el) {
  document.querySelectorAll('.slot').forEach(s => s.classList.remove('selected'));
  el.classList.add('selected');
  S.selectedSlot = { team: el.dataset.team, pos: el.dataset.pos };
}

function assignPlayer(team, num) {
  if (!S.selectedSlot || S.selectedSlot.team !== team) {
    const positions = ['F1','F2','F3','D1','D2','G','X'];
    for (const pos of positions) { if (!S.slots[team][pos]) { S.selectedSlot = { team, pos }; break; } }
  }
  if (!S.selectedSlot) return;
  const p = S.rosters[team].find(x => x.num === num);
  if (!p) return;
  S.slots[team][S.selectedSlot.pos] = p;
  S.selectedSlot = null;
  renderSlots(); renderRosters(); renderQuickAdd();
  onSlotsChanged(); // Update strength
}

function clearSlots(team) {
  Object.keys(S.slots[team]).forEach(pos => S.slots[team][pos] = null);
  renderSlots(); renderRosters(); renderQuickAdd();
  onSlotsChanged(); // Update strength
}

function clearSlot(team, pos) {
  S.slots[team][pos] = null;
  S.selectedSlot = null;
  renderSlots(); renderRosters(); renderQuickAdd();
  onSlotsChanged(); // Update strength
}

// ============================================================
// EVENT ENTRY
// ============================================================
function setEvtTeam(team) {
  const oldTeam = S.evtTeam;
  S.evtTeam = team;
  
  // v23.8: If players are populated and team changed, swap event/opp roles
  if (oldTeam && oldTeam !== team && S.curr.players && S.curr.players.length > 0) {
    const evtPlayers = S.curr.players.filter(p => p.role?.startsWith('event'));
    const oppPlayers = S.curr.players.filter(p => p.role?.startsWith('opp'));
    
    // Swap roles
    evtPlayers.forEach((p, i) => {
      p.role = `opp_team_player_${i + 1}`;
      p.roleNum = i + 1;
    });
    oppPlayers.forEach((p, i) => {
      p.role = `event_team_player_${i + 1}`;
      p.roleNum = i + 1;
    });
    
    // Merge back - new event players first, then new opp players
    S.curr.players = [...oppPlayers, ...evtPlayers];
    
    // Update player teams to match their new roles
    S.curr.players.forEach(p => {
      if (p.role?.startsWith('event')) {
        p.team = team;
      } else if (p.role?.startsWith('opp')) {
        p.team = team === 'home' ? 'away' : 'home';
      }
    });
    
    // Re-render players
    if (typeof renderCurrentPlayers === 'function') renderCurrentPlayers();
    if (typeof renderQuickAdd === 'function') renderQuickAdd();
  }
  
  document.querySelectorAll('.team-toggle button.home, .team-toggle button.away').forEach(b => b.classList.remove('active'));
  document.querySelector(`.team-toggle .${team}`).classList.add('active');
  renderQuickAdd();
  updateZoneDisplay();
}

function swapEvtTeam() {
  // Swap the event team
  const newTeam = S.evtTeam === 'home' ? 'away' : 'home';
  
  // Also swap players between event and opp roles
  const evtPlayers = S.curr.players.filter(p => p.role?.startsWith('event'));
  const oppPlayers = S.curr.players.filter(p => p.role?.startsWith('opp'));
  
  // Swap roles - use consistent format event_team_player_N / opp_team_player_N
  evtPlayers.forEach((p, i) => {
    p.role = `opp_team_player_${i + 1}`;
    p.roleNum = i + 1;
  });
  oppPlayers.forEach((p, i) => {
    p.role = `event_team_player_${i + 1}`;
    p.roleNum = i + 1;
  });
  
  // Merge back - new event players first
  S.curr.players = [...oppPlayers, ...evtPlayers];
  
  // Set new team
  setEvtTeam(newTeam);
  renderQuickAdd();
  toast(`Swapped to ${newTeam.toUpperCase()}`, 'info');
}

function setEvtType(type) {
  S.curr.type = type;
  document.querySelectorAll('.evt-btn').forEach(b => b.classList.remove('active'));
  document.querySelector(`.evt-btn[data-type="${type}"]`)?.classList.add('active');

  // v23.8: Auto-populate F1 players for faceoffs
  if (type === 'Faceoff') {
    autoPopulateFaceoffPlayers();
  }

  // v23.3: Auto-link and setup for follow-up events (Shot ‚Üí Save, etc.)
  autoLinkFollowUp(type);

  // v16.06: Use S.eventDetails1 from dim_event_detail if available
  let d1Options = [];
  if (S.eventDetails1?.length > 0) {
    // Case-insensitive filtering for event type
    const filtered = S.eventDetails1.filter(e => 
      String(e.eventType || '').toLowerCase() === String(type || '').toLowerCase()
    );
    d1Options = filtered.map(e => e.name);
    
    // For Penalty type: Validate that Supabase data has proper penalty types
    // If event_detail_name is just "penalty" (generic), it's invalid data
    if (type === 'Penalty') {
      const hasInvalidData = d1Options.length > 0 && 
        d1Options.every(opt => {
          const optLower = opt.toLowerCase();
          // Check if all options are just generic "penalty" without specific types
          return optLower === 'penalty' || 
                 (!optLower.includes('minor') && !optLower.includes('major') && !optLower.includes('misconduct'));
        });
      
      if (hasInvalidData) {
        console.warn('‚ö†Ô∏è Supabase penalty data is invalid - event_detail_name values are generic "penalty" instead of specific types (Penalty_Minor, Penalty_Major, Penalty_Misconduct)');
        console.warn('Falling back to LISTS.details. Please fix dim_event_detail table in Supabase.');
        d1Options = []; // Clear invalid data to trigger fallback
      }
    }
  }
  
  // Fall back to LISTS.details if no Supabase data or invalid/incomplete data
  // For Penalty, we need at least 3 specific types (Minor, Major, Misconduct)
  const needsFallback = d1Options.length === 0 || 
    (type === 'Penalty' && (
      d1Options.length < 3 || 
      !d1Options.some(opt => {
        const optLower = opt.toLowerCase();
        return optLower.includes('minor') || optLower.includes('major') || optLower.includes('misconduct');
      })
    ));
  
  if (needsFallback) {
    const opts = LISTS.details[type] || { d1: [], d2: [] };
    const fallbackOptions = opts.d1 || [];
    if (fallbackOptions.length > 0) {
      d1Options = fallbackOptions;
      if (type === 'Penalty') {
        console.log('Using fallback LISTS.details for Penalty:', fallbackOptions);
      }
    }
  }

  document.getElementById('evtD1').innerHTML = '<option value="">--</option>' +
    d1Options.map(o => `<option value="${o}">${o}</option>`).join('');
  document.getElementById('evtD2').innerHTML = '<option value="">--</option>';

  // v23.4: Render quick detail buttons
  renderQuickDetails(type, d1Options);

  // Update linked events dropdown based on current type
  updateLinkedEventsDropdown();

  // Apply linked event data if linked
  applyLinkedEventData();

  // Auto-derive zone from position if we have XY
  const zone = calculateZone();
  if (zone) document.getElementById('evtZone').value = zone;

  // Auto-derive strength from slots
  const strength = deriveStrength();
  if (strength) document.getElementById('evtStrength').value = strength;
  
  // v23.3: Auto-populate goalie for Save events
  if (type === 'Save') {
    autoPopulateGoalie();
  }
  
  // v23.8: Auto-detect success when event type changes
  if (autoSuccessEnabled) {
    const success = deriveSuccess();
    if (success) {
      document.getElementById('evtSuccess').value = success;
      autoDetectAllSuccess();
    }
  }
  
  // v23.8: Auto-detect side of puck when zone is set
  autoDetectAllSideOfPuck();
  
  // Check penalty detail dropdowns when type = Penalty
  if (type === 'Penalty') {
    const d1El = document.getElementById('evtD1');
    const d2El = document.getElementById('evtD2');
    console.log('Penalty type selected - Detail 1 options:', d1El ? Array.from(d1El.options).map(o => o.value).filter(v => v) : 'N/A');
    console.log('Penalty type selected - Detail 2 options:', d2El ? Array.from(d2El.options).map(o => o.value).filter(v => v) : 'N/A');
    if (d1El && d1El.options.length <= 1) {
      toast('‚ö†Ô∏è No penalty detail1 options available - check configuration', 'warning');
    }
  }
}

// ============================================================
// v23.4: QUICK DETAIL BUTTONS
// ============================================================

// Most common details by event type for quick buttons
const QUICK_DETAILS = {
  Shot: ['Shot_OnNet', 'Shot_Missed', 'Shot_Blocked', 'Shot_Goal'],
  Goal: ['Goal_Scored', 'Goal_Disallowed'],
  Pass: ['Pass_Completed', 'Pass_Incomplete', 'Pass_Intercepted'],
  Faceoff: ['Faceoff_Won', 'Faceoff_Lost'],
  Turnover: ['Turnover_Giveaway', 'Turnover_Takeaway'],
  Zone_Entry_Exit: ['Zone_Entry', 'Zone_Exit'],
  Save: ['Save_Made', 'Save_Rebound'],
  Possession: ['Possession_Gained', 'Possession_Lost', 'Possession_Cycle'],
  Stoppage: ['Stoppage_Icing', 'Stoppage_Offside', 'Stoppage_GoalieFreeze'],
  Penalty: ['Penalty_Tripping', 'Penalty_Hooking', 'Penalty_Slashing', 'Penalty_Holding']
};

/**
 * Render quick detail buttons for current event type
 */
function renderQuickDetails(type, allOptions) {
  const row = document.getElementById('quickDetailRow');
  if (!row) return;
  
  // Get quick details for this type, or use first 4 from all options
  const quickOptions = QUICK_DETAILS[type] || allOptions.slice(0, 4);
  
  if (quickOptions.length === 0) {
    row.style.display = 'none';
    return;
  }
  
  row.style.display = 'flex';
  row.innerHTML = quickOptions.map(opt => {
    const label = opt.replace(`${type}_`, '').replace(/_/g, ' ');
    const isActive = document.getElementById('evtD1').value === opt;
    return `<button class="btn-sm ${isActive ? 'active' : ''}" onclick="quickSetDetail1('${opt}')" style="font-size:8px;padding:2px 6px;">${label}</button>`;
  }).join('');
}

/**
 * Quick set Detail 1 value
 */
function quickSetDetail1(value) {
  document.getElementById('evtD1').value = value;
  onD1Change();
  
  // Update button states
  document.querySelectorAll('#quickDetailRow button').forEach(btn => {
    btn.classList.remove('active');
  });
  event.target.classList.add('active');
}

/**
 * Set zone via button click
 */
function setZone(zone) {
  document.getElementById('evtZone').value = zone;

  // Update button states
  document.querySelectorAll('.zone-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.zone === zone);
    btn.style.background = btn.dataset.zone === zone ?
      (zone === 'o' ? 'var(--success)' : zone === 'd' ? 'var(--danger)' : 'var(--muted)') : '';
    btn.style.color = btn.dataset.zone === zone ? '#fff' : '';
  });
  
  // v23.8: Auto-detect side of puck when zone changes
  autoDetectAllSideOfPuck();
}

/**
 * Set success via button click
 */
function setSuccess(success) {
  document.getElementById('evtSuccess').value = success;
  
  // Update button states
  document.querySelectorAll('.success-btn').forEach(btn => {
    const isActive = btn.dataset.success === success;
    btn.style.opacity = isActive ? '1' : '0.5';
    btn.style.transform = isActive ? 'scale(1.1)' : 'scale(1)';
  });
  
  // v23.8: Auto-detect success for all players when success is set
  autoDetectAllSuccess();
}

function onD1Change() {
  const type = S.curr.type;
  const d1 = document.getElementById('evtD1').value;
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onD1Change:10491',message:'Function entry',data:{type,d1,eventDetails2Count:S.eventDetails2?.length||0,eventDetails2Exists:!!S.eventDetails2,evtD2ElementExists:!!document.getElementById('evtD2')},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
  // #endregion
  console.log('onD1Change called - type:', type, 'd1:', d1);
  
  // v23.8: Auto-detect success when detail1 changes
  if (autoSuccessEnabled) {
    const success = deriveSuccess();
    if (success) {
      document.getElementById('evtSuccess').value = success;
      autoDetectAllSuccess();
    }
  }
  
  let d2Opts = [];
  
  // If no detail1 selected, clear detail2
  if (!d1 || d1 === '') {
    document.getElementById('evtD2').innerHTML = '<option value="">--</option>';
    return;
  }
  
  // Special handling for Penalty - always use LISTS.details
  if (d1.startsWith('Penalty_')) {
    const penaltyOpts = LISTS.details.Penalty || {};
    if (penaltyOpts.d2 && penaltyOpts.d2.length > 0) {
      d2Opts = penaltyOpts.d2;
      console.log('Penalty detail2 options:', d2Opts);
    }
  }
  // v16.08: Use S.eventDetails2 from dim_event_detail_2 - filter by code prefix
  else if (S.eventDetails2?.length > 0) {
    // Determine code prefix based on detail1 value
    let codePrefix = null;
    if (d1.startsWith('Shot_')) codePrefix = 'Shot_';
    else if (d1.startsWith('Pass_')) codePrefix = 'Pass_';
    else if (d1.startsWith('Goal_')) codePrefix = 'Goal_';
    else if (d1.startsWith('Save_')) codePrefix = 'Save_';
    else if (d1.includes('Giveaway')) codePrefix = 'Giveaway_';
    else if (d1.includes('Takeaway')) codePrefix = 'Takeaway_';
    else if (d1.includes('Entry')) codePrefix = 'ZoneEntry_';
    else if (d1.includes('Exit') || d1.includes('Keepin')) codePrefix = 'ZoneExit_';
    else if (d1 === 'Stoppage_Play') codePrefix = 'Stoppage_';
    else if (d1 === 'Play_Offensive') codePrefix = 'PlayOffensive_';
    else if (d1 === 'Play_Defensive') codePrefix = 'PlayDefensive_';
    else if (d1.startsWith('Faceoff_')) codePrefix = 'Faceoff_';
    else if (d1.startsWith('Possession_')) codePrefix = 'Possession_';
    else if (d1.startsWith('Rebound_')) codePrefix = 'Rebound_';
    
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onD1Change:10525',message:'Code prefix determination',data:{d1,codePrefix,eventDetails2Count:S.eventDetails2.length,eventDetails2SampleCodes:S.eventDetails2.slice(0,5).map(e=>({code:e.code,name:e.name}))},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
    // #endregion
    if (codePrefix) {
      d2Opts = S.eventDetails2
        .filter(e => e.code && e.code.startsWith(codePrefix))
        .map(e => e.name);
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onD1Change:10542',message:'After Supabase filter',data:{codePrefix,d2OptsCount:d2Opts.length,d2Opts},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
      // #endregion
      console.log('Detail2 filter from Supabase:', codePrefix, '‚Üí', d2Opts.length, 'options', d2Opts);
    } else {
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onD1Change:10547',message:'No code prefix matched',data:{d1},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
      // #endregion
      console.log('No code prefix matched for d1:', d1);
    }
  }
  
  // Fall back to LISTS.details if no Supabase data or Supabase returned no matches
  if (d2Opts.length === 0) {
    const opts = LISTS.details[type] || {};
    d2Opts = opts.d2 || [];
    if (d1.includes('Giveaway') && opts.d2_Giveaway) d2Opts = opts.d2_Giveaway;
    else if (d1.includes('Takeaway') && opts.d2_Takeaway) d2Opts = opts.d2_Takeaway;
    else if (d1.includes('Entry') && opts.d2_Entry) d2Opts = opts.d2_Entry;
    else if (d1.includes('Exit') && opts.d2_Exit) d2Opts = opts.d2_Exit;
    else if (d1.includes('Play') && opts.d2_Play) d2Opts = opts.d2_Play;
    else if (d1.includes('Offensive') && opts.d2_Offensive) d2Opts = opts.d2_Offensive;
    else if (d1.includes('Defensive') && opts.d2_Defensive) d2Opts = opts.d2_Defensive;
    else if (d1.includes('Keepin') && opts.d2_Exit) d2Opts = opts.d2_Exit;
    
    if (d2Opts.length > 0) {
      console.log('Using fallback LISTS.details for detail2:', d2Opts.length, 'options', d2Opts);
    } else {
      console.log('No detail2 options found for type:', type, 'd1:', d1);
    }
  }
  
  const d2Html = '<option value="">--</option>' + d2Opts.map(o => `<option value="${o}">${o}</option>`).join('');
  const evtD2El = document.getElementById('evtD2');
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onD1Change:10571',message:'Before setting evtD2 innerHTML',data:{d2OptsCount:d2Opts.length,evtD2ElementExists:!!evtD2El,d2HtmlLength:d2Html.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
  // #endregion
  if (evtD2El) {
    evtD2El.innerHTML = d2Html;
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onD1Change:10572',message:'After setting evtD2 innerHTML',data:{d2OptsCount:d2Opts.length,evtD2OptionsCount:evtD2El.options.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
    // #endregion
  } else {
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onD1Change:10572',message:'evtD2 element not found',data:{d2OptsCount:d2Opts.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
    // #endregion
  }
  console.log('Detail2 dropdown populated with', d2Opts.length, 'options');
  
  // Auto-derive success
  const success = deriveSuccess();
  if (success) document.getElementById('evtSuccess').value = success;
  
  // v23.3: Check if this is a shot on net or goal - prompt for net location
  const needsNetLocation = (type === 'Shot' && (d1.includes('OnNet') || d1.includes('Goal'))) || 
                           type === 'Goal' || 
                           (d1 && d1.includes('Goal_Scored'));
  if (needsNetLocation) {
    setTimeout(() => document.getElementById('netModal').classList.add('show'), 100);
    // v23.3: Auto-add opposing goalie for shots on net
    autoPopulateGoalie();
  }
}

function togglePlayer(num, role) {
  const team = role === 'evt' ? S.evtTeam : (S.evtTeam === 'home' ? 'away' : 'home');
  const p = S.rosters[team]?.find(x => x.num === num);
  
  // v23.3: Guard - can't add player from wrong team
  if (!p) {
    // Check if player is from opposite team
    const otherTeam = team === 'home' ? 'away' : 'home';
    const otherPlayer = S.rosters[otherTeam]?.find(x => x.num === num);
    if (otherPlayer) {
      toast(`#${num} is on ${otherTeam} team - use ${role === 'evt' ? 'Opp' : 'Event'} side`, 'warning');
    }
    return;
  }
  
  // v23.3: Guard - check if adding this player would create mixed teams in event/opp
  const existingEvtPlayers = S.curr.players.filter(x => x.role?.startsWith('event'));
  const existingOppPlayers = S.curr.players.filter(x => x.role?.startsWith('opp'));
  
  if (role === 'evt' && existingEvtPlayers.length > 0) {
    const existingTeam = existingEvtPlayers[0].team;
    if (existingTeam !== team) {
      toast(`Event players must all be from same team (${existingTeam})`, 'error');
      return;
    }
  }
  if (role === 'opp' && existingOppPlayers.length > 0) {
    const existingTeam = existingOppPlayers[0].team;
    if (existingTeam !== team) {
      toast(`Opp players must all be from same team (${existingTeam})`, 'error');
      return;
    }
  }
  
  const existingIdx = S.curr.players.findIndex(x => x.num === num);
  if (existingIdx >= 0) {
    S.curr.players.splice(existingIdx, 1);
    if (S.selectedPlayer?.num === num) S.selectedPlayer = null;
  } else {
    const roleNum = S.curr.players.filter(x => x.role?.startsWith(role === 'evt' ? 'event' : 'opp')).length + 1;
    S.curr.players.push({
      ...p, 
      team: team, // v23.8: Explicitly set team to ensure correct colors
      role: `${role === 'evt' ? 'event' : 'opp'}_team_player_${roleNum}`,
      roleNum, xy: [], playD1: '', playD2: '', playSuccess: '', pressure: '', sideOfPuck: ''
    });
  }
  renumberPlayers();
  
  // v23.8: Auto-detect all settings when players are added
  autoDetectAllPressure();
  autoDetectAllSuccess();
  autoDetectAllSideOfPuck();
  
  renderQuickAdd(); renderMarkers();
}

function removePlayer(num) {
  S.curr.players = S.curr.players.filter(p => p.num !== num);
  if (S.selectedPlayer?.num === num) S.selectedPlayer = null;
  renumberPlayers();
  renderQuickAdd(); renderMarkers();
}

function renumberPlayers() {
  let evtN = 1, oppN = 1;
  S.curr.players.forEach(p => {
    if (p.role?.startsWith('event')) { p.role = `event_team_player_${evtN}`; p.roleNum = evtN++; }
    else { p.role = `opp_team_player_${oppN}`; p.roleNum = oppN++; }
  });
}

// ============================================================
// PLAYER CHIP DRAG AND DROP
// ============================================================
let draggedPlayer = null;

function handlePlayerDragStart(e) {
  const chip = e.target.closest('.player-chip');
  if (!chip) return;
  
  draggedPlayer = {
    num: chip.dataset.num,
    role: chip.dataset.role,
    idx: parseInt(chip.dataset.idx)
  };
  chip.classList.add('dragging');
  e.dataTransfer.effectAllowed = 'move';
  e.dataTransfer.setData('text/plain', JSON.stringify(draggedPlayer));
}

function handlePlayerDragEnd(e) {
  const chip = e.target.closest('.player-chip');
  if (chip) chip.classList.remove('dragging');
  document.querySelectorAll('.player-chip').forEach(c => c.classList.remove('drag-over'));
  document.querySelectorAll('.player-list').forEach(l => l.classList.remove('drag-target'));
  draggedPlayer = null;
}

function handlePlayerDragOver(e) {
  e.preventDefault();
  if (!draggedPlayer) return;
  
  const chip = e.target.closest('.player-chip');
  if (chip && chip.dataset.num !== draggedPlayer.num) {
    chip.classList.add('drag-over');
  }
  
  // Also highlight the player list container for cross-list drops
  const list = e.target.closest('.player-list');
  if (list) list.classList.add('drag-target');
  
  e.dataTransfer.dropEffect = 'move';
}

function handlePlayerDrop(e) {
  e.preventDefault();
  const chip = e.target.closest('.player-chip');
  
  document.querySelectorAll('.player-chip').forEach(c => c.classList.remove('drag-over'));
  document.querySelectorAll('.player-list').forEach(l => l.classList.remove('drag-target'));
  
  if (!draggedPlayer) return;
  
  const sourceNum = draggedPlayer.num;
  const sourceRole = draggedPlayer.role; // 'evt' or 'opp'
  
  // Find the source player
  const sourcePlayer = S.curr.players.find(p => p.num === sourceNum);
  if (!sourcePlayer) return;
  
  // Determine target role from drop location
  let targetRole = sourceRole;
  const list = e.target.closest('.player-list');
  if (list) {
    if (list.id === 'evtPlayers') targetRole = 'evt';
    else if (list.id === 'oppPlayers') targetRole = 'opp';
  }
  
  // If dropping on another chip in the SAME list, swap positions
  if (chip && chip.dataset.num !== sourceNum) {
    const targetNum = chip.dataset.num;
    const targetPlayer = S.curr.players.find(p => p.num === targetNum);
    const targetChipRole = chip.dataset.role;
    
    if (targetPlayer && sourceRole === targetChipRole) {
      // Same list - just swap positions
      const sourceIdx = S.curr.players.indexOf(sourcePlayer);
      const targetIdx = S.curr.players.indexOf(targetPlayer);
      S.curr.players[sourceIdx] = targetPlayer;
      S.curr.players[targetIdx] = sourcePlayer;
      renumberPlayers();
      renderQuickAdd();
      renderMarkers();
      toast('Swapped player positions', 'info');
      return;
    }
  }
  
  // v23.3: If dropping on opposite list (not on a chip), swap ALL players and team
  if (sourceRole !== targetRole) {
    // Swap ALL players: event becomes opp, opp becomes event
    S.curr.players.forEach(p => {
      if (p.role?.startsWith('event')) {
        p.role = p.role.replace('event', 'opp');
      } else if (p.role?.startsWith('opp')) {
        p.role = p.role.replace('opp', 'event');
      }
    });
    
    // Swap event team
    const newTeam = S.evtTeam === 'home' ? 'away' : 'home';
    setEvtTeam(newTeam);
    
    renumberPlayers();
    renderQuickAdd();
    renderMarkers();
    toast(`Swapped Event‚ÜîOpp (${S.homeTeam || 'Home'} is now ${newTeam === 'home' ? 'Event' : 'Opp'})`, 'success');
  }
}

function handleListDragOver(e) {
  e.preventDefault();
  if (!draggedPlayer) return;
  e.currentTarget.classList.add('drag-target');
  e.dataTransfer.dropEffect = 'move';
}

function handleListDragLeave(e) {
  e.currentTarget.classList.remove('drag-target');
}

function handleListDrop(e, targetRole) {
  e.preventDefault();
  e.currentTarget.classList.remove('drag-target');
  
  if (!draggedPlayer) return;
  
  // Check if we dropped directly on a chip (handled by chip handler)
  if (e.target.closest('.player-chip')) return;
  
  const sourceNum = draggedPlayer.num;
  const sourceRole = draggedPlayer.role;
  
  // Find the source player
  const sourcePlayer = S.curr.players.find(p => p.num === sourceNum);
  if (!sourcePlayer) return;
  
  // v23.3: When dragging to opposite list, swap ALL players and the event team
  if (sourceRole !== targetRole) {
    // Swap ALL players: event becomes opp, opp becomes event
    S.curr.players.forEach(p => {
      if (p.role?.startsWith('event')) {
        p.role = p.role.replace('event', 'opp');
      } else if (p.role?.startsWith('opp')) {
        p.role = p.role.replace('opp', 'event');
      }
    });
    
    // Swap event team
    const newTeam = S.evtTeam === 'home' ? 'away' : 'home';
    setEvtTeam(newTeam);
    
    renumberPlayers();
    renderQuickAdd();
    renderMarkers();
    toast(`Swapped Event‚ÜîOpp (now ${S.homeTeam || 'Home'} is ${newTeam === 'home' ? 'Event' : 'Opp'})`, 'success');
  }
}

function selectPlayer(num) {
  S.selectedPlayer = S.curr.players.find(p => p.num === num) || null;
  if (S.selectedPlayer && S.xyMode !== 'player') setXYMode('player');
  renderQuickAdd(); renderXYSlots();
}

function updatePlayerDetail(field, val) {
  if (!S.selectedPlayer) return;
  S.selectedPlayer[field] = val;
  renderQuickAdd();
}

// ============================================================
// XY HANDLING
// ============================================================
function setXYMode(mode) {
  S.xyMode = mode;
  document.getElementById('puckModeBtn').classList.toggle('active', mode === 'puck');
  document.getElementById('playerModeBtn').classList.toggle('active', mode === 'player');
  document.getElementById('modeInd').textContent = mode === 'puck' ? 'üèí PUCK' : 'üë§ PLAYER';
  document.getElementById('modeInd').className = 'mode-ind ' + mode;
  S.xySlot = 1;
  renderXYSlots(); renderQuickAdd();
}

function setXYSlot(n) {
  S.xySlot = n;
  renderXYSlots();
}

function selectXYPlayer(num) {
  if (!num || num === '') {
    // User selected puck option - switch to puck mode
    S.selectedPlayer = null;
    setXYMode('puck');
    S.xySlot = (S.curr.puckXY?.filter(Boolean).length || 0) + 1;
    if (S.xySlot > 6) S.xySlot = 1;
    renderXYSlots(); renderQuickAdd();
    return;
  }
  
  S.selectedPlayer = S.curr.players.find(p => p.num == num) || null;
  
  if (S.selectedPlayer) {
    // Only switch to player mode if we actually found the player
    setXYMode('player');
    // v23.9: Always start at slot 1 when selecting a player for XY editing
    S.xySlot = 1;
    toast(`#${num} selected - click rink to place (slot 1)`, 'info');
  } else {
    S.xySlot = 1;
  }
  
  renderXYSlots(); renderQuickAdd();
}

/**
 * Cycle through players in XY dropdown (next or previous)
 * @param {number} direction - 1 for next, -1 for previous
 */
function cycleXYPlayer(direction) {
  if (S.curr.players.length === 0) return;
  
  const currentIdx = S.selectedPlayer 
    ? S.curr.players.findIndex(p => p.num === S.selectedPlayer.num)
    : -1;
  
  let nextIdx;
  if (currentIdx === -1) {
    // No player selected - start at first or last
    nextIdx = direction > 0 ? 0 : S.curr.players.length - 1;
  } else {
    // Cycle through players
    nextIdx = currentIdx + direction;
    if (nextIdx < 0) nextIdx = S.curr.players.length - 1;
    if (nextIdx >= S.curr.players.length) nextIdx = 0;
  }
  
  const nextPlayer = S.curr.players[nextIdx];
  if (nextPlayer) {
    selectXYPlayer(nextPlayer.num);
  }
}

// ============================================================
// v23.4: DRAG FOR PASSES/SHOTS
// ============================================================
let dragStartXY = null;
let isDragging = false;

function handleRinkMouseDown(event) {
  const svg = document.getElementById('rinkSvg');
  const pt = svg.createSVGPoint();
  pt.x = event.clientX; pt.y = event.clientY;
  const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
  
  const relX = Math.round((svgPt.x - 100) * 100) / 100;
  const relY = Math.round((svgPt.y - 42.5) * 100) / 100;
  
  dragStartXY = { x: relX, y: relY, svgX: svgPt.x, svgY: svgPt.y };
  isDragging = false;
}

function handleRinkMouseMove(event) {
  if (!dragStartXY) return;
  
  const svg = document.getElementById('rinkSvg');
  const pt = svg.createSVGPoint();
  pt.x = event.clientX; pt.y = event.clientY;
  const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
  
  const dist = Math.sqrt(Math.pow(svgPt.x - dragStartXY.svgX, 2) + Math.pow(svgPt.y - dragStartXY.svgY, 2));
  
  // If moved more than 10px, we're dragging
  if (dist > 10) {
    isDragging = true;
    // Show drag preview line
    showDragPreview(dragStartXY, svgPt);
  }
}

function handleRinkMouseUp(event) {
  if (!dragStartXY) return;
  
  const svg = document.getElementById('rinkSvg');
  const pt = svg.createSVGPoint();
  pt.x = event.clientX; pt.y = event.clientY;
  const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
  
  const relX = Math.round((svgPt.x - 100) * 100) / 100;
  const relY = Math.round((svgPt.y - 42.5) * 100) / 100;
  
  hideDragPreview();
  
  if (isDragging) {
    // Handle drag as pass or shot
    handleDragEvent(dragStartXY, { x: relX, y: relY, svgX: svgPt.x, svgY: svgPt.y });
  } else {
    // Regular click - use existing handler
    handleRinkClickInternal(event, dragStartXY.x, dragStartXY.y, dragStartXY.svgX, dragStartXY.svgY);
  }
  
  dragStartXY = null;
  isDragging = false;
}

/**
 * Show drag preview line on rink
 */
function showDragPreview(start, end) {
  let preview = document.getElementById('dragPreviewLine');
  if (!preview) {
    const svg = document.getElementById('rinkSvg');
    preview = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    preview.id = 'dragPreviewLine';
    preview.setAttribute('stroke', '#00d4aa');
    preview.setAttribute('stroke-width', '2');
    preview.setAttribute('stroke-dasharray', '5,5');
    preview.setAttribute('pointer-events', 'none');
    svg.appendChild(preview);
  }
  preview.setAttribute('x1', start.svgX);
  preview.setAttribute('y1', start.svgY);
  preview.setAttribute('x2', end.x);
  preview.setAttribute('y2', end.y);
  preview.style.display = 'block';
}

function hideDragPreview() {
  const preview = document.getElementById('dragPreviewLine');
  if (preview) preview.style.display = 'none';
}

/**
 * Handle drag as pass or shot based on direction and end location
 */
function handleDragEvent(start, end) {
  // Determine if drag ends near net (shot) or not (pass)
  const isTowardNet = end.svgX > 170 || end.svgX < 30; // Near either net
  const zone = getZoneFromClick(start.svgX);
  
  // Set puck XY to start and end points
  S.curr.puckXY = [
    { x: start.x, y: start.y, seq: 1 },
    { x: end.x, y: end.y, seq: 2 }
  ];
  
  if (isTowardNet && zone === 'o') {
    // Shot toward net
    if (!S.curr.type) setEvtType('Shot');
    document.getElementById('evtZone').value = 'o';
    
    // Set net location if we have it
    if (end.svgX > 170) {
      S.curr.netXY = { x: end.x, y: end.y };
    }
    
    // Auto-link: E1 at start (shooter position)
    const e1 = S.curr.players.find(p => p.role === 'event_team_player_1');
    if (e1) e1.xy = [{ x: start.x, y: start.y, seq: 1 }];
    
    toast('Shot created from drag', 'success');
  } else {
    // Pass
    if (!S.curr.type) setEvtType('Pass');
    document.getElementById('evtZone').value = zone || 'n';
    
    // Auto-link: E1 at start (passer), E2 at end (receiver)
    const e1 = S.curr.players.find(p => p.role === 'event_team_player_1');
    const e2 = S.curr.players.find(p => p.role === 'event_team_player_2');
    if (e1) e1.xy = [{ x: start.x, y: start.y, seq: 1 }];
    if (e2) e2.xy = [{ x: end.x, y: end.y, seq: 1 }];
    
    toast('Pass created from drag', 'success');
  }
  
  S.xySlot = 3;
  renderXYSlots(); renderMarkers(); updateZoneDisplay(); renderQuickAdd();
}

// ============================================================
// v23.4: KEYBOARD MODIFIERS FOR XY PLACEMENT
// ============================================================
let xyKeyModifier = null; // null, 1, 2, 3... for which player

document.addEventListener('keydown', (e) => {
  // Number keys 1-6 while on rink = assign to that player slot
  if (e.key >= '1' && e.key <= '6' && !e.ctrlKey && !e.altKey) {
    const activeEl = document.activeElement;
    if (activeEl.tagName !== 'INPUT' && activeEl.tagName !== 'SELECT' && activeEl.tagName !== 'TEXTAREA') {
      xyKeyModifier = parseInt(e.key);
    }
  }
});

document.addEventListener('keyup', (e) => {
  if (e.key >= '1' && e.key <= '6') {
    xyKeyModifier = null;
  }
});

function handleRinkClick(event) {
  // Delegate to mousedown/up for drag support
  // This is now called internally after drag detection
}

function handleRinkClickInternal(event, relX, relY, svgX, svgY) {
  const xy = { x: relX, y: relY, seq: S.xySlot };
  
  // v23.4: Keyboard modifier - hold number key to place specific player
  if (xyKeyModifier && S.curr.players.length >= xyKeyModifier) {
    const player = S.curr.players[xyKeyModifier - 1];
    if (player) {
      player.xy = player.xy || [];
      player.xy.push(xy);
      toast(`Placed #${player.num} (key ${xyKeyModifier})`, 'info');
      renderXYSlots(); renderMarkers(); renderQuickAdd();
      return;
    }
  }
  
  // v23.3: Shot chart mode - create shot at click location
  if (shotChartModeActive) {
    if (handleShotChartClick(svgX, svgY, relX, relY)) return;
  }
  
  // v23.3: Batch placement mode
  if (batchPlacementPlayers.length > 0) {
    if (placeBatchPlayers(relX, relY)) return;
  }
  
  // v23.3: Detect faceoff dot clicks - auto-assign E1 and O1 positions
  const faceoffDot = detectFaceoffDot(svgX, svgY);
  if (faceoffDot && S.curr.type === 'Faceoff') {
    handleFaceoffDotClick(faceoffDot, relX, relY);
    return;
  }
  
  // v23.4: One-click event creation - if no type, suggest based on zone
  if (!S.curr.type) {
    const zone = getZoneFromClick(svgX);
    handleZoneClickNoType(zone, relX, relY);
    return;
  }
  
  // v23.3: Auto-set zone from click position (if zone not already set)
  if (!document.getElementById('evtZone').value) {
    const zone = getZoneFromClick(svgX);
    if (zone) {
      document.getElementById('evtZone').value = zone;
      setZone(zone);
    }
  }
  
  // v23.3: Smart first click - if player mode but no players, place puck first
  if (S.xyMode === 'player' && S.curr.players.length === 0) {
    S.curr.puckXY[0] = xy;
    S.xySlot = 2;
    setXYMode('puck');
    renderXYSlots(); renderMarkers(); updateZoneDisplay();
    toast('Placed puck (add players next)', 'info');
    return;
  }
  
  // Store for undo
  S.xyHistory.push({ mode: S.xyMode, player: S.selectedPlayer?.num, slot: S.xySlot, prev: null });
  
  if (S.xyMode === 'puck') {
    const d2 = document.getElementById('evtD2');
    const isPossession = d2 && (LISTS.possessionEvents.includes(S.curr.type) || LISTS.possessionDetails.includes(d2.value));
    
    if (!S.curr.puckXY) S.curr.puckXY = [];
    S.curr.puckXY[S.xySlot - 1] = xy;
    
    // v23.4: Smart XY auto-linking based on event type
    if (typeof smartAutoLinkXY === 'function') {
      smartAutoLinkXY(xy, S.xySlot);
    }
    
    // v23.8: Auto-suggest zone from puck XY if not already set
    const evtZoneEl = document.getElementById('evtZone');
    if (autoZoneEnabled && evtZoneEl && !evtZoneEl.value) {
      autoSetZoneFromXY(relX);
    }
    
    S.xySlot = Math.min(S.xySlot + 1, 10);
  } else if (S.xyMode === 'player') {
    if (!S.selectedPlayer) {
      if (!S.curr.puckXY) S.curr.puckXY = [];
      S.curr.puckXY[S.xySlot - 1] = xy;
      S.xySlot = Math.min(S.xySlot + 1, 10);
      toast('No player selected - placed puck instead', 'info');
      
      // v23.8: Auto-suggest zone from puck XY if not already set
      const evtZoneEl2 = document.getElementById('evtZone');
      if (autoZoneEnabled && evtZoneEl2 && !evtZoneEl2.value) {
        autoSetZoneFromXY(relX);
      }
    } else {
      if (!S.selectedPlayer.xy) S.selectedPlayer.xy = [];
      S.selectedPlayer.xy[S.xySlot - 1] = xy;
      S.xySlot = Math.min(S.xySlot + 1, 10);
      
      // v23.8: Auto-suggest zone from player XY if not already set
      const evtZoneEl3 = document.getElementById('evtZone');
      if (autoZoneEnabled && evtZoneEl3 && !evtZoneEl3.value) {
        autoSetZoneFromXY(relX);
      }
    }
  }
  
  renderXYSlots(); renderMarkers(); updateZoneDisplay(); 
  
  // v23.8: Auto-detect all settings when XY is placed
  autoDetectAllPressure();
  autoDetectAllSideOfPuck();
  
  renderQuickAdd();
}

/**
 * v23.4: Smart auto-link XY based on event type
 */
function smartAutoLinkXY(xy, slot) {
  const type = S.curr.type;
  const e1 = S.curr.players.find(p => p.role === 'event_team_player_1');
  const e2 = S.curr.players.find(p => p.role === 'event_team_player_2');
  const o1 = S.curr.players.find(p => p.role === 'opp_team_player_1');
  
  switch(type) {
    case 'Shot':
      // Slot 1 = shooter position (E1)
      if (slot === 1 && e1) {
        e1.xy = e1.xy || [];
        e1.xy[0] = {...xy};
      }
      break;
      
    case 'Pass':
      // Slot 1 = passer (E1), Slot 2 = receiver (E2)
      if (slot === 1 && e1) {
        e1.xy = e1.xy || [];
        e1.xy[0] = {...xy};
      } else if (slot === 2 && e2) {
        e2.xy = e2.xy || [];
        e2.xy[0] = {...xy};
      }
      break;
      
    case 'Hit':
    case 'Battle':
      // Both players at puck location
      if (slot === 1) {
        if (e1) { e1.xy = e1.xy || []; e1.xy[0] = {...xy}; }
        if (o1) { o1.xy = o1.xy || []; o1.xy[0] = {...xy}; }
      }
      break;
      
    case 'Possession':
    case 'Turnover':
      // E1 at puck
      if (slot === 1 && e1) {
        e1.xy = e1.xy || [];
        e1.xy[0] = {...xy};
      }
      break;
      
    case 'Zone_Entry_Exit':
      // E1 carries puck
      if (slot === 1 && e1) {
        e1.xy = e1.xy || [];
        e1.xy[0] = {...xy};
      }
      break;
  }
}

/**
 * v23.4: Handle zone click when no event type selected - suggest event
 */
function handleZoneClickNoType(zone, relX, relY) {
  const xy = { x: relX, y: relY, seq: 1 };
  
  // Show zone-based suggestions
  let suggestedType = 'Possession';
  let detail1 = '';
  
  if (zone === 'o') {
    // Offensive zone - likely shot or cycle
    suggestedType = 'Shot';
    detail1 = 'Shot_OnNet';
  } else if (zone === 'd') {
    // Defensive zone - likely possession/breakout
    suggestedType = 'Possession';
    detail1 = 'Possession_Breakout';
  } else {
    // Neutral zone - likely zone entry
    suggestedType = 'Zone_Entry_Exit';
    detail1 = 'Zone_Entry';
  }
  
  // Set it up
  setEvtType(suggestedType);
  setTimeout(() => {
    document.getElementById('evtD1').value = detail1;
    document.getElementById('evtZone').value = zone;
    setZone(zone);
    
    // Place puck
    S.curr.puckXY[0] = xy;
    S.xySlot = 2;
    
    renderXYSlots(); renderMarkers(); updateZoneDisplay(); renderQuickAdd();
    toast(`${zone === 'o' ? 'Offensive' : zone === 'd' ? 'Defensive' : 'Neutral'} zone ‚Üí ${suggestedType}`, 'info');
  }, 50);
}

/**
 * v23.3: Detect if click is on a faceoff dot
 * Returns dot info or null
 */
function detectFaceoffDot(svgX, svgY) {
  // Faceoff dot positions in SVG coordinates (200x85 rink)
  // Center ice: (100, 42.5)
  // Zone circles: approximately at (31, 22), (31, 63), (169, 22), (169, 63)
  // Neutral zone dots: (80, 22), (80, 63), (120, 22), (120, 63)
  
  const dots = [
    { name: 'center', svgX: 100, svgY: 42.5, relX: 0, relY: 0, zone: 'n' },
    { name: 'left_top', svgX: 31, svgY: 22, relX: -69, relY: -20.5, zone: 'left' },
    { name: 'left_bot', svgX: 31, svgY: 63, relX: -69, relY: 20.5, zone: 'left' },
    { name: 'right_top', svgX: 169, svgY: 22, relX: 69, relY: -20.5, zone: 'right' },
    { name: 'right_bot', svgX: 169, svgY: 63, relX: 69, relY: 20.5, zone: 'right' },
    { name: 'neut_left_top', svgX: 80, svgY: 22, relX: -20, relY: -20.5, zone: 'n' },
    { name: 'neut_left_bot', svgX: 80, svgY: 63, relX: -20, relY: 20.5, zone: 'n' },
    { name: 'neut_right_top', svgX: 120, svgY: 22, relX: 20, relY: -20.5, zone: 'n' },
    { name: 'neut_right_bot', svgX: 120, svgY: 63, relX: 20, relY: 20.5, zone: 'n' },
  ];
  
  const RADIUS = 8; // Click tolerance radius
  
  for (const dot of dots) {
    const dist = Math.sqrt(Math.pow(svgX - dot.svgX, 2) + Math.pow(svgY - dot.svgY, 2));
    if (dist <= RADIUS) {
      return dot;
    }
  }
  
  return null;
}

/**
 * v23.3: Handle faceoff dot click - auto-assign positions
 */
function handleFaceoffDotClick(dot, relX, relY) {
  // Set puck position at the dot
  S.curr.puckXY = [{ x: dot.relX, y: dot.relY, seq: 1 }];
  
  // Find E1 and O1
  const e1 = S.curr.players.find(p => p.role === 'event_team_player_1');
  const o1 = S.curr.players.find(p => p.role === 'opp_team_player_1');
  
  // Set E1 and O1 positions at the dot
  if (e1) {
    e1.xy = [{ x: dot.relX, y: dot.relY, seq: 1 }];
  }
  if (o1) {
    o1.xy = [{ x: dot.relX, y: dot.relY, seq: 1 }];
  }
  
  // Set zone based on dot location
  let zone = 'n';
  if (dot.zone === 'left' || dot.zone === 'right') {
    zone = getZoneFromClick(dot.svgX);
  }
  document.getElementById('evtZone').value = zone;
  
  // Update zone display
  const zoneName = zone === 'o' ? 'Offensive' : zone === 'd' ? 'Defensive' : 'Neutral';
  document.getElementById('zoneDisplay').innerHTML = `<span style="background:${zone === 'o' ? 'var(--success)' : zone === 'd' ? 'var(--danger)' : 'var(--muted)'};color:#fff;padding:1px 6px;border-radius:3px;font-size:9px;">${zoneName.toUpperCase()}</span>`;
  
  renderXYSlots();
  renderMarkers();
  
  const playersSet = [e1 ? 'E1' : '', o1 ? 'O1' : ''].filter(Boolean).join(', ');
  toast(`Faceoff at ${dot.name.replace('_', ' ')}: Puck${playersSet ? ' + ' + playersSet : ''} positioned`, 'success');
}

/**
 * v23.3: Get zone from rink X position
 */
function getZoneFromClick(svgX) {
  // svgX is 0-200, blue lines at 75 and 125
  const period = S.period || 1;
  const isOddPeriod = period === 1 || period === 3 || period === 'OT';
  const homeOffensiveRight = isOddPeriod ? S.homeAttacksRightP1 : !S.homeAttacksRightP1;
  
  let rawZone = '';
  if (svgX < 75) rawZone = 'left';
  else if (svgX > 125) rawZone = 'right';
  else rawZone = 'neutral';
  
  if (rawZone === 'neutral') return 'n';
  
  // Convert to offensive/defensive based on event team
  if (S.evtTeam === 'home') {
    if (homeOffensiveRight) {
      return rawZone === 'right' ? 'o' : 'd';
    } else {
      return rawZone === 'left' ? 'o' : 'd';
    }
  } else {
    if (homeOffensiveRight) {
      return rawZone === 'left' ? 'o' : 'd';
    } else {
      return rawZone === 'right' ? 'o' : 'd';
    }
  }
}

function undoLastXY() {
  if (!S.xyHistory.length) return;
  const last = S.xyHistory.pop();
  
  if (last.mode === 'puck') {
    S.curr.puckXY.pop();
    S.xySlot = Math.max(1, S.curr.puckXY.length + 1);
  } else if (last.player) {
    const p = S.curr.players.find(p => p.num === last.player);
    if (p) {
      p.xy.pop();
      S.xySlot = Math.max(1, p.xy.length + 1);
    }
  }
  
  renderXYSlots(); renderMarkers();
  toast('Undo XY', 'success');
}

function clearCurrentXY() {
  if (S.xyMode === 'puck') S.curr.puckXY = [];
  else if (S.selectedPlayer) S.selectedPlayer.xy = [];
  S.xySlot = 1;
  renderXYSlots(); renderMarkers();
}

function clearRink() {
  // v23.8: Clear all XY data from rink
  S.xyHistory = [];
  
  // Clear current event XY
  if (S.curr) {
    if (S.curr.puckXY) S.curr.puckXY = [];
    if (S.curr.players) {
      S.curr.players.forEach(p => {
        if (p.xy) p.xy = [];
      });
    }
  }
  
  // Reset XY slot
  S.xySlot = 1;
  
  // Clear zone if it was auto-set
  const evtZoneEl = document.getElementById('evtZone');
  if (evtZoneEl && evtZoneEl.value) {
    const zoneBtn = document.querySelector(`.zone-btn[data-zone="${evtZoneEl.value}"]`);
    if (zoneBtn) zoneBtn.classList.remove('active');
    evtZoneEl.value = '';
  }
  
  renderXYSlots();
  renderMarkers();
  if (typeof updateZoneDisplay === 'function') updateZoneDisplay();
  toast('Rink cleared', 'success');
}

/**
 * Handle mouse hover over rink for XY tooltips (v5)
 * Shows coordinates on hover, and player info when hovering markers
 */
function handleRinkHover(event) {
  const svg = document.getElementById('rinkSvg');
  const tooltip = document.getElementById('xyTooltip');
  if (!svg || !tooltip) return;
  
  const rect = svg.getBoundingClientRect();
  const pt = svg.createSVGPoint();
  pt.x = event.clientX; pt.y = event.clientY;
  const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
  
  // v16.06: Show center-relative coordinates
  const x = Math.round((svgPt.x - 100) * 10) / 10;
  const y = Math.round((svgPt.y - 42.5) * 10) / 10;
  
  // Check if hovering over a marker
  const target = event.target;
  let tooltipContent = `(${x}, ${y})`;
  
  if (target && target.dataset && target.dataset.type) {
    const type = target.dataset.type;
    const markerX = target.dataset.x || '--';
    const markerY = target.dataset.y || '--';
    
    if (type === 'puck') {
      tooltipContent = `üèí Puck (${markerX}, ${markerY})`;
    } else if (type === 'player') {
      const num = target.dataset.num || '?';
      const name = target.dataset.name || '';
      tooltipContent = `#${num} ${name}\n(${markerX}, ${markerY})`;
    } else if (type === 'history') {
      const evtNum = target.dataset.evtnum || '?';
      const evtType = target.dataset.evttype || '';
      tooltipContent = `Event #${evtNum} - ${evtType}\n(${markerX}, ${markerY})`;
    }
  }
  
  // Position tooltip at cursor
  tooltip.textContent = tooltipContent;
  tooltip.style.display = 'block';
  tooltip.style.left = (event.clientX - rect.left) + 'px';
  tooltip.style.top = (event.clientY - rect.top) + 'px';
}

/**
 * Hide XY tooltip (v5)
 */
function hideXYTooltip() {
  const tooltip = document.getElementById('xyTooltip');
  if (tooltip) tooltip.style.display = 'none';
}

// ============================================================
// NET LOCATION
// ============================================================
function handleNetClick(event) {
  const svg = document.getElementById('netSvg');
  const rect = svg.getBoundingClientRect();
  const x = ((event.clientX - rect.left) / rect.width) * 72;
  const y = ((event.clientY - rect.top) / rect.height) * 48;
  
  S.curr.netXY = { x: Math.round(x * 10) / 10, y: Math.round(y * 10) / 10 };
  
  const marker = document.getElementById('netMarker');
  marker.innerHTML = `<circle cx="${S.curr.netXY.x}" cy="${S.curr.netXY.y}" r="4" fill="#00d4aa" stroke="#fff" stroke-width="1"/>`;
}

function clearNetXY() {
  S.curr.netXY = null;
  document.getElementById('netMarker').innerHTML = '';
}

function closeNetModal() {
  document.getElementById('netModal').classList.remove('show');
}

// ============================================================
// LOG EVENT
// ============================================================
function logEvent() {
  if (!S.curr.type) { toast('Select event type', 'error'); return; }
  
  // v23.3: Check if user wants to skip confirmation
  if (document.getElementById('skipConfirm')?.checked) {
    logEventDirect();
    return;
  }
  
  // Show confirmation modal
  showConfirmModal();
}

/**
 * v23.3: Log event directly without confirmation modal
 */
function logEventDirect() {
  if (!S.curr.type) { toast('Select event type', 'error'); return; }
  
  // Get values directly from the main form
  const startTime = document.getElementById('evtStartTime').value || document.getElementById('clock').value;
  const endTime = document.getElementById('evtEndTime').value || startTime;
  const zone = document.getElementById('evtZone').value || calculateZone();
  const success = document.getElementById('evtSuccess').value || deriveSuccess();
  const strength = document.getElementById('evtStrength').value || deriveStrength();
  const isHighlight = document.getElementById('isHighlight').checked;
  const videoUrl = isHighlight ? (document.getElementById('evtVideoUrl').value.trim() || '') : '';

  // v23.8: Auto-detect all settings before logging
  autoDetectAllPressure();
  autoDetectAllSuccess();
  autoDetectAllSideOfPuck();
  
  // For Possession and Zone_Entry_Exit, copy player XY to puck
  const detail1 = document.getElementById('evtD1').value || '';
  const detail2 = document.getElementById('evtD2').value || '';
  const isPossessionEvent = S.curr.type === 'Possession' || 
    (S.curr.type === 'Zone_Entry_Exit' && (detail2.includes('Rush') || detail1.includes('Entry')));
  
  if (isPossessionEvent && S.curr.puckXY.length === 0) {
    const evtPlayer1 = S.curr.players.find(p => 
      p.role === 'event_team_player_1' || p.role === 'event_player_1' || p.roleNum === 1
    );
    if (evtPlayer1?.xy?.length > 0) {
      S.curr.puckXY = evtPlayer1.xy.map(xy => ({...xy}));
    }
  }
  
  // Build linked event chain
  let linkedEventChain = [];
  if (S.linkedEventIdx !== null) {
    linkedEventChain.push(S.linkedEventIdx);
    const linkedEvt = S.events.find(e => e.idx === S.linkedEventIdx);
    if (linkedEvt?.linkedEventChain?.length) {
      linkedEventChain = [...linkedEvt.linkedEventChain, S.linkedEventIdx];
    }
  }
  
  // v23.9: Ensure detail1 and detail2 are always populated (use type as fallback)
  const finalDetail1 = detail1 || S.curr.type || '';
  const finalDetail2 = detail2 || '';
  
  // Get codes and IDs for export (display uses names)
  const typeInfo = getEventTypeCodeAndId(S.curr.type);
  const detail1Info = getEventDetailCodeAndId(finalDetail1, S.curr.type);
  const detail2Info = getEventDetail2CodeAndId(finalDetail2);
  
  // Calculate adjusted video time (go back up to 10 seconds, or to nearest faceoff)
  const adjustedVideoTime = calculateAdjustedVideoTime(S.period, startTime, S.curr.type);
  
  const evt = {
    idx: S.evtIdx++,
    game_id: S.gameId,
    period: S.period,
    start_time: startTime,
    end_time: endTime,
    team: S.evtTeam,
    type: S.curr.type,  // Display name
    typeCode: typeInfo.code,  // Export code
    typeId: typeInfo.id,  // Export ID
    detail1: finalDetail1,  // Display name
    detail1Code: detail1Info.code,  // Export code
    detail1Id: detail1Info.id,  // Export ID
    detail2: finalDetail2,  // Display name
    detail2Code: detail2Info.code,  // Export code
    detail2Id: detail2Info.id,  // Export ID
    zone,
    success,
    strength,
    linkedEventIdx: S.linkedEventIdx,
    linkedEventChain,
    isHighlight,
    videoUrl: isHighlight ? videoUrl : undefined,  // v23.7: Individual highlight video URL
    adjustedVideoTime: adjustedVideoTime,  // Adjusted time for video playback
    puckXY: [...S.curr.puckXY],
    netXY: S.curr.netXY,
    players: S.curr.players.map(p => ({...p, xy: [...(p.xy || [])]}))
  };
  
  S.events.push(evt);
  
  // v23.4: Auto-sort and reindex events by time
  sortAndReindexEvents();
  
  // v23.8: Auto-detect assists for Goals
  if (evt.type === 'Goal') {
    detectAndLinkAssists(evt);
  }
  
  // v23.8: Determine end time (use start time if no end time)
  const actualEndTime = endTime || startTime;
  S.lastEndTime = actualEndTime;
  
  // v23.8: Auto-increment next event start time by 1 second (only if no linked event)
  let nextStartTime = actualEndTime;
  if (S.linkedEventIdx === null) {
    // Hockey clock counts down, so subtract 1 second (going forward in time = less time on clock)
    nextStartTime = incrementTimeBySeconds(actualEndTime, -1);
  }
  
  S.linkedEventIdx = null;
  
  const highlightIcon = isHighlight ? ' ‚≠ê' : '';
  toast(`Event #${evt.idx + 1}: ${evt.type}${highlightIcon}`, 'success');
  
  clearEvent();
  document.getElementById('evtStartTime').value = nextStartTime;
  
  renderEvents(); renderMarkers(); updateScores(); updateBoxScore();
  updateNextPlaySuggestions();
  autoSave();
  
  if (document.getElementById('autoEditNext')?.checked) {
    setTimeout(() => editEvent(S.events.length - 1), 100);
  }
}

/**
 * v23.8: Process all goals to detect and link assists
 * Called after loading games from Supabase, Excel, or localStorage
 */
function processAllGoalsForAssists() {
  if (!S.events || S.events.length === 0) return;
  
  // Sort events first to ensure proper ordering
  sortAndReindexEvents();
  
  const goals = S.events.filter(e => e.type === 'Goal');
  if (goals.length === 0) return;
  
  let totalProcessed = 0;
  let totalAutoLinked = 0;
  
  goals.forEach(goal => {
    const result = detectAndLinkAssists(goal, true); // true = silent mode (no prompts)
    if (result) {
      totalProcessed++;
      totalAutoLinked += (result.autoLinked || 0);
    }
  });
  
  if (totalAutoLinked > 0) {
    renderEvents();
    autoSave();
    toast(`Auto-linked ${totalAutoLinked} assist(s) for ${totalProcessed} goal(s)`, 'success');
  } else if (totalProcessed > 0) {
    // Still show message if we processed goals but found no assists to link
    console.log(`Processed ${totalProcessed} goal(s) for assist detection`);
  }
}

/**
 * v23.8: Auto-detect and link assists for Goals
 * Finds recent Pass events and either auto-links them (if already marked as assists)
 * or prompts user to mark them as assists
 * @param {Object} goalEvent - The goal event to process
 * @param {boolean} silent - If true, don't show prompts (for batch processing)
 * @returns {Object|null} - Result object with autoLinked count, or null
 */
function detectAndLinkAssists(goalEvent, silent = false) {
  if (!goalEvent || goalEvent.type !== 'Goal') return { autoLinked: 0, needsManualReview: false };
  
  const parseTime = (t) => {
    if (!t) return 0;
    const [min, sec] = t.split(':').map(Number);
    return (min || 0) * 60 + (sec || 0);
  };
  
  const goalTime = parseTime(goalEvent.start_time);
  const goalPeriod = goalEvent.period;
  const goalTeam = goalEvent.team;
  
  // Find recent Pass events (within 15 seconds before goal, same period, same team)
  // v23.8: Increased window to 15 seconds to capture secondary assists
  // Note: After sortAndReindexEvents(), goalEvent.idx may have changed, so we use object reference
  const goalEventIdx = goalEvent.idx; // Store before filtering
  const recentPasses = S.events
    .filter(e => {
      if (e.type !== 'Pass') return false;
      if (e.period !== goalPeriod) return false;
      if (e.team !== goalTeam) return false;
      if (e === goalEvent) return false; // Don't include the goal itself
      if (e.idx >= goalEventIdx) return false; // Must be before goal (by index)
      if (e.assistToGoalIdx !== null && e.assistToGoalIdx !== undefined) return false; // Already linked to a goal
      
      const passTime = parseTime(e.start_time);
      const timeDiff = goalTime - passTime;
      return timeDiff >= 0 && timeDiff <= 15; // Within 15 seconds (increased from 10 to capture secondary assists)
    })
    .sort((a, b) => parseTime(b.start_time) - parseTime(a.start_time)); // Most recent first
  
  if (recentPasses.length === 0) return { autoLinked: 0, needsManualReview: false };
  
  // Separate passes that already have assist markers vs those that don't
  const passesWithAssist = [];
  const passesWithoutAssist = [];
  
  recentPasses.forEach(pass => {
    const hasAssist = pass.players?.some(p => {
      const pd1 = (p.playD1 || '').toLowerCase();
      const pd2 = (p.playD2 || '').toLowerCase();
      return pd1.includes('assist') || pd2.includes('assist');
    });
    
    if (hasAssist) {
      passesWithAssist.push(pass);
    } else {
      passesWithoutAssist.push(pass);
    }
  });
  
  // Auto-link passes that already have assist markers
  if (passesWithAssist.length > 0) {
    // Re-find goalEvent after sorting (idx may have changed)
    const currentGoalEvent = S.events.find(e => e === goalEvent);
    if (currentGoalEvent) {
      passesWithAssist.forEach(pass => {
        // v23.8: Use assistToGoalIdx instead of linkedEventIdx for assists
        if (pass.assistToGoalIdx === null || pass.assistToGoalIdx === undefined) {
          pass.assistToGoalIdx = currentGoalEvent.idx;
        }
      });
      autoSave();
      toast(`Auto-linked ${passesWithAssist.length} assist(s) to goal`, 'success');
    }
  }
  
  // Show prompt for passes without assist markers (only if not in silent mode)
  if (passesWithoutAssist.length > 0 && !silent) {
    showAssistPromptModal(goalEvent, passesWithoutAssist);
  }
  
  // Return result for batch processing
  return {
    autoLinked: passesWithAssist.length,
    needsManualReview: passesWithoutAssist.length > 0 && !silent
  };
}

/**
 * v23.8: Show modal to mark recent passes as assists
 */
function showAssistPromptModal(goalEvent, passes) {
  // Create modal dynamically
  const modal = document.createElement('div');
  modal.className = 'overlay show';
  modal.id = 'assistPromptModal';
  modal.innerHTML = `
    <div class="modal" style="min-width:400px;max-width:600px;">
      <h3>üéØ Mark Assists for Goal #${goalEvent.idx + 1}</h3>
      <p style="font-size:10px;color:var(--muted);margin-bottom:12px;">
        Found ${passes.length} recent pass(es). Mark as assists?
      </p>
      <div id="assistPassesList" style="max-height:300px;overflow-y:auto;margin-bottom:12px;"></div>
      <div class="modal-actions">
        <button class="btn-primary" onclick="saveAssistSelections()">üíæ Save Assists</button>
        <button onclick="closeAssistPromptModal()">Skip</button>
      </div>
    </div>
  `;
  document.body.appendChild(modal);
  
  // Store in global for access
  window.currentAssistGoal = goalEvent;
  window.currentAssistPasses = passes;
  window.assistSelections = {}; // {passIdx: 'primary'|'secondary'|null}
  
  // Render pass list
  const list = document.getElementById('assistPassesList');
  list.innerHTML = passes.map((pass, i) => {
    const player = pass.players?.find(p => p.role === 'event_team_player_1' || p.role === 'event_player_1');
    const playerName = player ? `#${player.num} ${player.name}` : 'Unknown';
    const passTime = pass.start_time || '';
    
    return `
      <div style="background:var(--card);padding:8px;border-radius:4px;margin-bottom:6px;border-left:3px solid var(--accent);">
        <div style="font-size:10px;font-weight:600;margin-bottom:4px;">${playerName} @ ${passTime}</div>
        <div style="display:flex;gap:8px;align-items:center;">
          <button class="btn-sm ${window.assistSelections[pass.idx] === 'primary' ? 'active' : ''}" 
                  onclick="selectAssistType(${pass.idx}, 'primary')" 
                  style="flex:1;font-size:9px;">A1 (Primary)</button>
          <button class="btn-sm ${window.assistSelections[pass.idx] === 'secondary' ? 'active' : ''}" 
                  onclick="selectAssistType(${pass.idx}, 'secondary')" 
                  style="flex:1;font-size:9px;">A2 (Secondary)</button>
          <button class="btn-sm" onclick="selectAssistType(${pass.idx}, null)" 
                  style="flex:0.5;font-size:9px;background:var(--muted);">Skip</button>
        </div>
      </div>
    `;
  }).join('');
}

function selectAssistType(passIdx, type) {
  if (!window.assistSelections) window.assistSelections = {};
  window.assistSelections[passIdx] = type;
  
  // Update button states
  const buttons = document.querySelectorAll(`[onclick*="selectAssistType(${passIdx}"]`);
  buttons.forEach(btn => {
    if (btn.textContent.includes('A1') && type === 'primary') btn.classList.add('active');
    else if (btn.textContent.includes('A2') && type === 'secondary') btn.classList.add('active');
    else btn.classList.remove('active');
  });
}

function saveAssistSelections() {
  if (!window.currentAssistGoal || !window.currentAssistPasses || !window.assistSelections) return;
  
  // Re-find goalEvent after sorting (idx may have changed)
  const currentGoalEvent = S.events.find(e => e === window.currentAssistGoal);
  if (!currentGoalEvent) {
    toast('Goal event not found', 'error');
    closeAssistPromptModal();
    return;
  }
  
  let linked = 0;
  window.currentAssistPasses.forEach(pass => {
    const assistType = window.assistSelections[pass.idx];
    if (!assistType) return; // Skip if not selected
    
    // Find the pass event in S.events (use object reference)
    const passEvent = S.events.find(e => e === pass);
    if (!passEvent) return;
    
    // v23.8: Link assist to goal using assistToGoalIdx (separate from linkedEventIdx)
    passEvent.assistToGoalIdx = currentGoalEvent.idx;
    
    // Mark assist in play_detail1 for event_player_1
    const player1 = passEvent.players?.find(p => 
      p.role === 'event_team_player_1' || p.role === 'event_player_1'
    );
    if (player1) {
      if (assistType === 'primary') {
        player1.playD1 = 'AssistPrimary';
      } else if (assistType === 'secondary') {
        player1.playD1 = 'AssistSecondary';
      }
    }
    
    linked++;
  });
  
  if (linked > 0) {
    renderEvents();
    autoSave();
    toast(`Marked ${linked} assist(s) and linked to goal`, 'success');
  }
  
  closeAssistPromptModal();
}

function closeAssistPromptModal() {
  const modal = document.getElementById('assistPromptModal');
  if (modal) modal.remove();
  window.currentAssistGoal = null;
  window.currentAssistPasses = null;
  window.assistSelections = null;
}

/**
 * v23.8: Show modal to enter video URLs for imported goals
 */
function showGoalVideoUrlsModal(goals) {
  // Sort goals by period and time
  const sortedGoals = [...goals].sort((a, b) => {
    if (a.period !== b.period) return a.period - b.period;
    return a.start_time.localeCompare(b.start_time);
  });
  
  const scorer = (goal) => {
    const p = goal.players?.find(p => p.role === 'event_player_1');
    return p ? `#${p.num} ${p.name || ''}`.trim() : 'Unknown';
  };
  
  const html = `
    <div class="overlay show" id="goalVideoUrlsModal" style="z-index:10000;">
      <div class="modal" style="max-width:700px;max-height:85vh;overflow-y:auto;">
        <h3>‚≠ê Enter Video URLs for Goals</h3>
        <p style="font-size:10px;color:var(--muted);margin-bottom:12px;">
          ${sortedGoals.length} goal(s) were automatically marked as highlights. Enter YouTube URLs for each goal below.
        </p>
        
        <div style="max-height:60vh;overflow-y:auto;margin-bottom:12px;">
          ${sortedGoals.map((goal, idx) => {
            const goalId = `goalVideo_${goal.idx}`;
            const currentUrl = goal.videoUrl || '';
            return `
              <div style="background:var(--card);padding:10px;border-radius:4px;margin-bottom:8px;border-left:3px solid var(--${goal.team});">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
                  <div>
                    <strong style="font-size:11px;color:var(--${goal.team});">
                      P${goal.period} @ ${goal.start_time} - ${goal.team === 'home' ? (S.homeTeam || 'HOME') : (S.awayTeam || 'AWAY')}
                    </strong>
                    <div style="font-size:9px;color:var(--muted);margin-top:2px;">
                      ${scorer(goal)}
                    </div>
                  </div>
                  <span style="font-size:18px;">‚≠ê</span>
                </div>
                <div class="form-group" style="margin:0;">
                  <label style="font-size:9px;color:var(--muted);">YouTube URL:</label>
                  <input 
                    type="text" 
                    id="${goalId}" 
                    value="${currentUrl}"
                    placeholder="https://youtube.com/watch?v=..." 
                    style="width:100%;font-size:10px;padding:4px;"
                    onkeydown="if(event.key==='Enter') { event.preventDefault(); const next = document.querySelectorAll('#goalVideoUrlsModal input[type=text]')[${idx + 1}]; if(next) next.focus(); else saveGoalVideoUrls(); }"
                  >
                </div>
              </div>
            `;
          }).join('')}
        </div>
        
        <div style="background:rgba(59,130,246,0.1);padding:8px;border-radius:4px;margin-bottom:12px;font-size:9px;color:var(--muted);">
          üí° <strong>Tip:</strong> You can press Enter to move to the next goal. Leave blank to skip.
        </div>
        
        <div class="modal-actions">
          <button class="btn-primary" onclick="saveGoalVideoUrls()">üíæ Save Video URLs</button>
          <button onclick="skipGoalVideoUrls()">Skip</button>
        </div>
      </div>
    </div>
  `;
  
  // Remove existing modal if any
  const existing = document.getElementById('goalVideoUrlsModal');
  if (existing) existing.remove();
  
  // Add to body
  document.body.insertAdjacentHTML('beforeend', html);
  
  // Focus first input
  const firstInput = document.getElementById(`goalVideo_${sortedGoals[0].idx}`);
  if (firstInput) {
    setTimeout(() => firstInput.focus(), 100);
  }
}

function saveGoalVideoUrls() {
  const modal = document.getElementById('goalVideoUrlsModal');
  if (!modal) return;
  
  const inputs = modal.querySelectorAll('input[type="text"]');
  let saved = 0;
  
  inputs.forEach(input => {
    const goalIdx = parseInt(input.id.replace('goalVideo_', ''));
    const videoUrl = input.value.trim();
    
    const goal = S.events.find(e => e.idx === goalIdx);
    if (goal && goal.type === 'Goal') {
      if (videoUrl) {
        goal.videoUrl = videoUrl;
        saved++;
      } else {
        // If URL is cleared, remove it but keep highlight
        goal.videoUrl = undefined;
      }
    }
  });
  
  renderEvents();
  autoSave();
  
  if (saved > 0) {
    toast(`Saved ${saved} video URL(s) for goals`, 'success');
  }
  
  closeGoalVideoUrlsModal();
  
  // Open verification panel after saving
  setTimeout(() => {
    openVerifyModal();
  }, 300);
}

function skipGoalVideoUrls() {
  closeGoalVideoUrlsModal();
  
  // Open verification panel after skipping
  setTimeout(() => {
    openVerifyModal();
  }, 300);
}

function closeGoalVideoUrlsModal() {
  const modal = document.getElementById('goalVideoUrlsModal');
  if (modal) modal.remove();
}

/**
 * v23.3: Show confirmation modal before logging event
 */
function showConfirmModal() {
  const modal = document.getElementById('confirmEventModal');
  
  // Populate type dropdown with all event types
  const types = Object.keys(LISTS.details);
  document.getElementById('confirmType').innerHTML = types.map(t => 
    `<option value="${t}" ${t === S.curr.type ? 'selected' : ''}>${t}</option>`
  ).join('');
  
  // Team dropdown with team names
  const teamSel = document.getElementById('confirmTeam');
  teamSel.innerHTML = `<option value="home">${S.homeTeam || 'Home'}</option><option value="away">${S.awayTeam || 'Away'}</option>`;
  teamSel.value = S.evtTeam;
  
  // Populate D1 dropdown
  onConfirmTypeChange();
  document.getElementById('confirmD1').value = document.getElementById('evtD1').value || '';
  onConfirmD1Change();
  document.getElementById('confirmD2').value = document.getElementById('evtD2').value || '';
  
  // Other fields
  document.getElementById('confirmZone').value = document.getElementById('evtZone').value || calculateZone() || '';
  document.getElementById('confirmSuccess').value = document.getElementById('evtSuccess').value || deriveSuccess() || '';
  document.getElementById('confirmStrength').value = document.getElementById('evtStrength').value || deriveStrength() || '5v5';
  document.getElementById('confirmStartTime').value = document.getElementById('evtStartTime').value || document.getElementById('clock').value;
  document.getElementById('confirmEndTime').value = document.getElementById('evtEndTime').value || document.getElementById('evtStartTime').value || document.getElementById('clock').value;
  document.getElementById('confirmHighlight').checked = document.getElementById('isHighlight').checked;
  document.getElementById('confirmVideoUrl').value = document.getElementById('evtVideoUrl').value || '';
  toggleConfirmHighlightFields();
  document.getElementById('confirmLinked').value = S.linkedEventIdx !== null ? S.linkedEventIdx + 1 : '';
  
  // v23.9: Show players with editable details
  renderConfirmPlayers();
  
  modal.classList.add('show');
}

/**
 * v23.9: Render players in confirmation modal with editable details
 */
function renderConfirmPlayers() {
  const container = document.getElementById('confirmPlayers');
  if (!container) return;
  
  const evtPlayers = S.curr.players.filter(p => p.role?.startsWith('event') || (!p.role?.startsWith('opp') && p.role));
  const oppPlayers = S.curr.players.filter(p => p.role?.startsWith('opp'));
  
  let html = '';
  
  if (evtPlayers.length > 0) {
    html += '<div style="margin-bottom:8px;"><div style="font-size:9px;color:var(--accent);font-weight:bold;margin-bottom:4px;">Event Players:</div>';
    evtPlayers.forEach((p, idx) => {
      const pd1Display = p.playD1 || '--';
      const pd2Display = p.playD2 || '--';
      const successDisplay = p.playSuccess === 's' ? '‚úì' : (p.playSuccess === 'u' ? '‚úó' : '--');
      const pressureDisplay = p.pressure ? `#${p.pressure}` : '--';
      html += `<div style="display:grid;grid-template-columns:50px 1fr 1fr 60px 70px;gap:4px;padding:6px;background:var(--card);border-radius:3px;margin-bottom:3px;align-items:center;border-left:3px solid var(--accent);">
        <span style="font-weight:bold;color:var(--accent);font-size:11px;">#${p.num}</span>
        <select id="confirmPlayerPD1_${idx}" style="font-size:9px;padding:3px;" onchange="updateConfirmPlayerDetail(${idx}, 'playD1', this.value)" title="Play Detail 1">
          <option value="">PD1: ${pd1Display}</option>
          ${(S.playDetails1 || []).map(pd => `<option value="${pd.name}" ${p.playD1 === pd.name ? 'selected' : ''}>${pd.name}</option>`).join('')}
        </select>
        <select id="confirmPlayerPD2_${idx}" style="font-size:9px;padding:3px;" onchange="updateConfirmPlayerDetail(${idx}, 'playD2', this.value)" title="Play Detail 2">
          <option value="">PD2: ${pd2Display}</option>
          ${(S.playDetails2 || []).map(pd => `<option value="${pd.name}" ${p.playD2 === pd.name ? 'selected' : ''}>${pd.name}</option>`).join('')}
        </select>
        <select id="confirmPlayerSuccess_${idx}" style="font-size:9px;padding:3px;" onchange="updateConfirmPlayerDetail(${idx}, 'playSuccess', this.value)" title="Success/Unsuccess">
          <option value="">S/U: ${successDisplay}</option>
          <option value="s" ${p.playSuccess === 's' ? 'selected' : ''}>‚úì Success</option>
          <option value="u" ${p.playSuccess === 'u' ? 'selected' : ''}>‚úó Unsuccess</option>
        </select>
        <select id="confirmPlayerPressure_${idx}" style="font-size:9px;padding:3px;" onchange="updateConfirmPlayerDetail(${idx}, 'pressure', this.value)" title="Pressured By">
          <option value="">Press: ${pressureDisplay}</option>
          ${(S.rosters?.home || []).concat(S.rosters?.away || []).map(r => `<option value="${r.num}" ${p.pressure == r.num ? 'selected' : ''}>#${r.num}</option>`).join('')}
        </select>
      </div>`;
    });
    html += '</div>';
  }
  
  if (oppPlayers.length > 0) {
    html += '<div><div style="font-size:9px;color:var(--danger);font-weight:bold;margin-bottom:4px;">Opp Players:</div>';
    oppPlayers.forEach((p, idx) => {
      const oppIdx = evtPlayers.length + idx;
      const pd1Display = p.playD1 || '--';
      const pd2Display = p.playD2 || '--';
      const successDisplay = p.playSuccess === 's' ? '‚úì' : (p.playSuccess === 'u' ? '‚úó' : '--');
      const pressureDisplay = p.pressure ? `#${p.pressure}` : '--';
      html += `<div style="display:grid;grid-template-columns:50px 1fr 1fr 60px 70px;gap:4px;padding:6px;background:var(--card);border-radius:3px;margin-bottom:3px;align-items:center;border-left:3px solid var(--danger);">
        <span style="font-weight:bold;color:var(--danger);font-size:11px;">#${p.num}</span>
        <select id="confirmPlayerPD1_${oppIdx}" style="font-size:9px;padding:3px;" onchange="updateConfirmPlayerDetail(${oppIdx}, 'playD1', this.value)" title="Play Detail 1">
          <option value="">PD1: ${pd1Display}</option>
          ${(S.playDetails1 || []).map(pd => `<option value="${pd.name}" ${p.playD1 === pd.name ? 'selected' : ''}>${pd.name}</option>`).join('')}
        </select>
        <select id="confirmPlayerPD2_${oppIdx}" style="font-size:9px;padding:3px;" onchange="updateConfirmPlayerDetail(${oppIdx}, 'playD2', this.value)" title="Play Detail 2">
          <option value="">PD2: ${pd2Display}</option>
          ${(S.playDetails2 || []).map(pd => `<option value="${pd.name}" ${p.playD2 === pd.name ? 'selected' : ''}>${pd.name}</option>`).join('')}
        </select>
        <select id="confirmPlayerSuccess_${oppIdx}" style="font-size:9px;padding:3px;" onchange="updateConfirmPlayerDetail(${oppIdx}, 'playSuccess', this.value)" title="Success/Unsuccess">
          <option value="">S/U: ${successDisplay}</option>
          <option value="s" ${p.playSuccess === 's' ? 'selected' : ''}>‚úì Success</option>
          <option value="u" ${p.playSuccess === 'u' ? 'selected' : ''}>‚úó Unsuccess</option>
        </select>
        <select id="confirmPlayerPressure_${oppIdx}" style="font-size:9px;padding:3px;" onchange="updateConfirmPlayerDetail(${oppIdx}, 'pressure', this.value)" title="Pressured By">
          <option value="">Press: ${pressureDisplay}</option>
          ${(S.rosters?.home || []).concat(S.rosters?.away || []).map(r => `<option value="${r.num}" ${p.pressure == r.num ? 'selected' : ''}>#${r.num}</option>`).join('')}
        </select>
      </div>`;
    });
    html += '</div>';
  }
  
  container.innerHTML = html || '<span style="color:var(--muted);">No players</span>';
}

/**
 * v23.9: Update player detail in confirmation modal
 */
function updateConfirmPlayerDetail(playerIdx, field, value) {
  const allPlayers = S.curr.players.filter(p => p.role?.startsWith('event') || (!p.role?.startsWith('opp') && p.role))
    .concat(S.curr.players.filter(p => p.role?.startsWith('opp')));
  
  if (playerIdx >= 0 && playerIdx < allPlayers.length) {
    const player = allPlayers[playerIdx];
    if (field === 'playD1') player.playD1 = value;
    else if (field === 'playD2') player.playD2 = value;
    else if (field === 'playSuccess') player.playSuccess = value;
    else if (field === 'pressure') player.pressure = value;
  }
}

function onConfirmTypeChange() {
  const type = document.getElementById('confirmType').value;
  const d1Options = LISTS.details[type]?.d1 || [];
  document.getElementById('confirmD1').innerHTML = '<option value="">--</option>' + 
    d1Options.map(o => `<option value="${o}">${o}</option>`).join('');
  document.getElementById('confirmD2').innerHTML = '<option value="">--</option>';
}

function onConfirmD1Change() {
  const type = document.getElementById('confirmType').value;
  const d1 = document.getElementById('confirmD1').value;
  const opts = LISTS.details[type] || {};
  let d2Opts = opts.d2 || [];
  
  if (d1.includes('Giveaway') && opts.d2_Giveaway) d2Opts = opts.d2_Giveaway;
  else if (d1.includes('Takeaway') && opts.d2_Takeaway) d2Opts = opts.d2_Takeaway;
  else if (d1.includes('Entry') && opts.d2_Entry) d2Opts = opts.d2_Entry;
  else if (d1.includes('Exit') && opts.d2_Exit) d2Opts = opts.d2_Exit;
  
  document.getElementById('confirmD2').innerHTML = '<option value="">--</option>' + 
    d2Opts.map(o => `<option value="${o}">${o}</option>`).join('');
}

function closeConfirmModal() {
  document.getElementById('confirmEventModal').classList.remove('show');
}

/**
 * v23.3: Confirm and log the event, then continue tracking
 */
function confirmAndContinue() {
  doLogEvent();
  closeConfirmModal();
}

/**
 * v23.3: Confirm and log the event
 */
function confirmAndLog() {
  doLogEvent();
  closeConfirmModal();
}

/**
 * v23.3: Actually log the event (called from confirmation modal)
 */
function doLogEvent() {
  // Get values from confirmation modal
  const type = document.getElementById('confirmType').value;
  const team = document.getElementById('confirmTeam').value;
  const detail1 = document.getElementById('confirmD1').value;
  const detail2 = document.getElementById('confirmD2').value;
  const zone = document.getElementById('confirmZone').value;
  const success = document.getElementById('confirmSuccess').value;
  const strength = document.getElementById('confirmStrength').value;
  const startTime = document.getElementById('confirmStartTime').value;
  const endTime = document.getElementById('confirmEndTime').value || startTime;
  const isHighlight = document.getElementById('confirmHighlight').checked;
  const videoUrl = isHighlight ? (document.getElementById('confirmVideoUrl')?.value.trim() || '') : '';
  const linkedInput = document.getElementById('confirmLinked').value;
  const linkedEventIdx = linkedInput ? parseInt(linkedInput) - 1 : null;
  
  // Detect pressure for all event players
  detectPressure();
  
  // v23.3: For Possession and Zone_Entry_Exit (rush/carry), copy event_player_1's XY to puckXY
  const isPossessionEvent = type === 'Possession' || 
    (type === 'Zone_Entry_Exit' && (detail2.includes('Rush') || detail1.includes('Entry')));
  
  if (isPossessionEvent && S.curr.puckXY.length === 0) {
    const evtPlayer1 = S.curr.players.find(p => 
      p.role === 'event_team_player_1' || p.role === 'event_player_1' || p.roleNum === 1
    );
    if (evtPlayer1?.xy?.length > 0) {
      S.curr.puckXY = evtPlayer1.xy.map(xy => ({...xy}));
      console.log(`Copied #${evtPlayer1.num}'s XY to puckXY for ${type}`);
    }
  }
  
  // Build linked event chain
  let linkedEventChain = [];
  if (linkedEventIdx !== null) {
    linkedEventChain.push(linkedEventIdx);
    const linkedEvt = S.events.find(e => e.idx === linkedEventIdx);
    if (linkedEvt?.linkedEventChain?.length) {
      linkedEventChain = [...linkedEvt.linkedEventChain, linkedEventIdx];
    }
  }
  
  // v23.9: Ensure detail1 and detail2 are always populated (use type as fallback)
  const finalDetail1 = detail1 || type || '';
  const finalDetail2 = detail2 || '';
  
  // Get codes and IDs for export (display uses names)
  const typeInfo = getEventTypeCodeAndId(type);
  const detail1Info = getEventDetailCodeAndId(finalDetail1, type);
  const detail2Info = getEventDetail2CodeAndId(finalDetail2);
  
  // Calculate adjusted video time (go back up to 10 seconds, or to nearest faceoff)
  const adjustedVideoTime = calculateAdjustedVideoTime(S.period, startTime, type);
  
  const evt = {
    idx: S.evtIdx++,
    game_id: S.gameId,
    period: S.period,
    start_time: startTime,
    end_time: endTime,
    team: team,
    type: type,  // Display name
    typeCode: typeInfo.code,  // Export code
    typeId: typeInfo.id,  // Export ID
    detail1: finalDetail1,  // Display name
    detail1Code: detail1Info.code,  // Export code
    detail1Id: detail1Info.id,  // Export ID
    detail2: finalDetail2,  // Display name
    detail2Code: detail2Info.code,  // Export code
    detail2Id: detail2Info.id,  // Export ID
    zone,
    success,
    strength,
    linkedEventIdx: linkedEventIdx,
    linkedEventChain,
    isHighlight,
    videoUrl: isHighlight ? videoUrl : undefined,  // v23.7: Individual highlight video URL
    adjustedVideoTime: adjustedVideoTime,  // Adjusted time for video playback
    puckXY: [...S.curr.puckXY],
    netXY: S.curr.netXY,
    // v23.9: Use players from S.curr which may have been updated in confirmation modal
    players: S.curr.players.map(p => ({...p, xy: [...(p.xy || [])]}))
  };
  
  S.events.push(evt);
  
  // v23.4: Auto-sort and reindex events by time
  sortAndReindexEvents();
  
  // v23.8: Auto-detect assists for Goals
  if (evt.type === 'Goal') {
    detectAndLinkAssists(evt);
  }
  
  // v23.8: Determine end time (use start time if no end time)
  const actualEndTime = endTime || startTime;
  S.lastEndTime = actualEndTime;
  
  // v23.8: Auto-increment next event start time by 1 second (only if no linked event)
  let nextStartTime = actualEndTime;
  if (S.linkedEventIdx === null) {
    // Hockey clock counts down, so subtract 1 second (going forward in time = less time on clock)
    nextStartTime = incrementTimeBySeconds(actualEndTime, -1);
  }
  
  S.linkedEventIdx = null;
  
  const highlightIcon = isHighlight ? ' ‚≠ê' : '';
  toast(`Event #${evt.idx + 1}: ${evt.type}${highlightIcon}`, 'success');
  
  clearEvent();
  document.getElementById('evtStartTime').value = nextStartTime;
  
  renderEvents(); renderMarkers(); updateScores(); updateBoxScore();
  updateNextPlaySuggestions();
  autoSave();
  
  if (document.getElementById('autoEditNext')?.checked) {
    setTimeout(() => editEvent(S.events.length - 1), 100);
  }
}

/**
 * v23.3: Auto-populate goalie for Shot/Save events
 * For Shot_OnNet: Add opposing goalie as opp_team_player_1
 * For Save: Add event team goalie as event_team_player_1
 */
function autoPopulateGoalie() {
  const type = S.curr.type;
  const d1 = document.getElementById('evtD1').value;
  
  // Only for shots on net or saves
  const isShotOnNet = type === 'Shot' && (d1.includes('OnNet') || d1.includes('Goal'));
  const isSave = type === 'Save';
  
  if (!isShotOnNet && !isSave) return;
  
  if (isShotOnNet) {
    // Add opposing goalie as opp_team_player_1
    const oppTeam = S.evtTeam === 'home' ? 'away' : 'home';
    const oppGoalie = S.slots[oppTeam]?.G;
    
    if (oppGoalie) {
      // Check if goalie already added
      const existing = S.curr.players.find(p => p.num === oppGoalie.num);
      if (!existing) {
        S.curr.players.push({
          num: oppGoalie.num,
          name: oppGoalie.name,
          team: oppTeam,
          role: 'opp_team_player_1',
          roleNum: 1,
          xy: [],
          playD1: 'Save_Attempt',
          playD2: '',
          playSuccess: '',
          pressuredBy: '',
          sideOfPuck: ''
        });
        renumberPlayers();
        renderQuickAdd();
        toast(`Auto-added goalie #${oppGoalie.num} as O1`, 'info');
      }
    }
  } else if (isSave) {
    // Add event team goalie as event_team_player_1
    const evtGoalie = S.slots[S.evtTeam]?.G;
    
    if (evtGoalie) {
      // Check if goalie already added
      const existing = S.curr.players.find(p => p.num === evtGoalie.num);
      if (!existing) {
        S.curr.players.push({
          num: evtGoalie.num,
          name: evtGoalie.name,
          team: S.evtTeam,
          role: 'event_team_player_1',
          roleNum: 1,
          xy: [],
          playD1: 'Save_Made',
          playD2: '',
          playSuccess: 's',
          pressuredBy: '',
          sideOfPuck: ''
        });
        renumberPlayers();
        renderQuickAdd();
        toast(`Auto-added goalie #${evtGoalie.num} as E1`, 'info');
      } else {
        // Goalie exists, ensure they're E1
        existing.role = 'event_team_player_1';
        existing.roleNum = 1;
        renumberPlayers();
        renderQuickAdd();
      }
    }
  }
}

/**
 * v23.3: Auto-link and setup for follow-up events (Shot ‚Üí Save, etc.)
 */
function autoLinkFollowUp(type) {
  const lastEvt = S.events[S.events.length - 1];
  if (!lastEvt) return;
  
  // Save after Shot_OnNet: auto-link, swap team, setup goalie
  if (type === 'Save' && lastEvt.type === 'Shot' && 
      (lastEvt.detail1?.includes('OnNet') || lastEvt.detail1?.includes('Goal'))) {
    // Auto-link to the shot
    S.linkedEventIdx = lastEvt.idx;
    document.getElementById('linkedEvt').value = lastEvt.idx + 1;
    
    // Swap to the other team (goalie's team)
    const newTeam = lastEvt.team === 'home' ? 'away' : 'home';
    setEvtTeam(newTeam);
    
    // Copy time from shot
    document.getElementById('evtStartTime').value = lastEvt.start_time;
    
    // Copy puck position from shot
    if (lastEvt.puckXY?.length) {
      S.curr.puckXY = lastEvt.puckXY.map(xy => ({...xy}));
    }
    
    // Copy net position from shot
    if (lastEvt.netXY) {
      S.curr.netXY = {...lastEvt.netXY};
    }
    
    toast(`Auto-linked to Shot #${lastEvt.idx + 1}`, 'info');
  }
  
  // Rebound after Save: auto-link
  if (type === 'Rebound' && lastEvt.type === 'Save') {
    S.linkedEventIdx = lastEvt.idx;
    document.getElementById('linkedEvt').value = lastEvt.idx + 1;
    document.getElementById('evtStartTime').value = lastEvt.start_time;
    toast(`Auto-linked to Save #${lastEvt.idx + 1}`, 'info');
  }
}

function clearEvent() {
  const preserveStartTime = document.getElementById('evtStartTime').value;
  S.curr = { type: null, players: [], puckXY: [], netXY: null };
  S.selectedPlayer = null;
  S.xySlot = 1;
  S.xyHistory = [];
  document.querySelectorAll('.evt-btn').forEach(b => b.classList.remove('active'));
  document.getElementById('evtD1').innerHTML = '<option value="">--</option>';
  document.getElementById('evtD2').innerHTML = '<option value="">--</option>';
  document.getElementById('evtZone').value = '';
  document.getElementById('evtSuccess').value = '';
  document.getElementById('evtStartTime').value = preserveStartTime; // Keep for chaining
  document.getElementById('evtEndTime').value = '';
  document.getElementById('isHighlight').checked = false;
  document.getElementById('evtVideoUrl').value = '';
  document.getElementById('highlightVideoUrlRow').style.display = 'none';
  document.getElementById('zoneDisplay').innerHTML = '';
  renderQuickAdd(); renderXYSlots(); renderMarkers();
}

// v23.7: Toggle highlight video URL field visibility
function toggleHighlightFields() {
  const isHighlight = document.getElementById('isHighlight').checked;
  document.getElementById('highlightVideoUrlRow').style.display = isHighlight ? 'block' : 'none';
  if (!isHighlight) {
    document.getElementById('evtVideoUrl').value = '';
  }
}

// v23.7: Toggle edit highlight video URL field visibility
function toggleEditHighlightFields() {
  const isHighlight = document.getElementById('editHighlight').checked;
  document.getElementById('editHighlightVideoUrlRow').style.display = isHighlight ? 'block' : 'none';
  if (!isHighlight) {
    document.getElementById('editVideoUrl').value = '';
  }
}

// v23.7: Toggle confirm highlight video URL field visibility
function toggleConfirmHighlightFields() {
  const isHighlight = document.getElementById('confirmHighlight').checked;
  document.getElementById('confirmHighlightVideoUrlRow').style.display = isHighlight ? 'block' : 'none';
  if (!isHighlight) {
    document.getElementById('confirmVideoUrl').value = '';
  }
}

// ============================================================
// QUICK TIME & EVENT HELPERS (v5)
// ============================================================

/**
 * Copy current clock time to start time field
 */
function copyClockToStart() {
  const clock = document.getElementById('clock').value;
  document.getElementById('evtStartTime').value = clock;
  toast(`Start: ${clock}`, 'info');
}

/**
 * Copy current clock time to end time field
 */
function copyClockToEnd() {
  const clock = document.getElementById('clock').value;
  document.getElementById('evtEndTime').value = clock;
  toast(`End: ${clock}`, 'info');
}

/**
 * Copy last event's end time to current start time
 */
function copyLastEventTime() {
  if (S.events.length === 0) {
    toast('No previous events', 'info');
    return;
  }
  const lastEvt = S.events[S.events.length - 1];
  const time = lastEvt.end_time || lastEvt.start_time || '';
  document.getElementById('evtStartTime').value = time;
  toast(`Copied: ${time}`, 'info');
}

/**
 * v6: Nudge start time by variable seconds
 */
function nudgeStartTime(direction) {
  const amount = parseInt(document.getElementById('timeNudgeAmount').value) || 5;
  const startTimeEl = document.getElementById('evtStartTime');
  const newTime = nudgeTime(startTimeEl.value, direction * amount);
  startTimeEl.value = newTime;
  toast(`Start: ${newTime}`, 'info');
}

/**
 * v6: Nudge end time by variable seconds
 */
function nudgeEndTime(direction) {
  const amount = parseInt(document.getElementById('timeNudgeAmount').value) || 5;
  const endTimeEl = document.getElementById('evtEndTime');
  const newTime = nudgeTime(endTimeEl.value, direction * amount);
  endTimeEl.value = newTime;
  toast(`End: ${newTime}`, 'info');
}

/**
 * v6: Helper to add/subtract seconds from a time string (MM:SS)
 * Hockey clock counts DOWN, so adding seconds means earlier in period
 */
function nudgeTime(timeStr, seconds) {
  if (!timeStr) {
    // Use clock if no time set
    timeStr = document.getElementById('clock').value || '20:00';
  }
  const [min, sec] = (timeStr || '20:00').split(':').map(Number);
  let totalSec = (min || 0) * 60 + (sec || 0);
  totalSec += seconds; // Add seconds (hockey clock, so + goes earlier)
  
  // Clamp to 0:00 - 20:00
  totalSec = Math.max(0, Math.min(1200, totalSec));
  
  const newMin = Math.floor(totalSec / 60);
  const newSec = totalSec % 60;
  return `${newMin}:${String(newSec).padStart(2, '0')}`;
}

/**
 * v23.8: Increment time by seconds (hockey clock counts down, so negative = forward in time)
 * @param {string} timeStr - Time string in MM:SS format
 * @param {number} seconds - Number of seconds to add (negative = forward in time, positive = backward)
 * @returns {string} - New time string in MM:SS format
 */
function incrementTimeBySeconds(timeStr, seconds) {
  if (!timeStr) return '18:00'; // Default if no time
  
  const parts = String(timeStr).split(':');
  if (parts.length !== 2) return timeStr; // Invalid format
  
  const min = parseInt(parts[0]) || 0;
  const sec = parseInt(parts[1]) || 0;
  let totalSec = min * 60 + sec;
  
  // Add seconds (negative = forward in time = less time on clock)
  totalSec += seconds;
  
  // Clamp to valid range (0:00 to period length)
  const periodLength = getPeriodLength(S.period) * 60; // Convert to seconds
  totalSec = Math.max(0, Math.min(periodLength, totalSec));
  
  const newMin = Math.floor(totalSec / 60);
  const newSec = totalSec % 60;
  return `${newMin}:${String(newSec).padStart(2, '0')}`;
}

/**
 * Duplicate the last event with current time
 */
function duplicateLastEvent() {
  if (S.events.length === 0) {
    toast('No events to duplicate', 'info');
    return;
  }
  
  const lastEvt = S.events[S.events.length - 1];
  
  // Set event type
  setEvtType(lastEvt.type);
  
  // Set team
  setEvtTeam(lastEvt.team);
  
  // Set details
  setTimeout(() => {
    document.getElementById('evtD1').value = lastEvt.detail1 || '';
    onD1Change();
    setTimeout(() => {
      document.getElementById('evtD2').value = lastEvt.detail2 || '';
    }, 50);
  }, 50);
  
  // Set zone, success, strength
  document.getElementById('evtZone').value = lastEvt.zone || '';
  document.getElementById('evtSuccess').value = lastEvt.success || '';
  document.getElementById('evtStrength').value = lastEvt.strength || '5v5';
  
  // Copy players
  S.curr.players = lastEvt.players.map(p => ({
    ...p,
    xy: [] // Don't copy XY - needs new positions
  }));
  
  renderQuickAdd();
  toast(`Duplicated: ${lastEvt.type}`, 'success');
}

/**
 * v23.3: Auto-format time as user types
 * 1534 ‚Üí 15:34, 0709 ‚Üí 07:09, 709 ‚Üí 7:09, 1800 ‚Üí 18:00
 * v23.8: Fixed to handle 4-digit inputs correctly (1800 ‚Üí 18:00, not 1:800)
 */
function autoFormatTime(input) {
  let val = input.value.replace(/[^0-9:]/g, '');
  
  // If already has colon, check if it's in the wrong position (e.g., "1:800")
  if (val.includes(':')) {
    const parts = val.split(':');
    // If we have something like "1:800", reformat it
    if (parts.length === 2 && parts[0].length === 1 && parts[1].length >= 2) {
      // Reconstruct: take first 2 digits from combined, then colon, then rest
      const combined = parts[0] + parts[1];
      if (combined.length === 4) {
        val = combined.slice(0, 2) + ':' + combined.slice(2);
      } else {
        // Keep as is if not 4 digits total
        input.value = val;
        return;
      }
    } else {
      // Colon is in correct position, just clean it
      input.value = val;
      return;
    }
  }
  
  // Auto-insert colon for 3-4 digit entries
  if (val.length === 3 && !val.includes(':')) {
    // 709 ‚Üí 7:09
    val = val.slice(0, 1) + ':' + val.slice(1);
  } else if (val.length === 4 && !val.includes(':')) {
    // 1534 ‚Üí 15:34, 0709 ‚Üí 07:09, 1800 ‚Üí 18:00
    val = val.slice(0, 2) + ':' + val.slice(2);
  }
  
  input.value = val;
}

// ============================================================
// v23.3: WORKFLOW AUTOMATION FEATURES
// ============================================================

/**
 * Add all players from current shift slots to the event
 */
function addAllOnIce() {
  const evtTeam = S.evtTeam;
  const oppTeam = evtTeam === 'home' ? 'away' : 'home';
  
  // Add event team players
  Object.entries(S.slots[evtTeam]).forEach(([pos, player]) => {
    if (player && !S.curr.players.find(p => p.num === player.num)) {
      const roleNum = S.curr.players.filter(p => p.role?.startsWith('event')).length + 1;
      S.curr.players.push({
        num: player.num,
        name: player.name,
        team: evtTeam,
        role: `event_team_player_${roleNum}`,
        roleNum,
        xy: [],
        playD1: '',
        playD2: '',
        playSuccess: '',
        pressuredBy: '',
        sideOfPuck: ''
      });
    }
  });
  
  // Add opposing team players
  Object.entries(S.slots[oppTeam]).forEach(([pos, player]) => {
    if (player && !S.curr.players.find(p => p.num === player.num)) {
      const roleNum = S.curr.players.filter(p => p.role?.startsWith('opp')).length + 1;
      S.curr.players.push({
        num: player.num,
        name: player.name,
        team: oppTeam,
        role: `opp_team_player_${roleNum}`,
        roleNum,
        xy: [],
        playD1: '',
        playD2: '',
        playSuccess: '',
        pressuredBy: '',
        sideOfPuck: ''
      });
    }
  });
  
  renumberPlayers();
  renderQuickAdd();
  toast(`Added ${S.curr.players.length} players from ice`, 'success');
}

/**
 * Copy all players from the last event
 */
function copyPlayersFromLast() {
  if (S.events.length === 0) {
    toast('No previous events', 'error');
    return;
  }
  
  const lastEvt = S.events[S.events.length - 1];
  if (!lastEvt.players?.length) {
    toast('Last event has no players', 'error');
    return;
  }
  
  // Copy players without XY
  S.curr.players = lastEvt.players.map(p => ({
    ...p,
    team: p.team || (p.role?.startsWith('event') ? S.evtTeam : (S.evtTeam === 'home' ? 'away' : 'home')), // v23.8: Ensure team is set
    xy: [] // Clear XY for new positions
  }));
  
  renumberPlayers();
  renderQuickAdd();
  toast(`Copied ${S.curr.players.length} players from event #${lastEvt.idx + 1}`, 'success');
}

/**
 * Quick add player by jersey number
 */
function quickAddByNumber(num, role = 'evt') {
  // Find player in rosters
  const team = role === 'evt' ? S.evtTeam : (S.evtTeam === 'home' ? 'away' : 'home');
  const roster = S.rosters[team] || [];
  const player = roster.find(p => p.num === num || p.num === String(num));
  
  if (!player) {
    // v23.3: Check if player is on opposite team
    const otherTeam = team === 'home' ? 'away' : 'home';
    const otherRoster = S.rosters[otherTeam] || [];
    const otherPlayer = otherRoster.find(p => p.num === num || p.num === String(num));
    if (otherPlayer) {
      toast(`#${num} is on ${otherTeam} team - use ${role === 'evt' ? 'Opp' : 'Event'} side`, 'warning');
    } else {
      toast(`Player #${num} not found in either roster`, 'error');
    }
    return false;
  }
  
  // Check if already added
  if (S.curr.players.find(p => p.num === player.num)) {
    toast(`#${num} already in event`, 'warning');
    return false;
  }
  
  // v23.3: Guard - check if adding this player would create mixed teams
  const existingPlayers = S.curr.players.filter(p => p.role?.startsWith(role === 'evt' ? 'event' : 'opp'));
  if (existingPlayers.length > 0) {
    const existingTeam = existingPlayers[0].team;
    if (existingTeam !== team) {
      toast(`${role === 'evt' ? 'Event' : 'Opp'} players must all be from same team (${existingTeam})`, 'error');
      return false;
    }
  }
  
  const roleNum = S.curr.players.filter(p => p.role?.startsWith(role === 'evt' ? 'event' : 'opp')).length + 1;
  S.curr.players.push({
    num: player.num,
    name: player.name,
    team: team,
    role: `${role === 'evt' ? 'event' : 'opp'}_team_player_${roleNum}`,
    roleNum,
    xy: [],
    playD1: '',
    playD2: '',
    playSuccess: '',
    pressuredBy: '',
    sideOfPuck: ''
  });
  
  renumberPlayers();
  renderQuickAdd();
  toast(`Added #${num} ${player.name} as ${role === 'evt' ? 'E' : 'O'}${roleNum}`, 'success');
  return true;
}

/**
 * Toggle sequence mode - auto-links events and keeps same time
 */
let sequenceModeActive = false;
function toggleSequenceMode() {
  sequenceModeActive = !sequenceModeActive;
  const btn = document.getElementById('seqModeBtn');
  if (btn) {
    btn.classList.toggle('active', sequenceModeActive);
    btn.style.background = sequenceModeActive ? 'var(--accent)' : '';
    btn.style.color = sequenceModeActive ? '#000' : '';
  }
  toast(`Sequence mode: ${sequenceModeActive ? 'ON' : 'OFF'}`, sequenceModeActive ? 'success' : 'info');
  
  if (sequenceModeActive && S.events.length > 0) {
    // Auto-link to last event
    const lastEvt = S.events[S.events.length - 1];
    S.linkedEventIdx = lastEvt.idx;
    document.getElementById('linkedEvt').value = lastEvt.idx + 1;
    document.getElementById('evtStartTime').value = lastEvt.start_time;
  }
}

/**
 * Get suggested next event type based on last event
 */
function getSuggestedNextEvent() {
  if (S.events.length === 0) return null;
  
  const lastEvt = S.events[S.events.length - 1];
  const type = lastEvt.type;
  const d1 = lastEvt.detail1 || '';
  
  // Shot on net ‚Üí Save
  if (type === 'Shot' && (d1.includes('OnNet') || d1.includes('Goal'))) {
    return { type: 'Save', reason: 'after shot on net' };
  }
  
  // Save ‚Üí Rebound or Possession
  if (type === 'Save') {
    return { type: 'Rebound', reason: 'after save', alt: 'Possession' };
  }
  
  // Faceoff ‚Üí Possession
  if (type === 'Faceoff') {
    return { type: 'Possession', reason: 'after faceoff' };
  }
  
  // Zone entry ‚Üí Possession or Shot
  if (type === 'Zone_Entry_Exit' && d1.includes('Entry')) {
    return { type: 'Possession', reason: 'after zone entry', alt: 'Shot' };
  }
  
  // Turnover takeaway ‚Üí Possession
  if (type === 'Turnover' && d1.includes('Takeaway')) {
    return { type: 'Possession', reason: 'after takeaway' };
  }
  
  // Pass completed ‚Üí continue possession or shot
  if (type === 'Pass' && lastEvt.success === 's') {
    return { type: 'Shot', reason: 'after pass', alt: 'Pass' };
  }
  
  return null;
}

/**
 * Highlight suggested next event button
 */
function highlightSuggestedEvent() {
  // Clear previous highlights
  document.querySelectorAll('.evt-btn.suggested').forEach(b => b.classList.remove('suggested'));
  
  const suggestion = getSuggestedNextEvent();
  if (suggestion) {
    const btn = document.querySelector(`.evt-btn[data-type="${suggestion.type}"]`);
    if (btn) {
      btn.classList.add('suggested');
      btn.title = `Suggested: ${suggestion.reason}`;
    }
    if (suggestion.alt) {
      const altBtn = document.querySelector(`.evt-btn[data-type="${suggestion.alt}"]`);
      if (altBtn) altBtn.classList.add('suggested');
    }
  }
}

/**
 * Quick faceoff - click zone and winner
 */
function quickFaceoff(zone, winner) {
  // Set event type
  setEvtType('Faceoff');

  // Set zone
  document.getElementById('evtZone').value = zone;

  // Set team and detail based on winner
  if (winner === 'evt') {
    document.getElementById('evtD1').value = 'Faceoff_Won';
    document.getElementById('evtSuccess').value = 's';
  } else {
    document.getElementById('evtD1').value = 'Faceoff_Lost';
    document.getElementById('evtSuccess').value = 'u';
  }

  // v23.8: Auto-populate F1 players for faceoff
  autoPopulateFaceoffPlayers();

  // Copy clock time
  document.getElementById('evtStartTime').value = document.getElementById('clock').value;

  renderQuickAdd();
  toast(`Faceoff: ${zone.toUpperCase()} zone, ${winner === 'evt' ? 'Won' : 'Lost'}`, 'success');
}

/**
 * v23.8: Auto-populate F1 players for faceoff events
 */
function autoPopulateFaceoffPlayers() {
  // Clear current players first
  S.curr.players = [];
  
  // Get F1 from event team
  const eventF1 = S.slots[S.evtTeam]?.F1;
  if (eventF1) {
    S.curr.players.push({
      num: eventF1.num,
      name: eventF1.name,
      role: 'event_player_1',
      team: S.evtTeam
    });
  }
  
  // Get F1 from opponent team
  const oppTeam = S.evtTeam === 'home' ? 'away' : 'home';
  const oppF1 = S.slots[oppTeam]?.F1;
  if (oppF1) {
    S.curr.players.push({
      num: oppF1.num,
      name: oppF1.name,
      role: 'opp_player_1',
      team: oppTeam
    });
  }
  
  // Update UI
  if (typeof renderCurrentPlayers === 'function') renderCurrentPlayers();
  if (typeof renderQuickAdd === 'function') renderQuickAdd();
}

/**
 * Smart first click: if puck mode and no puck XY, place puck; else place player
 * Called from rink click handler
 */
function smartFirstClick() {
  // If in player mode but no players added, switch to puck first
  if (S.xyMode === 'player' && S.curr.players.length === 0 && S.curr.puckXY.length === 0) {
    setXYMode('puck');
    toast('No players - placing puck first', 'info');
    return true; // Handled
  }
  return false; // Let normal handler proceed
}

/**
 * Handle jersey number input (type number to add player)
 */
let jerseyInputBuffer = '';
let jerseyInputTimeout = null;

function handleJerseyInput(key) {
  // Only handle if a digit
  if (!/^\d$/.test(key)) {
    jerseyInputBuffer = '';
    return false;
  }
  
  jerseyInputBuffer += key;
  
  // Clear timeout
  if (jerseyInputTimeout) clearTimeout(jerseyInputTimeout);
  
  // Wait for more digits or timeout
  jerseyInputTimeout = setTimeout(() => {
    if (jerseyInputBuffer.length > 0) {
      const num = parseInt(jerseyInputBuffer);
      if (num > 0 && num < 100) {
        quickAddByNumber(num, 'evt');
      }
      jerseyInputBuffer = '';
    }
  }, 500); // 500ms timeout
  
  return true;
}

// Add CSS for suggested events
const suggestedStyle = document.createElement('style');
suggestedStyle.textContent = `
  .evt-btn.suggested { 
    box-shadow: 0 0 0 2px var(--accent), 0 0 8px var(--accent); 
    animation: pulse-suggest 1s infinite;
  }
  @keyframes pulse-suggest {
    0%, 100% { box-shadow: 0 0 0 2px var(--accent), 0 0 8px var(--accent); }
    50% { box-shadow: 0 0 0 2px var(--accent), 0 0 15px var(--accent); }
  }
  .btn-sm.mode-active {
    background: var(--accent) !important;
    color: #000 !important;
  }
`;
document.head.appendChild(suggestedStyle);

// ============================================================
// v23.3: QUICK PENALTY
// ============================================================

/**
 * Populate quick penalty player dropdown based on event team
 */
function updateQuickPenaltyPlayers() {
  const team = S.evtTeam;
  const roster = S.rosters[team] || [];
  const select = document.getElementById('quickPenPlayer');
  if (!select) return;
  
  select.innerHTML = '<option value="">Player #</option>' + 
    roster.map(p => `<option value="${p.num}">#${p.num} ${p.name}</option>`).join('');
}

/**
 * Log a penalty quickly
 */
function quickPenalty() {
  const playerNum = document.getElementById('quickPenPlayer').value;
  const penType = document.getElementById('quickPenType').value;
  
  if (!playerNum || !penType) {
    toast('Select player and penalty type', 'error');
    return;
  }
  
  // Set event type
  setEvtType('Penalty');
  
  // Set detail
  setTimeout(() => {
    document.getElementById('evtD1').value = penType;
    
    // Add player
    quickAddByNumber(parseInt(playerNum), 'evt');
    
    // Set time
    document.getElementById('evtStartTime').value = document.getElementById('clock').value;
    
    // Auto-log
    logEventDirect();
    
    // Reset dropdowns
    document.getElementById('quickPenPlayer').value = '';
    document.getElementById('quickPenType').value = '';
    
    // v23.4: Start power play timer
    startPowerPlay(S.evtTeam === 'home' ? 'away' : 'home');
    
    toast(`Penalty: #${playerNum} - ${penType.replace('Penalty_', '')}`, 'success');
  }, 50);
}

// ============================================================
// v23.4: QUICK STOPPAGE
// ============================================================

/**
 * Log a stoppage quickly
 */
function quickStoppage(type) {
  setEvtType('Stoppage');
  
  setTimeout(() => {
    document.getElementById('evtD1').value = `Stoppage_${type}`;
    document.getElementById('evtStartTime').value = document.getElementById('clock').value;
    document.getElementById('evtZone').value = type === 'Icing' ? 'd' : 'n';
    
    // Auto-log
    logEventDirect();
    
    toast(`Stoppage: ${type}`, 'success');
  }, 50);
}

// ============================================================
// v23.4: UNDO LAST EVENT
// ============================================================

/**
 * Undo the last logged event
 */
function undoLastEvent() {
  if (S.events.length === 0) {
    toast('No events to undo', 'warning');
    return;
  }
  
  const lastEvt = S.events.pop();
  S.evtIdx = Math.max(0, S.evtIdx - 1);
  
  toast(`Undid event #${lastEvt.idx + 1}: ${lastEvt.type}`, 'success');
  
  renderEvents();
  renderMarkers();
  updateScores();
  updateBoxScore();
  updateNextPlaySuggestions();
  autoSave();
}

// ============================================================
// v23.4: POWER PLAY TIMER
// ============================================================
let ppTimerInterval = null;
let ppTimerSeconds = 180; // Default 3 minutes for rec league
let ppTeam = null;
let penaltyMinutes = 3; // Configurable penalty minutes

/**
 * Update penalty minutes setting
 */
function updatePPMinutes() {
  const input = document.getElementById('ppMinutes');
  if (input) {
    penaltyMinutes = parseInt(input.value) || 3;
    localStorage.setItem('benchsight_penaltyMinutes', penaltyMinutes);
  }
}

/**
 * Start power play timer
 */
function startPowerPlay(team) {
  ppTeam = team;
  
  // Use configurable penalty minutes
  const mins = parseInt(document.getElementById('ppMinutes')?.value) || penaltyMinutes;
  ppTimerSeconds = mins * 60;
  
  const row = document.getElementById('ppTimerRow');
  const teamEl = document.getElementById('ppTimerTeam');
  const displayEl = document.getElementById('ppTimerDisplay');
  
  if (!row) return;
  
  row.style.display = 'flex';
  teamEl.textContent = `${team === 'home' ? (S.homeTeam || 'Home') : (S.awayTeam || 'Away')} PP:`;
  row.style.background = team === 'home' ? 'var(--home)' : 'var(--away)';
  
  // Update display
  displayEl.textContent = `${mins}:00`;
  
  // Update strength dropdown
  document.getElementById('evtStrength').value = team === S.evtTeam ? '5v4' : '4v5';
  
  // Clear existing timer
  if (ppTimerInterval) clearInterval(ppTimerInterval);
  
  // Start countdown
  ppTimerInterval = setInterval(() => {
    ppTimerSeconds--;
    const min = Math.floor(ppTimerSeconds / 60);
    const sec = ppTimerSeconds % 60;
    displayEl.textContent = `${min}:${String(sec).padStart(2, '0')}`;
    
    if (ppTimerSeconds <= 0) {
      endPowerPlay();
    }
  }, 1000);
  
  toast(`Power Play started: ${team === 'home' ? S.homeTeam : S.awayTeam} (${mins} min)`, 'info');
}

/**
 * End power play timer
 */
function endPowerPlay() {
  if (ppTimerInterval) {
    clearInterval(ppTimerInterval);
    ppTimerInterval = null;
  }
  
  const row = document.getElementById('ppTimerRow');
  if (row) row.style.display = 'none';
  
  document.getElementById('evtStrength').value = '5v5';
  ppTeam = null;
  
  toast('Power Play ended', 'info');
}

// ============================================================
// v23.4: EVENT TEMPLATES
// ============================================================

const EVENT_TEMPLATES = {
  dumpAndChase: {
    name: 'Dump & Chase',
    events: [
      { type: 'Zone_Entry_Exit', d1: 'Zone_Entry', d2: 'Entry_Dump', zone: 'o' },
      { type: 'Possession', d1: 'Possession_Recovered', zone: 'o' }
    ]
  },
  cyclePlay: {
    name: 'Cycle Play',
    events: [
      { type: 'Possession', d1: 'Possession_Cycle', zone: 'o' },
      { type: 'Pass', d1: 'Pass_Cycle', zone: 'o' }
    ]
  },
  breakout: {
    name: 'Breakout',
    events: [
      { type: 'Possession', d1: 'Possession_Breakout', zone: 'd' },
      { type: 'Zone_Entry_Exit', d1: 'Zone_Exit', d2: 'Exit_Pass', zone: 'd' }
    ]
  },
  forecheck: {
    name: 'Forecheck',
    events: [
      { type: 'Possession', d1: 'Possession_Forecheck', zone: 'o' },
      { type: 'Turnover', d1: 'Turnover_Takeaway', zone: 'o', success: 's' }
    ]
  },
  oddManRush: {
    name: 'Odd-Man Rush',
    events: [
      { type: 'Zone_Entry_Exit', d1: 'Zone_Entry', d2: 'Entry_Rush', zone: 'o' },
      { type: 'Shot', d1: 'Shot_OnNet', zone: 'o' }
    ]
  }
};

/**
 * Apply selected event template
 */
function applyTemplate() {
  const select = document.getElementById('eventTemplates');
  const templateKey = select.value;
  
  if (!templateKey || !EVENT_TEMPLATES[templateKey]) {
    toast('Select a template', 'warning');
    return;
  }
  
  const template = EVENT_TEMPLATES[templateKey];
  const firstEvent = template.events[0];
  
  // Set up first event
  setEvtType(firstEvent.type);
  
  setTimeout(() => {
    if (firstEvent.d1) document.getElementById('evtD1').value = firstEvent.d1;
    if (firstEvent.d2) {
      onD1Change();
      setTimeout(() => {
        document.getElementById('evtD2').value = firstEvent.d2;
      }, 50);
    }
    if (firstEvent.zone) document.getElementById('evtZone').value = firstEvent.zone;
    if (firstEvent.success) document.getElementById('evtSuccess').value = firstEvent.success;
    
    // Enable sequence mode for multi-event templates
    if (template.events.length > 1 && !sequenceModeActive) {
      toggleSequenceMode();
    }
    
    toast(`Template: ${template.name} - ${template.events.length} events`, 'success');
  }, 50);
  
  // Reset dropdown
  select.value = '';
}

// ============================================================
// v23.4: PERIOD END CHECKLIST
// ============================================================

/**
 * Show period end checklist modal
 */
function showPeriodEndChecklist() {
  const issues = [];
  
  // Check goal count
  const homeGoals = S.events.filter(e => e.type === 'Goal' && e.detail1 === 'Goal_Scored' && e.team === 'home').length;
  const awayGoals = S.events.filter(e => e.type === 'Goal' && e.detail1 === 'Goal_Scored' && e.team === 'away').length;
  
  // Check for unclosed shifts
  const currentPeriodShifts = S.shifts.filter(sh => sh.period === S.period);
  const unclosedShifts = currentPeriodShifts.filter(sh => !sh.end_time);
  if (unclosedShifts.length > 0) {
    issues.push(`‚ö†Ô∏è ${unclosedShifts.length} unclosed shift(s) in P${S.period}`);
  }
  
  // Check for events without players
  const eventsWithoutPlayers = S.events.filter(e => e.period === S.period && (!e.players || e.players.length === 0));
  if (eventsWithoutPlayers.length > 0) {
    issues.push(`‚ö†Ô∏è ${eventsWithoutPlayers.length} event(s) without players`);
  }
  
  // Check shot-save ratio
  const shotsOnNet = S.events.filter(e => e.period === S.period && e.type === 'Shot' && 
    (e.detail1?.includes('OnNet') || e.detail1?.includes('Goal'))).length;
  const saves = S.events.filter(e => e.period === S.period && e.type === 'Save').length;
  const goals = S.events.filter(e => e.period === S.period && e.type === 'Goal' && e.detail1 === 'Goal_Scored').length;
  
  if (shotsOnNet > saves + goals) {
    issues.push(`‚ö†Ô∏è ${shotsOnNet - saves - goals} shot(s) on net missing saves`);
  }
  
  // Faceoff balance check
  const foWins = S.events.filter(e => e.period === S.period && e.type === 'Faceoff' && e.detail1?.includes('Won')).length;
  const foLosses = S.events.filter(e => e.period === S.period && e.type === 'Faceoff' && e.detail1?.includes('Lost')).length;
  
  // Build checklist HTML
  let html = `
    <h3>üìã Period ${S.period} Checklist</h3>
    <div style="margin:15px 0;">
      <h4 style="color:var(--accent);">Score</h4>
      <div style="display:flex;justify-content:space-around;margin:10px 0;">
        <div style="text-align:center;">
          <div style="font-size:24px;font-weight:bold;color:var(--home);">${homeGoals}</div>
          <div style="font-size:10px;color:var(--muted);">${S.homeTeam || 'Home'}</div>
        </div>
        <div style="font-size:24px;color:var(--muted);">-</div>
        <div style="text-align:center;">
          <div style="font-size:24px;font-weight:bold;color:var(--away);">${awayGoals}</div>
          <div style="font-size:10px;color:var(--muted);">${S.awayTeam || 'Away'}</div>
        </div>
      </div>
    </div>
    <div style="margin:15px 0;">
      <h4 style="color:var(--accent);">Stats</h4>
      <div style="font-size:11px;color:var(--text);">
        <div>Shots on Net: ${shotsOnNet}</div>
        <div>Saves: ${saves}</div>
        <div>Faceoffs: ${foWins}W - ${foLosses}L (${foWins + foLosses > 0 ? Math.round(foWins / (foWins + foLosses) * 100) : 0}%)</div>
        <div>Events: ${S.events.filter(e => e.period === S.period).length}</div>
        <div>Shifts: ${currentPeriodShifts.length}</div>
      </div>
    </div>
  `;
  
  if (issues.length > 0) {
    html += `
      <div style="margin:15px 0;background:rgba(245,158,11,0.1);padding:10px;border-radius:4px;">
        <h4 style="color:var(--warning);">Issues Found</h4>
        <ul style="font-size:11px;margin:5px 0 0 15px;">
          ${issues.map(i => `<li>${i}</li>`).join('')}
        </ul>
      </div>
    `;
  } else {
    html += `
      <div style="margin:15px 0;background:rgba(34,197,94,0.1);padding:10px;border-radius:4px;">
        <h4 style="color:var(--success);">‚úì All Checks Passed</h4>
      </div>
    `;
  }
  
  html += `
    <div class="modal-actions" style="margin-top:15px;">
      <button onclick="document.getElementById('checklistModal').classList.remove('show')">Close</button>
      <button class="btn-primary" onclick="advancePeriod()">Next Period ‚Üí</button>
    </div>
  `;
  
  // Show in a modal
  let modal = document.getElementById('checklistModal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'checklistModal';
    modal.className = 'overlay';
    modal.innerHTML = `<div class="modal" style="min-width:350px;"></div>`;
    document.body.appendChild(modal);
  }
  modal.querySelector('.modal').innerHTML = html;
  modal.classList.add('show');
}

/**
 * Advance to next period
 */
function advancePeriod() {
  document.getElementById('checklistModal')?.classList.remove('show');
  
  if (S.period === 1) S.period = 2;
  else if (S.period === 2) S.period = 3;
  else if (S.period === 3) S.period = 'OT';
  
  document.querySelectorAll('.period-btn').forEach(b => b.classList.remove('active'));
  document.querySelector(`.period-btn[data-period="${S.period}"]`)?.classList.add('active');
  
  // Reset clock to new period length
  const newPeriodLength = getPeriodLength(S.period);
  document.getElementById('clock').value = `${newPeriodLength}:00`;
  
  toast(`Advanced to Period ${S.period} (${newPeriodLength} min)`, 'success');
}

// ============================================================
// v23.4: SHIFT LENGTH WARNING
// ============================================================
let shiftWarningInterval = null;

/**
 * Start shift length monitoring
 */
function startShiftMonitoring() {
  if (shiftWarningInterval) clearInterval(shiftWarningInterval);
  
  shiftWarningInterval = setInterval(() => {
    const shiftStart = document.getElementById('shiftStart').value;
    const currentClock = document.getElementById('clock').value;
    
    if (!shiftStart || !currentClock) return;
    
    const startParts = shiftStart.split(':').map(Number);
    const currentParts = currentClock.split(':').map(Number);
    
    const startSec = startParts[0] * 60 + startParts[1];
    const currentSec = currentParts[0] * 60 + currentParts[1];
    
    // Clock counts down
    const shiftLength = startSec - currentSec;
    
    if (shiftLength >= 90 && shiftLength < 92) { // Only warn once
      toast('‚ö†Ô∏è Shift is 90+ seconds - consider ending', 'warning');
    }
  }, 2000);
}

// ============================================================
// v23.4: RECENT PLAYERS PINNED
// ============================================================

/**
 * Get recently used players (from last 3 events)
 */
function getRecentPlayers() {
  const recentEvents = S.events.slice(-3);
  const recentNums = new Set();
  
  recentEvents.forEach(evt => {
    evt.players?.forEach(p => {
      recentNums.add(p.num);
    });
  });
  
  return Array.from(recentNums);
}

// ============================================================
// v23.4: VIDEO TIME SYNC
// ============================================================
let videoOffset = 0; // Seconds between video time and game clock

/**
 * Set video offset
 */
function setVideoOffset() {
  const videoTime = prompt('Enter video timestamp (MM:SS) when clock shows current time:');
  if (!videoTime) return;
  
  const videoParts = videoTime.split(':').map(Number);
  const videoSec = videoParts[0] * 60 + videoParts[1];
  
  const clockTime = document.getElementById('clock').value;
  const clockParts = clockTime.split(':').map(Number);
  const clockSec = clockParts[0] * 60 + clockParts[1];
  
  // Video offset = video time when game clock shows current value
  // For period 1 at 18:00, if video shows 2:30, offset = 150 seconds
  videoOffset = videoSec;
  
  localStorage.setItem('benchsight_videoOffset', videoOffset);
  toast(`Video offset set: ${videoTime}`, 'success');
}

/**
 * Get video timestamp for a game clock time
 */
function getVideoTimestamp(clockTime, period) {
  const clockParts = clockTime.split(':').map(Number);
  const clockSec = clockParts[0] * 60 + clockParts[1];
  const periodLengthSec = getPeriodLengthSeconds(period);
  
  // Time elapsed in period = periodLength - clockSec
  const elapsedInPeriod = periodLengthSec - clockSec;
  
  // Add previous periods (using their specific lengths)
  let totalElapsed = elapsedInPeriod;
  if (period >= 2) totalElapsed += getPeriodLengthSeconds(1) + (S.intermission1 || 900);
  if (period >= 3) totalElapsed += getPeriodLengthSeconds(2) + (S.intermission2 || 900);
  if (period === 'OT' || period === 4) totalElapsed += getPeriodLengthSeconds(3) + (S.intermission3 || 300);
  
  // Add video offset
  const videoTime = videoOffset + totalElapsed;
  
  const min = Math.floor(videoTime / 60);
  const sec = videoTime % 60;
  return `${min}:${String(sec).padStart(2, '0')}`;
}

// ============================================================
// v23.4: ZONE CLICK SUGGESTIONS
// ============================================================

/**
 * Suggest event type based on zone clicked
 */
function suggestEventFromZone(zone) {
  if (S.curr.type) return; // Don't suggest if type already set
  
  const suggestions = {
    'o': ['Shot', 'Pass', 'Possession'],
    'd': ['Possession', 'Zone_Entry_Exit', 'Pass'],
    'n': ['Zone_Entry_Exit', 'Faceoff', 'Pass']
  };
  
  const zoneSuggestions = suggestions[zone] || [];
  if (zoneSuggestions.length > 0) {
    // Highlight suggested buttons
    document.querySelectorAll('.evt-btn').forEach(b => b.classList.remove('zone-suggested'));
    zoneSuggestions.forEach(type => {
      const btn = document.querySelector(`.evt-btn[data-type="${type}"]`);
      if (btn) btn.classList.add('zone-suggested');
    });
  }
}

// Add CSS for zone suggestions
const zoneSuggestStyle = document.createElement('style');
zoneSuggestStyle.textContent = `
  .evt-btn.zone-suggested {
    border: 2px dashed var(--accent);
  }
`;
document.head.appendChild(zoneSuggestStyle);

// ============================================================
// v23.4: SORT AND REINDEX EVENTS
// ============================================================

/**
 * Convert time string to seconds for comparison
 */
function timeToSeconds(timeStr) {
  if (!timeStr) return 0;
  const parts = timeStr.split(':').map(Number);
  return parts[0] * 60 + (parts[1] || 0);
}

/**
 * Get period number for sorting (P1=1, P2=2, P3=3, OT=4)
 */
function periodToNumber(period) {
  if (period === 'OT' || period === 'ot') return 4;
  return parseInt(period) || 1;
}

/**
 * Sort events by period and time, then reindex all events and fix linked references
 */
function sortAndReindexEvents() {
  if (!S.events || S.events.length === 0) return;
  
  // Build old->new index mapping before sorting
  const oldIndexes = S.events.map(e => e.idx);
  
  // Sort by period (ascending), then by time (descending - higher time = earlier in period)
  S.events.sort((a, b) => {
    const periodA = periodToNumber(a.period);
    const periodB = periodToNumber(b.period);
    if (periodA !== periodB) return periodA - periodB;
    
    // Within same period, sort by time descending (18:00 before 17:00)
    const timeA = timeToSeconds(a.start_time);
    const timeB = timeToSeconds(b.start_time);
    return timeB - timeA;
  });
  
  // Build old->new index mapping
  const indexMap = {};
  oldIndexes.forEach((oldIdx, i) => {
    const newIdx = S.events.findIndex(e => e.idx === oldIdx);
    if (newIdx >= 0) {
      indexMap[oldIdx] = newIdx;
    }
  });
  
  // Reassign sequential indexes
  S.events.forEach((evt, i) => {
    evt.idx = i;
  });
  
  // Update all linkedEventIdx references
  S.events.forEach(evt => {
    if (evt.linkedEventIdx !== null && evt.linkedEventIdx !== undefined) {
      // Find the new index for the linked event
      const linkedEvt = S.events.find(e => oldIndexes[indexMap[evt.linkedEventIdx]] === e.idx || 
                                           S.events[indexMap[evt.linkedEventIdx]] === e);
      if (linkedEvt) {
        evt.linkedEventIdx = linkedEvt.idx;
      }
    }
    
    // Update linked event chain
    if (evt.linkedEventChain?.length > 0) {
      evt.linkedEventChain = evt.linkedEventChain.map(oldIdx => {
        const newEvt = S.events.find((e, i) => indexMap[oldIdx] === i);
        return newEvt ? newEvt.idx : oldIdx;
      });
    }
  });
  
  // Update evtIdx counter
  S.evtIdx = S.events.length;
}

/**
 * Manual reindex button handler
 */
function manualReindexEvents() {
  sortAndReindexEvents();
  renderEvents();
  toast('Events reindexed by time', 'success');
}

/**
 * v23.8: Move event up in the list (swap with previous event)
 */
function moveEventUp(eventIdx) {
  if (eventIdx <= 0 || eventIdx >= S.events.length) {
    toast('Cannot move event', 'warning');
    return;
  }
  
  // Swap events
  const temp = S.events[eventIdx];
  S.events[eventIdx] = S.events[eventIdx - 1];
  S.events[eventIdx - 1] = temp;
  
  // Re-index all events
  reindexEventsAfterMove();
  
  // Update UI
  renderEvents();
  renderMarkers();
  updateScores();
  updateBoxScore();
  autoSave();
  
  toast(`Event #${eventIdx + 1} moved up`, 'success');
}

/**
 * v23.8: Move event down in the list (swap with next event)
 */
function moveEventDown(eventIdx) {
  if (eventIdx < 0 || eventIdx >= S.events.length - 1) {
    toast('Cannot move event', 'warning');
    return;
  }
  
  // Swap events
  const temp = S.events[eventIdx];
  S.events[eventIdx] = S.events[eventIdx + 1];
  S.events[eventIdx + 1] = temp;
  
  // Re-index all events
  reindexEventsAfterMove();
  
  // Update UI
  renderEvents();
  renderMarkers();
  updateScores();
  updateBoxScore();
  autoSave();
  
  toast(`Event #${eventIdx + 1} moved down`, 'success');
}

/**
 * v23.8: Re-index events after moving (updates idx and linked references)
 */
function reindexEventsAfterMove() {
  // Reassign sequential indexes
  S.events.forEach((evt, i) => {
    evt.idx = i;
  });
  
  // Update linkedEventIdx references (they point to array indices)
  S.events.forEach(evt => {
    if (evt.linkedEventIdx !== null && evt.linkedEventIdx !== undefined) {
      // linkedEventIdx is an array index, so it should still be valid
      // But we need to verify the linked event still exists at that index
      if (evt.linkedEventIdx >= 0 && evt.linkedEventIdx < S.events.length) {
        const linkedEvt = S.events[evt.linkedEventIdx];
        if (linkedEvt) {
          // Reference is still valid
          evt.linkedEventIdx = linkedEvt.idx;
        } else {
          // Linked event not found, clear the link
          evt.linkedEventIdx = null;
        }
      }
    }
    
    // Update assistToGoalIdx references
    if (evt.assistToGoalIdx !== null && evt.assistToGoalIdx !== undefined) {
      if (evt.assistToGoalIdx >= 0 && evt.assistToGoalIdx < S.events.length) {
        const goalEvt = S.events[evt.assistToGoalIdx];
        if (goalEvt && goalEvt.type === 'Goal') {
          evt.assistToGoalIdx = goalEvt.idx;
        } else {
          // Goal not found, clear the link
          evt.assistToGoalIdx = null;
        }
      }
    }
    
    // Update linked event chain
    if (evt.linkedEventChain?.length > 0) {
      evt.linkedEventChain = evt.linkedEventChain.map(oldIdx => {
        if (oldIdx >= 0 && oldIdx < S.events.length) {
          const chainEvt = S.events[oldIdx];
          return chainEvt ? chainEvt.idx : oldIdx;
        }
        return oldIdx;
      }).filter(idx => idx >= 0 && idx < S.events.length);
    }
  });
  
  // Update evtIdx counter
  S.evtIdx = S.events.length;
}

// ============================================================
// v23.4: CUSTOM CHAIN PRESETS
// ============================================================

// User-defined chain presets (saved to localStorage)
let customChainPresets = [];

/**
 * Load custom chain presets from localStorage
 */
function loadCustomChainPresets() {
  try {
    const saved = localStorage.getItem('benchsight_customChains');
    if (saved) {
      customChainPresets = JSON.parse(saved);
      updateChainPresetsUI();
    }
  } catch (e) {
    console.error('Error loading custom chains:', e);
  }
}

/**
 * Save custom chain presets to localStorage
 */
function saveCustomChainPresets() {
  localStorage.setItem('benchsight_customChains', JSON.stringify(customChainPresets));
  updateChainPresetsUI();
}

/**
 * Add current event setup as a new chain preset
 */
function saveAsChainPreset() {
  const name = prompt('Enter preset name (e.g., "Zone Exit Rush"):');
  if (!name) return;
  
  // Get current event configuration
  const currentSetup = {
    type: S.curr.type,
    d1: document.getElementById('evtD1').value,
    d2: document.getElementById('evtD2').value,
    zone: document.getElementById('evtZone').value,
    success: document.getElementById('evtSuccess').value
  };
  
  // Ask for follow-up event
  const followUpType = prompt('Follow-up event type (e.g., "Possession", "Shot"):', '');
  const followUpD1 = followUpType ? prompt('Follow-up Detail 1:', '') : '';
  
  const preset = {
    id: Date.now(),
    name: name,
    events: [
      currentSetup,
      ...(followUpType ? [{ type: followUpType, d1: followUpD1, zone: currentSetup.zone }] : [])
    ]
  };
  
  customChainPresets.push(preset);
  saveCustomChainPresets();
  toast(`Saved chain preset: ${name}`, 'success');
}

/**
 * Delete a custom chain preset
 */
function deleteChainPreset(id) {
  customChainPresets = customChainPresets.filter(p => p.id !== id);
  saveCustomChainPresets();
  toast('Preset deleted', 'info');
}

/**
 * Apply a custom chain preset
 */
function applyCustomChain(id) {
  const preset = customChainPresets.find(p => p.id === id);
  if (!preset || !preset.events.length) return;
  
  const firstEvent = preset.events[0];
  
  setEvtType(firstEvent.type);
  
  setTimeout(() => {
    if (firstEvent.d1) document.getElementById('evtD1').value = firstEvent.d1;
    if (firstEvent.d2) {
      onD1Change();
      setTimeout(() => {
        document.getElementById('evtD2').value = firstEvent.d2;
      }, 50);
    }
    if (firstEvent.zone) document.getElementById('evtZone').value = firstEvent.zone;
    if (firstEvent.success) document.getElementById('evtSuccess').value = firstEvent.success;
    
    // Enable sequence mode for multi-event chains
    if (preset.events.length > 1 && !sequenceModeActive) {
      toggleSequenceMode();
    }
    
    toast(`Applied: ${preset.name}`, 'success');
  }, 50);
}

/**
 * Update the chain presets dropdown
 */
function updateChainPresetsUI() {
  const select = document.getElementById('eventTemplates');
  if (!select) return;
  
  // Keep built-in templates, add custom ones
  const builtInOptions = `
    <option value="">üìã Templates...</option>
    <option value="dumpAndChase">Dump & Chase</option>
    <option value="cyclePlay">Cycle Play</option>
    <option value="breakout">Breakout</option>
    <option value="forecheck">Forecheck</option>
    <option value="oddManRush">Odd-Man Rush</option>
  `;
  
  const customOptions = customChainPresets.length > 0 
    ? `<optgroup label="‚îÄ‚îÄ My Presets ‚îÄ‚îÄ">` + 
      customChainPresets.map(p => `<option value="custom_${p.id}">‚≠ê ${p.name}</option>`).join('') +
      `</optgroup>`
    : '';
  
  select.innerHTML = builtInOptions + customOptions;
}

/**
 * Extended apply template to handle custom presets
 */
const originalApplyTemplate = applyTemplate;
applyTemplate = function() {
  const select = document.getElementById('eventTemplates');
  const value = select.value;
  
  if (value.startsWith('custom_')) {
    const id = parseInt(value.replace('custom_', ''));
    applyCustomChain(id);
    select.value = '';
    return;
  }
  
  originalApplyTemplate();
};

// ============================================================
// v23.4: SETTINGS EXPORT/IMPORT
// ============================================================

/**
 * Export all settings, presets, and configurations to JSON file
 */
function exportSettings() {
  const settings = {
    exportDate: new Date().toISOString(),
    version: '23.4',
    
    // Custom chain presets
    customChainPresets: customChainPresets,
    
    // Penalty minutes
    penaltyMinutes: penaltyMinutes,
    
    // Video offset
    videoOffset: videoOffset,
    
    // BS settings (stored in localStorage)
    bsSettings: JSON.parse(localStorage.getItem('bs_settings') || '{}'),
    
    // Current game rosters (if loaded)
    homeRoster: S.homeRoster || [],
    awayRoster: S.awayRoster || [],
    
    // Team colors
    homeColor: S.homeColor,
    awayColor: S.awayColor,
    
    // Team names
    homeTeam: S.homeTeam,
    awayTeam: S.awayTeam
  };
  
  const blob = new Blob([JSON.stringify(settings, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `benchsight_settings_${new Date().toISOString().slice(0,10)}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  
  toast('Settings exported!', 'success');
}

/**
 * Import settings from JSON file
 */
function importSettings(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const settings = JSON.parse(e.target.result);
      
      // Import custom chain presets
      if (settings.customChainPresets) {
        customChainPresets = settings.customChainPresets;
        saveCustomChainPresets();
      }
      
      // Import penalty minutes
      if (settings.penaltyMinutes) {
        penaltyMinutes = settings.penaltyMinutes;
        localStorage.setItem('benchsight_penaltyMinutes', penaltyMinutes);
        const ppInput = document.getElementById('ppMinutes');
        if (ppInput) ppInput.value = penaltyMinutes;
      }
      
      // Import video offset
      if (settings.videoOffset !== undefined) {
        videoOffset = settings.videoOffset;
        localStorage.setItem('benchsight_videoOffset', videoOffset);
      }
      
      // Import BS settings
      if (settings.bsSettings) {
        localStorage.setItem('bs_settings', JSON.stringify(settings.bsSettings));
      }
      
      // Import rosters if present
      if (settings.homeRoster?.length) {
        S.homeRoster = settings.homeRoster;
        renderQuickAdd();
      }
      if (settings.awayRoster?.length) {
        S.awayRoster = settings.awayRoster;
        renderQuickAdd();
      }
      
      // Import colors
      if (settings.homeColor) S.homeColor = settings.homeColor;
      if (settings.awayColor) S.awayColor = settings.awayColor;
      
      // Import team names
      if (settings.homeTeam) S.homeTeam = settings.homeTeam;
      if (settings.awayTeam) S.awayTeam = settings.awayTeam;
      
      toast(`Imported settings from ${file.name}`, 'success');
    } catch (err) {
      console.error('Import error:', err);
      toast(`Import error: ${err.message}`, 'error');
    }
  };
  reader.readAsText(file);
  
  // Reset file input
  event.target.value = '';
}

// ============================================================
// v23.4: ROSTER IMPORT FROM EXCEL/CSV
// ============================================================

/**
 * Import roster from Excel/CSV file
 */
async function importRosterFromFile(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  const extension = file.name.split('.').pop().toLowerCase();
  
  try {
    if (extension === 'csv') {
      // Parse CSV
      const text = await file.text();
      const roster = parseCSVRoster(text);
      showRosterImportPreview(roster, file.name);
    } else if (extension === 'xlsx' || extension === 'xls') {
      // Parse Excel using SheetJS (must be loaded)
      if (typeof XLSX === 'undefined') {
        // Try to load SheetJS dynamically
        toast('Loading Excel parser...', 'info');
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js';
        script.onload = () => {
          parseExcelFile(file);
        };
        script.onerror = () => {
          toast('Could not load Excel parser. Try CSV format.', 'error');
        };
        document.head.appendChild(script);
      } else {
        parseExcelFile(file);
      }
    } else {
      toast('Unsupported file type. Use .xlsx, .xls, or .csv', 'error');
    }
  } catch (err) {
    console.error('Roster import error:', err);
    toast(`Import error: ${err.message}`, 'error');
  }
  
  // Reset file input
  event.target.value = '';
}

/**
 * Parse Excel file using SheetJS
 */
function parseExcelFile(file) {
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const data = new Uint8Array(e.target.result);
      const workbook = XLSX.read(data, { type: 'array' });
      
      // Get first sheet
      const firstSheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[firstSheetName];
      
      // Convert to JSON
      const json = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
      
      // Parse roster from rows
      const roster = parseRosterRows(json);
      showRosterImportPreview(roster, file.name);
    } catch (err) {
      console.error('Excel parse error:', err);
      toast(`Excel parse error: ${err.message}`, 'error');
    }
  };
  reader.readAsArrayBuffer(file);
}

/**
 * Parse CSV text to roster
 */
function parseCSVRoster(text) {
  const lines = text.split(/\r?\n/).filter(line => line.trim());
  const rows = lines.map(line => {
    // Handle quoted fields
    const result = [];
    let current = '';
    let inQuotes = false;
    
    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      if (char === '"') {
        inQuotes = !inQuotes;
      } else if (char === ',' && !inQuotes) {
        result.push(current.trim());
        current = '';
      } else {
        current += char;
      }
    }
    result.push(current.trim());
    return result;
  });
  
  return parseRosterRows(rows);
}

/**
 * Parse roster from 2D array of rows
 * Expects: jersey_number, first_name, last_name, position (optional)
 */
function parseRosterRows(rows) {
  if (rows.length === 0) return [];
  
  // Try to detect header row
  const headerRow = rows[0].map(h => String(h).toLowerCase().trim());
  
  // Find column indices
  let jerseyCol = -1, firstNameCol = -1, lastNameCol = -1, nameCol = -1, posCol = -1;
  
  headerRow.forEach((h, i) => {
    if (h.includes('jersey') || h.includes('number') || h === '#' || h === 'num') jerseyCol = i;
    if (h.includes('first') || h === 'fname') firstNameCol = i;
    if (h.includes('last') || h === 'lname') lastNameCol = i;
    if (h === 'name' || h === 'player') nameCol = i;
    if (h.includes('pos') || h === 'position') posCol = i;
  });
  
  // If no header detected, assume: jersey, first, last or jersey, name
  const hasHeader = jerseyCol >= 0 || firstNameCol >= 0 || nameCol >= 0;
  const startRow = hasHeader ? 1 : 0;
  
  if (!hasHeader) {
    // Assume first column is jersey number
    jerseyCol = 0;
    if (rows[0].length >= 3) {
      firstNameCol = 1;
      lastNameCol = 2;
    } else if (rows[0].length >= 2) {
      nameCol = 1;
    }
  }
  
  const roster = [];
  
  for (let i = startRow; i < rows.length; i++) {
    const row = rows[i];
    if (!row || row.length === 0) continue;
    
    let jersey = jerseyCol >= 0 ? row[jerseyCol] : null;
    let firstName = firstNameCol >= 0 ? row[firstNameCol] : '';
    let lastName = lastNameCol >= 0 ? row[lastNameCol] : '';
    let fullName = nameCol >= 0 ? row[nameCol] : '';
    let position = posCol >= 0 ? row[posCol] : '';
    
    // Parse jersey number
    jersey = parseInt(String(jersey).replace(/\D/g, ''));
    if (isNaN(jersey) || jersey <= 0) continue;
    
    // Build name
    let name = '';
    if (fullName) {
      name = String(fullName).trim();
    } else if (firstName || lastName) {
      name = `${String(firstName).trim()} ${String(lastName).trim()}`.trim();
    }
    
    if (!name) name = `Player ${jersey}`;
    
    roster.push({
      num: jersey,
      name: name,
      pos: String(position).trim().toUpperCase() || ''
    });
  }
  
  // Sort by jersey number
  roster.sort((a, b) => a.num - b.num);
  
  return roster;
}

/**
 * Show roster import preview modal
 */
function showRosterImportPreview(roster, filename) {
  if (roster.length === 0) {
    toast('No valid roster data found in file', 'error');
    return;
  }
  
  const rosterHtml = roster.map(p => 
    `<tr><td>${p.num}</td><td>${p.name}</td><td>${p.pos || '-'}</td></tr>`
  ).join('');
  
  const html = `
    <h3>üìã Import Roster</h3>
    <p style="font-size:11px;color:var(--muted);">File: ${filename} (${roster.length} players)</p>
    <div style="max-height:300px;overflow-y:auto;margin:10px 0;">
      <table style="width:100%;font-size:11px;border-collapse:collapse;">
        <thead><tr style="background:var(--panel);"><th>#</th><th>Name</th><th>Pos</th></tr></thead>
        <tbody>${rosterHtml}</tbody>
      </table>
    </div>
    <div style="margin-top:15px;">
      <label style="font-size:11px;">Import as:</label>
      <div style="display:flex;gap:8px;margin-top:5px;">
        <button class="btn-sm btn-primary" onclick="applyImportedRoster('home')" style="flex:1;">üè† Home Team</button>
        <button class="btn-sm btn-primary" onclick="applyImportedRoster('away')" style="flex:1;">‚úàÔ∏è Away Team</button>
      </div>
    </div>
    <div style="margin-top:10px;text-align:right;">
      <button class="btn-sm" onclick="closeModal()">Cancel</button>
    </div>
  `;
  
  // Store roster for apply function
  window._pendingRosterImport = roster;
  
  showModal(html);
}

/**
 * Apply imported roster to home or away team
 */
function applyImportedRoster(team) {
  const roster = window._pendingRosterImport;
  if (!roster) return;
  
  if (team === 'home') {
    S.homeRoster = roster;
    toast(`Imported ${roster.length} players to Home roster`, 'success');
  } else {
    S.awayRoster = roster;
    toast(`Imported ${roster.length} players to Away roster`, 'success');
  }
  
  window._pendingRosterImport = null;
  closeModal();
  renderQuickAdd();
}

/**
 * Show manual roster entry modal
 */
function showManualRosterEntry() {
  const html = `
    <h3>‚úèÔ∏è Manual Roster Entry</h3>
    <p style="font-size:11px;color:var(--muted);">Enter one player per line: <code>jersey_number, name</code></p>
    <p style="font-size:10px;color:var(--muted);">Example: <code>10, John Smith</code> or <code>10 John Smith</code></p>
    <textarea id="manualRosterText" style="width:100%;height:200px;font-family:monospace;font-size:11px;" placeholder="10, John Smith
23, Mike Johnson
88, Wayne Great
..."></textarea>
    <div style="margin-top:15px;">
      <label style="font-size:11px;">Import as:</label>
      <div style="display:flex;gap:8px;margin-top:5px;">
        <button class="btn-sm btn-primary" onclick="applyManualRoster('home')" style="flex:1;">üè† Home Team</button>
        <button class="btn-sm btn-primary" onclick="applyManualRoster('away')" style="flex:1;">‚úàÔ∏è Away Team</button>
      </div>
    </div>
    <div style="margin-top:10px;text-align:right;">
      <button class="btn-sm" onclick="closeModal()">Cancel</button>
    </div>
  `;
  
  showModal(html);
}

/**
 * Apply manually entered roster
 */
function applyManualRoster(team) {
  const text = document.getElementById('manualRosterText').value;
  if (!text.trim()) {
    toast('Enter roster data first', 'warning');
    return;
  }
  
  const lines = text.split(/\r?\n/).filter(l => l.trim());
  const roster = [];
  
  lines.forEach(line => {
    // Try to parse: "10, John Smith" or "10 John Smith" or "#10 John Smith"
    let match = line.match(/^#?(\d+)[,\s]+(.+)$/);
    if (match) {
      roster.push({
        num: parseInt(match[1]),
        name: match[2].trim(),
        pos: ''
      });
    }
  });
  
  if (roster.length === 0) {
    toast('Could not parse any players. Use format: 10, John Smith', 'error');
    return;
  }
  
  roster.sort((a, b) => a.num - b.num);
  
  if (team === 'home') {
    S.homeRoster = roster;
    toast(`Added ${roster.length} players to Home roster`, 'success');
  } else {
    S.awayRoster = roster;
    toast(`Added ${roster.length} players to Away roster`, 'success');
  }
  
  closeModal();
  renderQuickAdd();
}

// ============================================================
// v23.4: VALIDATION VS GAME DATA
// ============================================================

/**
 * Validate tracked data against fact_gameroster and dim_schedule
 */
async function validateAgainstGameData() {
  if (!S.connected || !S.sb || !S.gameId) {
    toast('Connect to database and select game first', 'error');
    return;
  }
  
  const issues = [];
  const successes = [];
  
  try {
    // Fetch fact_gameroster for this game
    const { data: gameroster, error: grError } = await S.sb
      .from('fact_gameroster')
      .select('*')
      .eq('game_id', S.gameId);
    
    if (grError) throw grError;
    
    // Fetch dim_schedule for this game
    const { data: schedule, error: schError } = await S.sb
      .from('dim_schedule')
      .select('*')
      .eq('game_id', S.gameId)
      .single();
    
    if (schError && schError.code !== 'PGRST116') throw schError;
    
    // ===== GOAL VALIDATION =====
    const trackedGoals = S.events.filter(e => e.type === 'Goal' && e.detail1 === 'Goal_Scored');
    const homeTrackedGoals = trackedGoals.filter(e => e.team === 'home').length;
    const awayTrackedGoals = trackedGoals.filter(e => e.team === 'away').length;
    
    if (schedule) {
      // Check total goals by period
      const p1HomeGoals = trackedGoals.filter(e => e.team === 'home' && e.period == 1).length;
      const p2HomeGoals = trackedGoals.filter(e => e.team === 'home' && e.period == 2).length;
      const p3HomeGoals = trackedGoals.filter(e => e.team === 'home' && e.period == 3).length;
      
      const p1AwayGoals = trackedGoals.filter(e => e.team === 'away' && e.period == 1).length;
      const p2AwayGoals = trackedGoals.filter(e => e.team === 'away' && e.period == 2).length;
      const p3AwayGoals = trackedGoals.filter(e => e.team === 'away' && e.period == 3).length;
      
      // Compare with dim_schedule
      if (schedule.home_goals_p1 !== undefined) {
        if (p1HomeGoals !== schedule.home_goals_p1) {
          issues.push(`‚ùå P1 Home Goals: Tracked ${p1HomeGoals}, Expected ${schedule.home_goals_p1}`);
        } else {
          successes.push(`‚úì P1 Home Goals match: ${p1HomeGoals}`);
        }
      }
      if (schedule.home_goals_p2 !== undefined) {
        if (p2HomeGoals !== schedule.home_goals_p2) {
          issues.push(`‚ùå P2 Home Goals: Tracked ${p2HomeGoals}, Expected ${schedule.home_goals_p2}`);
        } else {
          successes.push(`‚úì P2 Home Goals match: ${p2HomeGoals}`);
        }
      }
      if (schedule.home_goals_p3 !== undefined) {
        if (p3HomeGoals !== schedule.home_goals_p3) {
          issues.push(`‚ùå P3 Home Goals: Tracked ${p3HomeGoals}, Expected ${schedule.home_goals_p3}`);
        } else {
          successes.push(`‚úì P3 Home Goals match: ${p3HomeGoals}`);
        }
      }
      
      // Away goals
      if (schedule.away_goals_p1 !== undefined) {
        if (p1AwayGoals !== schedule.away_goals_p1) {
          issues.push(`‚ùå P1 Away Goals: Tracked ${p1AwayGoals}, Expected ${schedule.away_goals_p1}`);
        } else {
          successes.push(`‚úì P1 Away Goals match: ${p1AwayGoals}`);
        }
      }
      if (schedule.away_goals_p2 !== undefined) {
        if (p2AwayGoals !== schedule.away_goals_p2) {
          issues.push(`‚ùå P2 Away Goals: Tracked ${p2AwayGoals}, Expected ${schedule.away_goals_p2}`);
        } else {
          successes.push(`‚úì P2 Away Goals match: ${p2AwayGoals}`);
        }
      }
      if (schedule.away_goals_p3 !== undefined) {
        if (p3AwayGoals !== schedule.away_goals_p3) {
          issues.push(`‚ùå P3 Away Goals: Tracked ${p3AwayGoals}, Expected ${schedule.away_goals_p3}`);
        } else {
          successes.push(`‚úì P3 Away Goals match: ${p3AwayGoals}`);
        }
      }
      
      // Total goals
      const expectedHomeTotal = (schedule.home_goals_p1 || 0) + (schedule.home_goals_p2 || 0) + (schedule.home_goals_p3 || 0) + (schedule.home_goals_ot || 0);
      const expectedAwayTotal = (schedule.away_goals_p1 || 0) + (schedule.away_goals_p2 || 0) + (schedule.away_goals_p3 || 0) + (schedule.away_goals_ot || 0);
      
      if (homeTrackedGoals !== expectedHomeTotal) {
        issues.push(`‚ùå Total Home Goals: Tracked ${homeTrackedGoals}, Expected ${expectedHomeTotal}`);
      } else {
        successes.push(`‚úì Total Home Goals match: ${homeTrackedGoals}`);
      }
      
      if (awayTrackedGoals !== expectedAwayTotal) {
        issues.push(`‚ùå Total Away Goals: Tracked ${awayTrackedGoals}, Expected ${expectedAwayTotal}`);
      } else {
        successes.push(`‚úì Total Away Goals match: ${awayTrackedGoals}`);
      }
    }
    
    // ===== GOAL SCORER VALIDATION =====
    if (gameroster && gameroster.length > 0) {
      // Get players who should have goals
      const playersWithGoals = gameroster.filter(p => (p.goals || 0) > 0);
      
      playersWithGoals.forEach(player => {
        // Count goals by this player in tracked events
        const trackedPlayerGoals = trackedGoals.filter(e => {
          const scorer = e.players?.find(p => p.role === 'event_team_player_1');
          return scorer && (scorer.num == player.jersey_number || scorer.num == player.player_id);
        }).length;
        
        if (trackedPlayerGoals !== player.goals) {
          issues.push(`‚ùå #${player.jersey_number} Goals: Tracked ${trackedPlayerGoals}, Expected ${player.goals}`);
        } else if (player.goals > 0) {
          successes.push(`‚úì #${player.jersey_number} Goals match: ${player.goals}`);
        }
      });
      
      // Get players who should have assists
      const playersWithAssists = gameroster.filter(p => (p.assists || 0) > 0);
      
      playersWithAssists.forEach(player => {
        // v23.4 FIX: Assists are tracked via playD1/playD2 containing "Assist_Primary" or "Assist_Secondary"
        // Count assists by this player in tracked goal events
        let trackedPlayerAssists = 0;
        
        trackedGoals.forEach(e => {
          e.players?.forEach(p => {
            // Check if this player has an assist detail
            const hasAssist = (p.playD1 && (p.playD1.includes('Assist_Primary') || p.playD1.includes('Assist_Secondary'))) ||
                             (p.playD2 && (p.playD2.includes('Assist_Primary') || p.playD2.includes('Assist_Secondary')));
            
            if (hasAssist && (p.num == player.jersey_number || p.num == player.player_id)) {
              trackedPlayerAssists++;
            }
          });
        });
        
        if (trackedPlayerAssists < player.assists) {
          issues.push(`‚ö†Ô∏è #${player.jersey_number} Assists: Tracked ${trackedPlayerAssists}, Expected ${player.assists}`);
        } else if (player.assists > 0) {
          successes.push(`‚úì #${player.jersey_number} has ${trackedPlayerAssists} assist(s)`);
        }
      });
    }
    
    // Show validation results
    showValidationResults(issues, successes);
    
  } catch (error) {
    console.error('Validation error:', error);
    toast(`Validation error: ${error.message}`, 'error');
  }
}

/**
 * Show validation results in a modal
 */
function showValidationResults(issues, successes) {
  let html = `
    <h3>üîç Data Validation Results</h3>
    <div style="margin:15px 0;">
  `;
  
  if (successes.length > 0) {
    html += `
      <div style="background:rgba(34,197,94,0.1);padding:10px;border-radius:4px;margin-bottom:10px;">
        <h4 style="color:var(--success);margin-bottom:8px;">‚úì Matches (${successes.length})</h4>
        <ul style="font-size:11px;margin-left:15px;color:var(--text);">
          ${successes.slice(0, 10).map(s => `<li>${s}</li>`).join('')}
          ${successes.length > 10 ? `<li>... and ${successes.length - 10} more</li>` : ''}
        </ul>
      </div>
    `;
  }
  
  if (issues.length > 0) {
    html += `
      <div style="background:rgba(239,68,68,0.1);padding:10px;border-radius:4px;">
        <h4 style="color:var(--danger);margin-bottom:8px;">‚ùå Issues (${issues.length})</h4>
        <ul style="font-size:11px;margin-left:15px;color:var(--text);">
          ${issues.map(i => `<li>${i}</li>`).join('')}
        </ul>
      </div>
    `;
  } else {
    html += `
      <div style="background:rgba(34,197,94,0.1);padding:10px;border-radius:4px;text-align:center;">
        <h4 style="color:var(--success);">üéâ All validations passed!</h4>
      </div>
    `;
  }
  
  html += `
    </div>
    <div class="modal-actions" style="margin-top:15px;">
      <button onclick="document.getElementById('validationModal').classList.remove('show')">Close</button>
    </div>
  `;
  
  // Show in modal
  let modal = document.getElementById('validationModal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'validationModal';
    modal.className = 'overlay';
    modal.innerHTML = `<div class="modal" style="min-width:400px;max-height:80vh;overflow-y:auto;"></div>`;
    document.body.appendChild(modal);
  }
  modal.querySelector('.modal').innerHTML = html;
  modal.classList.add('show');
}

// ============================================================
// v23.4: PLAYER XY SELECTION IMPROVEMENTS
// ============================================================

/**
 * Click on player chip to select for XY editing
 * (Already implemented in selectPlayer, but let's enhance it)
 */
function selectPlayerForXY(num) {
  const player = S.curr.players.find(p => p.num === num);
  if (player) {
    S.selectedPlayer = player;
    setXYMode('player');
    S.xySlot = (player.xy?.length || 0) + 1;
    renderQuickAdd();
    renderXYSlots();
    toast(`Selected #${num} for XY placement`, 'info');
  }
}

// ============================================================
// v23.4: PLACE ALL PLAYERS HERE (Same Location)
// ============================================================

/**
 * Place all event players at the last puck XY position
 * Useful for hits, battles, board play where everyone is at puck
 */
function placeAllHere() {
  // Get last puck XY
  const lastPuckXY = S.curr.puckXY[S.curr.puckXY.length - 1] || S.curr.puckXY[0];
  
  if (!lastPuckXY) {
    toast('Place puck first, then click "All Here"', 'warning');
    return;
  }
  
  // Place all players at puck location (with slight offset to not overlap)
  let count = 0;
  S.curr.players.forEach((player, idx) => {
    // Small offset based on index so they don't all stack exactly
    const offsetX = (idx % 3 - 1) * 2; // -2, 0, +2
    const offsetY = (Math.floor(idx / 3) - 0.5) * 2; // slight Y spread
    
    player.xy = player.xy || [];
    player.xy[0] = { 
      x: lastPuckXY.x + offsetX, 
      y: lastPuckXY.y + offsetY, 
      seq: 1 
    };
    count++;
  });
  
  if (count > 0) {
    toast(`Placed ${count} player(s) at puck location`, 'success');
  } else {
    toast('Add players first', 'warning');
  }
  
  renderXYSlots(); renderMarkers(); renderQuickAdd();
}

// ============================================================
// v23.4: TIMELINE SCRUB
// ============================================================

/**
 * Render the timeline scrub showing recent events
 */
function renderTimeline() {
  const container = document.getElementById('timelineEvents');
  if (!container) return;
  
  // Get events for current period
  const periodEvents = S.events.filter(e => e.period === S.period);
  
  // Show last 20 events max
  const recentEvents = periodEvents.slice(-20);
  
  if (recentEvents.length === 0) {
    container.innerHTML = '<span style="font-size:8px;color:var(--muted);">No events yet</span>';
    return;
  }
  
  // Color map for event types
  const typeColors = {
    Shot: '#ef4444',
    Goal: '#22c55e',
    Pass: '#3b82f6',
    Faceoff: '#8b5cf6',
    Turnover: '#f59e0b',
    Possession: '#06b6d4',
    Save: '#6366f1',
    Hit: '#ec4899',
    Penalty: '#dc2626',
    Zone_Entry_Exit: '#14b8a6',
    Stoppage: '#6b7280'
  };
  
  container.innerHTML = recentEvents.map((evt, idx) => {
    const color = typeColors[evt.type] || 'var(--muted)';
    const label = evt.type.substring(0, 2).toUpperCase();
    const time = evt.start_time || '';
    const isHighlight = evt.isHighlight ? '‚≠ê' : '';
    const title = `#${evt.idx + 1} ${evt.type} @ ${time}${isHighlight ? ' (highlight)' : ''}`;
    
    return `<button class="timeline-evt" onclick="jumpToEvent(${evt.idx})" title="${title}" style="min-width:18px;height:18px;padding:0 2px;font-size:7px;background:${color};color:#fff;border:none;border-radius:2px;cursor:pointer;">${label}${isHighlight}</button>`;
  }).join('');
}

/**
 * Jump to and edit a specific event
 */
function jumpToEvent(idx) {
  const evt = S.events.find(e => e.idx === idx);
  if (!evt) return;
  
  // Open edit modal for this event
  editEvent(S.events.indexOf(evt));
  
  // Also show it on the rink
  renderMarkers();
  
  toast(`Jumped to event #${idx + 1}`, 'info');
}

// ============================================================
// v23.4: ENHANCED QUICK EVENT CHAINS
// ============================================================

// Enhanced event chains with full workflow
const QUICK_CHAINS = {
  controlledEntry: {
    name: 'Controlled Entry',
    sequence: [
      { type: 'Zone_Entry_Exit', d1: 'Zone_Entry', d2: 'Entry_Carry', zone: 'o', autoPlayers: ['E1'] },
      { type: 'Possession', d1: 'Possession_Cycle', zone: 'o' }
    ]
  },
  dumpIn: {
    name: 'Dump In',
    sequence: [
      { type: 'Zone_Entry_Exit', d1: 'Zone_Entry', d2: 'Entry_Dump', zone: 'o', autoPlayers: ['E1'] },
      { type: 'Possession', d1: 'Possession_Forecheck', zone: 'o' }
    ]
  },
  shotSequence: {
    name: 'Shot ‚Üí Save ‚Üí Rebound',
    sequence: [
      { type: 'Shot', d1: 'Shot_OnNet', zone: 'o', autoPlayers: ['E1'] },
      { type: 'Save', d1: 'Save_Rebound', zone: 'o' },
      { type: 'Shot', d1: 'Shot_OnNet', zone: 'o' }
    ]
  },
  breakout: {
    name: 'Breakout to Rush',
    sequence: [
      { type: 'Possession', d1: 'Possession_Breakout', zone: 'd', autoPlayers: ['E1'] },
      { type: 'Pass', d1: 'Pass_Breakout', zone: 'd' },
      { type: 'Zone_Entry_Exit', d1: 'Zone_Exit', d2: 'Exit_Rush', zone: 'n' }
    ]
  },
  ppCycle: {
    name: 'PP Cycle',
    sequence: [
      { type: 'Possession', d1: 'Possession_Cycle', zone: 'o', strength: '5v4' },
      { type: 'Pass', d1: 'Pass_Cycle', zone: 'o', strength: '5v4' },
      { type: 'Shot', d1: 'Shot_OnNet', zone: 'o', strength: '5v4' }
    ]
  }
};

let currentChainIdx = 0;
let activeChain = null;

/**
 * Start a quick chain sequence
 */
function startQuickChain(chainKey) {
  const chain = QUICK_CHAINS[chainKey];
  if (!chain) return;
  
  activeChain = chain;
  currentChainIdx = 0;
  
  // Enable sequence mode
  if (!sequenceModeActive) toggleSequenceMode();
  
  // Apply first event in chain
  applyChainStep();
  
  toast(`Starting: ${chain.name} (${chain.sequence.length} steps)`, 'success');
}

/**
 * Apply current chain step
 */
function applyChainStep() {
  if (!activeChain || currentChainIdx >= activeChain.sequence.length) {
    // Chain complete
    activeChain = null;
    currentChainIdx = 0;
    toast('Chain complete!', 'success');
    return;
  }
  
  const step = activeChain.sequence[currentChainIdx];
  
  setEvtType(step.type);
  
  setTimeout(() => {
    if (step.d1) document.getElementById('evtD1').value = step.d1;
    if (step.d2) {
      onD1Change();
      setTimeout(() => {
        document.getElementById('evtD2').value = step.d2;
      }, 30);
    }
    if (step.zone) setZone(step.zone);
    if (step.strength) document.getElementById('evtStrength').value = step.strength;
    
    // Show progress
    const progress = `Step ${currentChainIdx + 1}/${activeChain.sequence.length}`;
    toast(`${activeChain.name}: ${progress}`, 'info');
  }, 50);
}

/**
 * Advance to next chain step (called after logging event)
 */
function advanceChain() {
  if (!activeChain) return;
  currentChainIdx++;
  applyChainStep();
}

// Hook into event logging to advance chain and auto-advance
const originalLogEventDirect = logEventDirect;
logEventDirect = function() {
  // v23.5: Push undo state before logging
  pushUndoState('Log event');
  
  originalLogEventDirect.apply(this, arguments);
  advanceChain();
  renderTimeline();
  if (typeof setupAutoAdvance === 'function') setupAutoAdvance();
  
  // v23.5: Update recent players
  if (S.curr && S.curr.players) {
    S.curr.players.forEach(p => addToRecentPlayers(p));
  }
  
  // v23.5: Update suggestions
  renderEventSuggestions();
};

// ============================================================
// v23.4: KEYBOARD NAVIGATION
// ============================================================

/**
 * Setup keyboard navigation for dropdowns
 */
function setupKeyboardNav() {
  // Tab order enhancement
  const focusableElements = [
    'evtD1', 'evtD2', 'evtZone', 'evtSuccess', 'evtStrength',
    'evtStartTime', 'evtEndTime'
  ];
  
  focusableElements.forEach((id, idx) => {
    const el = document.getElementById(id);
    if (el) {
      el.tabIndex = idx + 1;
    }
  });
}

// Initialize on load
document.addEventListener('DOMContentLoaded', () => {
  setTimeout(() => {
    startShiftMonitoring();
    setupKeyboardNav();
    loadCustomChainPresets();
    
    // Load video offset from storage
    const savedOffset = localStorage.getItem('benchsight_videoOffset');
    if (savedOffset) videoOffset = parseInt(savedOffset);
    
    // Load penalty minutes from storage (default 3 for rec league)
    const savedPenMins = localStorage.getItem('benchsight_penaltyMinutes');
    if (savedPenMins) {
      penaltyMinutes = parseInt(savedPenMins);
      const ppInput = document.getElementById('ppMinutes');
      if (ppInput) ppInput.value = penaltyMinutes;
    }
  }, 1000);
});

// ============================================================
// v23.3: SHOT CHART MODE
// ============================================================
let shotChartModeActive = false;

/**
 * Toggle shot chart mode - click rink to create shots
 */
function toggleShotChartMode() {
  shotChartModeActive = !shotChartModeActive;
  possessionModeActive = false; // Turn off possession mode
  
  const shotBtn = document.getElementById('shotChartModeBtn');
  const possBtn = document.getElementById('possessionModeBtn');
  
  if (shotBtn) shotBtn.classList.toggle('mode-active', shotChartModeActive);
  if (possBtn) possBtn.classList.remove('mode-active');
  
  if (shotChartModeActive) {
    setEvtType('Shot');
    toast('Shot Chart Mode ON: Click rink to place shots', 'success');
  } else {
    toast('Shot Chart Mode OFF', 'info');
  }
}

/**
 * Handle shot chart click - creates shot at click location
 */
function handleShotChartClick(svgX, svgY, relX, relY) {
  if (!shotChartModeActive) return false;
  
  // Determine shot type based on location
  const zone = getZoneFromClick(svgX);
  if (zone !== 'o') {
    toast('Click in offensive zone to place shot', 'warning');
    return true; // Consumed the click
  }
  
  // Set shot type
  setEvtType('Shot');
  document.getElementById('evtZone').value = 'o';
  
  // Set puck position
  S.curr.puckXY = [{ x: relX, y: relY, seq: 1 }];
  
  // Set time
  document.getElementById('evtStartTime').value = document.getElementById('clock').value;
  
  // Show shot type modal or default to Shot_OnNet
  setTimeout(() => {
    document.getElementById('evtD1').value = 'Shot_OnNet';
    onD1Change();
    
    // Open net modal for shot location
    document.getElementById('netModal').classList.add('show');
  }, 50);
  
  renderMarkers();
  toast('Shot placed - select net location', 'info');
  return true; // Consumed the click
}

// ============================================================
// v23.3: POSSESSION MODE (sequence tracking)
// ============================================================
let possessionModeActive = false;
let possessionModeStartTime = null;  // Renamed to avoid conflict with v23.5
let possessionModeTeam = null;       // Renamed to avoid conflict with v23.5

/**
 * Toggle possession tracking mode
 */
function togglePossessionMode() {
  possessionModeActive = !possessionModeActive;
  shotChartModeActive = false; // Turn off shot mode
  
  const shotBtn = document.getElementById('shotChartModeBtn');
  const possBtn = document.getElementById('possessionModeBtn');
  
  if (shotBtn) shotBtn.classList.remove('mode-active');
  if (possBtn) possBtn.classList.toggle('mode-active', possessionModeActive);
  
  if (possessionModeActive) {
    possessionModeStartTime = document.getElementById('clock').value;
    possessionModeTeam = S.evtTeam;
    setEvtType('Possession');
    toggleSequenceMode(); // Also turn on sequence mode
    toast('Possession Mode ON: Track possession chain', 'success');
  } else {
    possessionModeStartTime = null;
    possessionModeTeam = null;
    if (sequenceModeActive) toggleSequenceMode(); // Turn off sequence mode
    toast('Possession Mode OFF', 'info');
  }
}

/**
 * End possession and log a turnover/shot
 */
function endPossession(reason) {
  if (!possessionModeActive) return;
  
  const duration = calculatePossessionModeDuration();
  
  if (reason === 'shot') {
    setEvtType('Shot');
  } else if (reason === 'turnover') {
    setEvtType('Turnover');
    document.getElementById('evtD1').value = 'Turnover_Giveaway';
  } else if (reason === 'pass') {
    // Continue possession with pass
    setEvtType('Pass');
    return;
  }
  
  toast(`Possession ended: ${duration}s - ${reason}`, 'info');
}

/**
 * Calculate possession duration
 */
function calculatePossessionModeDuration() {
  if (!possessionModeStartTime) return 0;
  
  const startParts = possessionModeStartTime.split(':').map(Number);
  const startSec = startParts[0] * 60 + startParts[1];
  
  const currentTime = document.getElementById('clock').value;
  const currentParts = currentTime.split(':').map(Number);
  const currentSec = currentParts[0] * 60 + currentParts[1];
  
  // Clock counts down, so start > current
  return startSec - currentSec;
}

// ============================================================
// v23.3: SHIFT AUTO-END
// ============================================================

/**
 * Auto-end shift on stoppage events
 */
function checkAutoEndShift(evt) {
  if (!evt) return;
  
  // Events that typically end a shift
  const shiftEndingEvents = ['Stoppage', 'Faceoff', 'Penalty', 'Goal'];
  const shiftEndingDetails = ['Icing', 'Offside', 'PeriodEnd', 'Timeout'];
  
  if (shiftEndingEvents.includes(evt.type) || 
      shiftEndingDetails.some(d => (evt.detail1 || '').includes(d))) {
    
    // Auto-fill shift end time
    const shiftEndEl = document.getElementById('shiftEnd');
    if (shiftEndEl && !shiftEndEl.value) {
      shiftEndEl.value = evt.start_time;
      toast('Shift end time auto-filled', 'info');
    }
  }
}

// ============================================================
// v23.3: BATCH PLAYER PLACEMENT
// ============================================================
let batchPlacementPlayers = [];

/**
 * Select multiple players for batch placement
 */
function toggleBatchPlayer(num) {
  const idx = batchPlacementPlayers.indexOf(num);
  if (idx >= 0) {
    batchPlacementPlayers.splice(idx, 1);
  } else {
    batchPlacementPlayers.push(num);
  }
  renderQuickAdd(); // Re-render to show selection
}

/**
 * Place all batch-selected players at a position
 */
function placeBatchPlayers(x, y) {
  if (batchPlacementPlayers.length === 0) return false;
  
  batchPlacementPlayers.forEach((num, i) => {
    const player = S.curr.players.find(p => p.num === num);
    if (player) {
      // Offset each player slightly so they don't overlap
      const offsetX = (i % 3 - 1) * 3;
      const offsetY = Math.floor(i / 3) * 3;
      player.xy.push({ x: x + offsetX, y: y + offsetY, seq: 1 });
    }
  });
  
  batchPlacementPlayers = [];
  renderMarkers();
  renderQuickAdd();
  toast('Players placed', 'success');
  return true;
}

// ============================================================
// v23.3: AUTO-ADVANCE FEATURES
// ============================================================

/**
 * Auto-advance to next event after logging
 */
function setupAutoAdvance() {
  // After logging, check if we should auto-setup next event
  const lastEvt = S.events[S.events.length - 1];
  if (!lastEvt) return;
  
  const suggestion = getSuggestedNextEvent();
  if (suggestion && sequenceModeActive) {
    // Auto-set suggested event type
    setEvtType(suggestion.type);
  }
  
  // Check for shift auto-end
  checkAutoEndShift(lastEvt);
}

// Hook into event logging
const originalDoLogEvent = doLogEvent;
doLogEvent = function() {
  originalDoLogEvent();
  setupAutoAdvance();
};

// Update penalty player dropdown when team changes
const originalSetEvtTeam = setEvtTeam;
setEvtTeam = function(team) {
  originalSetEvtTeam(team);
  updateQuickPenaltyPlayers();
};

// Initialize penalty dropdown on load
document.addEventListener('DOMContentLoaded', () => {
  setTimeout(updateQuickPenaltyPlayers, 1000);
});

/**
 * Quick time entry: type 1530 and it becomes 15:30
 */
function setupTimeInputs() {
  ['evtStartTime', 'evtEndTime', 'clock', 'shiftStart', 'shiftEnd'].forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      el.addEventListener('blur', () => {
        let val = el.value.replace(/[^0-9:]/g, '');
        // If no colon and 3-4 digits, auto-format
        if (!val.includes(':') && val.length >= 3) {
          val = val.slice(0, -2) + ':' + val.slice(-2);
        }
        // Ensure seconds are padded
        if (val.includes(':')) {
          const [min, sec] = val.split(':');
          val = min + ':' + (sec || '00').padStart(2, '0');
        }
        el.value = val;
      });
    }
  });
}

// ============================================================
// EDIT EVENT MODAL
// ============================================================
function editEvent(idx) {
  S.editingEvtIdx = idx;
  const evt = S.events[idx];

  // Ensure players array exists
  if (!evt.players) evt.players = [];
  if (!evt.puckXY) evt.puckXY = [];
  
  // v23.9: Initialize XY editing state
  S.editingXYType = null;
  S.editingXYIdx = null;
  S.editingXYPlayerIdx = null;
  
  document.getElementById('editEvtIdx').textContent = idx + 1;
  document.getElementById('editHighlightBadge').textContent = evt.isHighlight ? '‚≠ê' : '';
  document.getElementById('editType').value = evt.type;
  
  // Update team dropdown with actual team names
  const editTeamSel = document.getElementById('editTeam');
  editTeamSel.innerHTML = `<option value="home">${S.homeTeam || 'Home'}</option><option value="away">${S.awayTeam || 'Away'}</option>`;
  editTeamSel.value = evt.team;
  document.getElementById('editStartTime').value = evt.start_time || evt.time || '';
  document.getElementById('editEndTime').value = evt.end_time || evt.start_time || evt.time || '';
  document.getElementById('editZone').value = evt.zone || '';
  document.getElementById('editSuccess').value = evt.success || '';
  document.getElementById('editStrength').value = evt.strength || '5v5';
  document.getElementById('editHighlight').checked = evt.isHighlight || false;
  document.getElementById('editVideoUrl').value = evt.videoUrl || '';
  toggleEditHighlightFields(); // v23.7: Show/hide video URL field
  
  // Linked event index (editable)
  const linkedIdxEl = document.getElementById('editLinkedIdx');
  if (linkedIdxEl) {
    linkedIdxEl.value = (evt.linkedEventIdx !== null && evt.linkedEventIdx !== undefined) ? evt.linkedEventIdx + 1 : '';
  }
  
  // v23.8: Sequence and play keys (now editable)
  const seqKeyEl = document.getElementById('editSeqKey');
  const playKeyEl = document.getElementById('editPlayKey');
  if (seqKeyEl) seqKeyEl.value = evt.sequenceIdx || evt.seqIdx || evt.sequence_key || evt.sequence_id || '';
  if (playKeyEl) playKeyEl.value = evt.playIdx || evt.play_key || evt.play_id || '';
  
  // v23.8: Event ID (now editable)
  const eventIdEl = document.getElementById('editEventId');
  const eventIndexEl = document.getElementById('editEventIndex');
  if (eventIdEl) eventIdEl.value = evt.eventId || evt.event_id || '';
  if (eventIndexEl) eventIndexEl.textContent = evt.idx || (idx + 1);
  
  // Show linked chain
  const chainText = evt.linkedEventChain?.length 
    ? `Chain: ${evt.linkedEventChain.map(i => `#${i+1}`).join(' ‚Üí ')} ‚Üí #${idx+1}`
    : (evt.linkedEventIdx !== null && evt.linkedEventIdx !== undefined ? `Linked to #${evt.linkedEventIdx + 1}` : '--');
  document.getElementById('editLinkedChain').textContent = chainText;
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'editEvent:15207',message:'editEvent: Setting event type and details',data:{idx,type:evt.type,detail1:evt.detail1,detail2:evt.detail2,eventDetails1Loaded:S.eventDetails1?.length||0,eventDetails2Loaded:S.eventDetails2?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
  // #endregion
  
  onEditTypeChange();
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'editEvent:15208',message:'editEvent: After onEditTypeChange, setting editD1 value',data:{detail1:evt.detail1,editD1Options:document.getElementById('editD1').options.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
  // #endregion
  
  // Set detail1 value - use setTimeout to ensure dropdown is fully populated
  const editD1El = document.getElementById('editD1');
  const detail1Value = evt.detail1 || '';
  
  // Check if value exists in options, if not add it
  const d1Options = Array.from(editD1El.options).map(o => o.value);
  if (detail1Value && !d1Options.includes(detail1Value)) {
    // Value not in dropdown - add it
    const option = document.createElement('option');
    option.value = detail1Value;
    option.textContent = detail1Value + ' (loaded)';
    editD1El.insertBefore(option, editD1El.firstChild.nextSibling);
  }
  
  editD1El.value = detail1Value;
  
  // Verify value was set - if not, try case-insensitive match
  if (editD1El.value !== detail1Value && detail1Value) {
    const caseInsensitiveMatch = Array.from(editD1El.options).find(o => 
      o.value.toLowerCase() === detail1Value.toLowerCase()
    );
    if (caseInsensitiveMatch) {
      editD1El.value = caseInsensitiveMatch.value;
    }
  }
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'editEvent:15209',message:'editEvent: After setting editD1.value, checking if value matches',data:{detail1:evt.detail1,editD1Value:editD1El.value,valueMatches:editD1El.value===evt.detail1,optionsIncludeValue:Array.from(editD1El.options).some(o=>o.value===evt.detail1)},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
  // #endregion
  
  // v16.06: Pass detail2 to preserve it in dropdown options
  onEditD1Change(evt.detail2 || '');
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'editEvent:15210',message:'editEvent: After onEditD1Change, checking editD2',data:{detail2:evt.detail2,editD2Value:document.getElementById('editD2').value,editD2Options:document.getElementById('editD2').options.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
  // #endregion
  
  renderEditPlayers(evt.players);
  renderEditPuckXY(evt.puckXY);
  
  // Populate XY target dropdown (puck + each player)
  const xyTargetSel = document.getElementById('editXYTarget');
  xyTargetSel.innerHTML = '<option value="puck">Puck</option>' + 
    (evt.players || []).map((p, i) => `<option value="player_${i}">#${p.num} ${p.name}</option>`).join('');
  
  renderEditRinkMarkers();
  
  // Show/hide net section for shots/goals
  const showNet = ['Shot', 'Goal'].includes(evt.type);
  document.getElementById('editNetSection').style.display = showNet ? 'block' : 'none';
  if (showNet) {
    renderEditNetMarker(evt.netXY);
    document.getElementById('editNetLocation').textContent = getNetLocationName(evt.netXY) || '--';
  }
  
  // v23.8: Show/hide assists section for goals
  const showAssists = evt.type === 'Goal';
  document.getElementById('editAssistsSection').style.display = showAssists ? 'block' : 'none';
  if (showAssists) {
    renderEditAssists(evt);
  }
  
  // v23.8: Show/hide assist-to-goal link field (for Pass events or events with assist markers)
  const hasAssistMarker = evt.players?.some(p => {
    const pd1 = (p.playD1 || '').toLowerCase();
    const pd2 = (p.playD2 || '').toLowerCase();
    return pd1.includes('assist') || pd2.includes('assist');
  });
  const showAssistToGoal = evt.type === 'Pass' || hasAssistMarker;
  const assistToGoalSection = document.getElementById('editAssistToGoalSection');
  if (assistToGoalSection) {
    assistToGoalSection.style.display = showAssistToGoal ? 'block' : 'none';
    if (showAssistToGoal) {
      const assistToGoalEl = document.getElementById('editAssistToGoalIdx');
      if (assistToGoalEl) {
        assistToGoalEl.value = (evt.assistToGoalIdx !== null && evt.assistToGoalIdx !== undefined) ? evt.assistToGoalIdx + 1 : '';
      }
    }
  }
  
  document.getElementById('editModal').classList.add('show');
  
  // v23.8: Update box score to show stats up to this event
  updateBoxScore(idx);
}

function renderEditNetMarker(netXY) {
  const g = document.getElementById('editNetMarker');
  if (!g) return;
  
  if (netXY?.x != null && netXY?.y != null) {
    // v23.9: Net coordinates are already in net SVG format (0-72, 0-48)
    // No conversion needed for net display
    g.innerHTML = `<circle cx="${netXY.x}" cy="${netXY.y}" r="4" fill="#10b981" stroke="#fff" stroke-width="1"/>`;
  } else {
    g.innerHTML = '';
  }
}

function getNetLocationName(netXY) {
  if (!netXY?.x || !netXY?.y) return null;
  
  // v23.9: Net coordinates are in net SVG system (0-72 for x, 0-48 for y)
  // Check if coordinates are in center-relative format and convert to net SVG format
  let x = netXY.x;
  let y = netXY.y;
  
  // If coordinates are in center-relative format (negative values or > 72/48), they need conversion
  // But net SVG uses its own coordinate system, so we'll assume they're already in net format
  // If they're center-relative, we'd need to map them, but for now assume net format
  if (x < 0 || x > 72 || y < 0 || y > 48) {
    // Coordinates might be in center-relative format, but net uses its own system
    // For now, just use the values as-is and clamp to net bounds
    x = Math.max(0, Math.min(72, x));
    y = Math.max(0, Math.min(48, y));
  }
  
  // Divide net into zones (72x48 viewbox)
  if (y < 16) {
    return x < 36 ? 'Top Left' : 'Top Right';
  } else if (y > 32) {
    return x < 36 ? 'Low Left' : 'Low Right';
  } else {
    return 'Five Hole';
  }
}

function handleEditNetClick(event) {
  if (S.editingEvtIdx === null) return;
  
  const svg = document.getElementById('editNetSvg');
  const pt = svg.createSVGPoint();
  pt.x = event.clientX; pt.y = event.clientY;
  const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
  
  // v23.9: Net SVG uses its own coordinate system (0-72 for x, 0-48 for y)
  // Store coordinates in net SVG format (not center-relative)
  const netXY = { 
    x: Math.round(svgPt.x * 100) / 100, 
    y: Math.round(svgPt.y * 100) / 100 
  };
  S.events[S.editingEvtIdx].netXY = netXY;
  
  renderEditNetMarker(netXY);
  document.getElementById('editNetLocation').textContent = getNetLocationName(netXY);
  toast('Net location set: ' + getNetLocationName(netXY), 'success');
}

function clearEditNetXY() {
  if (S.editingEvtIdx === null) return;
  S.events[S.editingEvtIdx].netXY = null;
  renderEditNetMarker(null);
  document.getElementById('editNetLocation').textContent = '--';
  toast('Net location cleared', 'info');
}

/**
 * v23.9: Convert center-relative coordinates to SVG coordinates for display
 * Handles both center-relative (x: -100 to +100, y: -42.5 to +42.5) and SVG (x: 0-200, y: 0-85) formats
 * 
 * Detection logic:
 * - If coordinates are clearly outside center-relative range (x > 120 or x < -120, y > 50 or y < -50), assume SVG
 * - If coordinates are in center-relative range (-120 to 120 for x, -50 to 50 for y), convert them
 * - Otherwise, check if converting would result in valid SVG coordinates; if not, assume already SVG
 */
function relativeToSvg(relative) {
  if (!relative || typeof relative.x !== 'number' || typeof relative.y !== 'number') {
    return { x: 100, y: 42.5 }; // Default to center
  }
  
  // Check if coordinates are clearly outside center-relative range (likely already SVG)
  if (relative.x > 120 || relative.x < -120 || relative.y > 50 || relative.y < -50) {
    // Already in SVG format (legacy data)
    return { x: relative.x, y: relative.y };
  }
  
  // Coordinates are in center-relative range - convert to SVG
  const svgX = relative.x + 100;
  const svgY = relative.y + 42.5;
  
  // Validate converted coordinates are within SVG bounds
  if (svgX >= 0 && svgX <= 200 && svgY >= 0 && svgY <= 85) {
    return { x: svgX, y: svgY };
  }
  
  // If conversion results in invalid coordinates, assume already SVG (shouldn't happen with valid data)
  return { x: relative.x, y: relative.y };
}

/**
 * v23.9: Convert SVG coordinates to center-relative for storage
 */
function svgToRelative(svgX, svgY) {
  return {
    x: svgX - 100,  // Convert to center-relative (center ice = 0)
    y: svgY - 42.5  // Convert to center-relative (center ice = 0)
  };
}

function renderEditRinkMarkers() {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  const g = document.getElementById('editRinkMarkers');
  if (!g) return;
  
  // Clear existing markers
  g.innerHTML = '';
  
  const target = document.getElementById('editXYTarget')?.value || 'puck';
  
  // Render puck XY - v23.9: Convert center-relative to SVG coordinates
  (evt.puckXY || []).forEach((xy, i) => {
    const svgCoords = relativeToSvg(xy);
    const isActive = target === 'puck';
    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('cx', svgCoords.x);
    circle.setAttribute('cy', svgCoords.y);
    circle.setAttribute('r', '3');
    circle.setAttribute('fill', isActive ? '#ef4444' : '#666');
    circle.setAttribute('stroke', '#fff');
    circle.setAttribute('stroke-width', '0.5');
    circle.style.cursor = 'pointer';
    circle.addEventListener('click', (e) => {
      e.stopPropagation();
      selectEditXY('puck', i);
    });
    g.appendChild(circle);
    
    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text.setAttribute('x', svgCoords.x + 4);
    text.setAttribute('y', svgCoords.y - 2);
    text.setAttribute('font-size', '4');
    text.setAttribute('fill', '#fff');
    text.textContent = `P${i+1}`;
    g.appendChild(text);
  });
  
  // Render player XYs - v23.9: Convert center-relative to SVG coordinates
  (evt.players || []).forEach((p, pi) => {
    const isActive = target === `player_${pi}`;
    (p.xy || []).forEach((xy, i) => {
      const svgCoords = relativeToSvg(xy);
      const color = p.role?.startsWith('event') ? '#3b82f6' : '#ef4444';
      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle.setAttribute('cx', svgCoords.x);
      circle.setAttribute('cy', svgCoords.y);
      circle.setAttribute('r', '2.5');
      circle.setAttribute('fill', isActive ? color : '#666');
      circle.setAttribute('stroke', '#fff');
      circle.setAttribute('stroke-width', '0.3');
      circle.style.cursor = 'pointer';
      circle.addEventListener('click', (e) => {
        e.stopPropagation();
        selectEditXY(`player_${pi}`, i);
      });
      g.appendChild(circle);
      
      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text.setAttribute('x', svgCoords.x + 3);
      text.setAttribute('y', svgCoords.y - 1);
      text.setAttribute('font-size', '3');
      text.setAttribute('fill', '#fff');
      text.textContent = `${p.num}.${i+1}`;
      g.appendChild(text);
    });
  });
}

function handleEditRinkClick(event) {
  if (S.editingEvtIdx === null) return;
  
  const svg = document.getElementById('editRinkSvg');
  const pt = svg.createSVGPoint();
  pt.x = event.clientX; pt.y = event.clientY;
  const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
  
  // v23.9: Convert SVG coordinates to center-relative for storage
  const relativeCoords = svgToRelative(svgPt.x, svgPt.y);
  const xy = { 
    x: Math.round(relativeCoords.x * 100) / 100, 
    y: Math.round(relativeCoords.y * 100) / 100, 
    seq: 1 
  };
  
  const evt = S.events[S.editingEvtIdx];
  const target = document.getElementById('editXYTarget').value;
  
  if (target === 'puck') {
    if (S.editingXYIdx !== null && evt.puckXY?.[S.editingXYIdx]) {
      evt.puckXY[S.editingXYIdx] = xy;
    } else {
      evt.puckXY = evt.puckXY || [];
      xy.seq = evt.puckXY.length + 1;
      evt.puckXY.push(xy);
    }
    renderEditPuckXY(evt.puckXY);
  } else if (target.startsWith('player_')) {
    const pi = parseInt(target.split('_')[1]);
    if (evt.players?.[pi]) {
      if (S.editingXYIdx !== null && evt.players[pi].xy?.[S.editingXYIdx]) {
        evt.players[pi].xy[S.editingXYIdx] = xy;
      } else {
        evt.players[pi].xy = evt.players[pi].xy || [];
        xy.seq = evt.players[pi].xy.length + 1;
        evt.players[pi].xy.push(xy);
      }
    }
  }
  
  S.editingXYIdx = null;
  S.editingXYPlayerIdx = null;
  renderEditRinkMarkers();
  renderEditPlayers(evt.players);
}

function selectEditXY(target, idx) {
  document.getElementById('editXYTarget').value = target;
  S.editingXYIdx = idx;
  
  // v23.9: Parse player index if target is a player
  if (target.startsWith('player_')) {
    S.editingXYPlayerIdx = parseInt(target.split('_')[1]);
    S.editingXYType = 'player';
  } else {
    S.editingXYPlayerIdx = null;
    S.editingXYType = 'puck';
  }
  
  renderEditRinkMarkers();
  toast(`Selected ${target} point ${idx + 1} - click rink to move`, 'info');
}

function addEditXYPoint() {
  // Just click on rink to add
  toast('Click on rink to add XY point', 'info');
}

function onEditTypeChange() {
  const type = document.getElementById('editType').value;
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onEditTypeChange:15513',message:'onEditTypeChange: Entry',data:{type,eventDetails1Count:S.eventDetails1?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
  // #endregion
  
  // v16.06: Use S.eventDetails1 from dim_event_detail if available
  let d1Options = [];
  if (S.eventDetails1?.length > 0) {
    // Case-insensitive filtering for event type
    const filtered = S.eventDetails1.filter(e => 
      String(e.eventType || '').toLowerCase() === String(type || '').toLowerCase()
    );
    d1Options = filtered.map(e => e.name);
    
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onEditTypeChange:15522',message:'onEditTypeChange: After Supabase filter',data:{type,filteredCount:filtered.length,d1OptionsCount:d1Options.length,firstFew:d1Options.slice(0,3)},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
    // #endregion
    
    // Debug logging for Penalty type
    if (type === 'Penalty') {
      console.log('Penalty detail1 options from Supabase:', {
        totalEventDetails: S.eventDetails1.length,
        penaltyMatches: filtered.length,
        options: d1Options,
        allPenaltyTypes: S.eventDetails1.filter(e => 
          String(e.eventType || '').toLowerCase().includes('penalty')
        ).map(e => ({ eventType: e.eventType, name: e.name }))
      });
      
      // Check if Supabase data is invalid (just "penalty" instead of specific types)
      const hasInvalidData = d1Options.length > 0 && 
        d1Options.every(opt => opt.toLowerCase() === 'penalty' || opt.toLowerCase().includes('penalty_') === false);
      
      if (hasInvalidData) {
        console.warn('‚ö†Ô∏è Supabase penalty data appears invalid - event_detail_name values are generic "penalty" instead of specific types (Penalty_Minor, Penalty_Major, etc.)');
        console.warn('Falling back to LISTS.details. Please fix dim_event_detail table in Supabase.');
        d1Options = []; // Clear invalid data to trigger fallback
      }
    }
  }
  
  // Fall back to LISTS.details if no Supabase data or insufficient/invalid options
  // For Penalty, we expect at least 3 options (Minor, Major, Misconduct) with proper naming
  const supabaseCount = d1Options.length;
  const needsFallback = d1Options.length === 0 || 
    (type === 'Penalty' && (d1Options.length < 3 || !d1Options.some(opt => opt.includes('Minor') || opt.includes('Major') || opt.includes('Misconduct'))));
  
  if (needsFallback) {
    const opts = LISTS.details[type] || { d1: [], d2: [] };
    const fallbackOptions = opts.d1 || [];
    if (fallbackOptions.length > 0) {
      d1Options = fallbackOptions;
      if (type === 'Penalty') {
        console.warn('Using fallback LISTS.details for Penalty:', {
          reason: supabaseCount === 0 ? 'No Supabase data' : 'Supabase data insufficient/invalid',
          supabaseCount: supabaseCount,
          supabaseOptions: S.eventDetails1?.filter(e => 
            String(e.eventType || '').toLowerCase() === 'penalty'
          ).map(e => e.name),
          fallbackOptions: fallbackOptions
        });
      }
    }
  }
  
  const editD1Html = '<option value="">--</option>' + 
    d1Options.map(o => `<option value="${o}">${o}</option>`).join('');
  document.getElementById('editD1').innerHTML = editD1Html;
  document.getElementById('editD2').innerHTML = '<option value="">--</option>';
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onEditTypeChange:15573',message:'onEditTypeChange: Exit',data:{type,d1OptionsCount:d1Options.length,editD1OptionsAfter:document.getElementById('editD1').options.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
  // #endregion
}

function onEditD1Change(preserveD2Value = null) {
  const type = document.getElementById('editType').value;
  const d1 = document.getElementById('editD1').value;
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onEditD1Change:15578',message:'onEditD1Change: Entry',data:{type,d1,preserveD2Value,eventDetails2Count:S.eventDetails2?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
  // #endregion
  
  // Get current d2 value or use preserved value
  const currentD2 = preserveD2Value || document.getElementById('editD2').value;
  
  let d2Opts = [];
  
  // Special handling for Penalty - always use LISTS.details
  if (d1.startsWith('Penalty_')) {
    const penaltyOpts = LISTS.details.Penalty || {};
    if (penaltyOpts.d2 && penaltyOpts.d2.length > 0) {
      d2Opts = penaltyOpts.d2;
      
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onEditD1Change:15605',message:'onEditD1Change: Penalty detail2 from LISTS',data:{d1,penaltyD2Count:d2Opts.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
      // #endregion
    }
  }
  // v16.08: Use S.eventDetails2 from dim_event_detail_2 - filter by code prefix
  else if (S.eventDetails2?.length > 0 && d1) {
    // Determine code prefix based on detail1 value
    let codePrefix = null;
    if (d1.startsWith('Shot_')) codePrefix = 'Shot_';
    else if (d1.startsWith('Pass_')) codePrefix = 'Pass_';
    else if (d1.startsWith('Goal_')) codePrefix = 'Goal_';
    else if (d1.startsWith('Save_')) codePrefix = 'Save_';
    else if (d1.includes('Giveaway')) codePrefix = 'Giveaway_';
    else if (d1.includes('Takeaway')) codePrefix = 'Takeaway_';
    else if (d1.includes('Entry')) codePrefix = 'ZoneEntry_';
    else if (d1.includes('Exit') || d1.includes('Keepin')) codePrefix = 'ZoneExit_';
    else if (d1 === 'Stoppage_Play') codePrefix = 'Stoppage_';
    else if (d1 === 'Play_Offensive') codePrefix = 'PlayOffensive_';
    else if (d1 === 'Play_Defensive') codePrefix = 'PlayDefensive_';
    else if (d1.startsWith('Faceoff_')) codePrefix = 'Faceoff_';
    else if (d1.startsWith('Possession_')) codePrefix = 'Possession_';
    else if (d1.startsWith('Rebound_')) codePrefix = 'Rebound_';
    
    if (codePrefix) {
      d2Opts = S.eventDetails2
        .filter(e => e.code && e.code.startsWith(codePrefix))
        .map(e => e.name);
      
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onEditD1Change:15642',message:'onEditD1Change: After Supabase filter',data:{d1,codePrefix,d2OptsCount:d2Opts.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
      // #endregion
    }
  }
  
  // Fall back to LISTS.details if no Supabase data or Supabase returned no matches
  if (d2Opts.length === 0) {
    const opts = LISTS.details[type] || {};
    d2Opts = opts.d2 || [];
    if (d1.includes('Giveaway') && opts.d2_Giveaway) d2Opts = opts.d2_Giveaway;
    else if (d1.includes('Takeaway') && opts.d2_Takeaway) d2Opts = opts.d2_Takeaway;
    else if (d1.includes('Entry') && opts.d2_Entry) d2Opts = opts.d2_Entry;
    else if (d1.includes('Exit') && opts.d2_Exit) d2Opts = opts.d2_Exit;
    else if (d1.includes('Play') && opts.d2_Play) d2Opts = opts.d2_Play;
    else if (d1.includes('Offensive') && opts.d2_Offensive) d2Opts = opts.d2_Offensive;
    else if (d1.includes('Defensive') && opts.d2_Defensive) d2Opts = opts.d2_Defensive;
    else if (d1.includes('Keepin') && opts.d2_Exit) d2Opts = opts.d2_Exit;
    
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onEditD1Change:15624',message:'onEditD1Change: Using fallback LISTS',data:{type,d1,d2OptsCount:d2Opts.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
    // #endregion
  }
  
  // Build options HTML
  let optionsHtml = '<option value="">--</option>' + d2Opts.map(o => `<option value="${o}">${o}</option>`).join('');
  
  // If current/preserved value not in options, add it at top
  if (currentD2 && !d2Opts.includes(currentD2)) {
    optionsHtml = `<option value="">--</option><option value="${currentD2}">${currentD2} (loaded)</option>` + 
                  d2Opts.map(o => `<option value="${o}">${o}</option>`).join('');
  }
  
  document.getElementById('editD2').innerHTML = optionsHtml;
  
  // Restore selection if it existed
  const editD2El = document.getElementById('editD2');
  if (currentD2) {
    editD2El.value = currentD2;
    
    // Verify value was set - if not, try case-insensitive match
    if (editD2El.value !== currentD2) {
      const caseInsensitiveMatch = Array.from(editD2El.options).find(o => 
        o.value.toLowerCase() === currentD2.toLowerCase()
      );
      if (caseInsensitiveMatch) {
        editD2El.value = caseInsensitiveMatch.value;
      }
    }
    
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onEditD1Change:15639',message:'onEditD1Change: After setting editD2.value',data:{currentD2,editD2Value:editD2El.value,valueMatches:editD2El.value===currentD2,optionsIncludeValue:Array.from(editD2El.options).some(o=>o.value===currentD2)},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
    // #endregion
  }
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'onEditD1Change:15641',message:'onEditD1Change: Exit',data:{type,d1,d2OptsCount:d2Opts.length,currentD2,editD2OptionsAfter:editD2El.options.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
  // #endregion
}

function renderEditPlayers(players) {
  const container = document.getElementById('editPlayersContainer');
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'renderEditPlayers:15644',message:'renderEditPlayers: Entry',data:{playersCount:players?.length||0,playDetails1Count:S.playDetails1?.length||0,playDetails2Count:S.playDetails2?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
  // #endregion
  
  // v16.06: Build options with player-specific selection
  const buildPD1Options = (playerValue) => {
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'renderEditPlayers:buildPD1Options',message:'buildPD1Options: Entry',data:{playerValue,playDetails1Count:S.playDetails1?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
    // #endregion
    
    let opts = S.playDetails1.length > 0 
      ? S.playDetails1.map(p => `<option value="${p.name}" ${p.name === playerValue ? 'selected' : ''}>${p.name}</option>`).join('')
      : LISTS.playOffensive.concat(LISTS.playDefensive).map(o => `<option value="${o}" ${o === playerValue ? 'selected' : ''}>${o}</option>`).join('');
    
    // If player has a value not in options, add it
    const valueInOptions = S.playDetails1.length > 0 
      ? S.playDetails1.find(pd => pd.name === playerValue)
      : LISTS.playOffensive.concat(LISTS.playDefensive).includes(playerValue);
    
    if (playerValue && !valueInOptions) {
      opts = `<option value="${playerValue}" selected>${playerValue}</option>` + opts;
    }
    
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'renderEditPlayers:buildPD1Options',message:'buildPD1Options: Exit',data:{playerValue,valueInOptions:!!valueInOptions,optionsLength:opts.split('</option>').length-1},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
    // #endregion
    
    return opts;
  };
  
  const buildPD2Options = (playerValue) => {
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'renderEditPlayers:buildPD2Options',message:'buildPD2Options: Entry',data:{playerValue,playDetails2Count:S.playDetails2?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
    // #endregion
    
    let opts = S.playDetails2.length > 0 
      ? S.playDetails2.map(p => `<option value="${p.name}" ${p.name === playerValue ? 'selected' : ''}>${p.name}</option>`).join('')
      : '';
    
    // If player has a value not in options, add it
    const valueInOptions = S.playDetails2.length > 0 
      ? S.playDetails2.find(pd => pd.name === playerValue)
      : false;
    
    if (playerValue && !valueInOptions) {
      opts = `<option value="${playerValue}" selected>${playerValue}</option>` + opts;
    }
    
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'renderEditPlayers:buildPD2Options',message:'buildPD2Options: Exit',data:{playerValue,valueInOptions:!!valueInOptions,optionsLength:opts.split('</option>').length-1},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
    // #endregion
    
    return opts;
  };
  
  // Player role options
  const eventRoles = S.playerRoles.filter(r => r.type === 'event_team');
  const oppRoles = S.playerRoles.filter(r => r.type === 'opp_team');
  
  container.innerHTML = (players || []).map((p, i) => {
    const isOpp = p.role?.startsWith('opp');
    const roleOptions = isOpp ? oppRoles : eventRoles;
    const roleOpts = roleOptions.length > 0 
      ? roleOptions.map(r => `<option value="${r.code}" ${p.role===r.code?'selected':''}>${r.name}</option>`).join('')
      : `<option value="event_player_1">Event Player 1</option><option value="event_player_2">Event Player 2</option><option value="opp_player_1">Opp Player 1</option>`;
    
    // Build role select with current value highlighted
    const currentRole = p.role || '';
    const buildRoleOption = (val, label) => {
      const selected = currentRole === val ? 'selected' : '';
      return `<option value="${val}" ${selected}>${label}</option>`;
    };
    
    return `
    <div class="edit-player-row" data-idx="${i}" style="display:grid;grid-template-columns:80px 90px 130px 130px 60px 25px;gap:4px;align-items:center;margin-bottom:6px;padding:4px;background:var(--panel);border-radius:3px;">
      <span class="pnum" style="font-weight:bold;font-size:10px;">#${p.num} ${p.name?.split(' ').pop() || ''}</span>
      <select onchange="updateEditPlayer(${i}, 'role', this.value)" style="font-size:9px;" title="Player Role">
        <option value="">-- Role --</option>
        <optgroup label="Event Team">
          ${buildRoleOption('event_player_1', 'Event P1')}
          ${buildRoleOption('event_player_2', 'Event P2')}
          ${buildRoleOption('event_player_3', 'Event P3')}
          ${buildRoleOption('event_player_4', 'Event P4')}
          ${buildRoleOption('event_player_5', 'Event P5')}
          ${buildRoleOption('event_player_6', 'Event P6')}
          ${buildRoleOption('event_goalie', 'Event Goalie')}
        </optgroup>
        <optgroup label="Opponent">
          ${buildRoleOption('opp_player_1', 'Opp P1')}
          ${buildRoleOption('opp_player_2', 'Opp P2')}
          ${buildRoleOption('opp_player_3', 'Opp P3')}
          ${buildRoleOption('opp_player_4', 'Opp P4')}
          ${buildRoleOption('opp_player_5', 'Opp P5')}
          ${buildRoleOption('opp_player_6', 'Opp P6')}
          ${buildRoleOption('opp_goalie', 'Opp Goalie')}
        </optgroup>
      </select>
      <select onchange="updateEditPlayer(${i}, 'playD1', this.value)" style="font-size:9px;" title="Play Detail 1">
        <option value="">-- Play D1 --</option>
        ${buildPD1Options(p.playD1)}
      </select>
      <select onchange="updateEditPlayer(${i}, 'playD2', this.value)" style="font-size:9px;" title="Play Detail 2">
        <option value="">-- Play D2 --</option>
        ${buildPD2Options(p.playD2)}
      </select>
      <select onchange="updateEditPlayer(${i}, 'playSuccess', this.value)" style="font-size:9px;" title="Success">
        <option value="">Succ</option>
        <option value="s" ${p.playSuccess==='s'?'selected':''}>S</option>
        <option value="u" ${p.playSuccess==='u'?'selected':''}>U</option>
      </select>
      <button class="btn-sm btn-danger" onclick="removeEditPlayer(${i})" style="padding:2px 4px;">‚úï</button>
    </div>`;
  }).join('') || '<p style="color:var(--muted);font-size:9px;">No players - click + Add to add players</p>';
}

function renderEditPuckXY(puckXY) {
  const container = document.getElementById('editPuckXY');
  if (!container) return;
  
  // Use exact same pattern as renderEditPlayers - inline onclick handlers
  let html = (puckXY || []).map((xy, i) => 
    `<button class="edit-xy-btn has" onclick="editXYPoint('puck', ${i})" title="(${xy.x}, ${xy.y})">${i+1}: (${Math.round(xy.x)}, ${Math.round(xy.y)})</button>
     <button class="btn-sm btn-danger" onclick="deleteXYPoint('puck', ${i})" style="padding:2px 4px;">‚úï</button>`
  ).join('');
  html += `<button class="edit-xy-btn" onclick="addXYPoint('puck')">+ Add XY</button>`;
  
  container.innerHTML = html;
}

function renderEditPlayerXY(players) {
  // Add player XY display to edit modal
  const playerContainer = document.getElementById('editPlayersContainer');
  if (!playerContainer || !players?.length) return;
  
  // Append XY info to each player row (already in renderEditPlayers)
}

// v23.9: XY editing functions - regular function declarations like other working functions
function editXYPoint(type, idx) {
  console.log('editXYPoint called', type, idx);
  if (S.editingEvtIdx === null) {
    toast('No event being edited', 'error');
    return;
  }
  S.editingXYType = type;
  S.editingXYIdx = idx;
  
  const modal = document.getElementById('xyEditModal');
  if (modal) {
    modal.classList.add('show');
    renderXYEditRink();
  }
}

function addXYPoint(type) {
  console.log('addXYPoint called', type);
  if (S.editingEvtIdx === null) {
    toast('No event being edited', 'error');
    return;
  }
  const evt = S.events[S.editingEvtIdx];
  if (!evt) return;
  
  if (type === 'puck') {
    evt.puckXY = evt.puckXY || [];
    evt.puckXY.push({ x: 0, y: 0, seq: evt.puckXY.length + 1 });
    renderEditPuckXY(evt.puckXY);
    renderEditRinkMarkers();
    toast('XY point added', 'success');
  }
}

function deleteXYPoint(type, idx) {
  console.log('deleteXYPoint called', type, idx);
  if (S.editingEvtIdx === null) {
    toast('No event being edited', 'error');
    return;
  }
  const evt = S.events[S.editingEvtIdx];
  if (!evt) return;
  
  if (type === 'puck' && evt.puckXY) {
    evt.puckXY.splice(idx, 1);
    renderEditPuckXY(evt.puckXY);
    renderEditRinkMarkers();
    toast('XY point deleted', 'success');
  }
}

function renderXYEditRink() {
  // Highlight current point on mini rink
  const marker = document.getElementById('xyEditMarker');
  if (!marker) return;
  
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  
  let xy = null;
  if (S.editingXYType === 'puck' && evt.puckXY?.[S.editingXYIdx]) {
    xy = evt.puckXY[S.editingXYIdx];
  } else if (S.editingXYType === 'player' && S.editingXYPlayerIdx !== null && evt.players?.[S.editingXYPlayerIdx]?.xy?.[S.editingXYIdx]) {
    xy = evt.players[S.editingXYPlayerIdx].xy[S.editingXYIdx];
  }
  
  if (xy) {
    // v23.9: Convert center-relative to SVG coordinates for display
    const svgCoords = relativeToSvg(xy);
    marker.innerHTML = `<circle cx="${svgCoords.x}" cy="${svgCoords.y}" r="3" fill="#ef4444" stroke="#fff" stroke-width="0.5"/>`;
  } else {
    marker.innerHTML = '';
  }
}

function handleXYEditClick(event) {
  if (S.editingEvtIdx === null) return;
  
  const svg = document.getElementById('xyEditSvg');
  const rect = svg.getBoundingClientRect();
  const pt = svg.createSVGPoint();
  pt.x = event.clientX; pt.y = event.clientY;
  const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
  
  // v23.9: Convert SVG coordinates to center-relative for storage
  const relativeCoords = svgToRelative(svgPt.x, svgPt.y);
  const xy = { 
    x: Math.round(relativeCoords.x * 100) / 100, 
    y: Math.round(relativeCoords.y * 100) / 100 
  };
  
  const evt = S.events[S.editingEvtIdx];
  
  if (S.editingXYType === 'puck' && evt.puckXY?.[S.editingXYIdx]) {
    evt.puckXY[S.editingXYIdx].x = xy.x;
    evt.puckXY[S.editingXYIdx].y = xy.y;
    renderEditPuckXY(evt.puckXY);
  } else if (S.editingXYType === 'player' && S.editingXYPlayerIdx !== null && evt.players?.[S.editingXYPlayerIdx]?.xy?.[S.editingXYIdx]) {
    evt.players[S.editingXYPlayerIdx].xy[S.editingXYIdx].x = xy.x;
    evt.players[S.editingXYPlayerIdx].xy[S.editingXYIdx].y = xy.y;
  }
  
  renderXYEditRink();
  renderEditRinkMarkers(); // Update main edit modal rink too
}

function closeXYEditModal() {
  document.getElementById('xyEditModal').classList.remove('show');
  S.editingXYType = null;
  S.editingXYIdx = null;
  S.editingXYPlayerIdx = null;
  renderEditRinkMarkers(); // Update main edit modal rink
}

function updateEditPlayer(idx, field, val) {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  if (evt.players[idx]) evt.players[idx][field] = val;
}

function removeEditPlayer(idx) {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  evt.players.splice(idx, 1);
  renderEditPlayers(evt.players);
}

function addPlayerToEdit() {
  if (S.editingEvtIdx === null) {
    toast('No event being edited', 'error');
    return;
  }
  
  const evt = S.events[S.editingEvtIdx];
  
  // Update picker dropdown with team names
  const pickerTeamSel = document.getElementById('pickerTeam');
  pickerTeamSel.innerHTML = `<option value="home">${S.homeTeam || 'Home'}</option><option value="away">${S.awayTeam || 'Away'}</option>`;
  
  // Set team based on event being edited
  pickerTeamSel.value = evt.team || S.evtTeam;
  
  // Check if rosters are loaded
  if (!S.rosters.home?.length && !S.rosters.away?.length) {
    toast('No rosters loaded - select a game first', 'error');
    return;
  }
  
  renderPlayerPicker();
  document.getElementById('playerPickerModal').classList.add('show');
}

// ============================================================
// SAVE FOLDER MANAGEMENT (File System Access API)
// v23.8: Updated to use S.saveDirectoryHandle and backup system
// ============================================================

// Legacy function - now redirects to new implementation
async function pickSaveFolder() {
  await promptForSaveDirectory();
}

// Legacy function - now uses new implementation
function quickSaveToFolder() {
  if (!S.saveDirectoryHandle) {
    toast('No folder selected. Click "Choose" to pick a save folder.', 'error');
    return;
  }

  if (!S.gameId) {
    toast('No game loaded', 'error');
    return;
  }

  // Trigger manual save which will save to file system
  manualSave();
}

// Initialize save folder UI on page load
function initSaveFolderUI() {
  const lastFolderName = localStorage.getItem('bs_lastFolderName');
  if (lastFolderName) {
    document.getElementById('saveFolderPath').textContent = `${lastFolderName} (re-select to enable)`;
    document.getElementById('saveFolderPath').classList.remove('empty');
    document.getElementById('saveFolderStatus').textContent = 'üí° Re-select folder to enable Quick Save (browser security)';
  }
  
  // Update autosave display
  const autoSaveInt = document.getElementById('autoSaveInt');
  if (autoSaveInt) {
    const display = document.getElementById('autoSaveDisplay');
    if (display) display.textContent = autoSaveInt.value || '30';
    autoSaveInt.addEventListener('change', () => {
      if (display) display.textContent = autoSaveInt.value;
    });
  }
}

function renderPlayerPicker() {
  const team = document.getElementById('pickerTeam').value;
  const roster = S.rosters[team] || [];
  
  document.getElementById('playerPickerList').innerHTML = roster.map(p => `
    <div class="picker-player" onclick="selectPlayerFromPicker('${p.num}', '${p.name}')" 
         style="padding:6px;margin:2px 0;background:var(--card);border-radius:3px;cursor:pointer;display:flex;justify-content:space-between;">
      <span><strong>#${p.num}</strong> ${p.name}</span>
      <span style="color:var(--muted);">${p.pos || 'F'}</span>
    </div>
  `).join('') || '<div style="color:var(--muted);">No players</div>';
}

function selectPlayerFromPicker(num, name) {
  if (S.editingEvtIdx === null) {
    toast('No event being edited', 'error');
    return;
  }
  const evt = S.events[S.editingEvtIdx];
  
  // Ensure players array exists
  if (!evt.players) evt.players = [];
  
  const role = document.getElementById('pickerRole').value;
  const team = document.getElementById('pickerTeam').value;
  
  // Check if player already in event
  if (evt.players.some(p => p.num === num)) {
    toast(`#${num} already in event`, 'error');
    return;
  }
  
  // Determine next role number
  const existingRoles = evt.players.filter(p => p.role?.startsWith(role)).length;
  const roleNum = existingRoles + 1;
  
  evt.players.push({
    num, name, 
    role: `${role}_${roleNum}`,
    roleNum,
    team,
    xy: [],
    playD1: '', playD2: '', playSuccess: '', pressure: '', sideOfPuck: ''
  });
  
  renderEditPlayers(evt.players);
  
  // Update XY target dropdown
  const xyTargetSel = document.getElementById('editXYTarget');
  xyTargetSel.innerHTML = '<option value="puck">Puck</option>' + 
    evt.players.map((p, i) => `<option value="player_${i}">#${p.num} ${p.name}</option>`).join('');
  
  closePlayerPicker();
  toast(`Added #${num} ${name}`, 'success');
}

function closePlayerPicker() {
  document.getElementById('playerPickerModal').classList.remove('show');
}

// ============================================================
// VERIFICATION PANEL
// ============================================================
async function openVerifyModal() {
  // Set noradhockey link
  const link = document.getElementById('noradGameLink');
  if (S.gameId) {
    link.href = `https://noradhockey.com/event/${S.gameId}/`;
    link.style.display = 'inline';
    
    // v15.02: Auto-populate official score from dim_schedule if connected
    if (S.connected) {
      try {
        console.log('Loading official score for game', S.gameId);
        const { data: schedData, error: schedError } = await S.sb.from('dim_schedule')
          .select('home_total_goals,away_total_goals,home_team_period1_goals,home_team_period2_goals,home_team_period3_goals,away_team_period1_goals,away_team_period2_goals,away_team_period3_goals')
          .eq('game_id', S.gameId)
          .single();
        
        if (schedError) {
          console.error('Error loading official score:', schedError);
        }
        
        console.log('Official score data:', schedData);
        
        if (schedData) {
          // Store in hidden fields
          document.getElementById('officialHomeGoals').value = schedData.home_total_goals ?? 0;
          document.getElementById('officialAwayGoals').value = schedData.away_total_goals ?? 0;
          
          // Display total goals
          document.getElementById('officialHomeGoalsDisplay').textContent = schedData.home_total_goals ?? 0;
          document.getElementById('officialAwayGoalsDisplay').textContent = schedData.away_total_goals ?? 0;
          
          // Display by period
          const hp1 = schedData.home_team_period1_goals ?? '-';
          const hp2 = schedData.home_team_period2_goals ?? '-';
          const hp3 = schedData.home_team_period3_goals ?? '-';
          const ap1 = schedData.away_team_period1_goals ?? '-';
          const ap2 = schedData.away_team_period2_goals ?? '-';
          const ap3 = schedData.away_team_period3_goals ?? '-';
          
          document.getElementById('officialHomeByPeriod').textContent = `P1: ${hp1} | P2: ${hp2} | P3: ${hp3}`;
          document.getElementById('officialAwayByPeriod').textContent = `P1: ${ap1} | P2: ${ap2} | P3: ${ap3}`;
          
          // Store period data for comparison
          S.officialPeriodGoals = {
            home: { 1: hp1, 2: hp2, 3: hp3 },
            away: { 1: ap1, 2: ap2, 3: ap3 }
          };
          
          console.log('Official score loaded successfully');
        } else {
          console.log('No schedule data found for game', S.gameId);
        }
        
        // v6: Load fact_gameroster for verification
        const { data: rosterData } = await S.sb.from('fact_gameroster')
          .select('player_game_number,player_full_name,goals,assist,team_venue')
          .eq('game_id', S.gameId);
        
        if (rosterData) {
          S.rosterStats = {};
          rosterData.forEach(p => {
            S.rosterStats[String(p.player_game_number)] = {
              name: p.player_full_name,
              goals: parseInt(p.goals) || 0,
              assists: parseInt(p.assist) || 0,
              team: (p.team_venue || '').toLowerCase() === 'home' ? 'home' : 'away'
            };
          });
        }
      } catch(e) { console.log('Could not auto-populate score:', e); }
    }
  } else {
    link.style.display = 'none';
  }
  
  runVerification();
  document.getElementById('verifyModal').classList.add('show');
}

function closeVerifyModal() {
  document.getElementById('verifyModal').classList.remove('show');
}

function runVerification() {
  // v6: Count tracked goals by team and period
  const homeGoals = S.events.filter(e => e.type === 'Goal' && e.detail1 === 'Goal_Scored' && e.team === 'home');
  const awayGoals = S.events.filter(e => e.type === 'Goal' && e.detail1 === 'Goal_Scored' && e.team === 'away');
  
  // Count by period
  const homeP1 = homeGoals.filter(g => g.period === 1 || g.period === '1').length;
  const homeP2 = homeGoals.filter(g => g.period === 2 || g.period === '2').length;
  const homeP3 = homeGoals.filter(g => g.period === 3 || g.period === '3').length;
  const awayP1 = awayGoals.filter(g => g.period === 1 || g.period === '1').length;
  const awayP2 = awayGoals.filter(g => g.period === 2 || g.period === '2').length;
  const awayP3 = awayGoals.filter(g => g.period === 3 || g.period === '3').length;
  
  document.getElementById('verifyHomeGoals').textContent = homeGoals.length;
  document.getElementById('verifyAwayGoals').textContent = awayGoals.length;
  document.getElementById('verifyHomeByPeriod').textContent = `P1: ${homeP1} | P2: ${homeP2} | P3: ${homeP3}`;
  document.getElementById('verifyAwayByPeriod').textContent = `P1: ${awayP1} | P2: ${awayP2} | P3: ${awayP3}`;
  
  // Compare to official
  const officialHome = parseInt(document.getElementById('officialHomeGoals').value) || 0;
  const officialAway = parseInt(document.getElementById('officialAwayGoals').value) || 0;
  
  const resultEl = document.getElementById('verifyResult');
  if (homeGoals.length === officialHome && awayGoals.length === officialAway) {
    resultEl.innerHTML = '‚úÖ VERIFIED - Goals match official score!';
    resultEl.style.background = 'rgba(16, 185, 129, 0.2)';
    resultEl.style.color = 'var(--success)';
  } else {
    const diff = `Home: ${homeGoals.length} vs ${officialHome}, Away: ${awayGoals.length} vs ${officialAway}`;
    resultEl.innerHTML = `‚ùå MISMATCH - ${diff}`;
    resultEl.style.background = 'rgba(239, 68, 68, 0.2)';
    resultEl.style.color = 'var(--danger)';
  }
  
  // v6: Build goal list with scorer # and assist # (from %assist% in play_detail)
  const allGoals = [...homeGoals, ...awayGoals].sort((a, b) => {
    if (a.period !== b.period) return a.period - b.period;
    return (b.start_time || '20:00').localeCompare(a.start_time || '20:00');
  });
  
  // Track for warnings
  const warnings = [];
  
  document.getElementById('verifyGoalsList').innerHTML = allGoals.map(g => {
    const scorer = g.players?.find(p => p.role === 'event_player_1');
    
    // v6: Find assists by checking for '%assist%' in play_detail1 or play_detail2 (within goal event)
    const assistersInGoal = (g.players || []).filter(p => {
      const pd1 = (p.playD1 || '').toLowerCase();
      const pd2 = (p.playD2 || '').toLowerCase();
      return pd1.includes('assist') || pd2.includes('assist');
    });
    
    // v23.8: Also check for linked Pass events (for imported data and auto-detected assists)
    const linkedPassEvents = [];
    if (g.linkedEventIdx !== null && g.linkedEventIdx !== undefined) {
      // Goal is linked to another event (unlikely, but check)
      const linkedEvt = S.events.find(e => e.idx === g.linkedEventIdx);
      if (linkedEvt && linkedEvt.type === 'Pass') {
        linkedPassEvents.push(linkedEvt);
      }
    }
    
    // v23.8: Find Pass events that assist this goal (using assistToGoalIdx, not linkedEventIdx)
    const passEventsLinkedToGoal = S.events.filter(e => {
      if (e.type !== 'Pass') return false;
      if (e.assistToGoalIdx === null || e.assistToGoalIdx === undefined) return false;
      return e.assistToGoalIdx === g.idx;
    });
    
    // Combine all linked Pass events
    const allLinkedPasses = [...linkedPassEvents, ...passEventsLinkedToGoal];
    
    // Extract assisters from linked Pass events
    const assistersFromPasses = [];
    allLinkedPasses.forEach(passEvt => {
      // Check if Pass event has assist markers in player details
      const passAssisters = (passEvt.players || []).filter(p => {
        const pd1 = (p.playD1 || '').toLowerCase();
        const pd2 = (p.playD2 || '').toLowerCase();
        return pd1.includes('assist') || pd2.includes('assist');
      });
      
      // If no assist markers, check primary player (event_player_1) as potential assist
      if (passAssisters.length === 0) {
        const primaryPlayer = passEvt.players?.find(p => 
          p.role === 'event_player_1' || p.role === 'event_team_player_1'
        );
        if (primaryPlayer) {
          // Add as potential assist (will show with ? indicator)
          assistersFromPasses.push({ ...primaryPlayer, source: 'linked_pass', needsMarking: true });
        }
      } else {
        // Add marked assisters
        passAssisters.forEach(a => {
          assistersFromPasses.push({ ...a, source: 'linked_pass', needsMarking: false });
        });
      }
    });
    
    // Combine all assisters (from goal event + from linked Pass events)
    const allAssisters = [
      ...assistersInGoal.map(a => ({ ...a, source: 'goal_event', needsMarking: false })),
      ...assistersFromPasses
    ];
    
    // Remove duplicates by player number
    const uniqueAssisters = [];
    const seenNums = new Set();
    allAssisters.forEach(a => {
      if (a.num && !seenNums.has(a.num)) {
        seenNums.add(a.num);
        uniqueAssisters.push(a);
      }
    });
    
    const scorerNum = scorer?.num || '';
    const scorerName = scorer?.name || '';
    
    // Build assist string with indicators
    let assistStr = 'Unassisted';
    if (uniqueAssisters.length > 0) {
      assistStr = uniqueAssisters.map(a => {
        let display = `#${a.num}`;
        if (a.needsMarking) {
          display += '?'; // Indicates assist from linked Pass but not marked
        }
        if (a.source === 'linked_pass') {
          display += 'üîó'; // Indicates assist from linked Pass event
        }
        return display;
      }).join(', ');
    }
    
    // v6: Check against roster stats
    let rosterMatch = '‚úì';
    if (S.rosterStats && scorerNum) {
      const rosterPlayer = S.rosterStats[scorerNum];
      if (rosterPlayer) {
        // Check if roster shows this player has a goal
        if (rosterPlayer.goals === 0) {
          rosterMatch = '‚ö†Ô∏è';
          warnings.push(`#${scorerNum} ${scorerName} scored but roster shows 0 goals`);
        }
      } else {
        rosterMatch = '?';
        warnings.push(`#${scorerNum} ${scorerName} not found in roster`);
      }
      
      // Check assisters
      uniqueAssisters.forEach(a => {
        const assistRoster = S.rosterStats[a.num];
        if (assistRoster && assistRoster.assists === 0) {
          warnings.push(`#${a.num} has assist but roster shows 0 assists`);
        }
        if (a.needsMarking) {
          warnings.push(`#${a.num} has linked Pass assist but not marked with '%assist%' in play_detail`);
        }
      });
    }
    
    // Warn if goal has linked Pass events but no assists found
    if (allLinkedPasses.length > 0 && uniqueAssisters.length === 0) {
      warnings.push(`Goal #${g.idx} has ${allLinkedPasses.length} linked Pass event(s) but no assists detected`);
    }
    
    return `<tr>
      <td>P${g.period}</td>
      <td>${g.start_time || '--'}</td>
      <td style="color:${g.team === 'home' ? 'var(--home)' : 'var(--away)'};">${g.team === 'home' ? (S.homeTeam || 'HOME') : (S.awayTeam || 'AWAY')}</td>
      <td><strong>#${scorerNum}</strong> ${scorerName}</td>
      <td>${assistStr}</td>
      <td>${rosterMatch}</td>
    </tr>`;
  }).join('') || '<tr><td colspan="6" style="text-align:center;color:var(--muted);">No goals recorded</td></tr>';
  
  // v6: Additional warnings
  if (homeGoals.length !== officialHome) warnings.push(`Home goals off by ${Math.abs(homeGoals.length - officialHome)}`);
  if (awayGoals.length !== officialAway) warnings.push(`Away goals off by ${Math.abs(awayGoals.length - officialAway)}`);
  
  // Check period mismatches
  if (S.officialPeriodGoals) {
    if (S.officialPeriodGoals.home[1] !== '-' && homeP1 !== parseInt(S.officialPeriodGoals.home[1])) {
      warnings.push(`P1 home goals: ${homeP1} tracked vs ${S.officialPeriodGoals.home[1]} official`);
    }
    if (S.officialPeriodGoals.home[2] !== '-' && homeP2 !== parseInt(S.officialPeriodGoals.home[2])) {
      warnings.push(`P2 home goals: ${homeP2} tracked vs ${S.officialPeriodGoals.home[2]} official`);
    }
    if (S.officialPeriodGoals.away[1] !== '-' && awayP1 !== parseInt(S.officialPeriodGoals.away[1])) {
      warnings.push(`P1 away goals: ${awayP1} tracked vs ${S.officialPeriodGoals.away[1]} official`);
    }
    if (S.officialPeriodGoals.away[2] !== '-' && awayP2 !== parseInt(S.officialPeriodGoals.away[2])) {
      warnings.push(`P2 away goals: ${awayP2} tracked vs ${S.officialPeriodGoals.away[2]} official`);
    }
  }
  
  // Goals without scorers
  const goalsWithoutScorer = allGoals.filter(g => !g.players?.find(p => p.role === 'event_player_1'));
  if (goalsWithoutScorer.length > 0) warnings.push(`${goalsWithoutScorer.length} goal(s) missing scorer`);
  
  // v23.8: Calculate player-level assist counts
  const playerAssistCounts = {};
  
  // Count assists from play_detail markers in goal events
  allGoals.forEach(goal => {
    const assistersInGoal = (goal.players || []).filter(p => {
      const pd1 = (p.playD1 || '').toLowerCase();
      const pd2 = (p.playD2 || '').toLowerCase();
      return pd1.includes('assist') || pd2.includes('assist');
    });
    
    assistersInGoal.forEach(a => {
      const num = String(a.num);
      if (!playerAssistCounts[num]) {
        playerAssistCounts[num] = {
          num: num,
          name: a.name || '',
          team: goal.team,
          tracked: 0,
          roster: 0
        };
      }
      playerAssistCounts[num].tracked++;
    });
  });
  
  // Count assists from linked Pass events (v23.8: Count ALL linked Pass events, not just those with markers)
  allGoals.forEach(goal => {
    const passEventsLinkedToGoal = S.events.filter(e => {
      if (e.type !== 'Pass') return false;
      if (e.assistToGoalIdx === null || e.assistToGoalIdx === undefined) return false;
      return e.assistToGoalIdx === goal.idx;
    });
    
    passEventsLinkedToGoal.forEach(passEvt => {
      // Find the passer (event_player_1 or event_team_player_1)
      const passer = passEvt.players?.find(p => 
        p.role === 'event_player_1' || p.role === 'event_team_player_1'
      );
      
      if (passer && passer.num) {
        const num = String(passer.num);
        // Check if already counted for THIS goal via play_detail markers in goal event
        // (to avoid double-counting the same assist)
        const alreadyCountedForThisGoal = (goal.players || []).some(p => 
          String(p.num) === num && 
          ((p.playD1 || '').toLowerCase().includes('assist') || (p.playD2 || '').toLowerCase().includes('assist'))
        );
        
        // Always count linked Pass events as assists (the link itself is proof of assist)
        // Only skip if we've already counted this player for this specific goal
        if (!alreadyCountedForThisGoal) {
          if (!playerAssistCounts[num]) {
            playerAssistCounts[num] = {
              num: num,
              name: passer.name || '',
              team: passEvt.team || goal.team,
              tracked: 0,
              roster: 0
            };
          }
          playerAssistCounts[num].tracked++;
        }
      }
      
      // Note: The passer was already counted above if not already counted via markers
      // This section is for legacy support if there are additional marked assisters
      // (but we've already counted the primary passer above, so this is mostly redundant)
    });
  });
  
  // Get roster assist counts
  if (S.rosterStats) {
    Object.keys(S.rosterStats).forEach(num => {
      const rosterPlayer = S.rosterStats[num];
      if (rosterPlayer.assists > 0) {
        if (!playerAssistCounts[num]) {
          playerAssistCounts[num] = {
            num: num,
            name: rosterPlayer.name || '',
            team: rosterPlayer.team || 'unknown',
            tracked: 0,
            roster: 0
          };
        }
        playerAssistCounts[num].roster = rosterPlayer.assists;
      }
    });
    
    // Also add tracked players to roster comparison
    Object.keys(playerAssistCounts).forEach(num => {
      if (S.rosterStats[num]) {
        playerAssistCounts[num].roster = S.rosterStats[num].assists || 0;
        playerAssistCounts[num].name = playerAssistCounts[num].name || S.rosterStats[num].name || '';
      }
    });
  }
  
  // Render player assist counts table
  const assistCountsList = document.getElementById('verifyAssistCountsList');
  if (assistCountsList) {
    const playersWithAssists = Object.values(playerAssistCounts).filter(p => p.tracked > 0 || p.roster > 0);
    
    if (playersWithAssists.length === 0) {
      assistCountsList.innerHTML = '<tr><td colspan="6" style="text-align:center;color:var(--muted);padding:8px;font-size:9px;">No assists tracked</td></tr>';
    } else {
      // Sort by team, then by tracked assists (desc), then by roster assists (desc)
      playersWithAssists.sort((a, b) => {
        if (a.team !== b.team) return a.team === 'home' ? -1 : 1;
        if (b.tracked !== a.tracked) return b.tracked - a.tracked;
        return b.roster - a.roster;
      });
      
      assistCountsList.innerHTML = playersWithAssists.map(p => {
        const match = p.tracked === p.roster;
        const mismatch = p.tracked !== p.roster;
        const status = match ? '‚úì' : (p.tracked > p.roster ? '‚ö†Ô∏è +' + (p.tracked - p.roster) : '‚ö†Ô∏è -' + (p.roster - p.tracked));
        const statusColor = match ? 'var(--success)' : 'var(--warn)';
        
        if (mismatch) {
          warnings.push(`#${p.num} ${p.name}: ${p.tracked} tracked assist(s) vs ${p.roster} roster assist(s)`);
        }
        
        return `
          <tr style="border-bottom:1px solid var(--border);cursor:pointer;" onclick="showPlayerEvents('${p.num}', '${p.name || ''}')" title="Click to view all events for #${p.num} ${p.name || ''}">
            <td style="padding:4px;font-weight:600;color:var(--${p.team});">#${p.num}</td>
            <td style="padding:4px;">${p.name || 'Unknown'}</td>
            <td style="padding:4px;font-size:8px;color:var(--muted);">${p.team === 'home' ? (S.homeTeam || 'HOME') : (S.awayTeam || 'AWAY')}</td>
            <td style="padding:4px;text-align:center;font-weight:600;">${p.tracked}</td>
            <td style="padding:4px;text-align:center;font-weight:600;">${p.roster}</td>
            <td style="padding:4px;text-align:center;color:${statusColor};font-weight:600;">${status}</td>
          </tr>
        `;
      }).join('');
    }
  }
  
  // v23.8: Count assist detection methods for summary
  let assistsFromPlayDetails = 0;
  let assistsFromLinkedPasses = 0;
  let assistsNeedingMarking = 0;
  allGoals.forEach(g => {
    const assistersInGoal = (g.players || []).filter(p => {
      const pd1 = (p.playD1 || '').toLowerCase();
      const pd2 = (p.playD2 || '').toLowerCase();
      return pd1.includes('assist') || pd2.includes('assist');
    });
    assistsFromPlayDetails += assistersInGoal.length;
    
    const passEventsLinkedToGoal = S.events.filter(e => {
      if (e.type !== 'Pass') return false;
      if (e.assistToGoalIdx === null || e.assistToGoalIdx === undefined) return false;
      return e.assistToGoalIdx === g.idx;
    });
    
    passEventsLinkedToGoal.forEach(passEvt => {
      const passAssisters = (passEvt.players || []).filter(p => {
        const pd1 = (p.playD1 || '').toLowerCase();
        const pd2 = (p.playD2 || '').toLowerCase();
        return pd1.includes('assist') || pd2.includes('assist');
      });
      if (passAssisters.length > 0) {
        assistsFromLinkedPasses += passAssisters.length;
      } else {
        assistsNeedingMarking += 1; // Linked Pass but not marked
      }
    });
  });
  
  // Add summary to warnings if there are linked assists
  if (assistsFromLinkedPasses > 0 || assistsNeedingMarking > 0) {
    const summary = [];
    if (assistsFromPlayDetails > 0) {
      summary.push(`${assistsFromPlayDetails} assist(s) from play_details`);
    }
    if (assistsFromLinkedPasses > 0) {
      summary.push(`${assistsFromLinkedPasses} assist(s) from linked Pass events üîó`);
    }
    if (assistsNeedingMarking > 0) {
      summary.push(`${assistsNeedingMarking} linked Pass event(s) need assist marking`);
    }
    if (summary.length > 0) {
      console.log('Assist verification summary:', summary.join(', '));
    }
  }
  
  // v6: Display warnings in dedicated section
  const warningsEl = document.getElementById('verifyWarnings');
  const warningsListEl = document.getElementById('verifyWarningsList');
  if (warnings.length > 0) {
    warningsEl.style.display = 'block';
    warningsListEl.innerHTML = warnings.map(w => {
      // Extract player number from warning (format: "#XX Name" or "#XX")
      const playerMatch = w.match(/#(\d+)/);
      if (playerMatch) {
        const playerNum = playerMatch[1];
        // Try to extract player name if present
        const nameMatch = w.match(/#\d+\s+([^:]+)/);
        const playerName = nameMatch ? nameMatch[1].trim() : '';
        return `<div style="cursor:pointer;padding:2px 0;" onclick="showPlayerEvents('${playerNum}', '${playerName}')" title="Click to view all events for #${playerNum} ${playerName}">‚Ä¢ ${w}</div>`;
      }
      return `<div>‚Ä¢ ${w}</div>`;
    }).join('');
  } else {
    warningsEl.style.display = 'none';
  }
}

// ============================================================
// LOAD EXISTING GAME
// ============================================================
function openLoadGameModal() {
  if (!S.connected) {
    toast('Connect to Supabase first', 'error');
    return;
  }
  populateLoadGameSelect();
  document.getElementById('loadGameModal').classList.add('show');
}

function closeLoadGameModal() {
  document.getElementById('loadGameModal').classList.remove('show');
}

async function populateLoadGameSelect() {
  const select = document.getElementById('loadGameSelect');
  select.innerHTML = '<option value="">Loading tracked games...</option>';
  
  try {
    // Paginate through fact_events to get ALL game_ids
    console.log('Load modal: Querying fact_events...');
    const allGameIds = new Set();
    let offset = 0;
    const pageSize = 1000;
    let hasMore = true;
    
    while (hasMore && offset < 50000) {
      const { data, error } = await S.sb.from('fact_events')
        .select('game_id')
        .range(offset, offset + pageSize - 1);
      
      if (error) break;
      if (!data || data.length === 0) {
        hasMore = false;
      } else {
        data.forEach(r => allGameIds.add(r.game_id));
        offset += pageSize;
        if (data.length < pageSize) hasMore = false;
      }
    }
    
    const trackedGameIds = Array.from(allGameIds);
    console.log('Load modal: Found game IDs:', trackedGameIds);
    
    if (trackedGameIds.length === 0) {
      select.innerHTML = '<option value="">No tracked games found</option>';
      return;
    }
    
    // Get game details for tracked games
    const { data: games } = await S.sb.from('dim_schedule')
      .select('game_id,date,home_team_name,away_team_name')
      .in('game_id', trackedGameIds)
      .order('date', { ascending: false });
    
    console.log('Load modal: Schedule returned', games?.length, 'rows');
    
    // Dedupe
    const seen = new Set();
    const uniqueGames = (games || []).filter(g => {
      if (seen.has(g.game_id)) return false;
      seen.add(g.game_id);
      return true;
    });
    
    select.innerHTML = '<option value="">Select tracked game (' + uniqueGames.length + ')</option>' + 
      uniqueGames.map(g => `<option value="${g.game_id}">${g.game_id} - ${g.date?.split('T')[0]} ${g.home_team_name} vs ${g.away_team_name}</option>`).join('');
      
    console.log('Load game modal:', uniqueGames.length, 'tracked games');
  } catch(e) {
    toast('Failed to load games', 'error');
    console.error(e);
  }
}

async function previewLoadGame() {
  const gameId = document.getElementById('loadGameSelect').value;
  if (!gameId) {
    document.getElementById('loadPreviewEvents').textContent = '--';
    document.getElementById('loadPreviewShifts').textContent = '--';
    return;
  }
  
  try {
    const { count: evtCount } = await S.sb.from('fact_events').select('*', { count: 'exact', head: true }).eq('game_id', gameId);
    const { count: shiftCount } = await S.sb.from('fact_shifts').select('*', { count: 'exact', head: true }).eq('game_id', gameId);
    
    document.getElementById('loadPreviewEvents').textContent = evtCount || 0;
    document.getElementById('loadPreviewShifts').textContent = shiftCount || 0;
  } catch(e) {
    console.error(e);
  }
}

async function confirmLoadGame() {
  const gameId = document.getElementById('loadGameSelect').value;
  if (!gameId) { toast('Select a game', 'error'); return; }
  
  // v23.8: Don't prompt for save directory automatically (requires user gesture)
  // User can select it manually from Settings if desired
  
  try {
    toast('Loading game data from Supabase...', 'info');
    console.log('=== LOADING GAME:', gameId, '===');
    
    // First set the game ID and find game info
    S.gameId = parseInt(gameId);
    const g = S.games.find(x => x.game_id == gameId);
    if (g) {
      S.homeTeam = g.home_team_name;
      S.awayTeam = g.away_team_name;
      console.log('Game info:', S.homeTeam, 'vs', S.awayTeam);
      
      // v16: Load team colors and logos from S.teams (loaded in loadReferenceData)
      const homeTeamData = S.teams[S.homeTeam] || {};
      const awayTeamData = S.teams[S.awayTeam] || {};
      S.homeColor = homeTeamData.color1 || '#3b82f6';
      S.awayColor = awayTeamData.color1 || '#ef4444';
      S.homeLogo = homeTeamData.logo || null;
      S.awayLogo = awayTeamData.logo || null;
      console.log('Team colors:', S.homeColor, S.awayColor);
      console.log('Team logos:', S.homeLogo, S.awayLogo);
      
      // v16: Apply team colors to CSS variables
      document.documentElement.style.setProperty('--home', S.homeColor);
      document.documentElement.style.setProperty('--away', S.awayColor);
      
      // v16: Update UI labels with team names (not Home/Away)
      document.getElementById('homeLbl').textContent = S.homeTeam;
      document.getElementById('awayLbl').textContent = S.awayTeam;
      document.getElementById('evtHomeLbl').textContent = S.homeTeam;
      document.getElementById('evtAwayLbl').textContent = S.awayTeam;
      
      // v16: Update team logos if available
      updateTeamLogos();
      updateZoneLabels();
    }
    
    // Update the main game dropdown
    document.getElementById('gameSelect').value = gameId;
    
    // Load events with pagination (Supabase 1000 row limit)
    console.log('Loading events...');
    let allEvents = [];
    let offset = 0;
    let hasMore = true;
    
    while (hasMore) {
      const { data, error } = await S.sb.from('fact_events')
        .select('*')
        .eq('game_id', gameId)
        .order('event_id')
        .range(offset, offset + 999);
      
      if (error) {
        console.error('Event load error:', error);
        throw error;
      }
      
      if (!data || data.length === 0) {
        hasMore = false;
      } else {
        allEvents = allEvents.concat(data);
        console.log(`  Events page: ${data.length} (total: ${allEvents.length})`);
        offset += 1000;
        if (data.length < 1000) hasMore = false;
      }
    }
    console.log('Total events loaded:', allEvents.length);
    
    // Load shifts with pagination
    console.log('Loading shifts...');
    let allShifts = [];
    offset = 0;
    hasMore = true;
    
    while (hasMore) {
      const { data, error } = await S.sb.from('fact_shifts')
        .select('*')
        .eq('game_id', gameId)
        .order('shift_index')
        .range(offset, offset + 999);
      
      if (error) {
        console.error('Shift load error:', error);
        throw error;
      }
      
      if (!data || data.length === 0) {
        hasMore = false;
      } else {
        allShifts = allShifts.concat(data);
        console.log(`  Shifts page: ${data.length} (total: ${allShifts.length})`);
        offset += 1000;
        if (data.length < 1000) hasMore = false;
      }
    }
    console.log('Total shifts loaded:', allShifts.length);
    
    // Load event players for player details
    console.log('Loading event players...');
    let allPlayers = [];
    offset = 0;
    hasMore = true;
    
    while (hasMore) {
      const { data, error } = await S.sb.from('fact_event_players')
        .select('*')
        .eq('game_id', gameId)
        .range(offset, offset + 999);
      
      if (error) {
        console.error('Player load error:', error);
        throw error;
      }
      
      if (!data || data.length === 0) {
        hasMore = false;
      } else {
        allPlayers = allPlayers.concat(data);
        console.log(`  Players page: ${data.length} (total: ${allPlayers.length})`);
        offset += 1000;
        if (data.length < 1000) hasMore = false;
      }
    }
    console.log('Total player rows loaded:', allPlayers.length);
    
    // v16.02: Debug - log column names from first player row
    if (allPlayers.length > 0) {
      console.log('Player columns:', Object.keys(allPlayers[0]));
      // Find a player with play_detail data for debugging
      const playerWithPD = allPlayers.find(p => p.play_detail1 || p.play_detail_1 || p['play_detail1']);
      if (playerWithPD) {
        console.log('Sample player with play_detail:', {
          event_id: playerWithPD.event_id,
          player_game_number: playerWithPD.player_game_number,
          play_detail1: playerWithPD.play_detail1,
          'play_detail_1': playerWithPD.play_detail_1,
          play_detail_2: playerWithPD.play_detail_2,
          'play_detail2': playerWithPD.play_detail2
        });
      } else {
        console.log('No players with play_detail found in sample');
        // Log first 3 players to see all fields
        console.log('First 3 players:', allPlayers.slice(0, 3).map(p => ({...p})));
      }
    }
    
    // Group players by event_id
    const playersByEvent = {};
    allPlayers.forEach(p => {
      const evtId = p.event_id;
      if (!playersByEvent[evtId]) playersByEvent[evtId] = [];
      playersByEvent[evtId].push(p);
    });
    console.log('Events with players:', Object.keys(playersByEvent).length);
    
    // Convert events to tracker format
    console.log('Converting events to tracker format...');
    S.events = allEvents.map((e, i) => {
      const evtPlayers = playersByEvent[e.event_id] || [];
      
      // v15: Fix team loading - use player_team from event_player_1, compare to home_team
      // The team_venue column in fact_events is unreliable (often all 'Away')
      // Instead, find the event_player_1 and check their player_team vs home_team
      let isHome = false;
      const eventPlayer1 = evtPlayers.find(p => 
        p.player_role === 'event_player_1' || p.player_role === 'event_team_player_1'
      );
      if (eventPlayer1) {
        // Compare player_team to home_team to determine if home or away
        isHome = eventPlayer1.player_team === e.home_team || eventPlayer1.player_team === S.homeTeam;
      } else {
        // Fallback: try team_venue but normalize case
        const teamVenue = (e.team_venue || e.team || '').toLowerCase();
        isHome = teamVenue === 'home' || teamVenue === 'h';
      }
      
      return {
        idx: i + 1,
        eventId: e.event_id,
        game_id: e.game_id,
        period: e.period,
        start_time: `${e.event_start_min || 0}:${String(e.event_start_sec || 0).padStart(2, '0')}`,
        end_time: `${e.event_end_min || e.event_start_min || 0}:${String(e.event_end_sec || e.event_start_sec || 0).padStart(2, '0')}`,
        team: isHome ? 'home' : 'away',
        type: e.event_type,
        detail1: e.event_detail,
        detail2: e.event_detail_2,
        zone: e.event_team_zone?.charAt(0).toLowerCase() || '',
        success: e.event_successful,
        strength: e.strength || '5v5',
        isHighlight: e.is_highlight === 1 || e.is_highlight === true,
        linkedEventIdx: e.linked_event_key || null,
        assistToGoalIdx: e.assist_to_goal_index ? (parseInt(e.assist_to_goal_index) - 1000) : (e.assist_to_goal_index_flag_ ? parseInt(e.assist_to_goal_index_flag_) - 1 : null), // v23.8: Separate column for assists
        sequenceIdx: e.sequence_key || null,
        playIdx: e.play_key || null,
        puckXY: (e.puck_x_start != null && e.puck_y_start != null) ? 
          [{ x: e.puck_x_start, y: e.puck_y_start }] : [],
        // v23.5: Load net target XY if available
        netXY: (e.net_x != null && e.net_y != null) ? 
          { x: e.net_x, y: e.net_y } : null,
        players: evtPlayers.map(p => {
          // v16.02: Debug play_detail mapping
          const pd1 = p.play_detail1 || p.play_detail_1 || p.player_play_detail_1 || '';
          const pd2 = p.play_detail_2 || p.play_detail2 || p.player_play_detail_2 || '';
          // v16.03: Target debug for specific event/player
          if (e.event_id === 'EV1896901058' || (pd1 && pd1.toLowerCase().includes('forced'))) {
            console.log(`üéØ TARGET DEBUG - Event ${e.event_id}, Player #${p.player_game_number}:`);
            console.log('  Raw play_detail1:', p.play_detail1);
            console.log('  Raw play_detail_2:', p.play_detail_2);
            console.log('  Mapped pd1:', pd1);
            console.log('  Mapped pd2:', pd2);
          }
          return {
          num: String(p.player_game_number || ''),
          name: p.player_name || '',
          role: p.player_role || 'event_team_player_1',
          roleNum: p.role_number || 1,
          // v16.02: Enhanced column checking with debug
          playD1: pd1,
          playD2: pd2,
          playSuccess: p.play_detail_successful || p.play_successful || '',
          pressure: p.pressured_pressurer || '',
          sideOfPuck: p.side_of_puck || '',
          teamVenue: p.team_venue || '',
          xy: (p.player_x != null && p.player_y != null) ? 
            [{ x: p.player_x, y: p.player_y }] : []
        };})
      };
    });
    console.log('Converted', S.events.length, 'events');
    
    // v16.03: Debug summary - count events with play_detail data
    const eventsWithPD = S.events.filter(e => e.players?.some(p => p.playD1 || p.playD2));
    console.log(`Events with play_detail data: ${eventsWithPD.length}/${S.events.length}`);
    if (eventsWithPD.length > 0) {
      console.log('Sample events with PD:', eventsWithPD.slice(0, 5).map(e => ({
        eventId: e.eventId,
        type: e.type,
        players: e.players?.map(p => ({ num: p.num, playD1: p.playD1, playD2: p.playD2 }))
      })));
    }
    // Check for specific event
    const targetEvent = S.events.find(e => e.eventId === 'EV1896901058');
    if (targetEvent) {
      console.log('üéØ Found EV1896901058:', targetEvent);
    } else {
      console.log('‚ö†Ô∏è EV1896901058 not found in loaded events');
    }
    
    // Convert shifts to tracker format
    console.log('Converting shifts to tracker format...');
    S.shifts = allShifts.map((sh, i) => ({
      idx: i + 1,
      shiftId: sh.shift_id,
      period: sh.period,
      start_time: `${sh.shift_start_min || 0}:${String(sh.shift_start_sec || 0).padStart(2, '0')}`,
      end_time: `${sh.shift_end_min || 0}:${String(sh.shift_end_sec || 0).padStart(2, '0')}`,
      start_type: sh.shift_start_type || 'OnTheFly',  // v17: Fixed to match LISTS format
      stop_type: sh.shift_stop_type || 'OnTheFly',    // v17: Fixed to match LISTS format
      strength: sh.strength || '5v5',
      stoppageTime: sh.stoppage_time || 0,
      home: {
        F1: sh.home_forward_1 ? { num: String(sh.home_forward_1) } : null,
        F2: sh.home_forward_2 ? { num: String(sh.home_forward_2) } : null,
        F3: sh.home_forward_3 ? { num: String(sh.home_forward_3) } : null,
        D1: sh.home_defense_1 ? { num: String(sh.home_defense_1) } : null,
        D2: sh.home_defense_2 ? { num: String(sh.home_defense_2) } : null,
        G: sh.home_goalie ? { num: String(sh.home_goalie) } : null,
        X: sh.home_xtra ? { num: String(sh.home_xtra) } : null
      },
      away: {
        F1: sh.away_forward_1 ? { num: String(sh.away_forward_1) } : null,
        F2: sh.away_forward_2 ? { num: String(sh.away_forward_2) } : null,
        F3: sh.away_forward_3 ? { num: String(sh.away_forward_3) } : null,
        D1: sh.away_defense_1 ? { num: String(sh.away_defense_1) } : null,
        D2: sh.away_defense_2 ? { num: String(sh.away_defense_2) } : null,
        G: sh.away_goalie ? { num: String(sh.away_goalie) } : null,
        X: sh.away_xtra ? { num: String(sh.away_xtra) } : null
      }
    }));
    console.log('Converted', S.shifts.length, 'shifts');
    
    S.evtIdx = S.events.length;
    S.shiftIdx = S.shifts.length;
    
    // Load rosters
    console.log('Loading rosters...');
    await loadRosters(gameId);
    
    // Close modal and render everything
    closeLoadGameModal();
    
    // v23.8: Process all goals to detect and link assists after loading from Supabase
    if (S.events && S.events.length > 0) {
      processAllGoalsForAssists();
      
      // v23.8: Auto-mark all Goal events as highlights
      const goals = S.events.filter(e => e.type === 'Goal' && e.detail1 === 'Goal_Scored');
      goals.forEach(goal => {
        if (!goal.isHighlight) {
          goal.isHighlight = true;
        }
      });
    }
    
    // Full render
    console.log('Rendering UI...');
    renderAll();
    renderRosters();
    renderEvents();
    renderShiftLog();
    updateScores();
    updateBoxScore();
    
    // Update localStorage
    localStorage.setItem('bs_lastGame', gameId);
    
    // v23.8: Show video URL entry modal for goals if any exist and don't have URLs
    if (S.events && S.events.length > 0) {
      const goalsWithoutUrls = S.events.filter(e => 
        e.type === 'Goal' && 
        e.detail1 === 'Goal_Scored' && 
        (!e.videoUrl || e.videoUrl.trim() === '')
      );
      if (goalsWithoutUrls.length > 0) {
        setTimeout(() => {
          showGoalVideoUrlsModal(goalsWithoutUrls);
        }, 1000);
      }
    }
    
    toast(`‚úÖ Loaded ${S.events.length} events, ${S.shifts.length} shifts`, 'success');
    console.log('=== LOAD COMPLETE ===');
    
  } catch(e) {
    toast('Failed to load game: ' + e.message, 'error');
    console.error('Load game error:', e);
  }
}

// ============================================================
// CLEAR ALL DATA
// ============================================================
function clearAllData() {
  if (!confirm('‚ö†Ô∏è Clear ALL events and shifts for this game?\n\nThis cannot be undone!')) return;
  if (!confirm('Are you REALLY sure? All tracking data will be lost.')) return;
  
  S.events = [];
  S.shifts = [];
  S.evtIdx = 0;
  S.shiftIdx = 0;
  S.lastSave = null;
  
  // Clear localStorage
  if (S.gameId) {
    localStorage.removeItem(`bs_${S.gameId}`);
  }
  
  renderAll();
  updateScores();
  updateBoxScore();
  
  toast('All data cleared', 'success');
  closeSettings();
}

/**
 * Clear all events (with confirmation)
 */
function clearAllEvents() {
  if (S.events.length === 0) {
    toast('No events to clear', 'info');
    return;
  }
  if (!confirm(`‚ö†Ô∏è Clear ALL ${S.events.length} events?\n\nThis cannot be undone!`)) return;
  
  S.events = [];
  S.evtIdx = 0;
  
  renderEvents();
  updateScores();
  updateBoxScore();
  renderMarkers();
  autoSave();
  
  toast(`Cleared all events`, 'success');
}

/**
 * Clear all shifts (with confirmation)
 */
function clearAllShifts() {
  if (S.shifts.length === 0) {
    toast('No shifts to clear', 'info');
    return;
  }
  if (!confirm(`‚ö†Ô∏è Clear ALL ${S.shifts.length} shifts?\n\nThis cannot be undone!`)) return;
  
  S.shifts = [];
  S.shiftIdx = 0;
  
  renderShiftLog();
  updateBoxScore();
  autoSave();
  
  toast(`Cleared all shifts`, 'success');
}

// ============================================================
// LINKED EVENT LOGIC
// ============================================================
function applyLinkedEventData() {
  // Copy XY data from linked event chain to current event
  // This applies to ALL linked event types
  if (S.linkedEventIdx === null && S.linkedEventIdx !== 0) return;
  
  const currType = S.curr.type;
  
  // ============================================================
  // FIND THE BEST SOURCE FOR XY DATA
  // Priority: 1) Most recent sibling (same linked_event), 2) Source event, 3) Previous event
  // ============================================================
  
  let sourceEvt = null;
  let sourceDesc = '';
  
  // 1. Check for sibling events (same linked_event) - get the most recent one with XY
  const siblings = S.events
    .filter(e => e.linkedEventIdx === S.linkedEventIdx && e.puckXY?.length)
    .sort((a, b) => b.idx - a.idx); // Most recent first
  
  if (siblings.length > 0) {
    sourceEvt = siblings[0];
    sourceDesc = `sibling #${sourceEvt.idx + 1} (${sourceEvt.type})`;
  }
  
  // 2. If no sibling has XY, check the source event itself
  if (!sourceEvt) {
    const linkedEvt = S.events.find(e => e.idx === S.linkedEventIdx);
    if (linkedEvt?.puckXY?.length) {
      sourceEvt = linkedEvt;
      sourceDesc = `source #${linkedEvt.idx + 1} (${linkedEvt.type})`;
    }
  }
  
  // 3. If still no XY, check the most recent event (regardless of linked_event)
  if (!sourceEvt && S.events.length > 0) {
    const lastEvt = S.events[S.events.length - 1];
    if (lastEvt?.puckXY?.length) {
      sourceEvt = lastEvt;
      sourceDesc = `previous #${lastEvt.idx + 1} (${lastEvt.type})`;
    }
  }
  
  // If no source found with XY, just copy zone from linked event
  if (!sourceEvt) {
    const linkedEvt = S.events.find(e => e.idx === S.linkedEventIdx);
    if (linkedEvt?.zone) {
      document.getElementById('evtZone').value = linkedEvt.zone;
    }
    toast(`Linked to #${S.linkedEventIdx + 1} (no XY to copy)`, 'info');
    return;
  }
  
  // ============================================================
  // COPY ALL XY DATA FROM SOURCE
  // ============================================================
  
  // Copy puck XY
  if (sourceEvt.puckXY?.length) {
    S.curr.puckXY = JSON.parse(JSON.stringify(sourceEvt.puckXY));
  }
  
  // Copy net XY if available
  if (sourceEvt.netXY) {
    S.curr.netXY = JSON.parse(JSON.stringify(sourceEvt.netXY));
  }
  
  // Copy ALL player positions from source event
  if (sourceEvt.players?.length) {
    // Determine if teams should swap roles (e.g., Shot‚ÜíSave)
    const shouldSwapTeams = (
      (currType === 'Save' && sourceEvt.type === 'Shot') ||
      (currType === 'Block' && sourceEvt.type === 'Shot')
    );
    
    sourceEvt.players.forEach(srcPlayer => {
      // Deep copy the player
      const newPlayer = JSON.parse(JSON.stringify(srcPlayer));
      
      // Map role if teams should swap
      if (shouldSwapTeams && newPlayer.role) {
        if (newPlayer.role.includes('event_team')) {
          newPlayer.role = newPlayer.role.replace('event_team', 'opp_team');
        } else if (newPlayer.role.includes('opp_team')) {
          newPlayer.role = newPlayer.role.replace('opp_team', 'event_team');
        }
      }
      
      // Check if this player already exists in current event
      const existingIdx = S.curr.players.findIndex(p => 
        p.num === newPlayer.num && p.team === newPlayer.team
      );
      
      if (existingIdx >= 0) {
        // Merge XY data into existing player
        if (newPlayer.xy?.length) {
          S.curr.players[existingIdx].xy = newPlayer.xy;
        }
      } else {
        // Add player with XY
        S.curr.players.push(newPlayer);
      }
    });
  }
  
  // Copy zone from source or linked event
  const zoneSource = sourceEvt.zone || S.events.find(e => e.idx === S.linkedEventIdx)?.zone;
  if (zoneSource) {
    document.getElementById('evtZone').value = zoneSource;
  }
  
  // Re-render to show copied data
  renderQuickAdd();
  renderMarkers();
  
  // Show confirmation
  toast(`Copied XY from ${sourceDesc}`, 'info');
}

// ============================================================
// EDIT SHIFT PLAYERS
// ============================================================
function editShiftPlayers(shiftIdx) {
  S.editingShiftIdx = shiftIdx;
  const shift = S.shifts[shiftIdx];
  if (!shift) return;
  
  // Open edit shift modal with player editing capability
  document.getElementById('editShiftIdx').textContent = shiftIdx + 1;
  document.getElementById('editShiftPeriod').value = shift.period;
  document.getElementById('editShiftStartTime').value = shift.start_time || '';
  document.getElementById('editShiftEndTime').value = shift.end_time || '';
  document.getElementById('editShiftStartType').value = shift.start_type || '';
  document.getElementById('editShiftStopType').value = shift.stop_type || '';
  document.getElementById('editShiftStrength').value = shift.strength || '5v5';
  
  // Render player slots in edit modal
  renderEditShiftPlayers(shift);
  
  document.getElementById('editShiftModal').classList.add('show');
}

function renderEditShiftPlayers(shift) {
  const container = document.getElementById('editShiftPlayersContainer');
  if (!container) return;
  
  // Build player options for each team
  const buildPlayerOptions = (team, currentNum) => {
    const roster = S.rosters[team] || [];
    // Convert currentNum to string for comparison (Excel imports as number, roster might be string)
    const currentNumStr = currentNum != null ? String(currentNum) : '';
    
    // If roster is empty but we have a current number, show it as an option
    if (roster.length === 0 && currentNumStr) {
      return `<option value="">--</option><option value="${currentNumStr}" selected>#${currentNumStr}</option>`;
    }
    
    return `<option value="">--</option>` + roster.map(p => {
      const numStr = String(p.num);
      const selected = numStr === currentNumStr ? 'selected' : '';
      return `<option value="${numStr}" ${selected}>#${p.num} ${p.name?.split(' ').pop() || ''}</option>`;
    }).join('');
  };
  
  let html = '<div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;">';
  
  // Home players
  html += `<div>
    <div style="font-size:10px;font-weight:bold;color:var(--home);margin-bottom:6px;border-bottom:1px solid var(--home);padding-bottom:2px;">HOME</div>
    <div style="display:grid;gap:4px;">`;
  
  // Forwards
  html += `<div style="font-size:8px;color:var(--muted);margin-top:4px;">Forwards</div>`;
  ['F1','F2','F3'].forEach(pos => {
    const p = shift.home?.[pos];
    html += `<div style="display:flex;align-items:center;gap:4px;">
      <span style="width:20px;font-size:9px;color:var(--accent);">${pos}</span>
      <select onchange="updateShiftPlayer('home','${pos}',this.value)" style="flex:1;font-size:9px;padding:2px;">
        ${buildPlayerOptions('home', p?.num)}
      </select>
    </div>`;
  });
  
  // Defense
  html += `<div style="font-size:8px;color:var(--muted);margin-top:4px;">Defense</div>`;
  ['D1','D2'].forEach(pos => {
    const p = shift.home?.[pos];
    html += `<div style="display:flex;align-items:center;gap:4px;">
      <span style="width:20px;font-size:9px;color:var(--accent);">${pos}</span>
      <select onchange="updateShiftPlayer('home','${pos}',this.value)" style="flex:1;font-size:9px;padding:2px;">
        ${buildPlayerOptions('home', p?.num)}
      </select>
    </div>`;
  });
  
  // Goalie & Extra
  html += `<div style="font-size:8px;color:var(--muted);margin-top:4px;">Goalie / Extra</div>`;
  ['G','X'].forEach(pos => {
    const p = shift.home?.[pos];
    html += `<div style="display:flex;align-items:center;gap:4px;">
      <span style="width:20px;font-size:9px;color:var(--accent);">${pos}</span>
      <select onchange="updateShiftPlayer('home','${pos}',this.value)" style="flex:1;font-size:9px;padding:2px;">
        ${buildPlayerOptions('home', p?.num)}
      </select>
    </div>`;
  });
  
  html += '</div></div>';
  
  // Away players  
  html += `<div>
    <div style="font-size:10px;font-weight:bold;color:var(--away);margin-bottom:6px;border-bottom:1px solid var(--away);padding-bottom:2px;">AWAY</div>
    <div style="display:grid;gap:4px;">`;
  
  // Forwards
  html += `<div style="font-size:8px;color:var(--muted);margin-top:4px;">Forwards</div>`;
  ['F1','F2','F3'].forEach(pos => {
    const p = shift.away?.[pos];
    html += `<div style="display:flex;align-items:center;gap:4px;">
      <span style="width:20px;font-size:9px;color:var(--accent);">${pos}</span>
      <select onchange="updateShiftPlayer('away','${pos}',this.value)" style="flex:1;font-size:9px;padding:2px;">
        ${buildPlayerOptions('away', p?.num)}
      </select>
    </div>`;
  });
  
  // Defense
  html += `<div style="font-size:8px;color:var(--muted);margin-top:4px;">Defense</div>`;
  ['D1','D2'].forEach(pos => {
    const p = shift.away?.[pos];
    html += `<div style="display:flex;align-items:center;gap:4px;">
      <span style="width:20px;font-size:9px;color:var(--accent);">${pos}</span>
      <select onchange="updateShiftPlayer('away','${pos}',this.value)" style="flex:1;font-size:9px;padding:2px;">
        ${buildPlayerOptions('away', p?.num)}
      </select>
    </div>`;
  });
  
  // Goalie & Extra
  html += `<div style="font-size:8px;color:var(--muted);margin-top:4px;">Goalie / Extra</div>`;
  ['G','X'].forEach(pos => {
    const p = shift.away?.[pos];
    html += `<div style="display:flex;align-items:center;gap:4px;">
      <span style="width:20px;font-size:9px;color:var(--accent);">${pos}</span>
      <select onchange="updateShiftPlayer('away','${pos}',this.value)" style="flex:1;font-size:9px;padding:2px;">
        ${buildPlayerOptions('away', p?.num)}
      </select>
    </div>`;
  });
  
  html += '</div></div></div>';
  
  container.innerHTML = html;
}

/**
 * Update a player in the shift being edited
 */
function updateShiftPlayer(team, pos, playerNum) {
  if (S.editingShiftIdx === null) return;
  const shift = S.shifts[S.editingShiftIdx];
  
  if (!shift[team]) shift[team] = {};
  
  if (playerNum) {
    // Find player in roster
    const roster = S.rosters[team] || [];
    const player = roster.find(p => p.num === playerNum);
    shift[team][pos] = player ? { num: player.num, name: player.name } : { num: playerNum };
  } else {
    shift[team][pos] = null;
  }
  
  // Update strength
  shift.strength = deriveStrengthFromShift(shift);
  document.getElementById('editShiftStrength').value = shift.strength;
}

/**
 * Derive strength from shift player counts
 */
function deriveStrengthFromShift(shift) {
  const countPlayers = (team) => {
    let count = 0;
    ['F1','F2','F3','D1','D2','X'].forEach(pos => {
      if (shift[team]?.[pos]?.num) count++;
    });
    return count;
  };
  
  const homeSkaters = countPlayers('home');
  const awaySkaters = countPlayers('away');
  
  // Check for empty net
  const homeEN = !shift.home?.G?.num;
  const awayEN = !shift.away?.G?.num;
  
  if (homeEN || awayEN) return 'ENG';
  if (homeSkaters === awaySkaters) return `${homeSkaters}v${awaySkaters}`;
  return `${homeSkaters}v${awaySkaters}`;
}

// ============================================================
// RENDER ALL (utility)
// ============================================================
// (renderAll is defined earlier - this is a comment placeholder)
// ============================================================

// ============================================================
// EDIT MODAL AUTO-CALCULATE FUNCTIONS
// ============================================================

/**
 * Auto-calculate zone from event's puckXY or player XY
 */
function autoEditZone() {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  
  // Get XY from puckXY or event_player_1
  let lastXY = null;
  if (evt.puckXY?.length) {
    lastXY = evt.puckXY[evt.puckXY.length - 1];
  } else {
    const evtP1 = (evt.players || []).find(p => 
      p.role === 'event_team_player_1' || p.role === 'event_player_1' || p.roleNum === 1
    );
    if (evtP1?.xy?.length) {
      lastXY = evtP1.xy[evtP1.xy.length - 1];
    }
  }
  
  if (!lastXY) {
    toast('Add XY coordinates to auto-detect zone', 'error');
    return;
  }
  
  // Calculate zone from X position
  const x = lastXY.x;
  const period = evt.period || 1;
  const isOddPeriod = period === 1 || period === 3 || period === 'OT';
  const homeOffensiveRight = isOddPeriod ? S.homeAttacksRightP1 : !S.homeAttacksRightP1;
  const team = evt.team || 'home';
  
  let zone = '';
  if (team === 'home') {
    if (homeOffensiveRight) {
      if (x > 125) zone = 'o';
      else if (x < 75) zone = 'd';
      else zone = 'n';
    } else {
      if (x < 75) zone = 'o';
      else if (x > 125) zone = 'd';
      else zone = 'n';
    }
  } else {
    if (homeOffensiveRight) {
      if (x < 75) zone = 'o';
      else if (x > 125) zone = 'd';
      else zone = 'n';
    } else {
      if (x > 125) zone = 'o';
      else if (x < 75) zone = 'd';
      else zone = 'n';
    }
  }
  
  document.getElementById('editZone').value = zone;
  toast(`Zone: ${zone === 'o' ? 'Offensive' : zone === 'd' ? 'Defensive' : 'Neutral'}`, 'success');
}

/**
 * Auto-calculate success from event type and detail
 */
function autoEditSuccess() {
  if (S.editingEvtIdx === null) return;
  
  const type = document.getElementById('editType').value;
  const d1 = document.getElementById('editD1').value;
  
  let success = '';
  
  if (type === 'Shot') {
    if (d1.includes('OnNet') || d1.includes('Goal')) success = 's';
    else if (d1.includes('Missed') || d1.includes('Blocked')) success = 'u';
  } else if (type === 'Pass') {
    if (d1.includes('Completed')) success = 's';
    else if (d1.includes('Missed') || d1.includes('Intercepted')) success = 'u';
  } else if (type === 'Zone_Entry_Exit') {
    if (d1.includes('Failed')) success = 'u';
    else if (d1.includes('Entry') || d1.includes('Exit') || d1.includes('Keepin')) success = 's';
  } else if (type === 'Turnover') {
    if (d1.includes('Takeaway')) success = 's';
    else if (d1.includes('Giveaway')) success = 'u';
  } else if (type === 'Goal' || type === 'Save') {
    success = 's';
  } else if (type === 'Faceoff') {
    if (d1.includes('Won')) success = 's';
    else if (d1.includes('Lost')) success = 'u';
  }
  
  if (success) {
    document.getElementById('editSuccess').value = success;
    toast(`Success: ${success === 's' ? 'Successful' : 'Unsuccessful'}`, 'success');
  } else {
    toast('Could not auto-derive success from type/detail', 'warning');
  }
}

/**
 * Auto-calculate strength from shift at event time
 */
function autoEditStrength() {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  
  // Find the shift that contains this event's time
  const eventTime = evt.start_time || evt.time;
  const eventPeriod = evt.period;
  
  const shift = S.shifts.find(s => 
    s.period === eventPeriod && isTimeBetween(eventTime, s.start_time, s.end_time)
  );
  
  if (shift) {
    const strength = deriveStrengthFromShift(shift);
    if (strength) {
      document.getElementById('editStrength').value = strength;
      toast(`Strength: ${strength} (from shift)`, 'success');
      return;
    }
  }
  
  // Fallback to current slot configuration
  const strength = deriveStrength();
  if (strength) {
    document.getElementById('editStrength').value = strength;
    toast(`Strength: ${strength} (from current slots)`, 'success');
  } else {
    toast('Could not determine strength', 'warning');
  }
}

function saveEditEvent() {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  
  evt.type = document.getElementById('editType').value;
  evt.team = document.getElementById('editTeam').value;
  evt.start_time = document.getElementById('editStartTime').value;
  evt.end_time = document.getElementById('editEndTime').value;
  evt.zone = document.getElementById('editZone').value;
  evt.success = document.getElementById('editSuccess').value;
  evt.strength = document.getElementById('editStrength').value;
  evt.detail1 = document.getElementById('editD1').value;
  evt.detail2 = document.getElementById('editD2').value;
  evt.isHighlight = document.getElementById('editHighlight').checked;
  evt.videoUrl = evt.isHighlight ? (document.getElementById('editVideoUrl').value.trim() || undefined) : undefined;  // v23.7: Individual highlight video URL
  
  // Save linked event index (convert from 1-based to 0-based)
  const linkedIdxEl = document.getElementById('editLinkedIdx');
  if (linkedIdxEl) {
    const linkedVal = linkedIdxEl.value ? parseInt(linkedIdxEl.value) - 1 : null;
    evt.linkedEventIdx = (linkedVal !== null && linkedVal >= 0) ? linkedVal : null;
  }
  
  // v23.8: Save assist-to-goal link (convert from 1-based to 0-based)
  const assistToGoalEl = document.getElementById('editAssistToGoalIdx');
  if (assistToGoalEl && assistToGoalEl.offsetParent !== null) { // Only if visible
    const goalVal = assistToGoalEl.value ? parseInt(assistToGoalEl.value) - 1 : null;
    if (goalVal !== null && goalVal >= 0) {
      const goalEvent = S.events[goalVal];
      if (goalEvent && goalEvent.type === 'Goal' && goalEvent.detail1 === 'Goal_Scored') {
        evt.assistToGoalIdx = goalVal;
        // Also mark as assist if not already marked
        const player = evt.players?.find(p => 
          p.role === 'event_player_1' || p.role === 'event_team_player_1'
        );
        if (player) {
          const pd1 = (player.playD1 || '').toLowerCase();
          const pd2 = (player.playD2 || '').toLowerCase();
          if (!pd1.includes('assist') && !pd2.includes('assist')) {
            player.playD1 = player.playD1 ? player.playD1 + ', AssistPrimary' : 'AssistPrimary';
          }
        }
      } else {
        toast('Invalid goal event number', 'error');
        return;
      }
    } else {
      evt.assistToGoalIdx = null;
    }
  }
  
  // v23.8: Save event_id, sequence_key, and play_key (editable fields)
  const eventIdEl = document.getElementById('editEventId');
  if (eventIdEl) {
    const eventIdVal = eventIdEl.value.trim();
    evt.eventId = eventIdVal || undefined;
    evt.event_id = eventIdVal || undefined; // Support both naming conventions
  }
  
  const seqKeyEl = document.getElementById('editSeqKey');
  if (seqKeyEl) {
    const seqKeyVal = seqKeyEl.value.trim();
    if (seqKeyVal) {
      evt.sequenceIdx = seqKeyVal;
      evt.seqIdx = seqKeyVal;
      evt.sequence_key = seqKeyVal;
      evt.sequence_id = seqKeyVal; // Support sequence_id as well
    } else {
      evt.sequenceIdx = undefined;
      evt.seqIdx = undefined;
      evt.sequence_key = undefined;
      evt.sequence_id = undefined;
    }
  }
  
  const playKeyEl = document.getElementById('editPlayKey');
  if (playKeyEl) {
    const playKeyVal = playKeyEl.value.trim();
    if (playKeyVal) {
      evt.playIdx = playKeyVal;
      evt.play_key = playKeyVal;
      evt.play_id = playKeyVal; // Support play_id as well
    } else {
      evt.playIdx = undefined;
      evt.play_key = undefined;
      evt.play_id = undefined;
    }
  }
  
  closeEditModal();
  renderEvents(); updateScores(); updateBoxScore();
  autoSave();
  toast('Event updated', 'success');
}

function deleteEvent() {
  if (S.editingEvtIdx === null) return;
  if (!confirm('Delete this event?')) return;
  
  S.events.splice(S.editingEvtIdx, 1);
  closeEditModal();
  renderEvents(); updateScores(); updateBoxScore();
  autoSave();
  toast('Event deleted', 'success');
}

/**
 * v20.7: Insert a new event BEFORE the current one
 */
function insertEventBefore() {
  if (S.editingEvtIdx === null) return;
  
  const currentEvt = S.events[S.editingEvtIdx];
  
  // Create new blank event with same context
  const newEvt = {
    period: currentEvt.period,
    team: currentEvt.team,
    type: '',
    detail1: '',
    detail2: '',
    zone: currentEvt.zone || '',
    success: '',
    strength: currentEvt.strength || '5v5',
    start_time: currentEvt.start_time,
    end_time: '',
    players: [],
    puckXY: [],
    linkedEventIdx: null,
    assistToGoalIdx: null, // v23.8: For Pass events that assist a Goal
    isHighlight: false
  };
  
  // Insert at position
  S.events.splice(S.editingEvtIdx, 0, newEvt);
  
  const newIdx = S.editingEvtIdx;
  S.editingEvtIdx = null;
  
  closeEditModal();
  renderEvents(); updateScores(); updateBoxScore();
  autoSave();
  toast(`Inserted event #${newIdx + 1}`, 'success');
  
  // Open the new event for editing
  setTimeout(() => editEvent(newIdx), 100);
}

/**
 * v20.7: Insert a new event AFTER the current one
 */
function insertEventAfter() {
  if (S.editingEvtIdx === null) return;
  
  const currentEvt = S.events[S.editingEvtIdx];
  
  // Create new blank event with same context
  const newEvt = {
    period: currentEvt.period,
    team: currentEvt.team,
    type: '',
    detail1: '',
    detail2: '',
    zone: currentEvt.zone || '',
    success: '',
    strength: currentEvt.strength || '5v5',
    start_time: currentEvt.start_time,
    end_time: '',
    players: [],
    puckXY: [],
    linkedEventIdx: null,
    assistToGoalIdx: null, // v23.8: For Pass events that assist a Goal
    isHighlight: false
  };
  
  // Insert after current position
  const insertIdx = S.editingEvtIdx + 1;
  S.events.splice(insertIdx, 0, newEvt);
  
  S.editingEvtIdx = null;
  
  closeEditModal();
  renderEvents(); updateScores(); updateBoxScore();
  autoSave();
  toast(`Inserted event #${insertIdx + 1}`, 'success');
  
  // Open the new event for editing
  setTimeout(() => editEvent(insertIdx), 100);
}

/**
 * v20.7: Duplicate the current event
 */
function duplicateEvent() {
  if (S.editingEvtIdx === null) return;
  
  const currentEvt = S.events[S.editingEvtIdx];
  
  // Deep clone the event
  const newEvt = JSON.parse(JSON.stringify(currentEvt));
  // Clear linking to avoid confusion
  newEvt.linkedEventIdx = null;
  newEvt.eventId = null;
  newEvt.event_id = null;
  
  // Insert after current position
  const insertIdx = S.editingEvtIdx + 1;
  S.events.splice(insertIdx, 0, newEvt);
  
  S.editingEvtIdx = null;
  
  closeEditModal();
  renderEvents(); updateScores(); updateBoxScore();
  autoSave();
  toast(`Duplicated event ‚Üí #${insertIdx + 1}`, 'success');
  
  // Open the new event for editing
  setTimeout(() => editEvent(insertIdx), 100);
}

/**
 * v20.7: Add a new event at the end of the list
 */
function addNewEvent() {
  const lastEvt = S.events.length > 0 ? S.events[S.events.length - 1] : null;
  
  // Create new blank event
  const newEvt = {
    period: lastEvt ? lastEvt.period : S.period || 1,
    team: S.evtTeam || 'home',
    type: '',
    detail1: '',
    detail2: '',
    zone: '',
    success: '',
    strength: '5v5',
    start_time: lastEvt ? lastEvt.start_time : '',
    end_time: '',
    players: [],
    puckXY: [],
    linkedEventIdx: null,
    assistToGoalIdx: null, // v23.8: For Pass events that assist a Goal
    isHighlight: false
  };
  
  // Add to end
  S.events.push(newEvt);
  const newIdx = S.events.length - 1;
  
  renderEvents(); updateScores(); updateBoxScore();
  autoSave();
  toast(`Added event #${newIdx + 1}`, 'success');
  
  // Open the new event for editing
  setTimeout(() => editEvent(newIdx), 100);
}

/**
 * v23.8: Render assists list in edit modal for Goal events
 */
function renderEditAssists(goalEvent) {
  const container = document.getElementById('editAssistsList');
  if (!container) return;
  
  // Find all Pass events that assist this goal
  const assistPasses = S.events.filter(e => {
    if (e.type !== 'Pass') return false;
    if (e.assistToGoalIdx === null || e.assistToGoalIdx === undefined) return false;
    return e.assistToGoalIdx === goalEvent.idx;
  });
  
  if (assistPasses.length === 0) {
    container.innerHTML = '<div style="font-size:9px;color:var(--muted);padding:8px;text-align:center;">No assists linked</div>';
    return;
  }
  
  // Sort by assist type (primary first) and then by event index
  assistPasses.sort((a, b) => {
    const aType = getAssistType(a);
    const bType = getAssistType(b);
    if (aType !== bType) {
      // Primary (A1) before Secondary (A2)
      if (aType === 'primary') return -1;
      if (bType === 'primary') return 1;
    }
    return a.idx - b.idx;
  });
  
  container.innerHTML = assistPasses.map(pass => {
    const player = pass.players?.find(p => 
      p.role === 'event_player_1' || p.role === 'event_team_player_1'
    );
    const playerName = player ? `#${player.num} ${player.name}` : 'Unknown';
    const assistType = getAssistType(pass);
    const assistLabel = assistType === 'primary' ? 'A1 (Primary)' : assistType === 'secondary' ? 'A2 (Secondary)' : 'Assist';
    
    return `
      <div style="background:var(--panel);padding:6px;border-radius:4px;margin-bottom:4px;border-left:3px solid var(--accent);display:flex;justify-content:space-between;align-items:center;">
        <div style="flex:1;">
          <div style="font-size:9px;font-weight:600;">${playerName}</div>
          <div style="font-size:8px;color:var(--muted);">Event #${pass.idx + 1} @ ${pass.start_time || ''} | ${assistLabel}</div>
        </div>
        <div style="display:flex;gap:4px;">
          <button class="btn-sm" onclick="changeAssistType(${pass.idx}, 'primary')" 
                  style="font-size:8px;${assistType === 'primary' ? 'background:var(--accent);' : ''}" 
                  title="Set as Primary (A1)">A1</button>
          <button class="btn-sm" onclick="changeAssistType(${pass.idx}, 'secondary')" 
                  style="font-size:8px;${assistType === 'secondary' ? 'background:var(--accent);' : ''}" 
                  title="Set as Secondary (A2)">A2</button>
          <button class="btn-sm" onclick="removeAssist(${pass.idx})" 
                  style="font-size:8px;background:var(--danger);" 
                  title="Remove assist">‚úï</button>
        </div>
      </div>
    `;
  }).join('');
}

/**
 * v23.8: Get assist type (primary/secondary) from Pass event
 */
function getAssistType(passEvent) {
  const player = passEvent.players?.find(p => 
    p.role === 'event_player_1' || p.role === 'event_team_player_1'
  );
  if (!player) return null;
  
  const pd1 = (player.playD1 || '').toLowerCase();
  const pd2 = (player.playD2 || '').toLowerCase();
  
  if (pd1.includes('assistprimary') || pd2.includes('assistprimary')) return 'primary';
  if (pd1.includes('assistsecondary') || pd2.includes('assistsecondary')) return 'secondary';
  if (pd1.includes('assist')) return 'primary'; // Default to primary if just "assist"
  
  return null;
}

/**
 * v23.8: Change assist type (primary/secondary)
 */
function changeAssistType(passIdx, newType) {
  if (S.editingEvtIdx === null) return;
  const goalEvent = S.events[S.editingEvtIdx];
  if (goalEvent.type !== 'Goal') return;
  
  const passEvent = S.events.find(e => e.idx === passIdx);
  if (!passEvent || passEvent.assistToGoalIdx !== goalEvent.idx) {
    toast('Assist not found', 'error');
    return;
  }
  
  const player = passEvent.players?.find(p => 
    p.role === 'event_player_1' || p.role === 'event_team_player_1'
  );
  if (!player) {
    toast('Player not found in pass event', 'error');
    return;
  }
  
  // Update play_detail1 with assist type
  if (newType === 'primary') {
    player.playD1 = 'AssistPrimary';
  } else if (newType === 'secondary') {
    player.playD1 = 'AssistSecondary';
  }
  
  renderEditAssists(goalEvent);
  renderEvents();
  autoSave();
  toast(`Changed assist to ${newType === 'primary' ? 'Primary (A1)' : 'Secondary (A2)'}`, 'success');
}

/**
 * v23.8: Remove assist link
 */
function removeAssist(passIdx) {
  if (S.editingEvtIdx === null) return;
  const goalEvent = S.events[S.editingEvtIdx];
  if (goalEvent.type !== 'Goal') return;
  
  const passEvent = S.events.find(e => e.idx === passIdx);
  if (!passEvent || passEvent.assistToGoalIdx !== goalEvent.idx) {
    toast('Assist not found', 'error');
    return;
  }
  
  if (!confirm(`Remove assist from event #${passIdx + 1}?`)) return;
  
  // Remove assist link
  passEvent.assistToGoalIdx = null;
  
  // Remove assist markers from player
  const player = passEvent.players?.find(p => 
    p.role === 'event_player_1' || p.role === 'event_team_player_1'
  );
  if (player) {
    if (player.playD1?.toLowerCase().includes('assist')) {
      player.playD1 = '';
    }
    if (player.playD2?.toLowerCase().includes('assist')) {
      player.playD2 = '';
    }
  }
  
  renderEditAssists(goalEvent);
  renderEvents();
  updateBoxScore();
  autoSave();
  toast('Assist removed', 'success');
}

/**
 * v23.8: Open modal to add a new assist
 * v23.8: Now shows ALL events leading up to goal for context
 */
function openAddAssistModal() {
  if (S.editingEvtIdx === null) return;
  const goalEvent = S.events[S.editingEvtIdx];
  if (goalEvent.type !== 'Goal') return;
  
  // Get ALL events before the goal (same team) for full context
  const allEventsBeforeGoal = S.events.filter(e => {
    if (e.team !== goalEvent.team) return false;
    if (e.idx >= goalEvent.idx) return false; // Must be before the goal
    // Skip if already linked to a different goal
    if (e.assistToGoalIdx !== null && e.assistToGoalIdx !== undefined) {
      if (e.assistToGoalIdx !== goalEvent.idx) return false;
    }
    return true;
  });
  
  // Sort by proximity to goal (most recent first)
  allEventsBeforeGoal.sort((a, b) => b.idx - a.idx);
  
  // Limit to last 50 events for performance
  const eventsToShow = allEventsBeforeGoal.slice(0, 50);
  
  if (eventsToShow.length === 0) {
    toast('No events found before this goal', 'info');
    return;
  }
  
  // Create modal
  const modal = document.createElement('div');
  modal.className = 'overlay show';
  modal.id = 'addAssistModal';
  modal.onclick = function(e) {
    if (e.target === modal) {
      document.getElementById('addAssistModal')?.remove();
    }
  };
  // Find all goals for navigation
  const allGoals = S.events.filter(e => e.type === 'Goal' && e.detail1 === 'Goal_Scored').sort((a, b) => a.idx - b.idx);
  const currentGoalIndex = allGoals.findIndex(g => g.idx === goalEvent.idx);
  const hasPrev = currentGoalIndex > 0;
  const hasNext = currentGoalIndex < allGoals.length - 1;
  const prevGoalIdx = hasPrev ? allGoals[currentGoalIndex - 1].idx : null;
  const nextGoalIdx = hasNext ? allGoals[currentGoalIndex + 1].idx : null;

  modal.innerHTML = `
    <div class="modal" style="min-width:700px;max-width:900px;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <h3 style="margin:0;">üéØ Add Assist to Goal #${goalEvent.idx + 1}</h3>
        <div style="display:flex;gap:4px;align-items:center;">
          <span style="font-size:9px;color:var(--muted);">Goal ${currentGoalIndex + 1} of ${allGoals.length}</span>
          <button class="btn-sm" onclick="navigateAddAssistGoal(${prevGoalIdx !== null ? prevGoalIdx : 'null'})" ${!hasPrev ? 'disabled' : ''} title="Previous goal">‚óÄ Prev</button>
          <button class="btn-sm" onclick="navigateAddAssistGoal(${nextGoalIdx !== null ? nextGoalIdx : 'null'})" ${!hasNext ? 'disabled' : ''} title="Next goal">Next ‚ñ∂</button>
        </div>
      </div>
      <p style="font-size:10px;color:var(--muted);margin-bottom:12px;">
        All events leading up to the goal. Select any event to link as an assist. Pass and Shot events are highlighted. You can set Primary (A1) or Secondary (A2) after adding.
      </p>
      <div id="addAssistPassesList" style="max-height:600px;overflow-y:auto;margin-bottom:12px;"></div>
      <div class="modal-actions">
        <button onclick="saveCurrentGoalAssists()" style="background:var(--success);color:#fff;" title="Save all assists for this goal">üíæ Save</button>
        <button onclick="document.getElementById('addAssistModal')?.remove()" title="Close without adding assist">Cancel</button>
      </div>
    </div>
  `;
  document.body.appendChild(modal);
  
  // Render event list with detailed info - show ALL events leading up to goal
  const list = document.getElementById('addAssistPassesList');
  list.innerHTML = eventsToShow.map(evt => {
    // Get primary player (event_player_1)
    const player1 = evt.players?.find(p => 
      p.role === 'event_player_1' || p.role === 'event_team_player_1'
    );
    const player1Name = player1 ? `#${player1.num} ${player1.name || ''}` : 'Unknown';
    
    // Get secondary player (event_player_2) - especially important for Pass events (recipient)
    const player2 = evt.players?.find(p => 
      p.role === 'event_player_2' || p.role === 'event_team_player_2'
    );
    const player2Name = player2 ? `#${player2.num} ${player2.name || ''}` : null;
    
    // Get all event players
    const eventPlayers = evt.players?.filter(p => 
      p.role?.startsWith('event') || (!p.role?.startsWith('opp') && evt.team === (p.team || evt.team))
    ) || [];
    
    // Get opp players
    const oppPlayers = evt.players?.filter(p => 
      p.role?.startsWith('opp')
    ) || [];
    
    const timeAgo = goalEvent.idx - evt.idx;
    
    // Get play details from primary player
    const pd1 = player1?.playD1 || evt.detail1 || '';
    const pd2 = player1?.playD2 || evt.detail2 || '';
    const hasAssistMarker = pd1.toLowerCase().includes('assist') || pd2.toLowerCase().includes('assist');
    const isAlreadyLinked = evt.assistToGoalIdx === goalEvent.idx;
    
    // Determine if this is a likely assist candidate (Pass or Shot)
    const isLikelyAssist = evt.type === 'Pass' || evt.type === 'Shot';
    
    // Calculate time difference
    const parseTime = (t) => {
      if (!t) return 0;
      const [min, sec] = String(t).split(':').map(Number);
      return (min || 0) * 60 + (sec || 0);
    };
    const goalTime = parseTime(goalEvent.start_time);
    const evtTime = parseTime(evt.start_time);
    const timeDiff = goalTime - evtTime;
    const timeDiffStr = timeDiff > 0 ? `${Math.floor(timeDiff / 60)}:${String(timeDiff % 60).padStart(2, '0')}` : '';
    
    // Determine border color: green for already linked, blue for likely assists, yellow for has marker, gray for others
    let borderColor = 'var(--muted)';
    if (isAlreadyLinked) {
      borderColor = 'var(--success)';
    } else if (hasAssistMarker) {
      borderColor = 'var(--accent)';
    } else if (isLikelyAssist) {
      borderColor = '#3b82f6'; // Blue for Pass/Shot
    }
    
    // Background color - slightly highlight likely assists
    const bgColor = isLikelyAssist && !isAlreadyLinked ? 'rgba(59, 130, 246, 0.05)' : 'var(--card)';
    
    // Build players info section
    let playersInfoHtml = '';
    if (evt.type === 'Pass' && player2Name) {
      // For Pass events, show passer ‚Üí recipient
      playersInfoHtml = `
        <div style="font-size:9px;color:var(--text);margin-top:4px;">
          <strong>Passer:</strong> ${player1Name}${player1?.playD1 ? ` (${player1.playD1})` : ''}${player1?.playD2 ? ` / ${player1.playD2}` : ''}
        </div>
        <div style="font-size:9px;color:var(--text);">
          <strong>Recipient:</strong> ${player2Name}${player2?.playD1 ? ` (${player2.playD1})` : ''}${player2?.playD2 ? ` / ${player2.playD2}` : ''}
        </div>
      `;
    } else if (eventPlayers.length > 1) {
      // Multiple event players
      playersInfoHtml = `
        <div style="font-size:9px;color:var(--text);margin-top:4px;">
          <strong>Event Players:</strong> ${eventPlayers.map(p => {
            const roleLabel = p.role?.replace('event_team_player_', 'P').replace('event_player_', 'P') || '';
            const details = [p.playD1, p.playD2].filter(Boolean).join(' / ');
            return `#${p.num} ${p.name || ''}${roleLabel ? ` (${roleLabel})` : ''}${details ? ` [${details}]` : ''}`;
          }).join(', ')}
        </div>
      `;
    } else if (player1) {
      // Single player with details
      playersInfoHtml = `
        <div style="font-size:9px;color:var(--text);margin-top:4px;">
          <strong>Player:</strong> ${player1Name}${player1.playD1 ? ` (${player1.playD1})` : ''}${player1.playD2 ? ` / ${player1.playD2}` : ''}
        </div>
      `;
    }
    
    // Opp players info
    let oppInfoHtml = '';
    if (oppPlayers.length > 0) {
      oppInfoHtml = `
        <div style="font-size:9px;color:var(--muted);margin-top:2px;">
          <strong>Opp:</strong> ${oppPlayers.map(p => `#${p.num} ${p.name || ''}${p.playD1 ? ` (${p.playD1})` : ''}`).join(', ')}
        </div>
      `;
    }
    
    return `
      <div style="background:${bgColor};padding:10px;border-radius:4px;margin-bottom:8px;border-left:4px solid ${borderColor};">
        <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:6px;">
          <div style="flex:1;">
            <div style="display:flex;align-items:center;gap:6px;margin-bottom:4px;">
              <div style="font-size:11px;font-weight:600;color:var(--text);">
                ${player1Name}
              </div>
              ${isLikelyAssist ? `<span style="font-size:8px;background:rgba(59, 130, 246, 0.2);color:#3b82f6;padding:2px 6px;border-radius:3px;font-weight:600;">${evt.type}</span>` : ''}
              ${hasAssistMarker ? `<span style="font-size:8px;background:var(--success);color:#fff;padding:2px 6px;border-radius:3px;">ASSIST</span>` : ''}
              ${isAlreadyLinked ? `<span style="font-size:8px;background:var(--accent);color:#fff;padding:2px 6px;border-radius:3px;">LINKED</span>` : ''}
            </div>
            <div style="font-size:9px;color:var(--muted);margin-bottom:2px;">
              <strong>Event #${evt.idx + 1}</strong> | ${evt.type || 'Unknown'} | P${evt.period || '?'} @ ${evt.start_time || '?'}
              ${timeDiffStr ? ` | ${timeDiffStr} before goal` : ''} | ${timeAgo} event${timeAgo !== 1 ? 's' : ''} before
            </div>
            ${evt.detail1 ? `<div style="font-size:9px;color:var(--text);margin-top:4px;"><strong>Event Detail1:</strong> ${evt.detail1}</div>` : ''}
            ${evt.detail2 ? `<div style="font-size:9px;color:var(--text);"><strong>Event Detail2:</strong> ${evt.detail2}</div>` : ''}
            ${evt.zone ? `<div style="font-size:9px;color:var(--text);"><strong>Zone:</strong> ${evt.zone === 'o' ? 'Offensive' : evt.zone === 'd' ? 'Defensive' : 'Neutral'}</div>` : ''}
            ${evt.success ? `<div style="font-size:9px;color:var(--text);"><strong>Success:</strong> ${evt.success === 's' ? 'Success' : evt.success === 'u' ? 'Unsuccess' : evt.success}</div>` : ''}
            ${playersInfoHtml}
            ${oppInfoHtml}
            ${hasAssistMarker ? `<div style="font-size:9px;color:var(--success);margin-top:4px;">‚úì Has assist marker</div>` : ''}
            ${isAlreadyLinked ? `<div style="font-size:9px;color:var(--accent);margin-top:4px;">‚úì Already linked to this goal</div>` : ''}
          </div>
        </div>
        <div style="display:flex;gap:6px;margin-top:8px;">
          ${!isAlreadyLinked ? `
            <button class="btn-sm btn-primary" onclick="addAssistToGoal(${evt.idx})" style="flex:1;font-size:9px;" title="Link this event as an assist to the goal">
              ${hasAssistMarker ? 'Link as Assist' : 'Add as Assist'}
            </button>
            <button class="btn-sm" onclick="editEvent(${evt.idx});document.getElementById('addAssistModal')?.remove();" style="font-size:9px;" title="Edit this event (will close this modal)">
              Edit Event
            </button>
          ` : `
            <button class="btn-sm" style="flex:1;background:var(--success);color:#fff;" disabled title="Already linked to this goal">
              ‚úì Linked
            </button>
            <button class="btn-sm" onclick="editEvent(${evt.idx});document.getElementById('addAssistModal')?.remove();" style="font-size:9px;" title="Edit this event (will close this modal)">
              Edit Event
            </button>
          `}
        </div>
      </div>
    `;
  }).join('');
}

/**
 * v23.8: Add assist to goal
 * v23.8: Now accepts any event type, not just Pass events
 */
function addAssistToGoal(eventIdx) {
  if (S.editingEvtIdx === null) return;
  const goalEvent = S.events[S.editingEvtIdx];
  if (goalEvent.type !== 'Goal') return;
  
  const assistEvent = S.events.find(e => e.idx === eventIdx);
  if (!assistEvent) {
    toast('Event not found', 'error');
    return;
  }
  
  // Check if already linked to a different goal
  if (assistEvent.assistToGoalIdx !== null && assistEvent.assistToGoalIdx !== undefined) {
    if (assistEvent.assistToGoalIdx !== goalEvent.idx) {
      toast('This event is already linked to another goal', 'error');
      return;
    }
    // Already linked to this goal - just refresh modal to show updated state
    refreshAddAssistModal();
    return;
  }
  
  // Link the assist
  assistEvent.assistToGoalIdx = goalEvent.idx;
  
  // Mark as assist in play_detail1 (default to primary, user can change)
  const player = assistEvent.players?.find(p => 
    p.role === 'event_player_1' || p.role === 'event_team_player_1'
  );
  if (player) {
    // Only add assist marker if not already present
    const pd1 = (player.playD1 || '').toLowerCase();
    const pd2 = (player.playD2 || '').toLowerCase();
    if (!pd1.includes('assist') && !pd2.includes('assist')) {
      player.playD1 = 'AssistPrimary';
    }
  }
  
  // Refresh assists list in edit modal if open
  renderEditAssists(goalEvent);
  renderEvents();
  updateBoxScore();
  autoSave();
  
  // Refresh the add assist modal to show updated state (don't close it)
  refreshAddAssistModal();
  
  toast(`Assist added (${assistEvent.type || 'Event'})`, 'success');
}

/**
 * v23.8: Save assists for the current goal being edited
 */
function saveCurrentGoalAssists() {
  if (S.editingEvtIdx === null) return;
  const goalEvent = S.events[S.editingEvtIdx];
  if (goalEvent.type !== 'Goal') return;
  
  // Refresh assists list in edit modal if open
  renderEditAssists(goalEvent);
  renderEvents();
  updateBoxScore();
  autoSave();
  
  toast('Assists saved for this goal', 'success');
}

/**
 * v23.8: Navigate to a different goal in the add assist modal
 */
function navigateAddAssistGoal(goalIdx) {
  if (goalIdx === null) return;
  
  // Save current goal's assists before navigating
  saveCurrentGoalAssists();
  
  // Find the goal event
  const goalEvent = S.events.find(e => e.idx === goalIdx);
  if (!goalEvent || goalEvent.type !== 'Goal') {
    toast('Goal not found', 'error');
    return;
  }
  
  // Update editing index to the new goal
  S.editingEvtIdx = goalIdx;
  
  // Refresh the modal with the new goal
  refreshAddAssistModal();
  
  // Also update the edit modal if it's open
  if (document.getElementById('editModal')?.classList.contains('show')) {
    editEvent(goalIdx);
  }
}

/**
 * v23.8: Refresh the add assist modal content to reflect current linking state
 */
function refreshAddAssistModal() {
  const modal = document.getElementById('addAssistModal');
  if (!modal) return;

  if (S.editingEvtIdx === null) return;
  const goalEvent = S.events[S.editingEvtIdx];
  if (goalEvent.type !== 'Goal') return;
  
  // Update navigation buttons
  const allGoals = S.events.filter(e => e.type === 'Goal' && e.detail1 === 'Goal_Scored').sort((a, b) => a.idx - b.idx);
  const currentGoalIndex = allGoals.findIndex(g => g.idx === goalEvent.idx);
  const hasPrev = currentGoalIndex > 0;
  const hasNext = currentGoalIndex < allGoals.length - 1;
  const prevGoalIdx = hasPrev ? allGoals[currentGoalIndex - 1].idx : null;
  const nextGoalIdx = hasNext ? allGoals[currentGoalIndex + 1].idx : null;
  
  // Update header with navigation
  const header = modal.querySelector('h3')?.parentElement;
  if (header) {
    header.innerHTML = `
      <h3 style="margin:0;">üéØ Add Assist to Goal #${goalEvent.idx + 1}</h3>
      <div style="display:flex;gap:4px;align-items:center;">
        <span style="font-size:9px;color:var(--muted);">Goal ${currentGoalIndex + 1} of ${allGoals.length}</span>
        <button class="btn-sm" onclick="navigateAddAssistGoal(${prevGoalIdx !== null ? prevGoalIdx : 'null'})" ${!hasPrev ? 'disabled' : ''} title="Previous goal">‚óÄ Prev</button>
        <button class="btn-sm" onclick="navigateAddAssistGoal(${nextGoalIdx !== null ? nextGoalIdx : 'null'})" ${!hasNext ? 'disabled' : ''} title="Next goal">Next ‚ñ∂</button>
      </div>
    `;
  }
  
  // Get ALL events before the goal (same team) for full context
  const allEventsBeforeGoal = S.events.filter(e => {
    if (e.team !== goalEvent.team) return false;
    if (e.idx >= goalEvent.idx) return false; // Must be before the goal
    // Skip if already linked to a different goal
    if (e.assistToGoalIdx !== null && e.assistToGoalIdx !== undefined) {
      if (e.assistToGoalIdx !== goalEvent.idx) return false;
    }
    return true;
  });
  
  // Sort by proximity to goal (most recent first)
  allEventsBeforeGoal.sort((a, b) => b.idx - a.idx);
  
  // Limit to last 50 events for performance
  const eventsToShow = allEventsBeforeGoal.slice(0, 50);
  
  // Re-render event list with detailed info
  const list = document.getElementById('addAssistPassesList');
  if (!list) return;
  
  list.innerHTML = eventsToShow.map(evt => {
    // Get primary player (event_player_1)
    const player1 = evt.players?.find(p => 
      p.role === 'event_player_1' || p.role === 'event_team_player_1'
    );
    const player1Name = player1 ? `#${player1.num} ${player1.name || ''}` : 'Unknown';
    
    // Get secondary player (event_player_2) - especially important for Pass events (recipient)
    const player2 = evt.players?.find(p => 
      p.role === 'event_player_2' || p.role === 'event_team_player_2'
    );
    const player2Name = player2 ? `#${player2.num} ${player2.name || ''}` : null;
    
    // Get all event players
    const eventPlayers = evt.players?.filter(p => 
      p.role?.startsWith('event') || (!p.role?.startsWith('opp') && evt.team === (p.team || evt.team))
    ) || [];
    
    // Get opp players
    const oppPlayers = evt.players?.filter(p => 
      p.role?.startsWith('opp')
    ) || [];
    
    const timeAgo = goalEvent.idx - evt.idx;
    
    // Get play details from primary player
    const pd1 = player1?.playD1 || evt.detail1 || '';
    const pd2 = player1?.playD2 || evt.detail2 || '';
    const hasAssistMarker = pd1.toLowerCase().includes('assist') || pd2.toLowerCase().includes('assist');
    const isAlreadyLinked = evt.assistToGoalIdx === goalEvent.idx;
    
    // Determine if this is a likely assist candidate (Pass or Shot)
    const isLikelyAssist = evt.type === 'Pass' || evt.type === 'Shot';
    
    // Calculate time difference
    const parseTime = (t) => {
      if (!t) return 0;
      const [min, sec] = String(t).split(':').map(Number);
      return (min || 0) * 60 + (sec || 0);
    };
    const goalTime = parseTime(goalEvent.start_time);
    const evtTime = parseTime(evt.start_time);
    const timeDiff = goalTime - evtTime;
    const timeDiffStr = timeDiff > 0 ? `${Math.floor(timeDiff / 60)}:${String(timeDiff % 60).padStart(2, '0')}` : '';
    
    // Determine border color: green for already linked, blue for likely assists, yellow for has marker, gray for others
    let borderColor = 'var(--muted)';
    if (isAlreadyLinked) {
      borderColor = 'var(--success)';
    } else if (hasAssistMarker) {
      borderColor = 'var(--accent)';
    } else if (isLikelyAssist) {
      borderColor = '#3b82f6'; // Blue for Pass/Shot
    }
    
    // Background color - slightly highlight likely assists
    const bgColor = isLikelyAssist && !isAlreadyLinked ? 'rgba(59, 130, 246, 0.05)' : 'var(--card)';
    
    // Build players info section
    let playersInfoHtml = '';
    if (evt.type === 'Pass' && player2Name) {
      // For Pass events, show passer ‚Üí recipient
      playersInfoHtml = `
        <div style="font-size:9px;color:var(--text);margin-top:4px;">
          <strong>Passer:</strong> ${player1Name}${player1?.playD1 ? ` (${player1.playD1})` : ''}${player1?.playD2 ? ` / ${player1.playD2}` : ''}
        </div>
        <div style="font-size:9px;color:var(--text);">
          <strong>Recipient:</strong> ${player2Name}${player2?.playD1 ? ` (${player2.playD1})` : ''}${player2?.playD2 ? ` / ${player2.playD2}` : ''}
        </div>
      `;
    } else if (eventPlayers.length > 1) {
      // Multiple event players
      playersInfoHtml = `
        <div style="font-size:9px;color:var(--text);margin-top:4px;">
          <strong>Event Players:</strong> ${eventPlayers.map(p => {
            const roleLabel = p.role?.replace('event_team_player_', 'P').replace('event_player_', 'P') || '';
            const details = [p.playD1, p.playD2].filter(Boolean).join(' / ');
            return `#${p.num} ${p.name || ''}${roleLabel ? ` (${roleLabel})` : ''}${details ? ` [${details}]` : ''}`;
          }).join(', ')}
        </div>
      `;
    } else if (player1) {
      // Single player with details
      playersInfoHtml = `
        <div style="font-size:9px;color:var(--text);margin-top:4px;">
          <strong>Player:</strong> ${player1Name}${player1.playD1 ? ` (${player1.playD1})` : ''}${player1.playD2 ? ` / ${player1.playD2}` : ''}
        </div>
      `;
    }
    
    // Opp players info
    let oppInfoHtml = '';
    if (oppPlayers.length > 0) {
      oppInfoHtml = `
        <div style="font-size:9px;color:var(--muted);margin-top:2px;">
          <strong>Opp:</strong> ${oppPlayers.map(p => `#${p.num} ${p.name || ''}${p.playD1 ? ` (${p.playD1})` : ''}`).join(', ')}
        </div>
      `;
    }
    
    return `
      <div style="background:${bgColor};padding:10px;border-radius:4px;margin-bottom:8px;border-left:4px solid ${borderColor};">
        <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:6px;">
          <div style="flex:1;">
            <div style="display:flex;align-items:center;gap:6px;margin-bottom:4px;">
              <div style="font-size:11px;font-weight:600;color:var(--text);">
                ${player1Name}
              </div>
              ${isLikelyAssist ? `<span style="font-size:8px;background:rgba(59, 130, 246, 0.2);color:#3b82f6;padding:2px 6px;border-radius:3px;font-weight:600;">${evt.type}</span>` : ''}
              ${hasAssistMarker ? `<span style="font-size:8px;background:var(--success);color:#fff;padding:2px 6px;border-radius:3px;">ASSIST</span>` : ''}
              ${isAlreadyLinked ? `<span style="font-size:8px;background:var(--accent);color:#fff;padding:2px 6px;border-radius:3px;">LINKED</span>` : ''}
            </div>
            <div style="font-size:9px;color:var(--muted);margin-bottom:2px;">
              <strong>Event #${evt.idx + 1}</strong> | ${evt.type || 'Unknown'} | P${evt.period || '?'} @ ${evt.start_time || '?'}
              ${timeDiffStr ? ` | ${timeDiffStr} before goal` : ''} | ${timeAgo} event${timeAgo !== 1 ? 's' : ''} before
            </div>
            ${evt.detail1 ? `<div style="font-size:9px;color:var(--text);margin-top:4px;"><strong>Event Detail1:</strong> ${evt.detail1}</div>` : ''}
            ${evt.detail2 ? `<div style="font-size:9px;color:var(--text);"><strong>Event Detail2:</strong> ${evt.detail2}</div>` : ''}
            ${evt.zone ? `<div style="font-size:9px;color:var(--text);"><strong>Zone:</strong> ${evt.zone === 'o' ? 'Offensive' : evt.zone === 'd' ? 'Defensive' : 'Neutral'}</div>` : ''}
            ${evt.success ? `<div style="font-size:9px;color:var(--text);"><strong>Success:</strong> ${evt.success === 's' ? 'Success' : evt.success === 'u' ? 'Unsuccess' : evt.success}</div>` : ''}
            ${playersInfoHtml}
            ${oppInfoHtml}
            ${hasAssistMarker ? `<div style="font-size:9px;color:var(--success);margin-top:4px;">‚úì Has assist marker</div>` : ''}
            ${isAlreadyLinked ? `<div style="font-size:9px;color:var(--accent);margin-top:4px;">‚úì Already linked to this goal</div>` : ''}
          </div>
        </div>
        <div style="display:flex;gap:6px;margin-top:8px;">
          ${!isAlreadyLinked ? `
            <button class="btn-sm btn-primary" onclick="addAssistToGoal(${evt.idx})" style="flex:1;font-size:9px;" title="Link this event as an assist to the goal">
              ${hasAssistMarker ? 'Link as Assist' : 'Add as Assist'}
            </button>
            <button class="btn-sm" onclick="editEvent(${evt.idx});document.getElementById('addAssistModal')?.remove();" style="font-size:9px;" title="Edit this event (will close this modal)">
              Edit Event
            </button>
          ` : `
            <button class="btn-sm" style="flex:1;background:var(--success);color:#fff;" disabled title="Already linked to this goal">
              ‚úì Linked
            </button>
            <button class="btn-sm" onclick="editEvent(${evt.idx});document.getElementById('addAssistModal')?.remove();" style="font-size:9px;" title="Edit this event (will close this modal)">
              Edit Event
            </button>
          `}
        </div>
      </div>
    `;
  }).join('');
}

/**
 * v23.8: Open modal to browse and select a goal to link assist to
 */
function openLinkAssistToGoalModal() {
  if (S.editingEvtIdx === null) return;
  const currentEvent = S.events[S.editingEvtIdx];
  
  // Find all Goal events (same team, after this event)
  const goals = S.events.filter(e => {
    if (e.type !== 'Goal' || e.detail1 !== 'Goal_Scored') return false;
    if (e.team !== currentEvent.team) return false;
    if (e.idx <= currentEvent.idx) return false; // Must be after this event
    return true;
  });
  
  if (goals.length === 0) {
    toast('No goals found after this event', 'info');
    return;
  }
  
  // Create modal
  const modal = document.createElement('div');
  modal.className = 'overlay show';
  modal.id = 'linkAssistToGoalModal';
  modal.onclick = function(e) {
    if (e.target === modal) {
      document.getElementById('linkAssistToGoalModal')?.remove();
    }
  };
  modal.innerHTML = `
    <div class="modal" style="min-width:500px;max-width:700px;">
      <h3>üéØ Link Assist to Goal</h3>
      <p style="font-size:10px;color:var(--muted);margin-bottom:12px;">
        Select a goal to link this assist to:
      </p>
      <div id="linkAssistGoalsList" style="max-height:400px;overflow-y:auto;margin-bottom:12px;"></div>
      <div class="modal-actions">
        <button onclick="document.getElementById('linkAssistToGoalModal')?.remove()" title="Close without linking">Cancel</button>
      </div>
    </div>
  `;
  document.body.appendChild(modal);
  
  // Render goals list
  const list = document.getElementById('linkAssistGoalsList');
  list.innerHTML = goals.map(goal => {
    const scorer = goal.players?.find(p => p.role === 'event_player_1');
    const scorerName = scorer ? `#${scorer.num} ${scorer.name || ''}` : 'Unknown';
    
    return `
      <div style="background:var(--card);padding:10px;border-radius:4px;margin-bottom:8px;border-left:4px solid var(--success);cursor:pointer;" 
           onclick="linkAssistToGoal(${goal.idx})">
        <div style="font-size:11px;font-weight:600;margin-bottom:4px;">
          Goal #${goal.idx + 1} - ${scorerName}
        </div>
        <div style="font-size:9px;color:var(--muted);">
          P${goal.period || '?'} @ ${goal.start_time || '?'} | ${goal.zone || '?'} zone
        </div>
        ${goal.detail1 ? `<div style="font-size:9px;color:var(--text);margin-top:4px;"><strong>Detail:</strong> ${goal.detail1}</div>` : ''}
      </div>
    `;
  }).join('');
}

/**
 * v23.8: Link current event as assist to selected goal
 */
function linkAssistToGoal(goalIdx) {
  if (S.editingEvtIdx === null) return;
  const currentEvent = S.events[S.editingEvtIdx];
  const goalEvent = S.events[goalIdx];
  
  if (!goalEvent || goalEvent.type !== 'Goal' || goalEvent.detail1 !== 'Goal_Scored') {
    toast('Invalid goal event', 'error');
    return;
  }
  
  // Set the assist link
  currentEvent.assistToGoalIdx = goalIdx;
  
  // Update the input field
  const assistToGoalEl = document.getElementById('editAssistToGoalIdx');
  if (assistToGoalEl) {
    assistToGoalEl.value = goalIdx + 1;
  }
  
  // Mark as assist if not already marked
  const player = currentEvent.players?.find(p => 
    p.role === 'event_player_1' || p.role === 'event_team_player_1'
  );
  if (player) {
    const pd1 = (player.playD1 || '').toLowerCase();
    const pd2 = (player.playD2 || '').toLowerCase();
    if (!pd1.includes('assist') && !pd2.includes('assist')) {
      player.playD1 = player.playD1 ? player.playD1 + ', AssistPrimary' : 'AssistPrimary';
    }
  }
  
  // Close modal
  document.getElementById('linkAssistToGoalModal')?.remove();
  
  toast(`Linked to Goal #${goalIdx + 1}`, 'success');
}

function closeEditModal() {
  document.getElementById('editModal').classList.remove('show');
  S.editingEvtIdx = null;
}

/**
 * v23.8: Get filtered events list (respects period filter and event filters)
 * @returns {Array} - Array of filtered events
 */
function getFilteredEvents() {
  let filteredEvents = S.events || [];
  const periodFilter = (S.eventLogFilter || 'all').toLowerCase();
  
  // Apply period filter
  if (periodFilter && periodFilter !== 'all') {
    filteredEvents = filteredEvents.filter(e => {
      const evtPeriod = String(e.period || '').toLowerCase();
      if (periodFilter === 'ot') {
        return evtPeriod === 'ot' || evtPeriod === '4' || parseInt(evtPeriod) > 3;
      }
      return evtPeriod === periodFilter;
    });
  }
  
  // Apply advanced filters
  const f = S.eventFilters || {};
  
  if (f.type) {
    filteredEvents = filteredEvents.filter(e => e.type === f.type);
  }
  if (f.detail1) {
    filteredEvents = filteredEvents.filter(e => (e.detail1 || e.detail) === f.detail1);
  }
  if (f.detail2) {
    filteredEvents = filteredEvents.filter(e => e.detail2 === f.detail2);
  }
  if (f.playDetail1) {
    filteredEvents = filteredEvents.filter(e => {
      const p1 = (e.players || []).find(p => p.role?.startsWith('event') || !p.role?.startsWith('opp'));
      return p1?.playD1 === f.playDetail1;
    });
  }
  if (f.playDetail2) {
    filteredEvents = filteredEvents.filter(e => {
      const p1 = (e.players || []).find(p => p.role?.startsWith('event') || !p.role?.startsWith('opp'));
      return p1?.playD2 === f.playDetail2;
    });
  }
  if (f.team) {
    filteredEvents = filteredEvents.filter(e => e.team === f.team);
  }
  // v23.8: Handle event index filter with "show X before/after" option
  if (f.eventIdx !== null && f.eventIdx !== undefined) {
    const targetIdx = f.eventIdx - 1; // Convert to 0-based index
    const targetEvent = S.events[targetIdx];
    if (targetEvent) {
      const eventsBefore = f.eventsBefore || 0;
      const eventsAfter = f.eventsAfter || 0;
      const startIdx = Math.max(0, targetIdx - eventsBefore);
      const endIdx = Math.min(S.events.length, targetIdx + 1 + eventsAfter);
      filteredEvents = S.events.slice(startIdx, endIdx);
    } else {
      filteredEvents = [];
    }
  }
  if (f.linkedIdx !== null && f.linkedIdx !== undefined) {
    filteredEvents = filteredEvents.filter(e => e.linkedEventIdx !== null && e.linkedEventIdx + 1 === f.linkedIdx);
  }
  if (f.shiftIdx !== null && f.shiftIdx !== undefined) {
    filteredEvents = filteredEvents.filter(e => e.shiftIdx === f.shiftIdx || e.shift_index === f.shiftIdx);
  }
  
  return filteredEvents;
}

/**
 * Navigate to previous/next event in edit modal
 * v23.8: Respects active filters - navigates within filtered events
 * @param {number} dir - Direction (-1 for prev, 1 for next)
 */
function navEditEvent(dir) {
  if (S.editingEvtIdx === null) return;
  
  // Save current event first
  saveEditEventSilent();
  
  // Check if filters are active
  const periodFilter = (S.eventLogFilter || 'all').toLowerCase();
  const f = S.eventFilters || {};
  const hasFilters = (periodFilter && periodFilter !== 'all') || 
                     f.type || f.detail1 || f.detail2 || f.playDetail1 || f.playDetail2 || 
                     f.team || (f.eventIdx !== null && f.eventIdx !== undefined) ||
                     (f.linkedIdx !== null && f.linkedIdx !== undefined) ||
                     (f.shiftIdx !== null && f.shiftIdx !== undefined);
  
  if (hasFilters) {
    // Navigate within filtered events
    const filteredEvents = getFilteredEvents();
    const currentEvent = S.events[S.editingEvtIdx];
    
    // Find current event's position in filtered list
    const currentFilteredIdx = filteredEvents.findIndex(e => e === currentEvent);
    
    if (currentFilteredIdx === -1) {
      // Current event not in filtered list - go to first/last filtered event
      if (filteredEvents.length === 0) {
        toast('No events match current filters', 'info');
        return;
      }
      const targetEvent = dir < 0 ? filteredEvents[filteredEvents.length - 1] : filteredEvents[0];
      const targetIdx = S.events.indexOf(targetEvent);
      if (targetIdx !== -1) {
        editEvent(targetIdx);
      }
      return;
    }
    
    // Navigate within filtered list
    const newFilteredIdx = currentFilteredIdx + dir;
    if (newFilteredIdx < 0 || newFilteredIdx >= filteredEvents.length) {
      toast(dir < 0 ? 'First filtered event' : 'Last filtered event', 'info');
      return;
    }
    
    const targetEvent = filteredEvents[newFilteredIdx];
    const targetIdx = S.events.indexOf(targetEvent);
    if (targetIdx !== -1) {
      editEvent(targetIdx);
    } else {
      toast('Event not found', 'error');
    }
  } else {
    // No filters - navigate through all events (original behavior)
    const newIdx = S.editingEvtIdx + dir;
    if (newIdx < 0 || newIdx >= S.events.length) {
      toast(dir < 0 ? 'First event' : 'Last event', 'info');
      return;
    }
    editEvent(newIdx);
  }
}

/**
 * Navigate to previous/next shift in edit modal
 * @param {number} dir - Direction (-1 for prev, 1 for next)
 */
function navEditShift(dir) {
  if (S.editingShiftIdx === null) return;
  
  // Save current shift first
  saveEditShiftSilent();
  
  const newIdx = S.editingShiftIdx + dir;
  if (newIdx < 0 || newIdx >= S.shifts.length) {
    toast(dir < 0 ? 'First shift' : 'Last shift', 'info');
    return;
  }
  
  editShift(newIdx);
}

/**
 * Save event without closing modal or showing toast
 */
function saveEditEventSilent() {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  
  evt.type = document.getElementById('editType').value;
  evt.team = document.getElementById('editTeam').value;
  evt.start_time = document.getElementById('editStartTime').value;
  evt.end_time = document.getElementById('editEndTime').value;
  evt.zone = document.getElementById('editZone').value;
  evt.success = document.getElementById('editSuccess').value;
  evt.strength = document.getElementById('editStrength').value;
  evt.detail1 = document.getElementById('editD1').value;
  evt.detail2 = document.getElementById('editD2').value;
  evt.isHighlight = document.getElementById('editHighlight').checked;
  
  const linkedIdxEl = document.getElementById('editLinkedIdx');
  if (linkedIdxEl) {
    const linkedVal = linkedIdxEl.value ? parseInt(linkedIdxEl.value) - 1 : null;
    evt.linkedEventIdx = (linkedVal !== null && linkedVal >= 0) ? linkedVal : null;
  }
  
  autoSave();
}

/**
 * Save shift without closing modal or showing toast
 */
function saveEditShiftSilent() {
  if (S.editingShiftIdx === null) return;
  const shift = S.shifts[S.editingShiftIdx];
  
  shift.period = document.getElementById('editShiftPeriod').value;
  shift.start_time = document.getElementById('editShiftStartTime').value;
  shift.end_time = document.getElementById('editShiftEndTime').value;
  shift.start_type = document.getElementById('editShiftStartType').value;
  shift.stop_type = document.getElementById('editShiftStopType').value;
  
  autoSave();
}

/**
 * Clear all events (keep shifts)
 */
function clearAllEvents() {
  if (!S.gameId) { toast('No game loaded', 'error'); return; }
  if (!confirm(`‚ö†Ô∏è Clear ALL ${S.events.length} events?\n\nShifts will be kept. This cannot be undone!`)) return;
  
  S.events = [];
  S.evtIdx = 0;
  
  renderAll();
  autoSave();
  toast('All events cleared', 'success');
}

/**
 * Clear all shifts (keep events)
 */
function clearAllShifts() {
  if (!S.gameId) { toast('No game loaded', 'error'); return; }
  if (!confirm(`‚ö†Ô∏è Clear ALL ${S.shifts.length} shifts?\n\nEvents will be kept. This cannot be undone!`)) return;
  
  S.shifts = [];
  S.shiftIdx = 0;
  
  renderShiftLog();
  autoSave();
  toast('All shifts cleared', 'success');
}

// ============================================================
// SHIFTS
// ============================================================

/**
 * Calculate total stoppage duration during a shift
 * Looks for Stoppage/Clockstop events within the shift time window
 * @param {object} shift - Shift object with period, start_time, end_time
 * @returns {number} - Total stoppage time in seconds
 */
function calculateShiftStoppageTime(shift) {
  if (!shift.start_time || !shift.end_time) return 0;
  
  const parseTime = (t) => {
    if (!t) return 0;
    const [min, sec] = t.split(':').map(Number);
    return (min || 0) * 60 + (sec || 0);
  };
  
  const shiftStartSec = parseTime(shift.start_time);  // Time remaining at shift start
  const shiftEndSec = parseTime(shift.end_time);      // Time remaining at shift end
  
  // Find stoppage events in this shift's period and time window
  // Note: Higher time = earlier in period (clock counts down)
  let stoppageTotal = 0;
  
  S.events.forEach(evt => {
    if (evt.period !== shift.period) return;
    if (evt.type !== 'Stoppage' && evt.type !== 'Clockstop' && evt.type !== 'Timeout') return;
    
    const evtTimeSec = parseTime(evt.start_time);
    
    // Check if event falls within shift (between end and start because clock counts down)
    if (evtTimeSec <= shiftStartSec && evtTimeSec >= shiftEndSec) {
      // Get event duration
      let duration = 0;
      if (evt.end_time && evt.end_time !== evt.start_time) {
        const evtEndSec = parseTime(evt.end_time);
        duration = Math.abs(evtTimeSec - evtEndSec);
      }
      
      // If no end time or duration is 0, use default durations
      if (duration > 0) {
        stoppageTotal += duration;
      } else {
        // Default durations by type
        if (evt.type === 'Timeout') stoppageTotal += 60;
        else if (evt.detail1?.includes('Icing')) stoppageTotal += 15;
        else if (evt.detail1?.includes('Offside')) stoppageTotal += 10;
        else if (evt.type === 'Clockstop') stoppageTotal += 30;  // Clock stops are usually longer
        else stoppageTotal += 5;  // Default 5 sec for other stoppages
      }
    }
  });
  
  return stoppageTotal;
}

/**
 * Calculate shift duration in seconds
 */
function calculateShiftDuration(shift) {
  if (!shift.start_time || !shift.end_time) return 0;
  
  const parseTime = (t) => {
    const [min, sec] = t.split(':').map(Number);
    return (min || 0) * 60 + (sec || 0);
  };
  
  // Clock counts down, so start > end
  return parseTime(shift.start_time) - parseTime(shift.end_time);
}

// Helper to check if event time falls within shift time range
// Clock counts DOWN (18:00 -> 0:00), so "between" means: start >= time >= end
function isTimeBetween(eventTime, shiftStart, shiftEnd) {
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'isTimeBetween:19154',message:'Function entry',data:{eventTime,shiftStart,shiftEnd},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
  // #endregion
  if (!eventTime || !shiftStart || !shiftEnd) {
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'isTimeBetween:19156',message:'Early return - missing times',data:{eventTime,shiftStart,shiftEnd},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
    // #endregion
    return false;
  }
  
  const parseTime = (t) => {
    if (!t) return 0;
    const [min, sec] = String(t).split(':').map(Number);
    return (min || 0) * 60 + (sec || 0);
  };
  
  const evt = parseTime(eventTime);
  const start = parseTime(shiftStart);
  const end = parseTime(shiftEnd);
  
  // Clock counts down, so start > end (e.g., 18:00 to 17:00)
  // Event time is "between" if: start >= eventTime >= end
  // This means: eventTime <= start AND eventTime >= end
  const result = evt <= start && evt >= end;
  
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c30ac5c8-e929-44dc-a58e-159aa6b2b75b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'isTimeBetween:19175',message:'Time comparison',data:{eventTime,shiftStart,shiftEnd,evtSeconds:evt,startSeconds:start,endSeconds:end,evtLessEqualStart:evt<=start,evtGreaterEqualEnd:evt>=end,result},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
  // #endregion
  
  return result;
}

function logShift() {
  const start = document.getElementById('shiftStart').value;
  const end = document.getElementById('shiftEnd').value || document.getElementById('clock').value;
  
  const shift = {
    idx: S.shiftIdx++,
    game_id: S.gameId,
    period: S.period,
    start_time: start,
    end_time: end,
    start_type: document.getElementById('shiftStartType').value,
    stop_type: document.getElementById('shiftStopType').value,
    strength: deriveStrength(),
    home: {...S.slots.home},
    away: {...S.slots.away}
  };
  
  // Calculate stoppage time during this shift
  shift.stoppageTime = calculateShiftStoppageTime(shift);
  
  // Calculate shift duration
  shift.duration = calculateShiftDuration(shift);
  
  S.shifts.push(shift);
  document.getElementById('shiftStart').value = end;
  document.getElementById('shiftEnd').value = '';
  S.lastEndTime = end;
  
  renderShiftLog();
  toast(`Shift #${shift.idx + 1} logged (${shift.stoppageTime}s stoppage)`, 'success');
  autoSave();
}

// Auto-update strength when slots change
function onSlotsChanged() {
  const strength = deriveStrength();
  document.getElementById('evtStrength').value = strength;
  updateQuickStats(); // v5
}

// ============================================================
// PERIOD & CLOCK
// ============================================================
function setPeriod(p) {
  S.period = p;
  document.querySelectorAll('.period-btn').forEach(b => b.classList.remove('active'));
  document.querySelector(`.period-btn[data-p="${p}"]`)?.classList.add('active');
  
  // Set clock based on period-specific length
  const periodLen = getPeriodLength(p);
  document.getElementById('clock').value = `${periodLen}:00`;
  
  // Update period length indicator
  updatePeriodLengthIndicator();
  
  // Update zone labels (they switch each period)
  updateZoneLabels();
}

/**
 * Flip which end home team attacks in P1
 * For beer league where benches aren't fixed home/away
 */
function flipZones() {
  S.homeAttacksRightP1 = !S.homeAttacksRightP1;
  updateZoneLabels();
  
  const direction = S.homeAttacksRightP1 ? 'RIGHT' : 'LEFT';
  const homeShort = (S.homeTeam || 'HOME').toUpperCase();
  toast(`${homeShort} attacks ${direction} in P1/P3`, 'info');
  
  // Update button visual
  const btn = document.getElementById('flipZonesBtn');
  if (btn) {
    btn.style.background = S.homeAttacksRightP1 ? '#374151' : '#7c3aed';
  }
  
  autoSave();
}

function updateClock() {
  // Just store the value, could trigger other updates
}

// ============================================================
// EXPORT
// ============================================================

/**
 * Helper functions to get code and ID from name for export
 */
function getEventTypeCodeAndId(typeName) {
  if (!typeName) return { code: '', id: '' };
  const found = S.eventTypesDB?.find(e => e.name === typeName || e.code === typeName);
  return found ? { code: found.code || '', id: found.id || '' } : { code: typeName, id: '' };
}

function getEventDetailCodeAndId(detailName, eventType) {
  if (!detailName) return { code: '', id: '' };
  const found = S.eventDetails1?.find(e => 
    (e.name === detailName || e.code === detailName) && 
    (e.eventType === eventType || !eventType)
  );
  return found ? { code: found.code || '', id: found.id || '' } : { code: detailName, id: '' };
}

function getEventDetail2CodeAndId(detail2Name) {
  if (!detail2Name) return { code: '', id: '' };
  const found = S.eventDetails2?.find(e => e.name === detail2Name || e.code === detail2Name);
  return found ? { code: found.code || '', id: found.id || '' } : { code: detail2Name, id: '' };
}

// Build the export workbook (reusable for both Export and Quick Save)
function buildExportWorkbook() {
  // Build LONG format export (one row per player per event)
  // Format matches ETL expected input with underscore suffix for input columns
  const rows = [];
  
  // Track zone changes for zone_change_index
  let lastZone = null;
  let zoneChangeIdx = 0;
  
  S.events.forEach((evt, i) => {
    const startTime = evt.start_time || evt.time || '';
    const endTime = evt.end_time || evt.start_time || evt.time || '';
    const [startMin, startSec] = (startTime || '').split(':');
    const [endMin, endSec] = (endTime || '').split(':');
    
    // Map zone to abbreviation (o/d/n)
    const zoneAbbr = evt.zone || 'n';
    
    // Track zone changes
    if (zoneAbbr !== lastZone) {
      zoneChangeIdx++;
      lastZone = zoneAbbr;
    }
    
    // Calculate time totals (clock counts down from periodLength:00 to 0:00)
    // Time elapsed = total period time - remaining time
    const period = parseInt(evt.period) || 1;
    const periodLengthMin = getPeriodLength(evt.period);
    const periodLengthSec = periodLengthMin * 60;
    const startMinInt = parseInt(startMin) || 0;
    const startSecInt = parseInt(startSec) || 0;
    const endMinInt = parseInt(endMin) || startMinInt;
    const endSecInt = parseInt(endSec) || startSecInt;
    // Remaining time in seconds: min*60 + sec
    // Elapsed time = periodLength*60 - remaining
    const startTotalSec = periodLengthSec - (startMinInt * 60 + startSecInt);
    const endTotalSec = periodLengthSec - (endMinInt * 60 + endSecInt);
    
    // Running time calculations - sum all previous periods
    let periodOffset = 0;
    for (let p = 1; p < period; p++) {
      periodOffset += getPeriodLengthSeconds(p);
    }
    const eventRunningStart = periodOffset + startTotalSec;
    const eventRunningEnd = periodOffset + endTotalSec;
    
    // Calculate running video time WITH intermissions
    const runningVideoTime = evt.videoTime || calculateRunningVideoTime(period, startTime);
    
    // Calculate intermission duration up to this point
    const int1 = S.videoTiming?.intermission1 || 0;
    const int2 = S.videoTiming?.intermission2 || 0;
    const int3 = S.videoTiming?.intermission3 || 0;
    let intermissionDuration = 0;
    if (period >= 2) intermissionDuration += int1;
    if (period >= 3) intermissionDuration += int2;
    if (period >= 4) intermissionDuration += int3;
    
    // Duration
    const duration = endTotalSec - startTotalSec;
    
    const base = {
      // Input columns (underscore suffix for ETL)
      'event_index_flag_': i + 1,
      'sequence_index_flag_': evt.sequenceIdx || '',
      'play_index_flag_': evt.playIdx || '',
      'linked_event_index_flag_': evt.linkedEventIdx !== null ? evt.linkedEventIdx + 1 : '',
      'assist_to_goal_index_flag_': evt.assistToGoalIdx !== null ? evt.assistToGoalIdx + 1 : '', // v23.8: Separate column for assists
      'event_start_min_': startMin || '',
      'event_start_sec_': startSec || '',
      'event_end_min_': endMin || '',
      'event_end_sec_': endSec || '',
      'event_team_zone_': zoneAbbr,
      'event_type_': evt.type,
      'event_detail_': evt.detail1 || '',
      'event_detail_2_': evt.detail2 || '',
      'event_successful_': evt.success || '',
      'team_': evt.team === 'home' ? 'h' : 'a',
      // Additional derived columns
      'period': evt.period,
      'event_index': 1000 + i,  // ETL format: 1000-based
      'tracking_event_index': 1000 + i,  // Same as event_index
      'linked_event_index': evt.linkedEventIdx !== null ? 1000 + evt.linkedEventIdx : '',
      'assist_to_goal_index': evt.assistToGoalIdx !== null ? 1000 + evt.assistToGoalIdx : '', // v23.8: Separate column for assists
      'game_id': S.gameId,
      'home_team': S.homeTeam,
      'away_team': S.awayTeam,
      'strength': evt.strength || '5v5',
      'event_team_zone': zoneAbbr === 'o' ? 'Offensive' : zoneAbbr === 'd' ? 'Defensive' : 'Neutral',
      // Non-underscore duplicates (ETL uses both)
      'event_start_min': startMin || '',
      'event_start_sec': startSec || '',
      'event_end_min': endMin || '',
      'event_end_sec': endSec || '',
      // Export codes and IDs instead of names
      'event_type_code': evt.typeCode || getEventTypeCodeAndId(evt.type).code,
      'event_type_id': evt.typeId || getEventTypeCodeAndId(evt.type).id,
      'event_detail_code': evt.detail1Code || getEventDetailCodeAndId(evt.detail1, evt.type).code,
      'event_detail_id': evt.detail1Id || getEventDetailCodeAndId(evt.detail1, evt.type).id,
      'event_detail_2_code': evt.detail2Code || getEventDetail2CodeAndId(evt.detail2).code,
      'event_detail_2_id': evt.detail2Id || getEventDetail2CodeAndId(evt.detail2).id,
      // Keep names for backward compatibility (but codes/IDs are primary)
      'event_detail': evt.detail1 || '',
      'event_detail_2': evt.detail2 || '',
      'event_successful': evt.success || '',
      // Calculated columns
      'time_start_total_seconds': startTotalSec,
      'time_end_total_seconds': endTotalSec,
      'duration': duration,
      'period_start_total_running_seconds': periodOffset,
      'running_video_time': runningVideoTime,
      'event_running_start': eventRunningStart,
      'event_running_end': eventRunningEnd,
      'running_intermission_duration': intermissionDuration,
      'zone_change_index': zoneChangeIdx,
      'shift_index': evt.shiftIdx || '',
      'is_highlight': evt.isHighlight ? 1 : 0,
      'video_url': evt.isHighlight && evt.videoUrl ? evt.videoUrl : '',  // v23.7: Individual highlight video URL
      'Type': evt.type  // Legacy uppercase column
    };
    
    // Add puck XY
    (evt.puckXY || []).forEach((xy, j) => {
      base[`puck_x_${j+1}`] = xy.x;
      base[`puck_y_${j+1}`] = xy.y;
    });
    
    // Net XY
    if (evt.netXY) {
      base.net_x = evt.netXY.x;
      base.net_y = evt.netXY.y;
    }
    
    // One row per player
    if (evt.players?.length) {
      evt.players.forEach(p => {
        const row = {...base};
        row['player_game_number_'] = p.num;
        row['player_game_number'] = p.num;
        // role_abrev: e1, e2, o1, o2, etc.
        const isOpp = p.role?.includes('opp');
        const rolePrefix = isOpp ? 'o' : 'e';
        row['role_abrev'] = rolePrefix + (p.roleNum || 1);
        row['role_abrev_binary_'] = rolePrefix;  // Just 'e' or 'o'
        row.player_role = p.role;
        row.player_name = p.name;
        row['play_detail1_'] = p.playD1 || '';
        row['play_detail2_'] = p.playD2 || '';
        row['play_detail_successful_'] = p.playSuccess || '';
        row['pressured_pressurer_'] = p.pressure || '';
        row['side_of_puck_'] = p.sideOfPuck || '';  // v16
        row.play_detail1 = p.playD1 || '';
        row.play_detail_2 = p.playD2 || '';
        row.play_detail_successful = p.playSuccess || '';
        row.pressured_pressurer = p.pressure || '';
        row.side_of_puck = p.sideOfPuck || '';  // v16
        
        // Player XY
        (p.xy || []).forEach((xy, j) => {
          row[`player_x_${j+1}`] = xy.x;
          row[`player_y_${j+1}`] = xy.y;
        });
        
        rows.push(row);
      });
    } else {
      // Event with no players still needs a row
      base['player_game_number_'] = '';
      base['role_abrev'] = '';
      rows.push(base);
    }
  });
  
  // Create workbook
  const wb = XLSX.utils.book_new();
  
  // Metadata sheet (v19: includes zone orientation, v23.6: includes video count)
  const metadata = [{
    game_id: S.gameId,
    home_team: S.homeTeam,
    away_team: S.awayTeam,
    period_length_minutes: S.periodLength,
    home_attacks_right_p1: S.homeAttacksRightP1 ? 1 : 0,
    export_timestamp: new Date().toISOString(),
    tracker_version: 'v23.6',
    total_videos: (S.videos && S.videos.length) || 0
  }];
  const wsMeta = XLSX.utils.json_to_sheet(metadata);
  XLSX.utils.book_append_sheet(wb, wsMeta, 'metadata');
  
  // Events sheet
  if (rows.length) {
    const ws = XLSX.utils.json_to_sheet(rows);
    XLSX.utils.book_append_sheet(wb, ws, 'events');
  }
  
  // Shifts sheet
  if (S.shifts.length) {
    // Calculate running goals from events AND per-shift goals
    let homeGoals = 0;
    let awayGoals = 0;
    
    // Pre-calculate goals by shift for running totals AND per-shift plus/minus
    const goalsByShift = [];
    S.shifts.forEach((s, i) => {
      // Store running total at shift START
      const goalsAtStart = { home: homeGoals, away: awayGoals };
      
      // Find goals that occurred IN this shift
      const shiftEvents = S.events.filter(e => 
        e.shiftIdx === i || 
        (e.period === s.period && isTimeBetween(e.start_time, s.start_time, s.end_time))
      );
      
      let homePlus = 0;  // Goals FOR home during this shift (EV/SH only)
      let awayPlus = 0;  // Goals FOR away during this shift (EV/SH only)
      
      // Get shift strength for PP determination
      const shiftStrength = s.strength || '5v5';
      const [homeStr, awayStr] = shiftStrength.split('v').map(n => parseInt(n) || 5);
      const homePP = homeStr > awayStr;  // Home on power play
      const awayPP = awayStr > homeStr;  // Away on power play
      
      shiftEvents.forEach(e => {
        if (e.type === 'Goal' && e.detail1 === 'Goal_Scored') {
          // Always update running total
          if (e.team === 'home') {
            homeGoals++;
            // Plus/minus: Only count if NOT a power play goal
            if (!homePP) {
              homePlus++;
            }
          } else {
            awayGoals++;
            // Away goal on away PP = no +/- change
            if (!awayPP) {
              awayPlus++;
            }
          }
        }
      });
      
      goalsByShift.push({ 
        startHome: goalsAtStart.home, 
        startAway: goalsAtStart.away,
        homePlus: homePlus,
        homeMinus: awayPlus,
        awayPlus: awayPlus,
        awayMinus: homePlus
      });
    });
    
    // Helper to determine zone from X coordinate
    const getZoneFromX = (x, team) => {
      if (x === null || x === undefined) return null;
      const isHome = team === 'home';
      if (x > 125) return isHome ? 'o' : 'd';
      if (x < 75) return isHome ? 'd' : 'o';
      return 'n';
    };
    
    const shiftRows = S.shifts.map((s, i) => {
      const stoppageTime = s.stoppageTime ?? calculateShiftStoppageTime(s);
      const duration = s.duration ?? calculateShiftDuration(s);
      
      const startMin = parseInt(s.start_time?.split(':')[0]) || 0;
      const startSec = parseInt(s.start_time?.split(':')[1]) || 0;
      const endMin = parseInt(s.end_time?.split(':')[0]) || startMin;
      const endSec = parseInt(s.end_time?.split(':')[1]) || startSec;
      
      const period = parseInt(s.period) || 1;
      const periodLengthSec = getPeriodLengthSeconds(s.period);
      // Time elapsed = period length - remaining time (clock counts down)
      const startTotalSec = periodLengthSec - (startMin * 60 + startSec);
      const endTotalSec = periodLengthSec - (endMin * 60 + endSec);
      
      // Running time calculations - sum all previous periods
      let periodOffset = 0;
      for (let p = 1; p < period; p++) {
        periodOffset += getPeriodLengthSeconds(p);
      }
      const startRunning = periodOffset + startTotalSec;
      const endRunning = periodOffset + endTotalSec;
      
      // Calculate running video time WITH intermissions
      const runningVideoTime = s.videoTime || calculateRunningVideoTime(period, s.start_time);
      
      // Calculate intermission duration up to this point
      const int1 = S.videoTiming?.intermission1 || 0;
      const int2 = S.videoTiming?.intermission2 || 0;
      const int3 = S.videoTiming?.intermission3 || 0;
      let shiftIntermissionDuration = 0;
      if (period >= 2) shiftIntermissionDuration += int1;
      if (period >= 3) shiftIntermissionDuration += int2;
      if (period >= 4) shiftIntermissionDuration += int3;
      
      // Determine zone from XY coordinates
      const startZone = s.start_xy?.x != null ? getZoneFromX(s.start_xy.x, 'home') : null;
      const endZone = s.end_xy?.x != null ? getZoneFromX(s.end_xy.x, 'home') : null;
      
      const goals = goalsByShift[i] || { startHome: 0, startAway: 0, homePlus: 0, homeMinus: 0, awayPlus: 0, awayMinus: 0 };
      
      return {
        shift_index: i,
        game_id: S.gameId,
        period: s.period,
        team: s.team,
        player_numbers: (s.players || []).join(','),
        start_time: s.start_time,
        end_time: s.end_time,
        start_type: s.start_type || '',
        stop_type: s.stop_type || '',
        strength: s.strength || '5v5',
        duration: duration,
        stoppage_time: stoppageTime,
        home_goals_start: goals.startHome,
        away_goals_start: goals.startAway,
        home_plus: goals.homePlus,
        home_minus: goals.homeMinus,
        away_plus: goals.awayPlus,
        away_minus: goals.awayMinus,
        start_x: s.start_xy?.x ?? '',
        start_y: s.start_xy?.y ?? '',
        end_x: s.end_xy?.x ?? '',
        end_y: s.end_xy?.y ?? '',
        start_zone: startZone || '',
        end_zone: endZone || '',
        home_ozone_start: startZone === 'o' ? 1 : 0,
        home_ozone_end: endZone === 'o' ? 1 : 0,
        home_dzone_start: startZone === 'd' ? 1 : 0,
        home_dzone_end: endZone === 'd' ? 1 : 0,
        home_nzone_start: startZone === 'n' ? 1 : 0,
        home_nzone_end: endZone === 'n' ? 1 : 0,
        period_start_total_running_seconds: periodOffset,
        running_video_time: runningVideoTime,
        running_intermission_duration: shiftIntermissionDuration,
        shift_start_running_time: startRunning,
        shift_end_running_time: endRunning
      };
    });
    const ws2 = XLSX.utils.json_to_sheet(shiftRows);
    XLSX.utils.book_append_sheet(wb, ws2, 'shifts');
  }
  
  // Videos sheet (v23.9: Game-level video metadata matching ETL expected format)
  // Calculate period start times
  const periodLengthSec = getPeriodLengthSeconds(1); // Period length in seconds
  const offset = S.videoTiming?.videoStartOffset || 0;
  const int1 = S.videoTiming?.intermission1 || 900;
  const int2 = S.videoTiming?.intermission2 || 900;
  
  const period1Start = offset; // Period 1 starts at video offset
  const period2Start = period1Start + periodLengthSec + int1;
  const period3Start = period2Start + periodLengthSec + int2;
  
  // Get video URL from videoTiming or first video in videos array
  const videoUrl = S.videoTiming?.youtubeUrl || 
                   (S.videos && S.videos.length > 0 ? S.videos[0].url : '') || 
                   '';
  
  // Get video type from first video or default to Full_Ice
  const videoType = (S.videos && S.videos.length > 0 && S.videos[0].type) ? 
                    S.videos[0].type : 'Full_Ice';
  
  // Get description from first video or default
  const description = (S.videos && S.videos.length > 0 && S.videos[0].description) ? 
                     S.videos[0].description : 
                     (S.videos && S.videos.length > 0 && S.videos[0].notes) ?
                     S.videos[0].notes : '';
  
  // Calculate duration if we have end time from last video
  let durationSeconds = '';
  if (S.videos && S.videos.length > 0) {
    const lastVideo = S.videos[S.videos.length - 1];
    if (lastVideo.end_time) {
      // Try to parse end_time as MM:SS and convert to seconds
      const endParts = lastVideo.end_time.split(':');
      if (endParts.length === 2) {
        const endMin = parseInt(endParts[0]) || 0;
        const endSec = parseInt(endParts[1]) || 0;
        durationSeconds = (endMin * 60) + endSec;
      }
    }
  }
  
  // Create video sheet with expected format (one row per game)
  const videoRows = [{
    game_id: S.gameId,
    video_type: videoType,
    video_url: videoUrl,
    duration_seconds: durationSeconds || '',
    period_1_start: period1Start,
    period_2_start: period2Start,
    period_3_start: period3Start,
    description: description
  }];
  
  const wsVideos = XLSX.utils.json_to_sheet(videoRows);
  XLSX.utils.book_append_sheet(wb, wsVideos, 'video');
  
  return wb;
}

function exportData() {
  if (!S.gameId) { toast('No game loaded', 'error'); return; }
  
  const wb = buildExportWorkbook();
  XLSX.writeFile(wb, `${S.gameId}_tracking.xlsx`);
  toast('Exported!', 'success');
}

// ============================================================
// IMPORT EXCEL
// ============================================================
async function importExcel(file) {
  if (!file) return;
  
  try {
    const data = await file.arrayBuffer();
    const wb = XLSX.read(data, { type: 'array' });
    
    console.log('Import: Sheets found:', wb.SheetNames);
    
    // Check for required sheets
    const hasEvents = wb.SheetNames.includes('events');
    const hasShifts = wb.SheetNames.includes('shifts');
    const hasMetadata = wb.SheetNames.includes('metadata');
    
    if (!hasEvents && !hasShifts) {
      toast('No events or shifts sheet found', 'error');
      return;
    }
    
    // Read videos sheet if present (v23.6)
    const hasVideos = wb.SheetNames.includes('videos');
    if (hasVideos) {
      const videosSheet = XLSX.utils.sheet_to_json(wb.Sheets['videos']);
      if (videosSheet && videosSheet.length > 0) {
        S.videos = videosSheet.map(v => ({
          id: Date.now().toString() + Math.random(),
          url: v.video_url || '',
          type: v.video_type || 'Full_Ice',
          video_id: v.video_id || '',
          title: v.title || undefined,
          description: v.description || undefined,
          start_time: v.start_time || undefined,
          end_time: v.end_time || undefined,
          period: v.period ? parseInt(v.period) : undefined,
          notes: v.notes || undefined
        }));
        toast(`Loaded ${S.videos.length} video(s)`, 'success');
      }
    }
    
    // Read metadata sheet if present (v19: includes zone orientation)
    if (hasMetadata) {
      const metaSheet = XLSX.utils.sheet_to_json(wb.Sheets['metadata']);
      if (metaSheet.length > 0) {
        const meta = metaSheet[0];
        if (meta.home_attacks_right_p1 !== undefined) {
          S.homeAttacksRightP1 = meta.home_attacks_right_p1 === 1 || meta.home_attacks_right_p1 === true;
          updateZoneLabels();
          const btn = document.getElementById('flipZonesBtn');
          if (btn) btn.style.background = S.homeAttacksRightP1 ? '#374151' : '#7c3aed';
        }
        if (meta.period_length_minutes) {
          S.periodLength = meta.period_length_minutes;
        }
        console.log('Import: Loaded metadata - homeAttacksRightP1:', S.homeAttacksRightP1);
      }
    }
    
    // Parse events sheet
    let importedEvents = [];
    let gameId = null;
    let homeTeam = null;
    let awayTeam = null;
    
    if (hasEvents) {
      const eventsSheet = XLSX.utils.sheet_to_json(wb.Sheets['events']);
      console.log('Import: Raw events rows:', eventsSheet.length);
      
      // Get game info from first row
      if (eventsSheet.length > 0) {
        gameId = eventsSheet[0].game_id;
        homeTeam = eventsSheet[0].home_team;
        awayTeam = eventsSheet[0].away_team;
      }
      
      // Group rows by event_index to reconstruct events with multiple players
      // The Excel is in LONG format (one row per player per event)
      const eventGroups = {};
      
      eventsSheet.forEach(row => {
        // Get event index - try multiple column names
        const eventIdx = row.event_index || row['event_index_flag_'] || row.event_index_ || row.tracking_event_index || 0;
        if (!eventIdx) return;
        
        // Get event type - prefer event_type_ over Type (Type is often sparse/calculated)
        const eventType = row.event_type_ || row['event_type_'] || row.Type || '';
        if (!eventType) return; // Skip rows without event type
        
        // Get times - check non-underscore columns first (they have actual data), then underscore versions
        const startMin = row.event_start_min ?? row['event_start_min_'] ?? '';
        const startSec = row.event_start_sec ?? row['event_start_sec_'] ?? '';
        const endMin = row.event_end_min ?? row['event_end_min_'] ?? '';
        const endSec = row.event_end_sec ?? row['event_end_sec_'] ?? '';
        
        if (!eventGroups[eventIdx]) {
          eventGroups[eventIdx] = {
            rows: [],
            period: row.period,
            type: eventType,
            team: parseTeam(row.team_ || row['team_'] || row.team_venue || row.team_venue_abv),
            zone: parseZone(row.event_team_zone_ || row['event_team_zone_'] || row.event_team_zone),
            success: parseSuccess(row.event_successful_ || row['event_successful_'] || row.event_successful),
            detail1: row.event_detail_ || row['event_detail_'] || row.event_detail || '',
            detail2: row.event_detail_2_ || row['event_detail_2_'] || row.event_detail_2 || '',
            start_time: formatTime(startMin, startSec),
            end_time: formatTime(endMin, endSec),
            strength: row.strength || '5v5',
            linkedEventIdx: row.linked_event_index_ || row['linked_event_index_'] || row.linked_event_index || null,
            assistToGoalIdx: row.assist_to_goal_index_ || row['assist_to_goal_index_'] || row.assist_to_goal_index ? (parseInt(row.assist_to_goal_index_ || row['assist_to_goal_index_'] || row.assist_to_goal_index) - 1000) : (row.assist_to_goal_index_flag_ ? parseInt(row.assist_to_goal_index_flag_) - 1 : null), // v23.8: Separate column for assists
            sequenceIdx: row.sequence_index_ || row['sequence_index_'] || row.sequence_index || null,
            playIdx: row.play_index_ || row['play_index_'] || row.play_index || null,
            isHighlight: row.is_highlight === 1 || row.is_highlight === true || false,  // v23.7: Import highlight flag
            videoUrl: row.video_url || ''  // v23.7: Import individual highlight video URL
          };
        }
        eventGroups[eventIdx].rows.push(row);
      });
      
      // Convert groups to events
      Object.keys(eventGroups).sort((a, b) => parseInt(a) - parseInt(b)).forEach((idx, i) => {
        const group = eventGroups[idx];
        const evt = {
          idx: i,
          period: parseInt(group.period) || 1,
          type: group.type || 'Unknown',
          team: group.team,
          zone: group.zone,
          success: group.success,
          detail1: group.detail1,
          detail2: group.detail2,
          start_time: group.start_time,
          end_time: group.end_time || group.start_time,
          strength: group.strength,
          linkedEventIdx: group.linkedEventIdx ? (group.linkedEventIdx >= 1000 ? parseInt(group.linkedEventIdx) - 1000 : parseInt(group.linkedEventIdx) - 1) : null,
          assistToGoalIdx: group.assistToGoalIdx ? (group.assistToGoalIdx >= 1000 ? parseInt(group.assistToGoalIdx) - 1000 : parseInt(group.assistToGoalIdx) - 1) : null, // v23.8: Separate column for assists
          sequenceIdx: group.sequenceIdx,
          playIdx: group.playIdx,
          players: [],
          puckXY: [],
          netXY: null,  // v23.5: Import net target location
          isHighlight: group.isHighlight || false,  // v23.7: Import highlight flag
          videoUrl: group.isHighlight && group.videoUrl ? group.videoUrl : undefined  // v23.7: Import individual highlight video URL
        };
        
        // Add players from rows
        group.rows.forEach(row => {
          const playerNum = row.player_game_number_ || row['player_game_number_'] || row.player_game_number;
          if (playerNum && !isNaN(parseInt(playerNum))) {
            const roleAbrev = row.role_abrev || '';
            const playerRoleRaw = row.player_role || '';
            const playerRole = parseRoleFromRaw(playerRoleRaw, roleAbrev);
            const numInt = parseInt(playerNum);
            
            // Determine player team based on role
            // event_team_player = same team as event
            // opp_team_player = opposite team
            const isOppPlayer = playerRoleRaw.includes('opp') || roleAbrev.toLowerCase().startsWith('o');
            let playerTeam = isOppPlayer 
              ? (group.team === 'home' ? 'away' : 'home')
              : group.team;
            
            // Try to get name from roster - check both teams to find the player
            let roster = S.rosters?.[playerTeam] || [];
            let rosterPlayer = roster.find(p => parseInt(p.num) === numInt);
            
            // If not found on expected team, check the other team
            if (!rosterPlayer) {
              const otherTeam = playerTeam === 'home' ? 'away' : 'home';
              const otherRoster = S.rosters?.[otherTeam] || [];
              const otherTeamPlayer = otherRoster.find(p => parseInt(p.num) === numInt);
              
              if (otherTeamPlayer) {
                // Player is on the other team - this will be flagged in validation
                // Keep the role-based assignment but validation will catch it
                console.warn(`Import: Player #${numInt} is on ${otherTeam} roster but role suggests ${playerTeam} team`);
              }
            }
            
            const playerName = rosterPlayer?.name || row.player_name || `#${numInt}`;
            
            evt.players.push({
              num: numInt,
              name: playerName,
              team: playerTeam,
              role: playerRole,
              roleNum: parseRoleNum(roleAbrev),
              playD1: row.play_detail1_ || row['play_detail1_'] || row.play_detail1 || '',
              playD2: row.play_detail2_ || row['play_detail2_'] || row.play_detail_2 || '',
              playSuccess: row.play_detail_successful_ || row['play_detail_successful_'] || row.play_detail_successful || '',
              pressure: row.pressured_pressurer_ || row['pressured_pressurer_'] || row.pressured_pressurer || '',
              sideOfPuck: row.side_of_puck_ || row['side_of_puck_'] || row.side_of_puck || '',
              xy: []
            });
            
            // v23.5: Extract player XY coordinates for this player
            const lastPlayer = evt.players[evt.players.length - 1];
            for (let k = 1; k <= 10; k++) {
              const plx = row[`player_x_${k}`];
              const ply = row[`player_y_${k}`];
              if (plx !== undefined && ply !== undefined && !isNaN(plx) && !isNaN(ply)) {
                lastPlayer.xy.push({ x: parseFloat(plx), y: parseFloat(ply), seq: k });
              }
            }
          }
          
          // Extract puck XY coordinates
          for (let j = 1; j <= 10; j++) {
            const px = row[`puck_x_${j}`];
            const py = row[`puck_y_${j}`];
            if (px !== undefined && py !== undefined && !isNaN(px) && !isNaN(py)) {
              // Only add if not already present (since it's repeated per player row)
              if (!evt.puckXY.find(p => p.x === px && p.y === py)) {
                evt.puckXY.push({ x: parseFloat(px), y: parseFloat(py) });
              }
            }
          }
          
          // v23.5: Extract net XY coordinates (shot target)
          if (!evt.netXY) {
            const nx = row.net_x ?? row['net_x'];
            const ny = row.net_y ?? row['net_y'];
            if (nx !== undefined && ny !== undefined && !isNaN(nx) && !isNaN(ny)) {
              evt.netXY = { x: parseFloat(nx), y: parseFloat(ny) };
            }
          }
        });
        
        importedEvents.push(evt);
      });
      
      console.log('Import: Parsed events:', importedEvents.length);
    }
    
    // Parse shifts sheet
    let importedShifts = [];
    
    if (hasShifts) {
      const shiftsSheet = XLSX.utils.sheet_to_json(wb.Sheets['shifts']);
      console.log('Import: Raw shifts rows:', shiftsSheet.length);
      
      // Get game info if not already set
      if (!gameId && shiftsSheet.length > 0) {
        gameId = shiftsSheet[0].game_id;
        homeTeam = shiftsSheet[0].home_team;
        awayTeam = shiftsSheet[0].away_team;
      }
      
      shiftsSheet.forEach((row, i) => {
        // Handle NaN values for stop_type
        let stopType = row.shift_stop_type;
        if (stopType === null || stopType === undefined || (typeof stopType === 'number' && isNaN(stopType)) || stopType === 'nan') {
          stopType = '';
        }
        
        const shift = {
          period: parseInt(row.Period) || 1,
          start_time: formatTime(row.shift_start_min, row.shift_start_sec),
          end_time: formatTime(row.shift_end_min, row.shift_end_sec),
          start_type: row.shift_start_type || 'OnTheFly',
          stop_type: stopType,
          strength: row.strength || '5v5',
          duration: row.shift_duration || null,
          stoppageTime: row.stoppage_time || 0,
          home: {
            F1: parsePlayer(row.home_forward_1, 'home'),
            F2: parsePlayer(row.home_forward_2, 'home'),
            F3: parsePlayer(row.home_forward_3, 'home'),
            D1: parsePlayer(row.home_defense_1, 'home'),
            D2: parsePlayer(row.home_defense_2, 'home'),
            G: parsePlayer(row.home_goalie, 'home'),
            X: parsePlayer(row.home_xtra, 'home')
          },
          away: {
            F1: parsePlayer(row.away_forward_1, 'away'),
            F2: parsePlayer(row.away_forward_2, 'away'),
            F3: parsePlayer(row.away_forward_3, 'away'),
            D1: parsePlayer(row.away_defense_1, 'away'),
            D2: parsePlayer(row.away_defense_2, 'away'),
            G: parsePlayer(row.away_goalie, 'away'),
            X: parsePlayer(row.away_xtra, 'away')
          }
        };
        importedShifts.push(shift);
      });
      
      console.log('Import: Parsed shifts:', importedShifts.length);
    }
    
    // Confirm import
    const evtCount = importedEvents.length;
    const shiftCount = importedShifts.length;
    const msg = `Import ${evtCount} events and ${shiftCount} shifts from game ${gameId}?\n\nThis will REPLACE current data.\n\nNote: Select the game in dropdown FIRST to load rosters for player name lookup.`;
    
    if (!confirm(msg)) {
      toast('Import cancelled', 'info');
      document.getElementById('importFileInput').value = '';
      return;
    }
    
    // Try to select the game if we have a gameId
    if (gameId) {
      S.gameId = parseInt(gameId);
      S.homeTeam = homeTeam;
      S.awayTeam = awayTeam;
      
      // Try to select the game in dropdown and load roster
      const gameSelect = document.getElementById('gameSelect');
      if (gameSelect && gameSelect.querySelector(`option[value="${gameId}"]`)) {
        gameSelect.value = gameId;
        // Try to load roster for this game
        try {
          await selectGame(gameId);
          // Re-process players with loaded roster
          importedShifts = importedShifts.map(shift => ({
            ...shift,
            home: {
              F1: shift.home.F1 ? parsePlayer(shift.home.F1.num, 'home') : null,
              F2: shift.home.F2 ? parsePlayer(shift.home.F2.num, 'home') : null,
              F3: shift.home.F3 ? parsePlayer(shift.home.F3.num, 'home') : null,
              D1: shift.home.D1 ? parsePlayer(shift.home.D1.num, 'home') : null,
              D2: shift.home.D2 ? parsePlayer(shift.home.D2.num, 'home') : null,
              G: shift.home.G ? parsePlayer(shift.home.G.num, 'home') : null,
              X: shift.home.X ? parsePlayer(shift.home.X.num, 'home') : null
            },
            away: {
              F1: shift.away.F1 ? parsePlayer(shift.away.F1.num, 'away') : null,
              F2: shift.away.F2 ? parsePlayer(shift.away.F2.num, 'away') : null,
              F3: shift.away.F3 ? parsePlayer(shift.away.F3.num, 'away') : null,
              D1: shift.away.D1 ? parsePlayer(shift.away.D1.num, 'away') : null,
              D2: shift.away.D2 ? parsePlayer(shift.away.D2.num, 'away') : null,
              G: shift.away.G ? parsePlayer(shift.away.G.num, 'away') : null,
              X: shift.away.X ? parsePlayer(shift.away.X.num, 'away') : null
            }
          }));
        } catch (e) {
          console.log('Could not load game roster:', e);
        }
      }
    }
    
    // v20.5: Load dim values and check for mapping needs
    await loadDimValuesForValidation();
    const mappingsNeeded = analyzeImportMappings(importedEvents);
    
    // Function to complete import (called after mappings are applied or skipped)
    const completeImport = (events, shifts) => {
      S.events = events;
      S.shifts = shifts;
      S.evtIdx = events.length;
      S.shiftIdx = shifts.length;
      
      // POST-IMPORT: Propagate XY data to linked events missing it
      propagateXYToLinkedEvents();
      
      // v23.8: Process all goals to detect and link assists
      processAllGoalsForAssists();
      
      // v23.8: Auto-mark all Goal events as highlights
      const goals = S.events.filter(e => e.type === 'Goal' && e.detail1 === 'Goal_Scored');
      goals.forEach(goal => {
        goal.isHighlight = true;
      });
      
      // Render
      renderAll();
      autoSave();
      
      toast(`Imported ${events.length} events, ${shifts.length} shifts`, 'success');
      console.log('Import complete:', { events: S.events.length, shifts: S.shifts.length });
      
      // v23.8: Show video URL entry modal for goals if any exist
      if (goals.length > 0) {
        setTimeout(() => {
          showGoalVideoUrlsModal(goals);
        }, 500);
      } else {
        // If no goals, just show verification
        setTimeout(() => {
          openVerifyModal();
        }, 500);
      }
    };
    
    // If mappings needed, show modal
    if (mappingsNeeded.length > 0) {
      console.log('Import: Found', mappingsNeeded.length, 'values needing mapping review');
      showMappingModal(
        mappingsNeeded,
        // onAccept - apply mappings then validate teams and show warning
        (finalMappings) => {
          const mappedEvents = applyMappingsToEvents(importedEvents, finalMappings);
          // Validate player teams and show warning if needed
          validatePlayerTeams(mappedEvents, () => {
            completeImport(mappedEvents, importedShifts);
          });
        },
        // onSkip - validate teams and show warning, then complete
        () => {
          toast('Skipped value mapping - using original values', 'info');
          validatePlayerTeams(importedEvents, () => {
            completeImport(importedEvents, importedShifts);
          });
        }
      );
    } else {
      // No mappings needed - validate teams and show warning
      console.log('Import: All values match dim tables');
      validatePlayerTeams(importedEvents, () => {
        completeImport(importedEvents, importedShifts);
      });
    }
    
  } catch (e) {
    console.error('Import error:', e);
    toast('Import failed: ' + e.message, 'error');
  }
  
  // Reset file input
  document.getElementById('importFileInput').value = '';
}

/**
 * POST-IMPORT: Propagate XY data to linked events missing it
 * For each event without puckXY, find a sibling (same linkedEventIdx) that has XY and copy it
 */
function propagateXYToLinkedEvents() {
  if (!S.events?.length) return;
  
  let propagatedCount = 0;
  
  // Group events by linkedEventIdx
  const linkedGroups = {};
  S.events.forEach((evt, idx) => {
    if (evt.linkedEventIdx !== null && evt.linkedEventIdx !== undefined) {
      const key = evt.linkedEventIdx;
      if (!linkedGroups[key]) linkedGroups[key] = [];
      linkedGroups[key].push({ evt, idx });
    }
  });
  
  // For each linked group, find events with XY and propagate to those without
  Object.values(linkedGroups).forEach(group => {
    // Find events in this group that have XY data
    const withXY = group.filter(g => g.evt.puckXY?.length > 0);
    const withoutXY = group.filter(g => !g.evt.puckXY?.length);
    
    if (withXY.length === 0 || withoutXY.length === 0) return;
    
    // Use the most recent event with XY as source
    const source = withXY.sort((a, b) => b.idx - a.idx)[0].evt;
    
    // Copy XY to events missing it
    withoutXY.forEach(({ evt, idx }) => {
      // Copy puck XY
      if (source.puckXY?.length) {
        S.events[idx].puckXY = JSON.parse(JSON.stringify(source.puckXY));
      }
      // Copy net XY
      if (source.netXY) {
        S.events[idx].netXY = JSON.parse(JSON.stringify(source.netXY));
      }
      // Copy player XY (without role swapping for simplicity during import)
      if (source.players?.length) {
        source.players.forEach(srcPlayer => {
          if (!srcPlayer.xy?.length) return;
          
          const existingIdx = S.events[idx].players?.findIndex(p => 
            p.num === srcPlayer.num && p.team === srcPlayer.team
          );
          
          if (existingIdx >= 0) {
            S.events[idx].players[existingIdx].xy = JSON.parse(JSON.stringify(srcPlayer.xy));
          } else {
            if (!S.events[idx].players) S.events[idx].players = [];
            S.events[idx].players.push(JSON.parse(JSON.stringify(srcPlayer)));
          }
        });
      }
      propagatedCount++;
    });
  });
  
  if (propagatedCount > 0) {
    console.log(`Propagated XY data to ${propagatedCount} linked events`);
    toast(`Filled XY for ${propagatedCount} linked events`, 'info');
  }
}

// Helper functions for import
function parseTeam(value) {
  if (!value) return 'home';
  const v = String(value).toLowerCase().trim();
  if (v === 'h' || v === 'home' || v.includes('home')) return 'home';
  if (v === 'a' || v === 'away' || v.includes('away')) return 'away';
  return 'home';
}

function parseZone(value) {
  if (!value) return 'n';
  const v = String(value).toLowerCase().trim();
  if (v === 'o' || v === 'off' || v.includes('offensive')) return 'o';
  if (v === 'd' || v === 'def' || v.includes('defensive')) return 'd';
  if (v === 'n' || v === 'neu' || v.includes('neutral')) return 'n';
  return 'n';
}

function parseSuccess(value) {
  if (value === null || value === undefined || value === '') return null;
  const v = String(value).toLowerCase().trim();
  if (v === 's' || v === 'y' || v === 'yes' || v === 'true' || v === '1') return true;
  if (v === 'u' || v === 'n' || v === 'no' || v === 'false' || v === '0') return false;
  return null;
}

function formatTime(min, sec) {
  if (min === null || min === undefined || min === '') return '';
  const m = String(min).padStart(2, '0');
  const s = String(sec || 0).padStart(2, '0');
  return `${m}:${s}`;
}

function parsePlayer(num, team) {
  if (!num || isNaN(parseInt(num))) return null;
  const numInt = parseInt(num);
  
  // Try to find player name from roster
  const roster = S.rosters?.[team] || [];
  const rosterPlayer = roster.find(p => parseInt(p.num) === numInt);
  
  return { 
    num: numInt, 
    name: rosterPlayer?.name || `#${numInt}` 
  };
}

function parseRoleFromRaw(rawRole, abrev) {
  // Convert Excel role format to tracker format
  // Excel: event_team_player_1, opp_team_player_1
  // Tracker: event_player_1, opp_player_1
  if (rawRole) {
    // Replace event_team_player with event_player
    if (rawRole.includes('event_team_player')) {
      return rawRole.replace('event_team_player', 'event_player');
    }
    // Replace opp_team_player with opp_player
    if (rawRole.includes('opp_team_player')) {
      return rawRole.replace('opp_team_player', 'opp_player');
    }
    // Already in correct format
    if (rawRole.includes('event_player') || rawRole.includes('opp_player')) {
      return rawRole;
    }
  }
  
  // Fall back to parsing from abbreviation
  return parseRoleFromAbrev(abrev);
}

function parseRoleFromAbrev(abrev) {
  if (!abrev) return 'event_player_1';
  const a = String(abrev).toLowerCase().trim();
  
  // e, e1, e2 -> event_player_X
  if (a === 'e' || a.startsWith('e')) {
    const num = parseInt(a.substring(1)) || 1;
    return `event_player_${num}`;
  }
  // o, o1, o2 -> opp_player_X
  if (a === 'o' || a.startsWith('o')) {
    const num = parseInt(a.substring(1)) || 1;
    return `opp_player_${num}`;
  }
  // h1, h2 -> event_player (home)
  if (a.startsWith('h')) {
    const num = parseInt(a.substring(1)) || 1;
    return `event_player_${num}`;
  }
  // a1, a2 -> could be either depending on context
  if (a.startsWith('a')) {
    const num = parseInt(a.substring(1)) || 1;
    return `event_player_${num}`;
  }
  
  return 'event_player_1';
}

function parseRoleNum(abrev) {
  if (!abrev) return 1;
  const match = String(abrev).match(/\d+/);
  return match ? parseInt(match[0]) : 1;
}

// ============================================================
// KEYBOARD
// ============================================================
function setupKeys() {
  document.addEventListener('keydown', e => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
    
    const key = e.key.toUpperCase();
    
    // Event type hotkeys - flash indicator on activation (v5)
    const typeMap = { F:'Faceoff', S:'Shot', P:'Pass', G:'Goal', T:'Turnover', Z:'Zone_Entry_Exit', N:'Penalty', X:'Stoppage', O:'Possession', V:'Save', R:'Rebound', D:'DeadIce', Y:'Play' };
    if (typeMap[key]) { 
      setEvtType(typeMap[key]); 
      flashHotkeyIndicator(key);
      return; 
    }
    
    // Enter = log event (with confirmation), Shift+Enter = quick log (no confirmation)
    if (e.key === 'Enter') { 
      if (e.shiftKey) {
        logEventDirect(); // Quick log without confirmation
      } else {
        logEvent(); // Normal log (shows confirmation if not skipped)
      }
      return; 
    }
    
    // Escape = clear or close modals
    if (e.key === 'Escape') { 
      // Close any open modals first
      const modals = document.querySelectorAll('.overlay.show');
      if (modals.length > 0) {
        modals.forEach(m => m.classList.remove('show'));
        return;
      }
      clearEvent(); 
      return; 
    }
    
    // L = log shift
    if (key === 'L') { logShift(); return; }
    
    // E = end shift (v5)
    if (key === 'E') { endShift(); return; }
    
    // Tab = switch XY mode
    if (e.key === 'Tab') { e.preventDefault(); setXYMode(S.xyMode === 'puck' ? 'player' : 'puck'); return; }
    
    // M = toggle XY mode (puck/player)
    if (key === 'M' && !e.ctrlKey && !e.altKey && !e.shiftKey) {
      e.preventDefault();
      const newMode = S.xyMode === 'puck' ? 'player' : 'puck';
      setXYMode(newMode);
      toast(newMode === 'puck' ? 'üèí Puck XY mode' : 'üë§ Player XY mode', 'info');
      return;
    }
    
    // v16.06: P = switch to puck XY mode
    if (key === 'P' && !e.ctrlKey && !e.altKey) { setXYMode('puck'); toast('üèí Puck XY mode', 'info'); return; }
    
    // [ and ] to cycle through players in XY dropdown (when in player mode or when players exist)
    if (e.key === '[' && S.curr.players.length > 0) {
      e.preventDefault();
      cycleXYPlayer(-1); // Previous player
      return;
    }
    if (e.key === ']' && S.curr.players.length > 0) {
      e.preventDefault();
      cycleXYPlayer(1); // Next player
      return;
    }
    
    // H/A = set team
    if (key === 'H') { setEvtTeam('home'); return; }
    if (key === 'A') { setEvtTeam('away'); return; }
    
    // Shift+S = swap event/opp teams (v23.3)
    if (e.shiftKey && key === 'S') { swapEvtTeam(); return; }
    
    // ` (backtick) = switch to puck XY mode (v16.06)
    if (e.key === '`') { 
      setXYMode('puck'); 
      toast('Switched to Puck XY mode', 'info'); 
      return; 
    }
    
    // v6: 1-6 = select event player slot (not period anymore)
    // Use Alt+1-6 for opponent players (Ctrl+1-6 conflicts with browser tab switching)
    // v23.3: If player is selected, reassign their role instead of adding new
    if (['1','2','3','4','5','6'].includes(e.key)) {
      e.preventDefault();
      const num = parseInt(e.key);
      
      // If Shift is held, force ADD new player (bypass role reassignment)
      if (e.shiftKey) {
        selectEventPlayerSlot(e.altKey ? 'opp' : 'evt', num);
        return;
      }
      
      // If a player is selected, reassign their role
      if (S.selectedPlayer) {
        const newRole = e.altKey ? 'opp_team_player_' + num : 'event_team_player_' + num;
        const oldRole = S.selectedPlayer.role;
        
        // Check if another player already has this role
        const existing = S.curr.players.find(p => p !== S.selectedPlayer && 
          (p.role === newRole || p.role === newRole.replace('_team', '') || p.roleNum === num));
        
        if (existing) {
          // Swap roles with existing player
          existing.role = oldRole;
          existing.roleNum = S.selectedPlayer.roleNum;
        }
        
        S.selectedPlayer.role = newRole;
        S.selectedPlayer.roleNum = num;
        renumberPlayers();
        renderQuickAdd();
        toast(`Reassigned #${S.selectedPlayer.num} to ${e.altKey ? 'O' : 'E'}${num}`, 'success');
        return;
      }
      
      // No player selected - use slot-based add/select
      if (e.altKey || e.ctrlKey) {
        selectEventPlayerSlot('opp', num);
      } else {
        selectEventPlayerSlot('evt', num);
      }
      return;
    }
    
    // Q = quick line change (v6)
    if (key === 'Q') { quickLineChange(); return; }
    
    // W = cycle forward presets, Shift+W = cycle D presets (v6)
    if (key === 'W') {
      if (e.shiftKey) {
        cyclePreset(S.evtTeam, 'D');
      } else {
        cyclePreset(S.evtTeam, 'F');
      }
      return;
    }
    
    // * = toggle highlight (v5)
    if (e.key === '*' || (e.shiftKey && e.key === '8')) {
      const hl = document.getElementById('isHighlight');
      if (hl) { hl.checked = !hl.checked; toast(hl.checked ? '‚≠ê Highlight ON' : 'Highlight OFF', 'info'); }
      return;
    }
    
    // Ctrl+Z = smart undo (XY if points exist, otherwise events)
    if (e.ctrlKey && key === 'Z' && !e.shiftKey) { 
      e.preventDefault(); 
      // If there are XY points to undo, undo those first
      if (S.curr && S.curr.puckXY && S.curr.puckXY.length > 0) {
        undoLastXY();
      } else if (undoStack && undoStack.length > 0) {
        undo();
      } else {
        undoLastXY(); // Fallback
      }
      return; 
    }
    
    // Ctrl+Shift+Z = force undo event (v23.5)
    if (e.ctrlKey && e.shiftKey && key === 'Z') { e.preventDefault(); undo(); return; }
    
    // Arrow keys in edit modals (v5) - prioritize over video controls
    if (S.editingEvtIdx !== null) {
      if (e.key === 'ArrowLeft') { e.preventDefault(); navEditEvent(-1); return; }
      if (e.key === 'ArrowRight') { e.preventDefault(); navEditEvent(1); return; }
    }
    if (S.editingShiftIdx !== null) {
      if (e.key === 'ArrowLeft') { e.preventDefault(); navEditShift(-1); return; }
      if (e.key === 'ArrowRight') { e.preventDefault(); navEditShift(1); return; }
    }
    
    // ? = open help
    if (e.key === '?') { openHelp(); return; }
  });
}

/**
 * Flash hotkey indicator for visual feedback (v5)
 */
function flashHotkeyIndicator(key) {
  const btn = document.querySelector(`.evt-btn[data-hotkey="${key}"]`);
  if (btn) {
    btn.classList.add('hotkey-flash');
    setTimeout(() => btn.classList.remove('hotkey-flash'), 300);
  }
}

/**
 * End current shift with current clock time (v5)
 */
function endShift() {
  const clock = document.getElementById('clock').value;
  document.getElementById('shiftEnd').value = clock;
  toast(`Shift end set to ${clock}`, 'info');
}

// ============================================================
// V6 FEATURES: LINE PRESETS, PERIOD FILTERS, COMPACT MODE
// ============================================================

// Line preset storage
S.linePresets = JSON.parse(localStorage.getItem('bs_line_presets') || '{}');
S.shiftLogFilter = 'all';
S.eventLogFilter = 'all';
// v20.4: Advanced event filters
S.eventFilters = {
  type: '',
  detail1: '',
  detail2: '',
  playDetail1: '',
  playDetail2: '',
  team: '',
  eventIdx: null,
  eventsBefore: 0, // v23.8: Show X events before found event
  eventsAfter: 0, // v23.8: Show X events after found event
  linkedIdx: null,
  shiftIdx: null,
  playerSearch: '' // v23.8: Search by player number or name
};
S.shiftLogPlayerFilter = ''; // v23.8: Search shifts by player number or name
// S.saveDirectoryHandle and S.maxBackups are now initialized in S object definition above
S.selectedPlayerSlot = null;
S.compactMode = false;

// v20.5: Dim table value cache for import validation
S.dimValues = {
  event_type: [],
  event_detail: [],
  event_detail_2: [],
  play_detail: [],
  play_detail_2: [],
  loaded: false
};
S.pendingMappings = null; // Holds mappings during modal review

/**
 * v20.5: Load dim table values from Supabase for import validation
 * v22.1: Fixed to load ALL values and better fallback
 */
async function loadDimValuesForValidation() {
  if (S.dimValues.loaded) return true;
  
  try {
    // Try Supabase first
    if (typeof supabase !== 'undefined' && S.sb) {
      const tables = [
        { name: 'dim_event_type', field: 'event_type', col: 'event_type_code' },
        { name: 'dim_event_detail', field: 'event_detail', col: 'event_detail_code' },
        { name: 'dim_event_detail_2', field: 'event_detail_2', col: 'event_detail_2_code' },
        { name: 'dim_play_detail', field: 'play_detail', col: 'play_detail_code' },
        { name: 'dim_play_detail_2', field: 'play_detail_2', col: 'play_detail_2_code' }
      ];
      
      let loadedCount = 0;
      for (const t of tables) {
        // v22.1: Load ALL rows (up to 1000) - use .limit(1000) to ensure we get everything
        const { data, error } = await S.sb.from(t.name).select(t.col).limit(1000);
        if (!error && data && data.length > 0) {
          S.dimValues[t.field] = data.map(r => r[t.col]).filter(Boolean);
          loadedCount++;
          console.log(`Loaded ${S.dimValues[t.field].length} values from ${t.name}`);
        } else {
          console.warn(`Failed to load ${t.name}:`, error || 'no data');
        }
      }
      
      if (loadedCount >= 3) {
        S.dimValues.loaded = true;
        console.log('Loaded dim values from Supabase:', Object.keys(S.dimValues).map(k => `${k}: ${S.dimValues[k]?.length || 0}`).join(', '));
        return true;
      }
    }
  } catch (e) {
    console.warn('Supabase dim load failed, using fallback:', e);
  }
  
  // v22.1: Comprehensive fallback values (if Supabase load fails)
  S.dimValues.event_type = ['Shot', 'Save', 'Pass', 'Faceoff', 'Turnover', 'Zone_Entry_Exit', 'Possession', 'Penalty', 'Hit', 'Block', 'Stoppage', 'Goal', 'GameStart', 'GameEnd', 'PeriodStart', 'PeriodEnd', 'Rebound', 'DeadIce', 'Play', 'Intermission', 'Clockstop', 'Timeout', 'LoosePuck', 'PenaltyShot_Shootout', 'Penalty_Delayed'];
  
  S.dimValues.event_detail = ['Shot_OnNetSaved', 'Shot_Goal', 'Goal_Scored', 'Shot_Missed', 'Shot_MissedWide', 'Shot_MissedHigh', 'Shot_HitPost', 'Shot_Blocked', 'Shot_TippedOnNetSaved', 'Shot_OnNetGoal', 'Shot_BlockedSameTeam', 'Shot_Deflected', 'Pass_Completed', 'Pass_Missed', 'Pass_Intercepted', 'Pass_Deflected', 'Turnover_Giveaway', 'Turnover_Takeaway', 'Zone_Entry', 'Zone_Exit', 'Zone_Keepin', 'Zone_EntryFailed', 'Zone_ExitFailed', 'Faceoff_Won', 'Faceoff_Lost', 'Faceoff_PeriodStart', 'Faceoff_GameStart', 'Faceoff_AfterGoal', 'Faceoff_AfterPenalty', 'Faceoff_AfterStoppage', 'Save_Rebound', 'Save_Freeze', 'Save_Played', 'Stoppage_PeriodEnd', 'Stoppage_Play', 'Stoppage_Other', 'Stoppage_GameEnd', 'Penalty_Minor', 'Penalty_Major', 'Penalty_Misconduct', 'Goal_Shootout', 'Goal_PenaltyShot', 'Rebound_TeamRecovered', 'Rebound_OppRecovered', 'Rebound_ShotGenerated', 'DeadIce_Icing', 'DeadIce_Offside', 'DeadIce_PuckOut', 'Play_Offensive', 'Play_Defensive', 'Breakaway', 'PuckRetrieval', 'PuckRecovery', 'Regroup', 'LoosePuck'];
  
  // v22.1: Full list of event_detail_2 values
  S.dimValues.event_detail_2 = [
    // Pass modifiers
    'Pass_Forehand', 'Pass_Backhand', 'Pass_Bank', 'Pass_Stretch', 'Pass_Rim/Wrap', 'Pass_Drop', 'Pass_Dump', 'Pass_OneTouch', 'Pass_Lob', 'Pass_Reverse', 'Pass_QuickUp', 'Pass_GiveAndGo', 'Pass_SecondTouch', 'Pass_Tipped', 'Pass_Deflected/TippedShot', 'Pass_ReceiverMissed', 'Pass_Other',
    // Shot modifiers
    'Shot_Wrist', 'Shot_Slap', 'Shot_Backhand', 'Shot_Snap', 'Shot_WrapAround', 'Shot_Bat', 'Shot_Poke', 'Shot_OneTime', 'Shot_Tip', 'Shot_Deflection', 'Shot_Other', 'Shot_BetweenLegs', 'Shot_Cradle',
    // Goal modifiers
    'Goal_Wrist', 'Goal_Slap', 'Goal_Backhand', 'Goal_Snap', 'Goal_WrapAround', 'Goal_Bat', 'Goal_Poke', 'Goal_OneTime', 'Goal_Tip', 'Goal_Deflection', 'Goal_Dumpin', 'Goal_Other', 'Goal_BetweenLegs', 'Goal_Cradle',
    // Save modifiers
    'Save_Glove', 'Save_Blocker', 'Save_Pad', 'Save_Stick', 'Save_Butterfly', 'Save_Other',
    // Zone entry modifiers
    'ZoneEntry_Rush', 'ZoneEntry_Carry', 'ZoneEntry_Pass', 'ZoneEntry_DumpIn', 'ZoneEntry_Chip', 'ZoneEntry_OppTeam', 'ZoneEntry_PassMiss/Misplay',
    // Zone exit modifiers  
    'ZoneExit_Rush', 'ZoneExit_Carry', 'ZoneExit_Pass', 'ZoneExit_Clear', 'ZoneExit_Chip', 'ZoneExit_PassMiss/Misplay',
    // Giveaway modifiers
    'Giveaway_Misplayed', 'Giveaway_BattleLost', 'Giveaway_PassIntercepted', 'Giveaway_PassMissed', 'Giveaway_PassBlocked', 'Giveaway_PassReceiverMissed', 'Giveaway_ShotBlocked', 'Giveaway_ShotMissed', 'Giveaway_DumpInZone', 'Giveaway_ZoneClear/Dump', 'Giveaway_ZoneEntry/ExitMisplay', 'Giveaway_AttemptedZoneClear/Dump', 'Giveaway_Other',
    // Takeaway modifiers
    'Takeaway_BattleWon', 'Takeaway_PokeCheck', 'Takeaway_PassIntercepted', 'Takeaway_PassBlocked', 'Takeaway_Other',
    // Stoppage modifiers
    'Stoppage_Icing', 'Stoppage_Offsides', 'Stoppage_GoalieStoppage', 'Stoppage_PuckOut', 'Stoppage_Penalty', 'Stoppage_Goal', 'Stoppage_HandPass', 'Stoppage_NetOff', 'Stoppage_Injury',
    // Penalty modifiers
    'Penalty_Tripping', 'Penalty_Hooking', 'Penalty_Slashing', 'Penalty_Interference', 'Penalty_Holding', 'Penalty_Roughing', 'Penalty_HighSticking', 'Penalty_CrossChecking', 'Penalty_Boarding', 'Penalty_Other',
    // Play context modifiers
    'Deke', 'DriveMiddle', 'DriveWide', 'DumpChase', 'Rush', 'Cycle', 'Rebound', 'OneTimer', 'Tip', 'Deflection', 'Breakaway', 'OddManRush', 'CrashNet', 'Forecheck', 'Backcheck', 'NetFront', 'PointShot', 'Screen',
    // Zone keep-in
    'Zone_KeepIn', 'ZoneEntry_KeepIn'
  ];
  
  // v22.1: Comprehensive play_detail fallback (111 values from dim_play_detail)
  S.dimValues.play_detail = ['AssistPrimary','AssistSecondary','AssistTertiary','AttemptedBlockedShot','AttemptedBreakOutClear','AttemptedBreakOutPass','AttemptedBreakOutRush','AttemptedEntryDumpIn','AttemptedEntryPass','AttemptedEntryRush','AttemptedKeepin','AttemptedPass','AttemptedShot','AttemptedTip/Deflection','Backcheck','BeatDeke','BeatFake','BeatMiddle','BeatSpeed','BeatWide','BlockedShot','BoxOut','Breakout','CededZoneEntry','CededZoneExit','Chip','ClearingAttempt','Contain','CrashNet','CutBack','Cycle','DeflectedShot','Deke','Delay','DelayedOffside','DriveCorner','DriveMiddle','DriveNetMiddle','DriveNetWide','DriveWide','Dump/RimInZone','DumpChase','DumpInAttempt','EndToEndRush','FakeShot','ForcedDumpin/Clear','ForcedLostPossession','ForcedMissedPass','ForcedMissedShot','ForcedTurnover','ForceWide','ForecedOutside','Forecheck','FrontofNet','GapControl','GiveAndGo','InShotPassLane','LoosePuckBattleLost','LoosePuckBattleWon','LostPuck','ManOnMan','MisplayedPuck','OpenIceDeke','Other','PassDeflected','PassForTip','PassIntercepted','PenaltyKillClear','PokeCheck','Pressure','PuckRecoveryRetreivalAttemptedClear','PuckRecoveryRetreivalClear','PuckRecoveryRetreivalDumpIn','PuckRecoveryRetreivalFaceoff','PuckRecoveryRetreivalLoosePuckBattle','PuckRecoveryRetreivalOther','PuckRecoveryRetreivalPass','PuckRecoveryRetreivalRebound','PuckRecoveryRetreivalShot','PuckRecoveryRetreivalTurnover','PuckRetrievalDumpIn','PuckRetrievalRebound','PuckRetrievalShot','QuickUp','ReceiverMissed','RecoveryRetreivalDumpIn','RecoveryRetreivalFaceoff','RecoveryRetreivalOther','RecoveryRetreivalPass','RecoveryRetreivalRebound','RecoveryRetreivalShot','RecoveryRetreivalTurnover','RecoveryRetrievalDumpIn','RecoveryRetrievalShot','Regroup','RegroupClear','RegroupDumpin','Reverse','Screen','SecondTouch','SeperateFromPuck','Speed','StickCheck','StoppedDeke','Surf','Tracker','Wheel','Zone','ZoneEntryDenial','ZoneExitDenial','ZoneKeepin'];
  
  // v22.1: Comprehensive play_detail_2 fallback (111 values from dim_play_detail_2)
  S.dimValues.play_detail_2 = ['AssistPrimary','AssistSecondary','AssistTertiary','AttemptedBlockedShot','AttemptedBreakOutClear','AttemptedBreakOutPass','AttemptedBreakOutRush','AttemptedEntryDumpIn','AttemptedEntryPass','AttemptedEntryRush','AttemptedKeepin','AttemptedPass','AttemptedShot','AttemptedTip/Deflection','Backcheck','BeatDeke','BeatFake','BeatMiddle','BeatSpeed','BeatWide','BlockedShot','BoxOut','Breakout','CededZoneEntry','CededZoneExit','Chip','ClearingAttempt','Contain','CrashNet','CutBack','Cycle','DeflectedShot','Deke','Delay','DelayedOffside','DriveCorner','DriveMiddle','DriveNetMiddle','DriveNetWide','DriveWide','Dump/RimInZone','DumpChase','DumpInAttempt','EndToEndRush','FakeShot','ForcedDumpin/Clear','ForcedLostPossession','ForcedMissedPass','ForcedMissedShot','ForcedTurnover','ForceWide','ForecedOutside','Forecheck','FrontofNet','GapControl','GiveAndGo','InShotPassLane','LoosePuckBattleLost','LoosePuckBattleWon','LostPuck','ManOnMan','MisplayedPuck','OpenIceDeke','Other','PassDeflected','PassForTip','PassIntercepted','PenaltyKillClear','PokeCheck','Pressure','PuckRecoveryRetreivalAttemptedClear','PuckRecoveryRetreivalClear','PuckRecoveryRetreivalDumpIn','PuckRecoveryRetreivalFaceoff','PuckRecoveryRetreivalLoosePuckBattle','PuckRecoveryRetreivalOther','PuckRecoveryRetreivalPass','PuckRecoveryRetreivalRebound','PuckRecoveryRetreivalShot','PuckRecoveryRetreivalTurnover','PuckRetrievalDumpIn','PuckRetrievalRebound','PuckRetrievalShot','QuickUp','ReceiverMissed','RecoveryRetreivalDumpIn','RecoveryRetreivalFaceoff','RecoveryRetreivalOther','RecoveryRetreivalPass','RecoveryRetreivalRebound','RecoveryRetreivalShot','RecoveryRetreivalTurnover','RecoveryRetrievalDumpIn','RecoveryRetrievalShot','Regroup','RegroupClear','RegroupDumpin','Reverse','Screen','SecondTouch','SeperateFromPuck','Speed','StickCheck','StoppedDeke','Surf','Tracker','Wheel','Zone','ZoneEntryDenial','ZoneExitDenial','ZoneKeepin'];
  
  S.dimValues.loaded = true;
  console.log('Loaded fallback dim values (Supabase unavailable)');
  return true;
}

/**
 * v20.5: Normalize string for fuzzy matching
 * Handles: case, underscores vs hyphens vs spaces, common prefixes
 */
function normalizeForMatch(str) {
  if (!str) return '';
  return str
    .toLowerCase()
    .replace(/[-_ ]/g, '')  // Remove separators
    .replace(/^(play|shot|pass|zone|turnover|giveaway|takeaway|save|faceoff|goal)[_-]?/i, '')  // Remove common prefixes for matching
    .trim();
}

/**
 * v23.5: Synonym map for fuzzy matching old data formats
 * Maps old terminology to current terminology (from Supabase dim tables)
 */
const VALUE_SYNONYMS = {
  // Zone Entry/Exit Rush = Carried (with puck control)
  'ZoneEntry_Rush': 'ZoneEntry_Carried',
  'ZoneEntry-Rush': 'ZoneEntry-Carried',
  'ZoneEntry Rush': 'ZoneEntry Carried',
  'Entry_Rush': 'Entry_Carried',
  'Entry-Rush': 'Entry-Carried',
  'Rush': 'Carried',
  
  'ZoneExit_Rush': 'ZoneExit_Carried', 
  'ZoneExit-Rush': 'ZoneExit-Carried',
  'ZoneExit Rush': 'ZoneExit Carried',
  'Exit_Rush': 'Exit_Carried',
  'Exit-Rush': 'Exit-Carried',
  
  // Other common mappings
  'Shot_OnNet': 'Shot_OnNetSaved',
  'Shot On Net': 'Shot_OnNetSaved',
  'Blocked': 'Shot_Blocked',
  'Missed': 'Shot_Missed'
};

/**
 * v23.5: Apply synonyms before fuzzy matching
 */
function applySynonyms(value) {
  if (!value) return value;
  
  // Check exact synonym match
  if (VALUE_SYNONYMS[value]) {
    return VALUE_SYNONYMS[value];
  }
  
  // Check case-insensitive
  const lower = value.toLowerCase();
  for (const [key, replacement] of Object.entries(VALUE_SYNONYMS)) {
    if (key.toLowerCase() === lower) {
      return replacement;
    }
  }
  
  // Check if value contains Rush (for zone entries/exits)
  if (value.toLowerCase().includes('rush') && 
      (value.toLowerCase().includes('entry') || value.toLowerCase().includes('exit') || value.toLowerCase().includes('zone'))) {
    return value.replace(/rush/gi, 'Carried');
  }
  
  return value;
}

/**
 * v20.5: Calculate match score between two strings (0-100)
 */
function matchScore(a, b) {
  if (!a || !b) return 0;
  
  // v23.5: Apply synonyms first
  const aSyn = applySynonyms(a);
  const bSyn = applySynonyms(b);
  
  const na = normalizeForMatch(aSyn);
  const nb = normalizeForMatch(bSyn);
  
  // Exact match (normalized)
  if (na === nb) return 100;
  
  // One contains the other
  if (na.includes(nb) || nb.includes(na)) return 85;
  
  // Levenshtein-ish: count common chars
  const setA = new Set(na.split(''));
  const setB = new Set(nb.split(''));
  const intersection = [...setA].filter(c => setB.has(c)).length;
  const union = new Set([...setA, ...setB]).size;
  const similarity = union > 0 ? (intersection / union) * 100 : 0;
  
  return Math.round(similarity);
}

/**
 * v20.5: Find best match from valid values
 * v23.5: Added synonym support for old data formats
 */
function findBestMatch(value, validValues, threshold = 60) {
  if (!value || !validValues?.length) return { match: null, score: 0, type: 'none' };
  
  // v23.5: Apply synonyms first (e.g., Rush -> Carry)
  const synonymValue = applySynonyms(value);
  
  // Check exact match first (case-insensitive) - with synonym applied
  const exactMatch = validValues.find(v => 
    v.toLowerCase() === value.toLowerCase() || 
    v.toLowerCase() === synonymValue.toLowerCase()
  );
  if (exactMatch) return { match: exactMatch, score: 100, type: 'exact' };
  
  // Fuzzy match using synonym-applied value
  let best = { match: null, score: 0 };
  for (const candidate of validValues) {
    const score = matchScore(synonymValue, candidate);
    if (score > best.score) {
      best = { match: candidate, score };
    }
  }
  
  if (best.score >= threshold) {
    return { ...best, type: 'fuzzy' };
  }
  
  return { match: null, score: best.score, type: 'none' };
}

/**
 * v20.5: Analyze imported events and find mappings needed
 */
function analyzeImportMappings(events) {
  const fields = [
    { key: 'type', dimKey: 'event_type', label: 'Event Type' },
    { key: 'detail1', dimKey: 'event_detail', label: 'Event Detail' },
    { key: 'detail', dimKey: 'event_detail', label: 'Event Detail' },  // Alias
    { key: 'detail2', dimKey: 'event_detail_2', label: 'Event Detail 2' }
  ];
  
  // Also check player play details
  const playerFields = [
    { key: 'playD1', dimKey: 'play_detail', label: 'Play Detail 1' },
    { key: 'playD2', dimKey: 'play_detail_2', label: 'Play Detail 2' }
  ];
  
  const mappings = [];
  const seenValues = new Set();
  
  // Collect unique values from events
  for (const evt of events) {
    for (const f of fields) {
      const val = evt[f.key];
      if (val && !seenValues.has(`${f.dimKey}:${val}`)) {
        seenValues.add(`${f.dimKey}:${val}`);
        const result = findBestMatch(val, S.dimValues[f.dimKey]);
        if (result.type !== 'exact') {
          mappings.push({
            field: f.label,
            dimKey: f.dimKey,
            eventKey: f.key,
            original: val,
            ...result
          });
        }
      }
    }
    
    // Check player play details
    for (const player of (evt.players || [])) {
      for (const f of playerFields) {
        const val = player[f.key];
        if (val && !seenValues.has(`${f.dimKey}:${val}`)) {
          seenValues.add(`${f.dimKey}:${val}`);
          const result = findBestMatch(val, S.dimValues[f.dimKey]);
          if (result.type !== 'exact') {
            mappings.push({
              field: f.label,
              dimKey: f.dimKey,
              eventKey: f.key,
              isPlayerField: true,
              original: val,
              ...result
            });
          }
        }
      }
    }
  }
  
  return mappings;
}

/**
 * v20.5: Show mapping modal for user review
 * v22.1: Added "Show More" functionality and ensured correct dim table per field
 */
function showMappingModal(mappings, onAccept, onSkip) {
  // Create modal HTML
  const fuzzyCount = mappings.filter(m => m.type === 'fuzzy').length;
  const noMatchCount = mappings.filter(m => m.type === 'none').length;
  
  let tableRows = mappings.map((m, i) => {
    // v22.1: Get options ONLY from the correct dim table for this field
    const allOptions = S.dimValues[m.dimKey] || [];
    const dimTableName = m.dimKey; // e.g., "event_detail_2"
    
    // v22.1: Sort options by relevance to the original value
    const scoredOptions = allOptions.map(o => ({
      value: o,
      score: matchScore(m.original, o)
    })).sort((a, b) => b.score - a.score);
    
    // v22.1: Show top 8 matches initially, with "Show More" to expand
    const topOptions = scoredOptions.slice(0, 8);
    const hasMore = scoredOptions.length > 8;
    
    // Build select HTML with top matches first
    let selectHtml = '<select id="mapping_' + i + '" class="mapping-select" onchange="handleMappingSelect(this, ' + i + ', \'' + m.dimKey + '\')">';
    selectHtml += '<option value="">-- No mapping --</option>';
    
    // Add suggested match first if it exists and not in top options
    if (m.match && !topOptions.find(o => o.value === m.match)) {
      const mScore = scoredOptions.find(o => o.value === m.match)?.score || m.score;
      selectHtml += '<option value="' + m.match + '" selected>‚úì ' + m.match + ' (' + mScore + '%)</option>';
    }
    
    // Add top scored options
    for (const opt of topOptions) {
      const selected = opt.value === m.match ? 'selected' : '';
      const scoreLabel = opt.score > 0 ? ' (' + opt.score + '%)' : '';
      selectHtml += '<option value="' + opt.value + '" ' + selected + '>' + opt.value + scoreLabel + '</option>';
    }
    
    // Add "Show More" option if there are more values
    if (hasMore) {
      selectHtml += '<option value="__SHOW_MORE__">‚ñº Show all ' + allOptions.length + ' from ' + dimTableName + '...</option>';
    }
    
    selectHtml += '</select>';
    
    const typeIcon = m.type === 'fuzzy' ? '‚âà' : '?';
    
    return '<tr data-dimkey="' + m.dimKey + '">' +
      '<td class="field">' + m.field + '</td>' +
      '<td class="original">' + m.original + '</td>' +
      '<td>' + typeIcon + '</td>' +
      '<td>' + selectHtml + '</td>' +
      '<td class="score">' + m.score + '%</td>' +
    '</tr>';
  }).join('');
  
  const modalHtml = 
    '<div class="modal mapping-modal" id="mappingModal">' +
      '<h3>üìã Import Value Mapping</h3>' +
      '<p class="summary">' +
        'Found <strong>' + mappings.length + '</strong> values needing review: ' +
        '<span style="color:var(--accent)">' + fuzzyCount + ' fuzzy matches</span>, ' +
        '<span style="color:var(--danger)">' + noMatchCount + ' no matches</span>' +
      '</p>' +
      '<p style="font-size:10px;color:var(--muted);">Each dropdown shows top matches from its correct dim table. Click "Show all" to see all options.</p>' +
      '<div class="mapping-legend">' +
        '<span><span class="dot exact"></span> Exact (auto-mapped)</span>' +
        '<span><span class="dot fuzzy"></span> Fuzzy (suggested)</span>' +
        '<span><span class="dot none"></span> No match (select manually)</span>' +
      '</div>' +
      '<table class="mapping-table">' +
        '<thead>' +
          '<tr><th>Field</th><th>Original Value</th><th>Type</th><th>Map To</th><th>Score</th></tr>' +
        '</thead>' +
        '<tbody>' + tableRows + '</tbody>' +
      '</table>' +
      '<div class="modal-actions">' +
        '<button class="btn-cancel" onclick="closeMappingModal(false)">Skip (Keep Original)</button>' +
        '<button class="btn-success" onclick="closeMappingModal(true)">Apply Mappings</button>' +
      '</div>' +
    '</div>' +
    '<div class="modal-overlay" onclick="closeMappingModal(false)"></div>';
  
  // Store callbacks
  S.pendingMappings = { mappings, onAccept, onSkip };
  
  // Show modal
  const container = document.createElement('div');
  container.id = 'mappingModalContainer';
  container.className = 'overlay show';
  container.innerHTML = modalHtml;
  document.body.appendChild(container);
}

/**
 * v22.1: Handle mapping select change - expand to show all options when "Show More" selected
 */
function handleMappingSelect(select, idx, dimKey) {
  if (select.value === '__SHOW_MORE__') {
    // Get all options from the correct dim table
    const allOptions = S.dimValues[dimKey] || [];
    const original = S.pendingMappings?.mappings[idx]?.original || '';
    
    // Sort by match score
    const scoredOptions = allOptions.map(o => ({
      value: o,
      score: matchScore(original, o)
    })).sort((a, b) => b.score - a.score);
    
    // Rebuild select with ALL options
    let newHtml = '<option value="">-- No mapping --</option>';
    for (const opt of scoredOptions) {
      const scoreLabel = opt.score > 0 ? ' (' + opt.score + '%)' : '';
      newHtml += '<option value="' + opt.value + '">' + opt.value + scoreLabel + '</option>';
    }
    
    select.innerHTML = newHtml;
    select.value = ''; // Reset selection so user can pick
    
    // Update the row to show it's expanded
    const row = select.closest('tr');
    if (row) {
      row.style.backgroundColor = 'rgba(100, 200, 255, 0.1)';
    }
    
    toast('Showing all ' + allOptions.length + ' values from ' + dimKey, 'info');
  }
}

function closeMappingModal(apply) {
  const container = document.getElementById('mappingModalContainer');
  if (!container) {
    console.warn('mappingModalContainer not found');
    return;
  }
  
  try {
    if (apply && S.pendingMappings) {
      // Read user selections
      const finalMappings = S.pendingMappings.mappings.map((m, i) => {
        const select = document.getElementById(`mapping_${i}`);
        if (select && select.value) {
          return {
            ...m,
            mappedTo: select.value
          };
        }
        return null;
      }).filter(m => m && m.mappedTo); // Only include ones with a mapping
      
      if (S.pendingMappings.onAccept && typeof S.pendingMappings.onAccept === 'function') {
        S.pendingMappings.onAccept(finalMappings);
      }
    } else {
      if (S.pendingMappings && S.pendingMappings.onSkip && typeof S.pendingMappings.onSkip === 'function') {
        S.pendingMappings.onSkip();
      }
    }
  } catch(e) {
    console.error('Error in closeMappingModal:', e);
  }
  
  // Close modal with animation
  container.classList.remove('show');
  setTimeout(() => {
    if (container && container.parentNode) {
      container.remove();
    }
    S.pendingMappings = null;
  }, 300);
}

/**
 * Validate that event players and opp players are on the correct teams
 * @param {Array} events - Events to validate
 * @param {Function} onComplete - Callback when validation is done (or user dismisses warning)
 */
function validatePlayerTeams(events, onComplete) {
  if (!events || events.length === 0) {
    if (onComplete) onComplete();
    return;
  }
  
  const issues = [];
  
  events.forEach((evt, evtIdx) => {
    if (!evt.players || evt.players.length === 0) return;
    
    const eventTeam = evt.team; // 'home' or 'away'
    const oppTeam = eventTeam === 'home' ? 'away' : 'home';
    
    evt.players.forEach((player, playerIdx) => {
      const isEventPlayer = player.role?.startsWith('event') || player.role?.includes('event');
      const isOppPlayer = player.role?.startsWith('opp') || player.role?.includes('opp');
      
      // Check if player is actually on the roster for their assigned team
      const assignedTeam = player.team;
      const roster = S.rosters?.[assignedTeam] || [];
      const playerOnRoster = roster.find(p => String(p.num) === String(player.num));
      
      // Check if player should be on event team or opp team based on role
      let expectedTeam = null;
      if (isEventPlayer) {
        expectedTeam = eventTeam;
      } else if (isOppPlayer) {
        expectedTeam = oppTeam;
      }
      
      // Issue 1: Player not on roster for assigned team
      if (!playerOnRoster && assignedTeam) {
        // Check if they're on the other team's roster
        const otherTeam = assignedTeam === 'home' ? 'away' : 'home';
        const otherRoster = S.rosters?.[otherTeam] || [];
        const onOtherTeam = otherRoster.find(p => String(p.num) === String(player.num));
        
        if (onOtherTeam) {
          issues.push({
            eventIdx: evtIdx,
            eventNum: evtIdx + 1,
            eventType: evt.type,
            eventTime: evt.start_time,
            playerNum: player.num,
            playerName: player.name,
            assignedTeam: assignedTeam,
            correctTeam: otherTeam,
            role: player.role,
            issue: 'wrong_team',
            message: `Event #${evtIdx + 1} (${evt.type} @ ${evt.start_time}): Player #${player.num} ${player.name} is assigned to ${assignedTeam} team but is on ${otherTeam} roster`
          });
        }
      }
      
      // Issue 2: Player role doesn't match expected team
      if (expectedTeam && assignedTeam !== expectedTeam) {
        issues.push({
          eventIdx: evtIdx,
          eventNum: evtIdx + 1,
          eventType: evt.type,
          eventTime: evt.start_time,
          playerNum: player.num,
          playerName: player.name,
          assignedTeam: assignedTeam,
          expectedTeam: expectedTeam,
          role: player.role,
          issue: 'role_team_mismatch',
          message: `Event #${evtIdx + 1} (${evt.type} @ ${evt.start_time}): Player #${player.num} ${player.name} has role "${player.role}" but is assigned to ${assignedTeam} team (should be ${expectedTeam})`
        });
      }
    });
  });
  
  if (issues.length > 0) {
    showTeamValidationWarning(issues, onComplete);
  } else {
    if (onComplete) onComplete();
  }
}

/**
 * Show warning modal for team validation issues
 */
function showTeamValidationWarning(issues, onComplete) {
  const wrongTeamIssues = issues.filter(i => i.issue === 'wrong_team');
  const roleMismatchIssues = issues.filter(i => i.issue === 'role_team_mismatch');
  
  const modalHtml = 
    '<div class="modal" id="teamValidationWarningModal" style="max-width:800px;max-height:80vh;overflow-y:auto;">' +
      '<h3>‚ö†Ô∏è Player Team Validation Warning</h3>' +
      '<p style="font-size:11px;color:var(--muted);margin-bottom:12px;">' +
        `Found <strong>${issues.length}</strong> player team issues. Please review and correct if needed.` +
      '</p>' +
      '<div style="margin-bottom:12px;">' +
        (wrongTeamIssues.length > 0 ? 
          `<div style="background:rgba(239,68,68,0.1);padding:8px;border-radius:4px;margin-bottom:8px;border-left:3px solid var(--danger);">
            <strong style="color:var(--danger);">${wrongTeamIssues.length} players on wrong team roster:</strong>
            <ul style="margin:4px 0;padding-left:20px;font-size:10px;">
              ${wrongTeamIssues.slice(0, 10).map(i => `<li>${i.message}</li>`).join('')}
              ${wrongTeamIssues.length > 10 ? `<li><em>...and ${wrongTeamIssues.length - 10} more</em></li>` : ''}
            </ul>
          </div>` : '') +
        (roleMismatchIssues.length > 0 ?
          `<div style="background:rgba(251,191,36,0.1);padding:8px;border-radius:4px;border-left:3px solid var(--warn);">
            <strong style="color:var(--warn);">${roleMismatchIssues.length} role/team mismatches:</strong>
            <ul style="margin:4px 0;padding-left:20px;font-size:10px;">
              ${roleMismatchIssues.slice(0, 10).map(i => `<li>${i.message}</li>`).join('')}
              ${roleMismatchIssues.length > 10 ? `<li><em>...and ${roleMismatchIssues.length - 10} more</em></li>` : ''}
            </ul>
          </div>` : '') +
      '</div>' +
      '<p style="font-size:10px;color:var(--muted);">' +
        'You can fix these issues by editing the events after import. Click "Continue" to proceed with import.' +
      '</p>' +
      '<div class="modal-actions">' +
        '<button class="btn-primary" onclick="closeTeamValidationWarning()">Continue with Import</button>' +
      '</div>' +
    '</div>' +
    '<div class="modal-overlay" onclick="closeTeamValidationWarning()"></div>';
  
  const container = document.createElement('div');
  container.id = 'teamValidationWarningContainer';
  container.className = 'overlay show';
  container.innerHTML = modalHtml;
  document.body.appendChild(container);
  
  // Store callback
  window.teamValidationCallback = onComplete;
}

function closeTeamValidationWarning() {
  const container = document.getElementById('teamValidationWarningContainer');
  if (container) {
    container.classList.remove('show');
    setTimeout(() => {
      if (container && container.parentNode) {
        container.remove();
      }
      if (window.teamValidationCallback) {
        window.teamValidationCallback();
        window.teamValidationCallback = null;
      }
    }, 300);
  }
}

/**
 * v20.5: Apply mappings to events array
 */
function applyMappingsToEvents(events, mappings) {
  if (!mappings?.length) return events;
  
  // Build lookup: original -> mapped
  const lookup = {};
  for (const m of mappings) {
    const key = `${m.eventKey}:${m.original}`;
    lookup[key] = m.mappedTo;
  }
  
  // Apply to events
  let changeCount = 0;
  for (const evt of events) {
    // Event-level fields
    for (const field of ['type', 'detail', 'detail1', 'detail2']) {
      const key = `${field}:${evt[field]}`;
      if (lookup[key]) {
        console.log(`Mapping ${field}: ${evt[field]} ‚Üí ${lookup[key]}`);
        evt[field] = lookup[key];
        changeCount++;
      }
    }
    
    // Player-level fields
    for (const player of (evt.players || [])) {
      for (const field of ['playD1', 'playD2']) {
        const key = `${field}:${player[field]}`;
        if (lookup[key]) {
          console.log(`Mapping player ${field}: ${player[field]} ‚Üí ${lookup[key]}`);
          player[field] = lookup[key];
          changeCount++;
        }
      }
    }
  }
  
  toast(`Applied ${changeCount} value mappings`, 'success');
  return events;
}

/**
 * Load a line preset into slots
 */
function loadPreset(team, preset) {
  const key = `${team}_${preset}`;
  const presetData = S.linePresets[key];
  if (!presetData || !presetData.players || presetData.players.length === 0) {
    toast(`No ${preset} preset saved for ${team}`, 'info');
    return;
  }
  
  // Determine which slots to fill based on preset type
  const isForward = preset.startsWith('F');
  const slots = isForward ? ['F1','F2','F3'] : ['D1','D2'];
  
  // Clear relevant slots first
  slots.forEach(slot => { S.slots[team][slot] = null; });
  
  // Fill slots with preset players
  presetData.players.forEach((num, i) => {
    if (i < slots.length) {
      const player = S.rosters[team].find(p => String(p.num) === String(num));
      if (player) {
        S.slots[team][slots[i]] = player;
      }
    }
  });
  
  renderSlots();
  renderRosters();
  onSlotsChanged();
  toast(`Loaded ${team} ${preset}: ${presetData.players.join(', ')}`, 'success');
}

/**
 * Save current slots as a preset
 */
function savePreset(team, preset) {
  const isForward = preset.startsWith('F');
  const slots = isForward ? ['F1','F2','F3'] : ['D1','D2'];
  
  const players = slots
    .map(slot => S.slots[team]?.[slot]?.num)
    .filter(num => num);
  
  if (players.length === 0) {
    toast(`No players in ${preset} slots`, 'warning');
    return;
  }
  
  const key = `${team}_${preset}`;
  S.linePresets[key] = { name: preset, players };
  localStorage.setItem('bs_line_presets', JSON.stringify(S.linePresets));
  toast(`Saved ${team} ${preset}: ${players.join(', ')}`, 'success');
}

/**
 * Cycle through forward or defense presets
 */
function cyclePreset(team, type) {
  const presets = type === 'F' ? ['F1','F2','F3'] : ['D1','D2'];
  const currentIdx = S.cycleIdx?.[team]?.[type] || 0;
  const nextIdx = (currentIdx + 1) % presets.length;
  
  if (!S.cycleIdx) S.cycleIdx = {};
  if (!S.cycleIdx[team]) S.cycleIdx[team] = {};
  S.cycleIdx[team][type] = nextIdx;
  
  loadPreset(team, presets[nextIdx]);
}

/**
 * Open line preset configuration modal
 */
function openLinePresetModal() {
  // Build modal content showing current presets
  let html = '<div style="max-height:400px;overflow-y:auto;">';
  
  ['home', 'away'].forEach(team => {
    html += `<h4 style="color:var(--accent);margin:8px 0 4px;">${team.toUpperCase()} PRESETS</h4>`;
    
    // Forward lines
    ['F1','F2','F3'].forEach(preset => {
      const key = `${team}_${preset}`;
      const data = S.linePresets[key];
      const players = data?.players?.join(', ') || 'Not set';
      html += `
        <div style="display:flex;gap:8px;align-items:center;margin:4px 0;">
          <span style="width:30px;font-weight:bold;">${preset}:</span>
          <span style="flex:1;color:var(--muted);">${players}</span>
          <button class="btn-sm" onclick="savePreset('${team}','${preset}')">Save Current</button>
          <button class="btn-sm" onclick="clearPreset('${team}','${preset}')">Clear</button>
        </div>`;
    });
    
    // Defense pairs
    ['D1','D2'].forEach(preset => {
      const key = `${team}_${preset}`;
      const data = S.linePresets[key];
      const players = data?.players?.join(', ') || 'Not set';
      html += `
        <div style="display:flex;gap:8px;align-items:center;margin:4px 0;">
          <span style="width:30px;font-weight:bold;">${preset}:</span>
          <span style="flex:1;color:var(--muted);">${players}</span>
          <button class="btn-sm" onclick="savePreset('${team}','${preset}')">Save Current</button>
          <button class="btn-sm" onclick="clearPreset('${team}','${preset}')">Clear</button>
        </div>`;
    });
  });
  
  html += '</div>';
  
  // Use a simple alert-style modal
  const modal = document.createElement('div');
  modal.className = 'overlay show';
  modal.id = 'linePresetModal';
  modal.innerHTML = `
    <div class="modal" style="min-width:400px;">
      <h3>‚öôÔ∏è Line Presets Configuration</h3>
      ${html}
      <p style="font-size:9px;color:var(--muted);margin-top:8px;">
        Fill slots with players, then click "Save Current" to save as a preset.
        Use preset buttons or W/Shift+W to cycle presets.
      </p>
      <div class="modal-actions" style="margin-top:16px;">
        <button class="btn-primary" onclick="closeLinePresetModal()">Close</button>
      </div>
    </div>`;
  document.body.appendChild(modal);
}

function closeLinePresetModal() {
  const modal = document.getElementById('linePresetModal');
  if (modal) modal.remove();
}

function clearPreset(team, preset) {
  const key = `${team}_${preset}`;
  delete S.linePresets[key];
  localStorage.setItem('bs_line_presets', JSON.stringify(S.linePresets));
  closeLinePresetModal();
  openLinePresetModal();
  toast(`Cleared ${team} ${preset}`, 'info');
}

/**
 * Filter shift log by period
 */
function filterShiftLog(period) {
  S.shiftLogFilter = period;

  // Update tab styles
  document.querySelectorAll('#leftPanel .period-filter-tab').forEach(tab => {
    tab.classList.toggle('active', tab.dataset.filter === period);
  });

  renderShiftLog();
}

/**
 * v23.8: Filter event log by player number or name
 */
function filterEventLogByPlayer(searchTerm) {
  if (!searchTerm || searchTerm.trim() === '') {
    // Clear player filter
    if (S.eventFilters) {
      S.eventFilters.playerSearch = '';
    }
    renderEvents();
    return;
  }
  
  const search = searchTerm.trim().toLowerCase();
  
  // Initialize eventFilters if needed
  if (!S.eventFilters) {
    S.eventFilters = {
      type: '', detail1: '', detail2: '', playDetail1: '', playDetail2: '',
      team: '', eventIdx: null, eventsBefore: 0, eventsAfter: 0,
      linkedIdx: null, shiftIdx: null, playerSearch: ''
    };
  }
  
  // Store search term
  S.eventFilters.playerSearch = search;
  
  // Re-render events with player filter
  renderEvents();
}

/**
 * v23.8: Filter shift log by player number or name
 */
function filterShiftLogByPlayer(searchTerm) {
  if (!searchTerm || searchTerm.trim() === '') {
    // Clear player filter
    if (S.shiftLogPlayerFilter) {
      S.shiftLogPlayerFilter = '';
    }
    renderShiftLog();
    return;
  }
  
  const search = searchTerm.trim().toLowerCase();
  S.shiftLogPlayerFilter = search;
  
  // Re-render shift log with player filter
  renderShiftLog();
}

/**
 * Filter event log by period
 */
function filterEventLog(period) {
  S.eventLogFilter = period;
  
  // Update tab styles
  document.querySelectorAll('.evt-list .period-filter-tab').forEach(tab => {
    tab.classList.toggle('active', tab.dataset.filter === period);
  });
  
  renderEvents();
}

/**
 * v20.4: Populate filter dropdowns with unique values from events
 */
function populateEventFilterDropdowns() {
  if (!S.events?.length) return;
  
  // Collect unique values
  const types = new Set();
  const detail1s = new Set();
  const detail2s = new Set();
  const pd1s = new Set();
  const pd2s = new Set();
  
  S.events.forEach(e => {
    if (e.type) types.add(e.type);
    if (e.detail1 || e.detail) detail1s.add(e.detail1 || e.detail);
    if (e.detail2) detail2s.add(e.detail2);
    
    // Get play details from primary player
    const primaryPlayer = (e.players || []).find(p => p.role?.startsWith('event') || !p.role?.startsWith('opp'));
    if (primaryPlayer?.playD1) pd1s.add(primaryPlayer.playD1);
    if (primaryPlayer?.playD2) pd2s.add(primaryPlayer.playD2);
  });
  
  // Helper to populate a select
  const populateSelect = (id, values) => {
    const sel = document.getElementById(id);
    if (!sel) return;
    const current = sel.value;
    sel.innerHTML = '<option value="">All</option>' + 
      [...values].sort().map(v => `<option value="${v}">${v.substring(0,15)}</option>`).join('');
    sel.value = current; // Restore selection
  };
  
  populateSelect('filterEvtType', types);
  populateSelect('filterEvtDetail1', detail1s);
  populateSelect('filterEvtDetail2', detail2s);
  populateSelect('filterPlayDetail1', pd1s);
  populateSelect('filterPlayDetail2', pd2s);
}

/**
 * v20.4: Apply event filters from UI
 */
function applyEventFilters() {
  S.eventFilters.type = document.getElementById('filterEvtType')?.value || '';
  S.eventFilters.detail1 = document.getElementById('filterEvtDetail1')?.value || '';
  S.eventFilters.detail2 = document.getElementById('filterEvtDetail2')?.value || '';
  S.eventFilters.playDetail1 = document.getElementById('filterPlayDetail1')?.value || '';
  S.eventFilters.playDetail2 = document.getElementById('filterPlayDetail2')?.value || '';
  S.eventFilters.team = document.getElementById('filterEvtTeam')?.value || '';
  
  const evtIdxVal = document.getElementById('filterEvtIdx')?.value;
  S.eventFilters.eventIdx = evtIdxVal ? parseInt(evtIdxVal) : null;
  
  // v23.8: Read "show X events before/after" values
  const eventsBeforeVal = document.getElementById('filterEventsBefore')?.value;
  S.eventFilters.eventsBefore = eventsBeforeVal ? parseInt(eventsBeforeVal) : 0;
  
  const eventsAfterVal = document.getElementById('filterEventsAfter')?.value;
  S.eventFilters.eventsAfter = eventsAfterVal ? parseInt(eventsAfterVal) : 0;
  
  const linkIdxVal = document.getElementById('filterLinkIdx')?.value;
  S.eventFilters.linkedIdx = linkIdxVal ? parseInt(linkIdxVal) : null;
  
  const shiftIdxVal = document.getElementById('filterShiftIdx')?.value;
  S.eventFilters.shiftIdx = shiftIdxVal ? parseInt(shiftIdxVal) : null;
  
  renderEvents();
}

/**
 * v20.4: Clear all event filters
 */
function clearEventFilters() {
  S.eventFilters = {
    type: '',
    detail1: '',
    detail2: '',
    playDetail1: '',
    playDetail2: '',
    team: '',
    eventIdx: null,
    eventsBefore: 0, // v23.8: Show X events before
    eventsAfter: 0, // v23.8: Show X events after
    linkedIdx: null,
    shiftIdx: null,
    playerSearch: '' // v23.8: Player search
  };

  // Clear UI elements
  ['filterEvtType', 'filterEvtDetail1', 'filterEvtDetail2', 'filterPlayDetail1',
   'filterPlayDetail2', 'filterEvtTeam'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.value = '';
  });
  ['filterEvtIdx', 'filterEventsBefore', 'filterEventsAfter', 'filterLinkIdx', 'filterShiftIdx'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.value = (id === 'filterEventsBefore' || id === 'filterEventsAfter') ? '0' : '';
  });
  
  // Clear player search
  const playerSearchEl = document.getElementById('eventLogPlayerSearch');
  if (playerSearchEl) playerSearchEl.value = '';

  renderEvents();
  toast('Filters cleared', 'info');
}

/**
 * Toggle compact mode
 */
function toggleCompactMode() {
  S.compactMode = !S.compactMode;
  document.body.classList.toggle('compact-mode', S.compactMode);
  toast(S.compactMode ? 'Compact mode ON' : 'Compact mode OFF', 'info');
}

/**
 * Toggle event log visibility (v17)
 */
function toggleEventLog() {
  const section = document.getElementById('eventLogSection');
  const body = document.getElementById('evtListBody');
  const tabs = section?.querySelector('.period-filter-tabs');
  
  if (body) {
    const isHidden = body.style.display === 'none';
    body.style.display = isHidden ? 'block' : 'none';
    if (tabs) tabs.style.display = isHidden ? 'flex' : 'none';
    toast(isHidden ? 'Event log shown' : 'Event log hidden', 'info');
  }
}

/**
 * Select event player slot for XY/details editing (v6)
 */
function selectEventPlayerSlot(type, num) {
  const rolePrefix1 = type === 'evt' ? 'event_team_player_' : 'opp_team_player_';
  const rolePrefix2 = type === 'evt' ? 'event_player_' : 'opp_player_';
  
  // Check if player with this role already exists (check both role formats)
  let player = S.curr.players.find(p => 
    p.role === rolePrefix1 + num || 
    p.role === rolePrefix2 + num ||
    (p.roleNum === num && p.role?.startsWith(type === 'evt' ? 'event' : 'opp'))
  );
  
  if (player) {
    // Player exists - just SELECT them (don't add duplicate)
    S.selectedPlayer = player;
    setXYMode('player');
    S.xySlot = (player.xy?.length || 0) + 1; // Start at next XY slot
    renderXYSlots();
    renderQuickAdd(); // Highlight selected player
    toast(`Selected ${type === 'evt' ? 'E' : 'O'}${num}: #${player.num}`, 'info');
    return;
  }
  
  // Player doesn't exist - try to add from slots
  const team = type === 'evt' ? S.evtTeam : (S.evtTeam === 'home' ? 'away' : 'home');
  const slots = S.slots[team];
  
  // Map slot positions to player numbers (F1, F2, F3, D1, D2)
  const slotMap = { 1: 'F1', 2: 'F2', 3: 'F3', 4: 'D1', 5: 'D2', 6: 'G' };
  const slotKey = slotMap[num];
  const slotPlayer = slots[slotKey];
  
  if (slotPlayer) {
    // Add player to current event
    player = {
      num: slotPlayer.num,
      name: slotPlayer.name,
      team: team,
      role: rolePrefix1 + num,
      roleNum: num,
      xy: [],
      playD1: '',
      playD2: '',
      playSuccess: '',
      pressuredBy: '',
      sideOfPuck: ''
    };
    S.curr.players.push(player);
    S.selectedPlayer = player;
    setXYMode('player');
    S.xySlot = 1;
    renderXYSlots();
    renderQuickAdd();
    toast(`Added ${type === 'evt' ? 'E' : 'O'}${num}: #${slotPlayer.num} ${slotPlayer.name}`, 'success');
  } else {
    toast(`${type === 'evt' ? 'Event' : 'Opp'} Player ${num} - No player in slot ${slotKey}`, 'warning');
    return;
  }
}

/**
 * Quick line change - ends all current shifts and starts new ones (v6)
 */
function quickLineChange() {
  const clock = document.getElementById('clock').value;
  
  // Log current shift with end time
  document.getElementById('shiftEnd').value = clock;
  logShift();
  
  // Start new shift immediately
  document.getElementById('shiftStart').value = clock;
  document.getElementById('shiftEnd').value = '';
  
  toast('Quick line change recorded', 'success');
}

// ============================================================
// RESIZE PANELS
// ============================================================
// v23.8: Enhanced resize system for modular layout
let resizing = null;
let savedPanelWidths = JSON.parse(localStorage.getItem('bs_panel_widths') || '{}');

function startResize(e, panel) {
  e.preventDefault();
  e.stopPropagation();
  const panelEl = document.getElementById(panel + 'Panel');
  resizing = { 
    panel, 
    startX: e.clientX, 
    startWidth: panelEl.offsetWidth,
    minWidth: 150,
    maxWidth: window.innerWidth * 0.5 // Max 50% of screen width
  };
  document.body.style.cursor = 'ew-resize';
  document.body.style.userSelect = 'none';
  document.addEventListener('mousemove', doResize);
  document.addEventListener('mouseup', stopResize);
  // Add active class to handle
  const handle = e.target;
  if (handle) handle.classList.add('active');
}

function doResize(e) {
  if (!resizing) return;
  e.preventDefault();
  const diff = e.clientX - resizing.startX;
  let newWidth;
  
  if (resizing.panel === 'left') {
    newWidth = resizing.startWidth + diff;
  } else if (resizing.panel === 'right') {
    newWidth = resizing.startWidth - diff;
  } else {
    return;
  }
  
  // Clamp to min/max
  newWidth = Math.max(resizing.minWidth, Math.min(resizing.maxWidth, newWidth));
  
  const panelEl = document.getElementById(resizing.panel + 'Panel');
  if (panelEl) {
    panelEl.style.width = newWidth + 'px';
    panelEl.style.flexShrink = '0';
    panelEl.style.flexGrow = '0';
    
    // Save to localStorage
    savedPanelWidths[resizing.panel] = newWidth;
    localStorage.setItem('bs_panel_widths', JSON.stringify(savedPanelWidths));
    
    // Update CSS variable for responsive layout
    if (resizing.panel === 'left') {
      document.documentElement.style.setProperty('--left-panel-width', newWidth + 'px');
    } else if (resizing.panel === 'right') {
      document.documentElement.style.setProperty('--right-panel-width', newWidth + 'px');
    }
  }
}

function stopResize() { 
  resizing = null; 
  document.body.style.cursor = '';
  document.body.style.userSelect = '';
  document.removeEventListener('mousemove', doResize); 
  document.removeEventListener('mouseup', stopResize);
  // Remove active class from all handles
  document.querySelectorAll('.resize-handle.active').forEach(h => h.classList.remove('active'));
}

// v23.8: Restore saved panel widths on load
function restorePanelWidths() {
  if (savedPanelWidths.left) {
    const leftPanel = document.getElementById('leftPanel');
    if (leftPanel) {
      leftPanel.style.width = savedPanelWidths.left + 'px';
      leftPanel.style.flexShrink = '0';
      leftPanel.style.flexGrow = '0';
      document.documentElement.style.setProperty('--left-panel-width', savedPanelWidths.left + 'px');
    }
  }
  if (savedPanelWidths.right) {
    const rightPanel = document.getElementById('rightPanel');
    if (rightPanel) {
      rightPanel.style.width = savedPanelWidths.right + 'px';
      rightPanel.style.flexShrink = '0';
      rightPanel.style.flexGrow = '0';
      document.documentElement.style.setProperty('--right-panel-width', savedPanelWidths.right + 'px');
    }
  }
}

// v23.8: Responsive layout adjustments
function adjustLayoutForScreenSize() {
  const width = window.innerWidth;
  const height = window.innerHeight;
  
  // On smaller screens, make panels more compact
  if (width < 1200) {
    // Reduce font sizes slightly
    document.documentElement.style.setProperty('--base-font-size', '10px');
    
    // Adjust panel min widths
    const leftPanel = document.getElementById('leftPanel');
    const rightPanel = document.getElementById('rightPanel');
    if (leftPanel && !savedPanelWidths.left) {
      leftPanel.style.width = '180px';
      document.documentElement.style.setProperty('--left-panel-width', '180px');
    }
    if (rightPanel && !savedPanelWidths.right) {
      rightPanel.style.width = '280px';
      document.documentElement.style.setProperty('--right-panel-width', '280px');
    }
  } else {
    document.documentElement.style.setProperty('--base-font-size', '11px');
  }
  
  // Adjust for height
  if (height < 700) {
    // Reduce max heights of scrollable areas
    document.querySelectorAll('.panel-body').forEach(el => {
      if (!el.style.maxHeight) {
        el.style.maxHeight = (height - 100) + 'px';
      }
    });
  }
}

// Listen for window resize
window.addEventListener('resize', adjustLayoutForScreenSize);

// ============================================================
// v23.4: GENERIC MODAL
// ============================================================

/**
 * Show generic modal with HTML content
 */
function showModal(html) {
  const overlay = document.getElementById('genericModal');
  const content = document.getElementById('genericModalContent');
  if (!overlay || !content) return;
  
  content.innerHTML = html;
  overlay.classList.add('show');
}

/**
 * Close generic modal
 */
function closeModal() {
  const overlay = document.getElementById('genericModal');
  if (overlay) overlay.classList.remove('show');
}

// ============================================================
// TOAST
// ============================================================
function toast(msg, type = '') {
  const el = document.getElementById('toast');
  el.textContent = msg;
  el.className = 'toast show ' + type;
  setTimeout(() => el.classList.remove('show'), 2000);
}

// ============================================================
// START
// ============================================================
document.addEventListener('DOMContentLoaded', () => {
  console.log('DOMContentLoaded - starting init');
  init().catch(e => {
    console.error('Init error:', e);
    // Even if init fails, try to build UI
    setTimeout(() => {
      console.log('Retrying buildUI after init error');
      buildUI();
    }, 500);
  });
});

// Also try to build buttons immediately if DOM is already ready
if (document.readyState === 'loading') {
  // DOM is still loading, wait for DOMContentLoaded
} else {
  // DOM is already ready, build buttons now as backup
  console.log('DOM already ready, building buttons as backup');
  setTimeout(buildEventTypeButtons, 100);
}
</script>
</body>
</html>
