<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BenchSight Tracker v23.3</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<style>
:root {
  --bg: #0a0e14; --panel: #131920; --card: #1a222c; --input: #0d1117;
  --border: #2a3441; --accent: #00d4aa; --accent2: #00b4d8;
  --success: #10b981; --warn: #f59e0b; --danger: #ef4444;
  --text: #e2e8f0; --muted: #64748b; --home: #3b82f6; --away: #ef4444;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: 'SF Mono', monospace; background: var(--bg); color: var(--text); font-size: 11px; overflow: hidden; height: 100vh; }
.app { display: grid; grid-template-rows: 36px 1fr; height: 100vh; }
.header { background: var(--panel); border-bottom: 1px solid var(--border); padding: 0 8px; display: flex; align-items: center; gap: 8px; }
.header h1 { font-size: 12px; background: linear-gradient(135deg, var(--accent), var(--accent2)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
.main { display: grid; grid-template-columns: 220px 1fr 320px; height: 100%; }
.panel { background: var(--panel); border-right: 1px solid var(--border); display: flex; flex-direction: column; overflow: hidden; position: relative; }
.panel:last-child { border-right: none; border-left: 1px solid var(--border); }
.panel-header { background: var(--card); padding: 4px 8px; font-size: 9px; font-weight: 600; text-transform: uppercase; color: var(--accent); border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; }
.panel-body { flex: 1; overflow-y: auto; padding: 6px; }
select, input, button { font-family: inherit; font-size: 10px; background: var(--input); border: 1px solid var(--border); color: var(--text); padding: 4px 6px; border-radius: 3px; }
select:focus, input:focus { border-color: var(--accent); outline: none; }
button { cursor: pointer; } button:hover { background: var(--card); border-color: var(--accent); }
.btn-sm { padding: 2px 5px; font-size: 9px; }
.btn-sm.active { background: var(--accent); color: #000; }
#quickDetailRow .btn-sm.active { background: var(--accent); color: #000; font-weight: bold; }
.btn-primary { background: var(--accent); color: #000; border-color: var(--accent); }
.btn-success { background: var(--success); color: #fff; }
.btn-danger { background: var(--danger); color: #fff; }
kbd { background: var(--bg); border: 1px solid var(--border); padding: 0 3px; border-radius: 2px; font-size: 8px; color: var(--muted); }
.form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 4px; }
.form-row.tri { grid-template-columns: 1fr 1fr 1fr; }
.form-group { display: flex; flex-direction: column; gap: 1px; }
.form-group label { font-size: 7px; color: var(--muted); text-transform: uppercase; }
.form-group select, .form-group input { width: 100%; }

/* Resize handles */
.resize-handle { position: absolute; background: transparent; z-index: 10; }
.resize-handle:hover { background: var(--accent); opacity: 0.5; }
.resize-handle.right { right: 0; top: 0; width: 4px; height: 100%; cursor: ew-resize; }

/* Header */
.game-select { width: 200px; }
.game-search { background: var(--input); border: 1px solid var(--border); color: var(--text); padding: 4px 8px; border-radius: 3px; width: 150px; font-size: 10px; }
.clock { font-size: 16px; font-weight: 700; color: var(--accent); background: var(--bg); padding: 2px 8px; border-radius: 3px; border: 1px solid var(--border); }
.score { font-size: 14px; font-weight: 700; }
.score-h { color: var(--home); } .score-a { color: var(--away); }
.period-btns { display: flex; gap: 2px; }
.period-btn { padding: 2px 6px; } .period-btn.active { background: var(--accent); color: #000; }
.header-right { margin-left: auto; display: flex; gap: 6px; align-items: center; }
.status { font-size: 8px; color: var(--muted); }
.save-ind { font-size: 7px; padding: 1px 4px; border-radius: 4px; background: var(--card); }
.save-ind.saving { background: var(--warn); color: #000; }
.save-ind.saved { background: var(--success); color: #fff; }
.conn { font-size: 7px; padding: 1px 4px; border-radius: 8px; }
.conn.on { background: var(--success); color: #fff; } .conn.off { background: var(--muted); color: #fff; }

/* Shift Panel */
.team-sec { margin-bottom: 8px; }
.team-hdr { display: flex; justify-content: space-between; align-items: center; padding: 3px 6px; background: var(--card); border-radius: 3px; margin-bottom: 3px; }
.team-hdr h4 { font-size: 9px; display: flex; align-items: center; gap: 4px; }
.team-dot { width: 8px; height: 8px; border-radius: 50%; }
.slots { display: grid; grid-template-columns: 20px 1fr; gap: 2px; margin-bottom: 2px; }
.slot-lbl { font-size: 7px; color: var(--muted); display: flex; align-items: center; }
.slot-row { display: flex; gap: 2px; }
.slot { flex: 1; min-height: 24px; border-radius: 3px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; border: 2px solid var(--border); background: var(--input); font-size: 10px; position: relative; transition: transform 0.1s, box-shadow 0.1s; }
.slot .num { font-weight: 700; } .slot .name { font-size: 6px; color: var(--muted); max-width: 40px; overflow: hidden; text-overflow: ellipsis; }
.slot.filled { border-color: var(--success); background: var(--card); cursor: grab; }
.slot.filled:active { cursor: grabbing; }
.slot.selected { box-shadow: 0 0 0 2px var(--accent); }
.slot.drag-over { border-color: var(--accent); background: rgba(0,212,170,0.2); transform: scale(1.05); }
.slot.dragging { opacity: 0.5; transform: scale(0.95); }
.slot .clear-x { position: absolute; top: -4px; right: -4px; width: 14px; height: 14px; border-radius: 50%; background: var(--danger); color: #fff; font-size: 10px; line-height: 14px; text-align: center; cursor: pointer; display: none; border: 1px solid var(--bg); z-index: 5; }
.slot.filled:hover .clear-x { display: block; }
.slot .clear-x:hover { background: #dc2626; transform: scale(1.1); }

/* Save Location UI */
.save-location-box { background: var(--card); border: 1px solid var(--border); border-radius: 4px; padding: 8px; margin-bottom: 8px; }
.save-location-box .folder-display { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
.save-location-box .folder-path { flex: 1; background: var(--bg); border: 1px solid var(--border); border-radius: 3px; padding: 6px 8px; font-size: 10px; color: var(--text); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.save-location-box .folder-path.empty { color: var(--muted); font-style: italic; }
.save-location-box .folder-actions { display: flex; gap: 4px; }
.save-location-box .folder-status { font-size: 9px; color: var(--muted); margin-top: 4px; }
.save-location-box .folder-status.ready { color: var(--success); }
.save-location-box .folder-status.error { color: var(--danger); }
.roster { background: var(--card); border-radius: 3px; padding: 3px; max-height: 100px; overflow-y: auto; }
.roster-group { margin-bottom: 4px; }
.roster-group-label { font-size: 7px; color: var(--accent); text-transform: uppercase; display: block; margin-bottom: 2px; }
.roster-btn { padding: 2px 4px; font-size: 8px; border-radius: 2px; cursor: pointer; border: 1px solid var(--border); background: var(--input); display: inline-flex; flex-direction: column; align-items: center; min-width: 36px; margin: 1px; }
.roster-btn .num { font-weight: 700; } .roster-btn .name { font-size: 6px; color: var(--muted); }
.roster-btn .rating { font-size: 6px; color: var(--accent); background: var(--bg); padding: 0 2px; border-radius: 2px; margin-top: 1px; }
.roster-btn:hover { background: var(--accent); color: #000; }
.roster-btn.on-ice { opacity: 0.3; }
.shift-times { display: grid; grid-template-columns: 1fr 1fr; gap: 3px; margin-top: 4px; padding: 4px; background: var(--card); border-radius: 3px; }
.shift-times label { font-size: 6px; color: var(--muted); }
.shift-actions { display: flex; gap: 3px; margin-top: 4px; }
.shift-actions button { flex: 1; padding: 6px; font-size: 9px; }

/* Center - Rink */
.center { display: flex; flex-direction: column; background: var(--panel); overflow-y: auto; }
.video-section { border-bottom: 2px solid var(--accent); }
.video-section .speed-btn.active { background: var(--accent); color: #000; }
.video-toggle-bar:hover { background: var(--panel); }
.rink-wrap { flex: 1; display: flex; align-items: center; justify-content: center; padding: 8px; position: relative; min-height: 300px; max-height: 450px; }
#rinkSvg { max-width: 100%; max-height: 100%; cursor: crosshair; }
.mode-ind { position: absolute; top: 6px; left: 50%; transform: translateX(-50%); padding: 3px 10px; border-radius: 12px; font-size: 9px; font-weight: 600; border: 2px solid; }
.mode-ind.puck { background: #000; color: #fff; border-color: #fff; }
.mode-ind.player { background: var(--accent); color: #000; border-color: var(--accent); }
.xy-controls { display: flex; gap: 4px; padding: 4px 8px; background: var(--card); border-top: 1px solid var(--border); align-items: center; flex-wrap: wrap; justify-content: center; }
.xy-btn { padding: 2px 6px; font-size: 9px; } .xy-btn.active { background: var(--accent); color: #000; }
.xy-slots { display: flex; gap: 1px; }
.xy-slot { width: 18px; height: 18px; border-radius: 2px; display: flex; align-items: center; justify-content: center; font-size: 8px; cursor: pointer; border: 1px solid var(--border); background: var(--input); }
.xy-slot.has { background: var(--success); color: #fff; } .xy-slot.active { box-shadow: 0 0 0 2px var(--accent); }
.xy-player-sel { min-width: 80px; font-size: 9px; }

/* Event List */
.evt-list { border-top: 1px solid var(--border); flex: 0 0 auto; min-height: 120px; max-height: 280px; overflow-y: auto; background: var(--card); }
.evt-header { display: grid; grid-template-columns: 35px 45px 100px 1fr 20px; gap: 2px; padding: 2px 6px; background: var(--card); font-size: 7px; color: var(--muted); position: sticky; top: 0; }
/* v20.4: Expanded columns - #, Sh, Lnk, Time, T, Type, Detail1, Detail2, Z, S, EvtP, OppP, PD1, PD2, PS, XY, ‚≠ê */
.evt-item { display: grid; grid-template-columns: 22px 22px 20px 48px 14px 46px 58px 58px 14px 12px 30px 30px 46px 46px 12px 12px 12px; gap: 1px; padding: 2px 3px; border-bottom: 1px solid var(--border); font-size: 7px; cursor: pointer; align-items: center; }
/* v20.4: Event log filter row */
.evt-filter-row { display: flex; flex-wrap: wrap; gap: 4px; padding: 4px 6px; background: var(--panel); border-bottom: 1px solid var(--border); align-items: center; }
.evt-filter-row select, .evt-filter-row input { font-size: 8px; padding: 2px 4px; background: var(--card); border: 1px solid var(--border); color: var(--text); border-radius: 3px; }
.evt-filter-row select { max-width: 80px; }
.evt-filter-row input { width: 40px; }
.evt-filter-row label { font-size: 7px; color: var(--muted); margin-right: 2px; }
.evt-filter-row .filter-group { display: flex; align-items: center; gap: 2px; }
.evt-filter-row .btn-clear { font-size: 8px; padding: 2px 6px; background: var(--danger); color: white; border: none; border-radius: 3px; cursor: pointer; }
.evt-item:hover { background: var(--panel); }
.evt-item.active { background: rgba(0,212,170,0.1); }
.evt-item .idx { color: var(--accent); font-family: monospace; font-size: 7px; }
.evt-item .seq { color: var(--accent2); font-family: monospace; font-size: 6px; }
.evt-item .link { color: var(--warn); font-family: monospace; font-size: 6px; }
.evt-item .time { color: var(--muted); font-size: 7px; }
.evt-item .team { font-weight: bold; font-size: 7px; }
.evt-item .type { font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 7px; }
.evt-item .detail { color: var(--muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 6px; }
.evt-item .zone { color: var(--accent2); font-size: 6px; }
.evt-item .success { color: var(--success); font-size: 7px; }
.evt-item .evtp { font-size: 6px; color: var(--accent); font-family: monospace; }
.evt-item .oppp { font-size: 6px; color: var(--muted); font-family: monospace; }
.evt-item .pd1 { font-size: 5px; color: var(--muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.evt-item .psucc { font-size: 6px; color: var(--success); }
.evt-item .xy-dot { color: var(--accent); font-size: 8px; }
.evt-item .hl { color: var(--warn); }

/* Right Panel - Event Entry */
.team-toggle { display: flex; gap: 2px; margin-bottom: 4px; }
.team-toggle button { flex: 1; padding: 5px; font-size: 9px; }
.team-toggle .swap-btn { flex: 0 0 28px; background: var(--card); border: 1px solid var(--border); font-size: 12px; padding: 2px; }
.team-toggle .swap-btn:hover { background: var(--accent); color: #000; }
.team-toggle .home.active { background: var(--home); color: #fff; }
.team-toggle .away.active { background: var(--away); color: #fff; }
.evt-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 2px; margin-bottom: 6px; }
.evt-btn { padding: 4px 2px; display: flex; flex-direction: column; align-items: center; font-size: 8px; border-radius: 3px; }
.evt-btn kbd { font-size: 7px; } .evt-btn.active { background: var(--accent); color: #000; }
.section { margin-bottom: 6px; }
.section-title { font-size: 8px; color: var(--muted); margin-bottom: 2px; display: flex; justify-content: space-between; }
.player-list { background: var(--card); border-radius: 3px; padding: 3px; min-height: 28px; }
.player-chip { display: inline-flex; align-items: center; gap: 2px; padding: 2px 5px; margin: 1px; border-radius: 3px; font-size: 9px; cursor: grab; border: 1px solid var(--border); background: var(--input); transition: transform 0.1s, opacity 0.1s; }
.player-chip:active { cursor: grabbing; }
.player-chip.dragging { opacity: 0.5; transform: scale(0.95); }
.player-chip.drag-over { transform: scale(1.05); box-shadow: 0 0 0 2px var(--accent); }
.player-chip .role-num { font-size: 7px; color: var(--muted); background: var(--bg); padding: 0 3px; border-radius: 2px; margin-right: 2px; }
.player-chip.evt { border-color: var(--accent); background: rgba(0,212,170,0.1); }
.player-chip.evt .role-num { color: var(--accent); }
.player-chip.opp { border-color: var(--danger); background: rgba(239,68,68,0.1); }
.player-chip.opp .role-num { color: var(--danger); }
.player-list { background: var(--card); border-radius: 3px; padding: 3px; min-height: 28px; }
.player-list.drag-target { background: rgba(0,212,170,0.1); border: 1px dashed var(--accent); }
.player-chip.selected { box-shadow: 0 0 0 2px var(--warn); }
.player-chip .num { font-weight: 700; }
.player-chip .su { font-size: 7px; padding: 0 2px; border-radius: 2px; margin-left: 2px; }
.player-chip .su.s { background: var(--success); color: #fff; }
.player-chip .su.u { background: var(--danger); color: #fff; }
.player-chip .remove { color: var(--muted); margin-left: 2px; } .player-chip .remove:hover { color: var(--danger); }
.quick-add { display: flex; flex-wrap: wrap; gap: 2px; padding: 3px; background: var(--card); border-radius: 3px; }
.quick-add button { padding: 2px 4px; font-size: 8px; min-width: 24px; }
.quick-add button.in-evt { background: var(--accent); color: #000; }
.quick-add button.recent { border: 2px solid var(--warning); box-shadow: 0 0 4px var(--warning); }
.player-details { background: var(--card); border-radius: 3px; padding: 4px; margin-top: 4px; font-size: 8px; }
.player-details h5 { color: var(--accent); margin-bottom: 3px; font-size: 9px; }
.log-actions { display: flex; gap: 3px; margin-top: 6px; }
.log-actions button { flex: 1; padding: 8px; font-size: 10px; }

/* Zone indicator */
.zone-ind { display: inline-block; padding: 2px 6px; border-radius: 3px; font-size: 8px; font-weight: bold; margin-left: 4px; }
.zone-ind.o { background: var(--success); color: #fff; }
.zone-ind.d { background: var(--danger); color: #fff; }
.zone-ind.n { background: var(--warn); color: #000; }

/* Modals */
.overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.85); display: none; align-items: center; justify-content: center; z-index: 100; }
.overlay.show { display: flex; }
.modal { background: var(--panel); border: 1px solid var(--border); border-radius: 6px; padding: 12px; min-width: 400px; max-width: 600px; max-height: 80vh; overflow-y: auto; }
.modal h3 { font-size: 12px; color: var(--accent); margin-bottom: 8px; }
.modal-actions { display: flex; gap: 4px; margin-top: 10px; }
.modal-actions button { flex: 1; }
/* v20.5: Mapping modal for import validation */
.mapping-modal { min-width: 700px; max-width: 900px; }
.mapping-modal h3 { font-size: 14px; margin-bottom: 12px; }
.mapping-modal .summary { font-size: 11px; color: var(--muted); margin-bottom: 10px; }
.mapping-table { width: 100%; border-collapse: collapse; font-size: 10px; margin: 10px 0; }
.mapping-table th { background: var(--card); color: var(--accent); padding: 6px 8px; text-align: left; border: 1px solid var(--border); }
.mapping-table td { padding: 6px 8px; border: 1px solid var(--border); }
.mapping-table tr:hover { background: rgba(0,212,255,0.1); }
.mapping-table .field { color: var(--muted); font-size: 9px; }
.mapping-table .original { color: var(--warn); font-family: monospace; }
.mapping-table .matched { color: var(--success); font-family: monospace; }
.mapping-table .no-match { color: var(--danger); }
.mapping-table select { font-size: 9px; padding: 2px 4px; max-width: 180px; background: var(--card); border: 1px solid var(--border); color: var(--text); }
.mapping-table .score { font-size: 9px; color: var(--muted); }
.mapping-legend { display: flex; gap: 15px; font-size: 9px; margin: 8px 0; }
.mapping-legend span { display: flex; align-items: center; gap: 4px; }
.mapping-legend .dot { width: 8px; height: 8px; border-radius: 50%; }
.mapping-legend .dot.exact { background: var(--success); }
.mapping-legend .dot.fuzzy { background: var(--accent); }
.mapping-legend .dot.none { background: var(--danger); }
.modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 999; }
.mapping-modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1000; }

/* Edit Modal Specific */
.edit-player-row { display: flex; gap: 4px; align-items: center; padding: 4px; background: var(--input); border-radius: 3px; margin-bottom: 4px; }
.edit-player-row .pnum { font-weight: bold; min-width: 50px; }
.edit-player-row select, .edit-player-row input { flex: 1; }
.edit-xy-grid { display: flex; gap: 2px; flex-wrap: wrap; margin-top: 4px; }
.edit-xy-btn { width: 24px; height: 24px; border-radius: 3px; display: flex; align-items: center; justify-content: center; font-size: 8px; cursor: pointer; }
.edit-xy-btn.has { background: var(--success); color: #fff; }

/* Toast */
.toast { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); background: var(--card); border: 1px solid var(--border); padding: 6px 14px; border-radius: 4px; font-size: 10px; z-index: 200; opacity: 0; transition: opacity 0.2s; }
.toast.show { opacity: 1; }
.toast.success { border-color: var(--success); color: var(--success); }
.toast.error { border-color: var(--danger); color: var(--danger); }

/* XY Tooltip v5 */
.xy-tooltip { position: absolute; background: rgba(0,0,0,0.9); color: #fff; padding: 6px 10px; border-radius: 4px; font-size: 10px; pointer-events: none; z-index: 100; white-space: nowrap; transform: translate(-50%, -100%); margin-top: -8px; }
.xy-tooltip::after { content: ''; position: absolute; bottom: -4px; left: 50%; transform: translateX(-50%); border-left: 5px solid transparent; border-right: 5px solid transparent; border-top: 5px solid rgba(0,0,0,0.9); }

/* Clear All Buttons v5 */
.clear-all-btn { padding: 4px 8px; font-size: 8px; background: var(--danger); color: #fff; border: none; border-radius: 3px; cursor: pointer; margin-left: 4px; }
.clear-all-btn:hover { background: #dc2626; }

/* Auto-popup checkbox v5 */
.auto-popup-row { display: flex; align-items: center; gap: 8px; margin: 8px 0; padding: 6px; background: var(--card); border-radius: 4px; font-size: 9px; }
.auto-popup-row input[type="checkbox"] { margin: 0; }

/* Enhanced player chip inline edit v5 */
.player-chip { position: relative; }
.player-chip .inline-edit { position: absolute; top: 100%; left: 0; background: var(--panel); border: 1px solid var(--accent); border-radius: 4px; padding: 4px; z-index: 50; min-width: 150px; display: none; }
.player-chip:hover .inline-edit.active { display: block; }

/* Hotkey indicator flash v5 */
.hotkey-flash { animation: hotkey-pulse 0.3s ease-out; }
@keyframes hotkey-pulse { 0% { box-shadow: 0 0 0 0 rgba(0,212,170,0.5); } 100% { box-shadow: 0 0 0 10px rgba(0,212,170,0); } }

/* Event type colors v5 */
.evt-btn[data-type="Goal"] { border-color: #22c55e !important; }
.evt-btn[data-type="Goal"].active { background: #22c55e !important; }
.evt-btn[data-type="Shot"] { border-color: #3b82f6 !important; }
.evt-btn[data-type="Shot"].active { background: #3b82f6 !important; }
.evt-btn[data-type="Penalty"] { border-color: #ef4444 !important; }
.evt-btn[data-type="Penalty"].active { background: #ef4444 !important; }
.evt-btn[data-type="Turnover"] { border-color: #f59e0b !important; }
.evt-btn[data-type="Turnover"].active { background: #f59e0b !important; }

/* Quick stats bar v5 */
.quick-stats { display: flex; gap: 8px; padding: 4px 8px; background: var(--card); font-size: 9px; border-bottom: 1px solid var(--border); }
.quick-stat { display: flex; align-items: center; gap: 4px; }
.quick-stat .label { color: var(--muted); }
.quick-stat .value { font-weight: bold; color: var(--accent); }

/* Period indicator enhanced v5 */
.period-btn.active { background: var(--accent); color: #000; font-weight: bold; }

/* Shift strength indicator v5 */
.strength-indicator { padding: 2px 6px; border-radius: 3px; font-size: 9px; font-weight: bold; }
.strength-indicator.pp { background: rgba(34,197,94,0.2); color: #22c55e; }
.strength-indicator.pk { background: rgba(239,68,68,0.2); color: #ef4444; }
.strength-indicator.even { background: rgba(100,116,139,0.2); color: #94a3b8; }

/* v6: Period filter tabs */
.period-filter-tabs { display: flex; gap: 2px; padding: 4px 8px; background: var(--bg); border-bottom: 1px solid var(--border); }
.period-filter-tab { padding: 2px 8px; font-size: 8px; border: 1px solid var(--border); border-radius: 3px; cursor: pointer; background: var(--input); color: var(--muted); }
.period-filter-tab.active { background: var(--accent); color: #000; border-color: var(--accent); }

/* v6: Line presets */
.line-presets { padding: 4px 8px; background: var(--card); border-bottom: 1px solid var(--border); font-size: 8px; }
.preset-row { display: flex; gap: 4px; align-items: center; margin-bottom: 2px; }
.preset-btn { padding: 2px 6px; font-size: 8px; border-radius: 3px; cursor: pointer; border: 1px solid var(--border); background: var(--input); }
.preset-btn:hover { background: var(--accent); color: #000; }
.preset-btn.active { border-color: var(--success); }

/* v6: Compact mode */
.compact-mode .panel-body { padding: 4px; }
.compact-mode .team-sec { margin-bottom: 4px; }
.compact-mode .team-hdr { padding: 2px 4px; margin-bottom: 2px; }
.compact-mode .slots { margin-bottom: 1px; }
.compact-mode .slot { min-height: 20px; font-size: 9px; }
.compact-mode .roster { max-height: 60px; padding: 2px; }
.compact-mode .roster-btn { padding: 1px 2px; font-size: 7px; min-width: 28px; }
.compact-mode .quick-stats { padding: 2px 8px; }

/* v6: Selected player indicator */
.selected-player-slot { box-shadow: 0 0 0 2px var(--accent), 0 0 8px var(--accent); }
.player-selector { display: inline-flex; align-items: center; gap: 2px; padding: 1px 4px; border-radius: 3px; font-size: 8px; cursor: pointer; border: 1px solid var(--border); }
.player-selector.selected { background: var(--accent); color: #000; border-color: var(--accent); }
</style>
</head>
<body>
<div class="app">
  <!-- Header -->
  <header class="header">
    <h1>üèí BenchSight v16.08</h1>
    <div style="display:flex;gap:4px;align-items:center;">
      <input type="text" id="gameSearch" class="game-search" placeholder="üîç Search games..." oninput="filterGames(this.value)">
      <select id="gameSelect" class="game-select" onchange="selectGame(this.value)"></select>
      <button class="btn-sm" onclick="loadGames()" title="Reload Games">üîÑ</button>
    </div>
    <div class="period-btns">
      <button class="period-btn active" data-p="1" onclick="setPeriod(1)">P1</button>
      <button class="period-btn" data-p="2" onclick="setPeriod(2)">P2</button>
      <button class="period-btn" data-p="3" onclick="setPeriod(3)">P3</button>
      <button class="period-btn" data-p="OT" onclick="setPeriod('OT')">OT</button>
      <span id="periodLengthIndicator" style="font-size:9px;color:var(--muted);margin-left:4px;" title="Current period length">(18m)</span>
      <button id="flipZonesBtn" onclick="flipZones()" title="Flip which end home attacks in P1 (for beer league variable benches)" style="margin-left:8px;padding:2px 6px;font-size:10px;background:#374151;">‚ü∑ Flip</button>
      <button class="btn-sm" onclick="showPeriodEndChecklist()" title="Period checklist & verification" style="font-size:9px;">üìã Check</button>
      <button class="btn-sm" onclick="setVideoOffset()" title="Set video sync offset" style="font-size:9px;">üé¨ Sync</button>
    </div>
    <span class="score"><span class="score-h" id="scoreH">0</span> - <span class="score-a" id="scoreA">0</span></span>
    <input type="text" class="clock" id="clock" value="18:00" style="width:60px;text-align:center;" onchange="updateClock()" oninput="autoFormatTime(this)">
    <div class="header-right">
      <span class="save-ind" id="saveInd">--</span>
      <button class="btn-sm" onclick="manualSave()" title="Save Now">üíæ</button>
      <button class="btn-sm" onclick="openLoadGameModal()" title="Load Existing Game">üìÇ</button>
      <button class="btn-sm" onclick="openVerifyModal()" title="Verify Goals">‚úÖ</button>
      <button class="btn-sm" onclick="openVideoTimingModal()" title="Video Timing">üé¨</button>
      <span class="conn off" id="connStatus">OFFLINE</span>
      <button class="btn-sm" onclick="openSettings()">‚öôÔ∏è</button>
      <button class="btn-sm" onclick="openHelp()" title="Quick Help (?)">‚ùì</button>
      <button class="btn-sm" onclick="openUserGuide()" title="Full User Guide" style="background:var(--accent);color:#000;">üìñ</button>
      <button class="btn-sm btn-success" onclick="exportData()">üì• Export</button>
      <button class="btn-sm" style="background:#6366f1;" onclick="document.getElementById('importFileInput').click()">üì§ Import</button>
      <input type="file" id="importFileInput" accept=".xlsx,.xls" style="display:none" onchange="importExcel(this.files[0])">
    </div>
  </header>
  
  <!-- Quick Stats Bar (v5) -->
  <div class="quick-stats" id="quickStatsBar">
    <div class="quick-stat"><span class="label">Events:</span><span class="value" id="qsEvents">0</span></div>
    <div class="quick-stat"><span class="label">Shifts:</span><span class="value" id="qsShifts">0</span></div>
    <div class="quick-stat"><span class="label">SOG:</span><span class="value" id="qsSOG">0-0</span></div>
    <div class="quick-stat"><span class="label">FO:</span><span class="value" id="qsFO">0-0</span></div>
    <div class="quick-stat"><span class="label">PEN:</span><span class="value" id="qsPEN">0-0</span></div>
    <div class="quick-stat" style="margin-left:auto;"><span class="label">Strength:</span><span class="value strength-indicator even" id="qsStrength">5v5</span></div>
  </div>
  
  <!-- v23.5: Workflow Bars -->
  <div class="workflow-bars" style="padding:4px 8px;background:var(--panel);border-bottom:1px solid var(--border);display:flex;flex-wrap:wrap;gap:8px;align-items:center;font-size:10px;">
    <!-- Possession -->
    <div style="display:flex;align-items:center;gap:4px;">
      <span style="color:var(--muted);font-size:8px;">POSS:</span>
      <button class="btn-sm" onclick="setPossession('home')" style="padding:2px 6px;background:var(--home);color:#fff;font-size:9px;">H</button>
      <div id="possessionDisplay" style="display:flex;align-items:center;width:80px;font-size:9px;">
        <span style="color:var(--home);">50%</span>
        <div style="flex:1;height:6px;background:var(--away);border-radius:3px;margin:0 4px;overflow:hidden;">
          <div style="width:50%;height:100%;background:var(--home);"></div>
        </div>
        <span style="color:var(--away);">50%</span>
      </div>
      <button class="btn-sm" onclick="setPossession('away')" style="padding:2px 6px;background:var(--away);color:#fff;font-size:9px;">A</button>
      <button class="btn-sm" onclick="resetPossessionTimers()" style="padding:2px 4px;font-size:8px;" title="Reset">‚Ü∫</button>
    </div>
    
    <span style="color:var(--border);">|</span>
    
    <!-- Penalty Box -->
    <div style="display:flex;align-items:center;gap:4px;">
      <span style="color:var(--muted);font-size:8px;">BOX:</span>
      <div id="penaltyBoxDisplay" style="display:flex;gap:4px;">
        <span style="font-size:9px;color:var(--muted);">No penalties</span>
      </div>
    </div>
    
    <span style="color:var(--border);">|</span>
    
    <!-- Quick Actions -->
    <div style="display:flex;align-items:center;gap:4px;">
      <button class="btn-sm" id="undoBtn" onclick="undo()" style="padding:2px 6px;font-size:9px;" title="Undo (Ctrl+Z)" disabled>‚Ü© Undo</button>
      <button class="btn-sm" id="batchSelectBtn" onclick="toggleBatchSelectMode()" style="padding:2px 6px;font-size:9px;" title="Batch select events">‚òë Batch</button>
      <button class="btn-sm" onclick="toggleKeyboardXYMode()" style="padding:2px 6px;font-size:9px;" title="WASD to move, Enter to place">‚å® XY</button>
      <button class="btn-sm" onclick="toggleStatsOverlay()" style="padding:2px 6px;font-size:9px;" title="Show stats on video">üìä</button>
      <button class="btn-sm" onclick="addQuickNote()" style="padding:2px 6px;font-size:9px;" title="Add note to event">üìù</button>
    </div>
    
    <span style="color:var(--border);">|</span>
    
    <!-- Recent Players -->
    <div style="display:flex;align-items:center;gap:4px;flex:1;">
      <span style="color:var(--muted);font-size:8px;">RECENT:</span>
      <div id="recentPlayersBar" style="display:flex;gap:2px;flex-wrap:wrap;">
        <span style="font-size:8px;color:var(--muted);">Recent players appear here</span>
      </div>
    </div>
  </div>
  
  <!-- v23.5: Event Queue & Suggestions -->
  <div style="display:flex;gap:8px;padding:4px 8px;background:var(--card);border-bottom:1px solid var(--border);align-items:center;min-height:24px;">
    <div id="eventSuggestions" style="display:flex;align-items:center;gap:4px;"></div>
    <div id="eventQueueDisplay" style="display:flex;align-items:center;gap:4px;flex-wrap:wrap;margin-left:auto;"></div>
    <button class="btn-sm" onclick="toggleSuggestions()" style="padding:2px 4px;font-size:8px;" title="Toggle suggestions">üí°</button>
  </div>
  
  <!-- v23.5: Speed Tools Bar -->
  <div style="display:flex;gap:8px;padding:3px 8px;background:var(--panel);border-bottom:1px solid var(--border);align-items:center;font-size:9px;">
    <!-- Mode Toggles -->
    <div style="display:flex;align-items:center;gap:2px;">
      <span style="color:var(--muted);font-size:8px;">MODE:</span>
      <button class="btn-sm" id="mirrorModeBtn" onclick="toggleMirrorMode()" style="padding:2px 5px;font-size:8px;" title="Auto-flip XY for P2">üîÑ Mirror</button>
      <button class="btn-sm" onclick="toggleAutoZone()" style="padding:2px 5px;font-size:8px;" title="Auto-set zone from XY">üéØ AutoZ</button>
      <button class="btn-sm" onclick="toggleGoalieAutoAdd()" style="padding:2px 5px;font-size:8px;" title="Auto-add goalie on shots">ü•Ö AutoG</button>
      <button class="btn-sm" onclick="toggleNumpadMode()" style="padding:2px 5px;font-size:8px;" title="Use numpad for player slots">üî¢ Numpad</button>
    </div>
    
    <span style="color:var(--border);">|</span>
    
    <!-- Quick Stoppages -->
    <div style="display:flex;align-items:center;gap:2px;">
      <span style="color:var(--muted);font-size:8px;">STOP:</span>
      <button class="btn-sm" onclick="quickIcing('home')" style="padding:2px 5px;font-size:8px;background:var(--home);color:#fff;">Ice-H</button>
      <button class="btn-sm" onclick="quickIcing('away')" style="padding:2px 5px;font-size:8px;background:var(--away);color:#fff;">Ice-A</button>
      <button class="btn-sm" onclick="quickOffside()" style="padding:2px 5px;font-size:8px;">Offside</button>
    </div>
    
    <span style="color:var(--border);">|</span>
    
    <!-- Strength Quick -->
    <div style="display:flex;align-items:center;gap:2px;">
      <span style="color:var(--muted);font-size:8px;">STR:</span>
      <button class="btn-sm strength-btn" data-strength="5v5" onclick="setStrength('5v5')" style="padding:2px 5px;font-size:8px;">5v5</button>
      <button class="btn-sm strength-btn" data-strength="5v4" onclick="setStrength('5v4')" style="padding:2px 5px;font-size:8px;background:var(--success);">PP</button>
      <button class="btn-sm strength-btn" data-strength="4v5" onclick="setStrength('4v5')" style="padding:2px 5px;font-size:8px;background:var(--danger);">PK</button>
      <button class="btn-sm strength-btn" data-strength="4v4" onclick="setStrength('4v4')" style="padding:2px 5px;font-size:8px;">4v4</button>
    </div>
    
    <span style="color:var(--border);">|</span>
    
    <!-- Empty Net & Tools -->
    <div style="display:flex;align-items:center;gap:2px;">
      <button class="btn-sm" onclick="toggleEmptyNet('home')" style="padding:2px 5px;font-size:8px;" title="Home empty net">EN-H</button>
      <button class="btn-sm" onclick="toggleEmptyNet('away')" style="padding:2px 5px;font-size:8px;" title="Away empty net">EN-A</button>
      <span id="emptyNetIndicator" style="display:none;font-weight:bold;padding:0 4px;"></span>
    </div>
    
    <span style="color:var(--border);">|</span>
    
    <!-- Analysis Tools -->
    <div style="display:flex;align-items:center;gap:2px;">
      <button class="btn-sm" onclick="findEventGaps()" style="padding:2px 5px;font-size:8px;" title="Find gaps in coverage">üîç Gaps</button>
      <button class="btn-sm" onclick="runConsistencyCheck()" style="padding:2px 5px;font-size:8px;" title="Check for issues">‚úÖ Check</button>
      <button class="btn-sm" onclick="toggleShotChartOverlay()" style="padding:2px 5px;font-size:8px;" title="Show shots on rink">üìç Shots</button>
    </div>
    
    <span style="color:var(--border);">|</span>
    
    <!-- Macros & Tools -->
    <div style="display:flex;align-items:center;gap:2px;">
      <button class="btn-sm" id="macroRecordBtn" onclick="recordingMacro ? stopRecordingMacro() : startRecordingMacro()" style="padding:2px 5px;font-size:8px;" title="Record event macro">‚è∫ Rec</button>
      <button class="btn-sm" onclick="showMacroManager()" style="padding:2px 5px;font-size:8px;" title="Manage macros">üé¨ Macros</button>
      <button class="btn-sm" onclick="toggleFloatingVideo()" style="padding:2px 5px;font-size:8px;" title="Floating video window">üì∫ Float</button>
    </div>
    
    <span style="color:var(--border);">|</span>
    
    <!-- Progress -->
    <div id="progressBar" style="min-width:100px;"></div>
  </div>

  <!-- Main -->
  <div class="main">
    <!-- Left: Shifts -->
    <div class="panel" id="leftPanel">
      <div class="resize-handle right" onmousedown="startResize(event, 'left')"></div>
      <div class="panel-header">
        <span>Shift Tracking</span>
        <button class="btn-sm" onclick="toggleCompactMode()" title="Toggle Compact Mode">‚äü</button>
      </div>
      <!-- v6: Line Presets -->
      <div class="line-presets" id="linePresetsBar">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:2px;">
          <span style="color:var(--muted);">LINE PRESETS</span>
          <button class="btn-sm" onclick="openLinePresetModal()">‚öôÔ∏è</button>
        </div>
        <div class="preset-row">
          <button class="preset-btn" onclick="loadPreset('home','F1')">F1</button>
          <button class="preset-btn" onclick="loadPreset('home','F2')">F2</button>
          <button class="preset-btn" onclick="loadPreset('home','F3')">F3</button>
          <button class="preset-btn" onclick="loadPreset('home','D1')">D1</button>
          <button class="preset-btn" onclick="loadPreset('home','D2')">D2</button>
          <span style="color:var(--muted);font-size:7px;">Home</span>
        </div>
        <div class="preset-row">
          <button class="preset-btn" onclick="loadPreset('away','F1')">F1</button>
          <button class="preset-btn" onclick="loadPreset('away','F2')">F2</button>
          <button class="preset-btn" onclick="loadPreset('away','F3')">F3</button>
          <button class="preset-btn" onclick="loadPreset('away','D1')">D1</button>
          <button class="preset-btn" onclick="loadPreset('away','D2')">D2</button>
          <span style="color:var(--muted);font-size:7px;">Away</span>
        </div>
      </div>
      <div class="panel-body">
        <!-- Home Team -->
        <div class="team-sec">
          <div class="team-hdr">
            <h4><img id="homeLogoImg" src="" alt="" style="height:20px;width:auto;margin-right:4px;display:none;vertical-align:middle;" onerror="this.style.display='none'" onload="this.style.display='inline'"><span class="team-dot" id="homeDot" style="background:var(--home)"></span><span id="homeLbl">Home</span></h4>
            <button class="btn-sm" onclick="clearSlots('home')">Clear</button>
          </div>
          <div class="slots"><span class="slot-lbl">F</span><div class="slot-row" id="homeF"></div></div>
          <div class="slots"><span class="slot-lbl">D</span><div class="slot-row" id="homeD"></div></div>
          <div class="slots"><span class="slot-lbl">G</span><div class="slot-row" id="homeG"></div></div>
          <div class="roster" id="homeRoster"></div>
        </div>
        <!-- Away Team -->
        <div class="team-sec">
          <div class="team-hdr">
            <h4><img id="awayLogoImg" src="" alt="" style="height:20px;width:auto;margin-right:4px;display:none;vertical-align:middle;" onerror="this.style.display='none'" onload="this.style.display='inline'"><span class="team-dot" id="awayDot" style="background:var(--away)"></span><span id="awayLbl">Away</span></h4>
            <button class="btn-sm" onclick="clearSlots('away')">Clear</button>
          </div>
          <div class="slots"><span class="slot-lbl">F</span><div class="slot-row" id="awayF"></div></div>
          <div class="slots"><span class="slot-lbl">D</span><div class="slot-row" id="awayD"></div></div>
          <div class="slots"><span class="slot-lbl">G</span><div class="slot-row" id="awayG"></div></div>
          <div class="roster" id="awayRoster"></div>
        </div>
        <!-- Shift Times -->
        <div class="shift-times">
          <div class="form-group"><label>Start Type</label><select id="shiftStartType"></select></div>
          <div class="form-group"><label>Stop Type</label><select id="shiftStopType"></select></div>
          <div class="form-group"><label>Start</label><input type="text" id="shiftStart" value="18:00" oninput="autoFormatTime(this)"></div>
          <div class="form-group"><label>End</label><input type="text" id="shiftEnd" value="" oninput="autoFormatTime(this)"></div>
        </div>
        <div class="shift-actions">
          <button class="btn-success" onclick="logShift()">Log Shift <kbd>L</kbd></button>
        </div>
        <!-- Shift Log -->
        <div class="log-container" style="margin-top:8px;">
          <div class="panel-header" style="font-size:8px;display:flex;justify-content:space-between;">
            <span>Shift Log</span>
            <span>
              <button class="btn-sm" onclick="addNewShift()" title="Add New Shift" style="background:var(--success);">‚ûï</button>
              <button class="clear-all-btn" onclick="clearAllShifts()" title="Clear All Shifts">üóëÔ∏è All</button>
              <button class="btn-sm" onclick="showAllShifts()">View All</button>
            </span>
          </div>
          <!-- v6: Period filter tabs -->
          <div class="period-filter-tabs">
            <button class="period-filter-tab active" data-filter="all" onclick="filterShiftLog('all')">ALL</button>
            <button class="period-filter-tab" data-filter="1" onclick="filterShiftLog('1')">P1</button>
            <button class="period-filter-tab" data-filter="2" onclick="filterShiftLog('2')">P2</button>
            <button class="period-filter-tab" data-filter="3" onclick="filterShiftLog('3')">P3</button>
            <button class="period-filter-tab" data-filter="OT" onclick="filterShiftLog('OT')">OT</button>
          </div>
          <div class="log-header" style="grid-template-columns: 25px 25px 40px 40px 60px;">
            <span>#</span><span>P</span><span>Start</span><span>End</span><span>Type</span>
          </div>
          <div id="shiftLogBody" style="max-height:200px;overflow-y:auto;"></div>
        </div>
        <!-- Player Box Score -->
        <div class="box-score" style="margin-top:8px;background:var(--card);border-radius:4px;padding:6px;">
          <div style="font-size:8px;color:var(--muted);margin-bottom:4px;display:flex;justify-content:space-between;">
            <span>PLAYER STATS</span>
            <button class="btn-sm" onclick="showFullBoxScore()">üìä</button>
          </div>
          <div id="playerBoxScore" style="max-height:120px;overflow-y:auto;">
            <table style="width:100%;font-size:8px;border-collapse:collapse;">
              <thead>
                <tr style="color:var(--muted);">
                  <td>#</td><td>Name</td><td>G</td><td>A</td><td>SOG</td><td>TOI</td>
                </tr>
              </thead>
              <tbody id="playerBoxBody"></tbody>
            </table>
          </div>
        </div>
        <!-- Team Summary -->
        <div class="team-summary" style="margin-top:4px;background:var(--card);border-radius:4px;padding:4px;font-size:8px;">
          <div style="display:flex;justify-content:space-between;">
            <span><span id="teamSumHome">HOME</span>: <strong id="teamSumHomeScore">0</strong></span>
            <span><span id="teamSumAway">AWAY</span>: <strong id="teamSumAwayScore">0</strong></span>
          </div>
          <div style="display:flex;justify-content:space-between;color:var(--muted);margin-top:2px;">
            <span>SOG: <span id="teamSumHomeSOG">0</span></span>
            <span>SOG: <span id="teamSumAwaySOG">0</span></span>
          </div>
        </div>
      </div>
    </div>

    <!-- Center: Rink -->
    <div class="center">
      <!-- v15.01: VIDEO PLAYER SECTION -->
      <div class="video-section" id="videoSection" style="display:none;">
        <div class="video-header" style="display:flex;justify-content:space-between;align-items:center;padding:4px 8px;background:var(--card);border-bottom:1px solid var(--border);">
          <div style="display:flex;align-items:center;gap:8px;">
            <span style="font-size:10px;font-weight:600;color:var(--accent);">üé¨ VIDEO</span>
            <select id="videoSourceSelect" onchange="switchVideoSource()" style="font-size:9px;width:120px;">
              <option value="">-- Sources --</option>
            </select>
            <button class="btn-sm" onclick="showAddVideoModal()" title="Add Video Source">+</button>
            <input type="file" id="videoFileInput" accept="video/*" style="display:none;" onchange="loadVideoFromFile(event)">
            <button class="btn-sm" onclick="document.getElementById('videoFileInput').click()" title="Load local file">üìÅ</button>
            <button class="btn-sm" onclick="showVideoSourcesManager()" title="Manage video sources">‚öôÔ∏è</button>
          </div>
          <div style="display:flex;align-items:center;gap:4px;">
            <!-- Video source hotkey buttons -->
            <div id="videoHotkeyBar" style="display:flex;gap:2px;margin-right:8px;"></div>
            <span id="videoTimeDisplay" style="font-size:12px;font-family:monospace;color:var(--accent);background:var(--bg);padding:2px 6px;border-radius:3px;">00:00:00</span>
            <span style="color:var(--muted);font-size:8px;">‚Üí</span>
            <span id="gameTimeFromVideo" style="font-size:10px;font-family:monospace;color:var(--warn);">P1 20:00</span>
            <button class="btn-sm" onclick="toggleVideoSection()" title="Minimize">‚ñº</button>
          </div>
        </div>
        <div id="videoPlayerContainer" style="position:relative;width:100%;height:200px;background:#000;overflow:hidden;">
          <!-- YouTube or HTML5 video will be inserted here -->
          <div id="videoPlaceholder" style="display:flex;align-items:center;justify-content:center;height:100%;color:var(--muted);font-size:11px;">
            No video loaded. Click + or üìÅ to add a video.
          </div>
          <div id="youtubePlayer" style="display:none;width:100%;height:100%;"></div>
          <video id="localVideoPlayer" style="display:none;width:100%;height:100%;" controls></video>
        </div>
        <!-- Video Scrub Bar -->
        <div id="videoScrubBar" style="padding:2px 8px;background:var(--card);"></div>
        <div class="video-controls" style="display:flex;gap:4px;padding:4px 8px;background:var(--card);border-top:1px solid var(--border);align-items:center;flex-wrap:wrap;">
          <!-- Playback controls -->
          <button class="btn-sm" onclick="videoSeek(-10)" title="Back 10s (Shift+‚Üê)">‚è™10</button>
          <button class="btn-sm" onclick="videoSeek(-1)" title="Back 1s (‚Üê)">‚óÄ1</button>
          <button class="btn-sm" onclick="videoFrameStep(-1)" title="Back 1 frame">|‚óÄ</button>
          <button class="btn-sm btn-primary" onclick="videoPlayPause()" id="videoPlayBtn" title="Play/Pause (Space)">‚ñ∂</button>
          <button class="btn-sm" onclick="videoFrameStep(1)" title="Forward 1 frame">‚ñ∂|</button>
          <button class="btn-sm" onclick="videoSeek(1)" title="Forward 1s">1‚ñ∂</button>
          <button class="btn-sm" onclick="videoSeek(10)" title="Forward 10s">10‚è©</button>
          
          <span style="color:var(--border);">|</span>
          
          <!-- Speed controls -->
          <span style="font-size:8px;color:var(--muted);">Speed:</span>
          <button class="btn-sm speed-btn" onclick="setVideoSpeed(0.25)" data-speed="0.25">0.25x</button>
          <button class="btn-sm speed-btn" onclick="setVideoSpeed(0.5)" data-speed="0.5">0.5x</button>
          <button class="btn-sm speed-btn active" onclick="setVideoSpeed(1)" data-speed="1">1x</button>
          <button class="btn-sm speed-btn" onclick="setVideoSpeed(1.5)" data-speed="1.5">1.5x</button>
          <button class="btn-sm speed-btn" onclick="setVideoSpeed(2)" data-speed="2">2x</button>
          
          <span style="color:var(--border);">|</span>
          
          <!-- Time sync controls -->
          <label style="font-size:8px;color:var(--muted);display:flex;align-items:center;gap:2px;">
            <input type="checkbox" id="videoAutoSync" checked onchange="toggleVideoAutoSync()"> Auto-sync times
          </label>
          <button class="btn-sm" onclick="captureStartTime()" title="Set event/shift START to current video time">üìç Start</button>
          <button class="btn-sm" onclick="captureEndTime()" title="Set event/shift END to current video time">üìç End</button>
          
          <span style="color:var(--border);">|</span>
          
          <!-- Zoom controls -->
          <span style="font-size:8px;color:var(--muted);">Zoom:</span>
          <button class="btn-sm" onclick="videoZoomOut()" title="Zoom out (-)">‚àí</button>
          <button class="btn-sm" onclick="videoZoomReset()" title="Reset zoom (0)">1:1</button>
          <button class="btn-sm" onclick="videoZoomIn()" title="Zoom in (+)">+</button>
          
          <span style="color:var(--border);">|</span>
          
          <!-- Hotkeys -->
          <span style="font-size:7px;color:var(--muted);">Keys: <kbd>Space</kbd>=play <kbd>‚Üê‚Üí</kbd>=¬±1s <kbd>‚áß‚Üê‚Üí</kbd>=¬±10s <kbd>;'</kbd>=frame <kbd>+-</kbd>=zoom</span>
        </div>
        <!-- Game Markers -->
        <div class="video-markers" style="display:flex;gap:4px;padding:4px 8px;background:var(--panel);border-top:1px solid var(--border);align-items:center;">
          <span style="font-size:8px;color:var(--muted);">Game Markers:</span>
          <button class="btn-sm" onclick="setGameMarker('P1Start')" title="Mark P1 puck drop">P1üèí</button>
          <button class="btn-sm" onclick="setGameMarker('P1End')" title="Mark P1 end">P1üõë</button>
          <button class="btn-sm" onclick="setGameMarker('P2Start')" title="Mark P2 puck drop">P2üèí</button>
          <button class="btn-sm" onclick="setGameMarker('P2End')" title="Mark P2 end">P2üõë</button>
          <button class="btn-sm" onclick="setGameMarker('P3Start')" title="Mark P3 puck drop">P3üèí</button>
          <button class="btn-sm" onclick="setGameMarker('P3End')" title="Mark P3 end">P3üõë</button>
          <button class="btn-sm" onclick="setGameMarker('OTStart')" title="Mark OT puck drop">OTüèí</button>
          <button class="btn-sm" onclick="addStoppageMarker()" title="Add stoppage (timeout, injury, etc)">‚è∏Ô∏è+</button>
          <span style="margin-left:auto;font-size:8px;color:var(--muted);" id="markerStatus">No markers set</span>
        </div>
      </div>
      <!-- Video Toggle Bar (shown when minimized) -->
      <div class="video-toggle-bar" id="videoToggleBar" style="display:flex;justify-content:space-between;align-items:center;padding:2px 8px;background:var(--card);border-bottom:1px solid var(--border);cursor:pointer;" onclick="toggleVideoSection()">
        <span style="font-size:9px;color:var(--accent);">üé¨ VIDEO</span>
        <span id="videoMiniTime" style="font-size:10px;font-family:monospace;color:var(--muted);">--:--:--</span>
        <span style="font-size:8px;color:var(--muted);">‚ñ≤ Expand</span>
      </div>
      
      <div class="rink-wrap">
        <div class="mode-ind puck" id="modeInd">üèí PUCK</div>
        <div class="xy-tooltip" id="xyTooltip" style="display:none;"></div>
        <svg id="rinkSvg" viewBox="0 0 200 85">
          <defs>
            <linearGradient id="iceGrad" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" style="stop-color:#f0f9ff;stop-opacity:1"/>
              <stop offset="50%" style="stop-color:#e0f2fe;stop-opacity:1"/>
              <stop offset="100%" style="stop-color:#f0f9ff;stop-opacity:1"/>
            </linearGradient>
            <pattern id="iceTexture" patternUnits="userSpaceOnUse" width="4" height="4">
              <rect width="4" height="4" fill="#e0f2fe" opacity="0.3"/>
              <circle cx="1" cy="1" r="0.3" fill="#fff" opacity="0.4"/>
            </pattern>
          </defs>
          
          <!-- Ice surface -->
          <rect x="0" y="0" width="200" height="85" fill="url(#iceGrad)" rx="14" ry="14"/>
          <rect x="0" y="0" width="200" height="85" fill="url(#iceTexture)" rx="14" ry="14"/>
          <!-- Boards -->
          <rect x="0" y="0" width="200" height="85" fill="none" rx="14" ry="14" stroke="#1f2937" stroke-width="2"/>
          
          <!-- Blue lines -->
          <rect x="74" y="0" width="2" height="85" fill="#1e40af"/>
          <rect x="124" y="0" width="2" height="85" fill="#1e40af"/>
          
          <!-- Red center line (dashed) -->
          <line x1="100" y1="0" x2="100" y2="85" stroke="#dc2626" stroke-width="1.5" stroke-dasharray="4,2"/>
          
          <!-- Goal lines -->
          <line x1="11" y1="0" x2="11" y2="85" stroke="#dc2626" stroke-width="1"/>
          <line x1="189" y1="0" x2="189" y2="85" stroke="#dc2626" stroke-width="1"/>
          
          <!-- Center ice logo -->
          <circle cx="100" cy="42.5" r="10" fill="rgba(30,58,138,0.08)" stroke="none"/>
          <image href="https://www.noradhockey.com/wp-content/uploads/2022/05/New-NORAD-Logo-White.png" x="88" y="31" width="24" height="23" preserveAspectRatio="xMidYMid meet"/>
          
          <!-- Center circle -->
          <circle cx="100" cy="42.5" r="15" fill="none" stroke="#1e40af" stroke-width="1"/>
          <circle cx="100" cy="42.5" r="1" fill="#1e40af"/>
          
          <!-- Left zone circles -->
          <circle cx="31" cy="22" r="15" fill="none" stroke="#dc2626" stroke-width="0.8"/>
          <circle cx="31" cy="22" r="1" fill="#dc2626"/>
          <circle cx="31" cy="63" r="15" fill="none" stroke="#dc2626" stroke-width="0.8"/>
          <circle cx="31" cy="63" r="1" fill="#dc2626"/>
          
          <!-- Right zone circles -->
          <circle cx="169" cy="22" r="15" fill="none" stroke="#dc2626" stroke-width="0.8"/>
          <circle cx="169" cy="22" r="1" fill="#dc2626"/>
          <circle cx="169" cy="63" r="15" fill="none" stroke="#dc2626" stroke-width="0.8"/>
          <circle cx="169" cy="63" r="1" fill="#dc2626"/>
          
          <!-- Neutral zone dots -->
          <circle cx="80" cy="22" r="1" fill="#dc2626"/>
          <circle cx="80" cy="63" r="1" fill="#dc2626"/>
          <circle cx="120" cy="22" r="1" fill="#dc2626"/>
          <circle cx="120" cy="63" r="1" fill="#dc2626"/>
          
          <!-- Creases - NHL standard: 8ft wide, 4.5ft deep (scaled: 4 wide, 2.25 deep) -->
          <path d="M 11 38.5 L 15 38.5 A 4 4 0 0 1 15 46.5 L 11 46.5 Z" fill="rgba(59,130,246,0.25)" stroke="#3b82f6" stroke-width="0.8"/>
          <path d="M 189 38.5 L 185 38.5 A 4 4 0 0 0 185 46.5 L 189 46.5 Z" fill="rgba(59,130,246,0.25)" stroke="#3b82f6" stroke-width="0.8"/>
          
          <!-- Left goal -->
          <rect x="7" y="39" width="4" height="7" fill="#111827" stroke="#f8fafc" stroke-width="0.5"/>
          <line x1="7" y1="40" x2="10" y2="42.5" stroke="#374151" stroke-width="0.3"/>
          <line x1="7" y1="45" x2="10" y2="42.5" stroke="#374151" stroke-width="0.3"/>
          
          <!-- Right goal -->
          <rect x="189" y="39" width="4" height="7" fill="#111827" stroke="#f8fafc" stroke-width="0.5"/>
          <line x1="193" y1="40" x2="190" y2="42.5" stroke="#374151" stroke-width="0.3"/>
          <line x1="193" y1="45" x2="190" y2="42.5" stroke="#374151" stroke-width="0.3"/>
          
          <!-- Trapezoids -->
          <path d="M 0 28 L 11 34 L 11 51 L 0 57" fill="none" stroke="#dc2626" stroke-width="0.5"/>
          <path d="M 200 28 L 189 34 L 189 51 L 200 57" fill="none" stroke="#dc2626" stroke-width="0.5"/>
          
          <!-- Zone labels -->
          <text x="43" y="81" font-size="3.5" fill="#64748b" text-anchor="middle" id="leftZoneLbl">AWAY OFF</text>
          <text x="100" y="81" font-size="3.5" fill="#64748b" text-anchor="middle">NEUTRAL</text>
          <text x="157" y="81" font-size="3.5" fill="#64748b" text-anchor="middle" id="rightZoneLbl">HOME OFF</text>
          
          <!-- Markers -->
          <g id="markers"></g>
        </svg>
      </div>
      <div class="xy-controls">
        <button class="xy-btn active" id="puckModeBtn" onclick="setXYMode('puck')" title="Place puck position (multiple clicks = trajectory)">üèí Puck</button>
        <button class="xy-btn" id="playerModeBtn" onclick="setXYMode('player')" title="Place player positions">üë§ Player</button>
        <select class="xy-player-sel" id="xyPlayerSel" onchange="selectXYPlayer(this.value)" title="Select player to place XY"></select>
        <span style="color:var(--muted);font-size:8px;margin-left:4px;">Slot:</span>
        <div class="xy-slots" id="xySlots"></div>
        <span id="xySlotIndicator" style="font-size:9px;color:var(--accent);margin-left:2px;">‚Üí auto-advance</span>
        <button class="btn-sm" onclick="undoLastXY()" title="Undo last XY placement (Ctrl+Z)">‚Ü©</button>
        <button class="btn-sm btn-danger" onclick="clearCurrentXY()" title="Clear current item XY">‚úï</button>
        <button class="btn-sm" onclick="clearRink()" title="Clear all markers from rink">üóë</button>
        <span style="margin-left:4px;font-size:8px;color:var(--muted);">Hist:</span>
        <input type="number" id="xyHistCnt" value="5" min="0" max="20" style="width:30px;font-size:9px;" onchange="renderMarkers()" title="Past events to show">
      </div>
      <!-- v23.4: Timeline Scrub -->
      <div id="timelineScrub" style="display:flex;gap:2px;margin:4px 0;padding:4px;background:var(--panel);border-radius:4px;overflow-x:auto;max-width:100%;">
        <span style="font-size:8px;color:var(--muted);white-space:nowrap;">Timeline:</span>
        <div id="timelineEvents" style="display:flex;gap:1px;flex:1;"></div>
      </div>
      <!-- Event List -->
      <div class="evt-list" id="eventLogSection">
        <div class="evt-header" style="display:flex;justify-content:space-between;align-items:center;">
          <!-- v20.4: Header columns now match expanded body columns -->
          <span style="display:flex;align-items:center;gap:4px;">
            <button class="btn-sm" onclick="toggleEventLog()" title="Toggle Event Log">üìù</button>
            <span id="evtLogHeader" style="display:grid;grid-template-columns:22px 22px 20px 48px 14px 46px 58px 58px 14px 12px 30px 30px 46px 46px 12px 12px 12px;gap:1px;flex:1;font-size:6px;">
              <span>#</span><span>Sh</span><span>Lnk</span><span>Time</span><span>T</span><span>Type</span><span>Detail1</span><span>Detail2</span><span>Z</span><span>S</span><span>EvtP</span><span>OppP</span><span>PD1</span><span>PD2</span><span>PS</span><span>XY</span><span>‚≠ê</span>
            </span>
          </span>
          <span>
            <button class="btn-sm" onclick="addNewEvent()" title="Add New Event" style="background:var(--success);">‚ûï</button>
            <button class="clear-all-btn" onclick="clearAllEvents()" title="Clear All Events">üóëÔ∏è All</button>
            <button class="btn-sm" onclick="showAllEvents()" style="margin-left:4px;">All</button>
          </span>
        </div>
        <!-- v6: Period filter tabs for events -->
        <div class="period-filter-tabs">
          <button class="period-filter-tab active" data-filter="all" onclick="filterEventLog('all')">ALL</button>
          <button class="period-filter-tab" data-filter="1" onclick="filterEventLog('1')">P1</button>
          <button class="period-filter-tab" data-filter="2" onclick="filterEventLog('2')">P2</button>
          <button class="period-filter-tab" data-filter="3" onclick="filterEventLog('3')">P3</button>
          <button class="period-filter-tab" data-filter="OT" onclick="filterEventLog('OT')">OT</button>
        </div>
        <!-- v20.4: Advanced filter row -->
        <div class="evt-filter-row" id="evtFilterRow">
          <div class="filter-group">
            <label>Type:</label>
            <select id="filterEvtType" onchange="applyEventFilters()">
              <option value="">All</option>
            </select>
          </div>
          <div class="filter-group">
            <label>Detail1:</label>
            <select id="filterEvtDetail1" onchange="applyEventFilters()">
              <option value="">All</option>
            </select>
          </div>
          <div class="filter-group">
            <label>Detail2:</label>
            <select id="filterEvtDetail2" onchange="applyEventFilters()">
              <option value="">All</option>
            </select>
          </div>
          <div class="filter-group">
            <label>PD1:</label>
            <select id="filterPlayDetail1" onchange="applyEventFilters()">
              <option value="">All</option>
            </select>
          </div>
          <div class="filter-group">
            <label>PD2:</label>
            <select id="filterPlayDetail2" onchange="applyEventFilters()">
              <option value="">All</option>
            </select>
          </div>
          <div class="filter-group">
            <label>Team:</label>
            <select id="filterEvtTeam" onchange="applyEventFilters()">
              <option value="">All</option>
              <option value="home">Home</option>
              <option value="away">Away</option>
            </select>
          </div>
          <div class="filter-group">
            <label>Evt#:</label>
            <input type="number" id="filterEvtIdx" min="1" placeholder="#" onchange="applyEventFilters()">
          </div>
          <div class="filter-group">
            <label>Link#:</label>
            <input type="number" id="filterLinkIdx" min="1" placeholder="#" onchange="applyEventFilters()">
          </div>
          <div class="filter-group">
            <label>Shift#:</label>
            <input type="number" id="filterShiftIdx" min="1" placeholder="#" onchange="applyEventFilters()">
          </div>
          <button class="btn-clear" onclick="clearEventFilters()">Clear</button>
        </div>
        <div id="evtListBody" style="max-height:300px;overflow-y:auto;"></div>
      </div>
      <!-- Next Play Suggestions -->
      <div class="next-play-bar" style="background:var(--card);padding:4px 8px;border-top:1px solid var(--border);">
        <span style="font-size:8px;color:var(--muted);">NEXT:</span>
        <span id="nextPlaySuggestions" style="font-size:9px;"></span>
      </div>
      <!-- v16.02: Box Score moved here - more visible below events -->
      <div class="center-box-score" style="background:var(--card);padding:6px;border-top:1px solid var(--border);">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
          <span style="font-size:9px;color:var(--accent);font-weight:bold;">üìä BOX SCORE</span>
          <button class="btn-sm" onclick="showFullBoxScore()">Full</button>
        </div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;font-size:10px;">
          <div style="text-align:center;">
            <span id="centerBoxHome" style="font-weight:bold;color:var(--home);">HOME</span>
            <span style="font-size:20px;font-weight:bold;display:block;" id="centerBoxHomeScore">0</span>
            <span style="font-size:8px;color:var(--muted);">SOG: <span id="centerBoxHomeSOG">0</span></span>
          </div>
          <div style="text-align:center;">
            <span id="centerBoxAway" style="font-weight:bold;color:var(--away);">AWAY</span>
            <span style="font-size:20px;font-weight:bold;display:block;" id="centerBoxAwayScore">0</span>
            <span style="font-size:8px;color:var(--muted);">SOG: <span id="centerBoxAwaySOG">0</span></span>
          </div>
        </div>
      </div>
    </div>

    <!-- Right: Event Entry -->
    <div class="panel" id="rightPanel">
      <div class="resize-handle right" style="left:0;right:auto;" onmousedown="startResize(event, 'right')"></div>
      <div class="panel-header"><span>Event Entry</span><span id="zoneDisplay"></span></div>
      <div class="panel-body">
        <!-- Team Toggle -->
        <div class="team-toggle">
          <button class="home active" id="evtHomeLbl" onclick="setEvtTeam('home')">Home</button>
          <button class="swap-btn" onclick="swapEvtTeam()" title="Swap Event/Opp Teams">‚áÑ</button>
          <button class="away" id="evtAwayLbl" onclick="setEvtTeam('away')">Away</button>
        </div>
        <!-- Event Types -->
        <div class="evt-grid" id="evtTypeGrid"></div>
        <!-- Quick Faceoff (v23.3) -->
        <div id="quickFaceoffRow" style="display:flex;gap:4px;margin:4px 0;padding:4px;background:var(--panel);border-radius:4px;">
          <span style="font-size:8px;color:var(--muted);align-self:center;">FO:</span>
          <button class="btn-sm" onclick="quickFaceoff('o','evt')" title="Offensive zone, Won" style="flex:1;font-size:9px;">O-Win</button>
          <button class="btn-sm" onclick="quickFaceoff('o','opp')" title="Offensive zone, Lost" style="flex:1;font-size:9px;">O-Loss</button>
          <button class="btn-sm" onclick="quickFaceoff('n','evt')" title="Neutral zone, Won" style="flex:1;font-size:9px;">N-Win</button>
          <button class="btn-sm" onclick="quickFaceoff('n','opp')" title="Neutral zone, Lost" style="flex:1;font-size:9px;">N-Loss</button>
          <button class="btn-sm" onclick="quickFaceoff('d','evt')" title="Defensive zone, Won" style="flex:1;font-size:9px;">D-Win</button>
          <button class="btn-sm" onclick="quickFaceoff('d','opp')" title="Defensive zone, Lost" style="flex:1;font-size:9px;">D-Loss</button>
        </div>
        <!-- Quick Stoppage (v23.4) -->
        <div id="quickStoppageRow" style="display:flex;gap:4px;margin:4px 0;padding:4px;background:var(--panel);border-radius:4px;">
          <span style="font-size:8px;color:var(--muted);align-self:center;">STOP:</span>
          <button class="btn-sm" onclick="quickStoppage('Icing')" title="Icing" style="flex:1;font-size:9px;">üßä Icing</button>
          <button class="btn-sm" onclick="quickStoppage('Offside')" title="Offside" style="flex:1;font-size:9px;">üö´ Offside</button>
          <button class="btn-sm" onclick="quickStoppage('PuckOutOfPlay')" title="Puck out of play" style="flex:1;font-size:9px;">üèí Out</button>
          <button class="btn-sm" onclick="quickStoppage('Timeout')" title="Timeout" style="flex:1;font-size:9px;">‚è∏Ô∏è T/O</button>
          <button class="btn-sm" onclick="quickStoppage('GoalieFreeze')" title="Goalie freeze" style="flex:1;font-size:9px;">ü•Ö Freeze</button>
        </div>
        <!-- Quick Penalty (v23.3) -->
        <div id="quickPenaltyRow" style="display:flex;gap:4px;margin:4px 0;padding:4px;background:var(--panel);border-radius:4px;">
          <span style="font-size:8px;color:var(--muted);align-self:center;">PEN:</span>
          <select id="quickPenPlayer" style="flex:2;font-size:9px;"><option value="">Player #</option></select>
          <select id="quickPenType" style="flex:2;font-size:9px;">
            <option value="">Type</option>
            <option value="Penalty_Tripping">Tripping</option>
            <option value="Penalty_Hooking">Hooking</option>
            <option value="Penalty_Slashing">Slashing</option>
            <option value="Penalty_Holding">Holding</option>
            <option value="Penalty_Interference">Interference</option>
            <option value="Penalty_HighSticking">High Stick</option>
            <option value="Penalty_Roughing">Roughing</option>
            <option value="Penalty_CrossChecking">Cross-Check</option>
            <option value="Penalty_Boarding">Boarding</option>
            <option value="Penalty_Other">Other</option>
          </select>
          <button class="btn-sm" onclick="quickPenalty()" title="Log penalty" style="background:var(--danger);color:#fff;">+Pen</button>
        </div>
        <!-- Power Play Timer (v23.4) -->
        <div id="ppTimerRow" style="display:none;gap:4px;margin:4px 0;padding:6px 8px;background:linear-gradient(90deg,var(--home),var(--away));border-radius:4px;color:#fff;font-weight:bold;align-items:center;">
          <span id="ppTimerTeam" style="font-size:10px;">PP:</span>
          <span id="ppTimerDisplay" style="font-size:14px;margin-left:8px;">3:00</span>
          <input type="number" id="ppMinutes" value="3" min="1" max="5" style="width:35px;margin-left:8px;font-size:10px;" title="Penalty minutes" onchange="updatePPMinutes()">
          <span style="font-size:8px;">min</span>
          <button class="btn-sm" onclick="endPowerPlay()" style="margin-left:auto;background:#fff;color:#000;font-size:9px;">End PP</button>
        </div>
        <!-- Quick Modes (v23.3) -->
        <div style="display:flex;gap:4px;margin:4px 0;">
          <button class="btn-sm" id="shotChartModeBtn" onclick="toggleShotChartMode()" title="Shot Chart Mode: click rink to log shots" style="flex:1;font-size:9px;">üéØ Shot Mode</button>
          <button class="btn-sm" id="possessionModeBtn" onclick="togglePossessionMode()" title="Possession Mode: track possession chains" style="flex:1;font-size:9px;">üèí Poss Mode</button>
          <button class="btn-sm" onclick="undoLastEvent()" title="Undo last event (Ctrl+Shift+Z)" style="flex:1;font-size:9px;background:var(--warning);color:#000;">‚Ü©Ô∏è Undo</button>
          <button class="btn-sm" onclick="manualReindexEvents()" title="Re-sort events by time" style="flex:1;font-size:9px;">üî¢ Reindex</button>
        </div>
        <!-- Event Templates (v23.4) -->
        <div style="display:flex;gap:4px;margin:4px 0;">
          <select id="eventTemplates" style="flex:1;font-size:9px;">
            <option value="">üìã Templates...</option>
            <option value="dumpAndChase">Dump & Chase</option>
            <option value="cyclePlay">Cycle Play</option>
            <option value="breakout">Breakout</option>
            <option value="forecheck">Forecheck</option>
            <option value="oddManRush">Odd-Man Rush</option>
          </select>
          <button class="btn-sm" onclick="applyTemplate()" title="Apply selected template" style="font-size:9px;">Apply</button>
          <button class="btn-sm" onclick="saveAsChainPreset()" title="Save current event as chain preset" style="font-size:9px;">üíæ Save</button>
        </div>
        <!-- Validation Row (v23.4) -->
        <div style="display:flex;gap:4px;margin:4px 0;">
          <button class="btn-sm" onclick="validateAgainstGameData()" title="Validate vs fact_gameroster & dim_schedule" style="flex:1;font-size:9px;">üîç Validate</button>
        </div>
        <!-- Settings & Data Import/Export (v23.4) -->
        <div style="display:flex;gap:2px;margin:4px 0;flex-wrap:wrap;padding:4px;background:var(--panel);border-radius:4px;">
          <span style="font-size:8px;color:var(--muted);align-self:center;">Data:</span>
          <button class="btn-sm" onclick="exportSettings()" title="Export all settings, presets, chains" style="font-size:8px;">üì§ Export Settings</button>
          <button class="btn-sm" onclick="document.getElementById('importSettingsFile').click()" title="Import settings from JSON" style="font-size:8px;">üì• Import Settings</button>
          <input type="file" id="importSettingsFile" accept=".json" style="display:none;" onchange="importSettings(event)">
          <span style="color:var(--border);margin:0 2px;">|</span>
          <button class="btn-sm" onclick="document.getElementById('importRosterFile').click()" title="Import roster from Excel (.xlsx)" style="font-size:8px;">üìã Import Roster</button>
          <input type="file" id="importRosterFile" accept=".xlsx,.xls,.csv" style="display:none;" onchange="importRosterFromFile(event)">
          <button class="btn-sm" onclick="showManualRosterEntry()" title="Manually enter roster" style="font-size:8px;">‚úèÔ∏è Manual Roster</button>
        </div>
        <!-- Quick Chains (v23.4) - Multi-event sequences -->
        <div style="display:flex;gap:2px;margin:4px 0;flex-wrap:wrap;">
          <span style="font-size:8px;color:var(--muted);align-self:center;">Chains:</span>
          <button class="btn-sm" onclick="startQuickChain('controlledEntry')" title="Zone Entry ‚Üí Possession" style="font-size:8px;">Entry</button>
          <button class="btn-sm" onclick="startQuickChain('dumpIn')" title="Dump ‚Üí Forecheck" style="font-size:8px;">Dump</button>
          <button class="btn-sm" onclick="startQuickChain('shotSequence')" title="Shot ‚Üí Save ‚Üí Rebound" style="font-size:8px;">Shot+</button>
          <button class="btn-sm" onclick="startQuickChain('breakout')" title="Breakout ‚Üí Pass ‚Üí Exit" style="font-size:8px;">Break</button>
          <button class="btn-sm" onclick="startQuickChain('ppCycle')" title="PP Cycle ‚Üí Pass ‚Üí Shot" style="font-size:8px;">PP</button>
        </div>
        <!-- v23.5: Quick Queue - log time only, fill details later -->
        <div style="display:flex;gap:2px;margin:4px 0;flex-wrap:wrap;">
          <span style="font-size:8px;color:var(--warn);align-self:center;" title="Quick mark events, fill details later">Queue:</span>
          <button class="btn-sm" onclick="quickQueueEvent('Shot')" style="font-size:8px;background:var(--warn);color:#000;">Sh</button>
          <button class="btn-sm" onclick="quickQueueEvent('Pass')" style="font-size:8px;background:var(--warn);color:#000;">Pa</button>
          <button class="btn-sm" onclick="quickQueueEvent('Turnover')" style="font-size:8px;background:var(--warn);color:#000;">TO</button>
          <button class="btn-sm" onclick="quickQueueEvent('Hit')" style="font-size:8px;background:var(--warn);color:#000;">Hi</button>
          <button class="btn-sm" onclick="quickQueueEvent('Zone_Entry_Exit')" style="font-size:8px;background:var(--warn);color:#000;">ZE</button>
          <button class="btn-sm" onclick="clearEventQueue()" style="font-size:8px;" title="Clear queue">‚úï</button>
        </div>
        <!-- Event Details -->
        <div class="form-row">
          <div class="form-group"><label>Detail 1</label><select id="evtD1" onchange="onD1Change()"></select></div>
          <div class="form-group"><label>Detail 2</label><select id="evtD2"></select></div>
        </div>
        <!-- Quick Detail Buttons (v23.4) - changes based on event type -->
        <div id="quickDetailRow" style="display:flex;gap:2px;margin:4px 0;flex-wrap:wrap;"></div>
        <!-- Hidden selects for compatibility -->
        <select id="evtZone" style="display:none;"><option value="">--</option><option value="o">Offensive</option><option value="d">Defensive</option><option value="n">Neutral</option></select>
        <select id="evtSuccess" style="display:none;"><option value="">--</option><option value="s">Success</option><option value="u">Unsuccess</option></select>
        <div class="form-row tri">
          <div class="form-group">
            <label>Zone</label>
            <div style="display:flex;gap:2px;">
              <button class="btn-sm zone-btn" onclick="setZone('o')" data-zone="o" title="Offensive" style="flex:1;font-size:9px;">O</button>
              <button class="btn-sm zone-btn" onclick="setZone('n')" data-zone="n" title="Neutral" style="flex:1;font-size:9px;">N</button>
              <button class="btn-sm zone-btn" onclick="setZone('d')" data-zone="d" title="Defensive" style="flex:1;font-size:9px;">D</button>
            </div>
          </div>
          <div class="form-group">
            <label>Success</label>
            <div style="display:flex;gap:2px;">
              <button class="btn-sm success-btn" onclick="setSuccess('s')" data-success="s" title="Success" style="flex:1;font-size:9px;background:var(--success);color:#fff;">‚úì</button>
              <button class="btn-sm success-btn" onclick="setSuccess('u')" data-success="u" title="Unsuccess" style="flex:1;font-size:9px;background:var(--danger);color:#fff;">‚úó</button>
            </div>
          </div>
          <div class="form-group">
            <label>Strength <button class="btn-sm" onclick="autoStrength()" title="Auto-detect from slots">‚ö°</button></label>
            <select id="evtStrength"><option value="5v5">5v5</option><option value="5v4">5v4 PP</option><option value="4v5">4v5 PK</option><option value="4v4">4v4</option><option value="3v3">3v3</option><option value="ENG">ENG</option><option value="ENA">ENA</option></select>
          </div>
        </div>
        <div class="form-row">
          <div class="form-group"><label>Start Time</label><input type="text" id="evtStartTime" placeholder="MM:SS" oninput="autoFormatTime(this)"></div>
          <div class="form-group"><label>End Time</label><input type="text" id="evtEndTime" placeholder="MM:SS (auto)" oninput="autoFormatTime(this)"></div>
        </div>
        <!-- Event Players -->
        <div class="section">
          <div class="section-title" style="display:flex;justify-content:space-between;align-items:center;">
            <span>Event Players (on puck)</span>
            <div style="display:flex;gap:2px;">
              <button class="btn-sm" onclick="addAllOnIce()" title="Add all on-ice players">+All</button>
              <button class="btn-sm" onclick="copyPlayersFromLast()" title="Copy players from last event">üìã</button>
              <button class="btn-sm" onclick="placeAllHere()" title="Place ALL players at last puck XY" style="background:var(--accent);color:#000;">üìç All Here</button>
              <button class="btn-sm" id="seqModeBtn" onclick="toggleSequenceMode()" title="Sequence mode: auto-link events">üîó</button>
            </div>
          </div>
          <div class="player-list" id="evtPlayers" ondragover="handleListDragOver(event)" ondragleave="handleListDragLeave(event)" ondrop="handleListDrop(event, 'evt')"></div>
          <div class="quick-add" id="evtQuickAdd"></div>
          <!-- Jersey number input -->
          <div style="display:flex;gap:4px;margin-top:4px;">
            <input type="text" id="jerseyNumInput" placeholder="Jersey #" style="width:60px;font-size:10px;" onkeypress="if(event.key==='Enter'){quickAddByNumber(parseInt(this.value));this.value='';return false;}">
            <button class="btn-sm" onclick="quickAddByNumber(parseInt(document.getElementById('jerseyNumInput').value));document.getElementById('jerseyNumInput').value='';" title="Add by jersey #">+#</button>
          </div>
        </div>
        <div class="section">
          <div class="section-title"><span>Opposing Players</span></div>
          <div class="player-list" id="oppPlayers" ondragover="handleListDragOver(event)" ondragleave="handleListDragLeave(event)" ondrop="handleListDrop(event, 'opp')"></div>
          <div class="quick-add" id="oppQuickAdd"></div>
        </div>
        <!-- Player Details -->
        <div class="player-details" id="playerDetails" style="display:none;">
          <h5 id="pdPlayerNum">#0 Player</h5>
          <div class="form-row">
            <!-- v16.02: Searchable play detail dropdowns using input with datalist -->
            <div class="form-group">
              <label>Play Detail 1</label>
              <input list="pdPlayD1List" id="pdPlayD1" style="width:100%;" onchange="updatePlayerDetail('playD1', this.value); updatePlayD2()" placeholder="Type to search...">
              <datalist id="pdPlayD1List"></datalist>
            </div>
            <div class="form-group">
              <label>Play Detail 2</label>
              <input list="pdPlayD2List" id="pdPlayD2" style="width:100%;" onchange="updatePlayerDetail('playD2', this.value)" placeholder="Type to search...">
              <datalist id="pdPlayD2List"></datalist>
            </div>
          </div>
          <div class="form-row">
            <div class="form-group"><label>Success <button class="btn-sm" onclick="derivePlayerSuccess()" title="Auto from event">‚ö°</button></label><select id="pdPlaySuccess" onchange="updatePlayerDetail('playSuccess', this.value)"><option value="">--</option><option value="s">S</option><option value="u">U</option></select></div>
            <div class="form-group"><label>Pressured By <button class="btn-sm" onclick="autoCalcPressure()" title="Auto from XY">‚ö°</button></label><select id="pdPressure" onchange="updatePlayerDetail('pressure', this.value)"><option value="">--</option></select></div>
          </div>
          <!-- v16: Side of Puck -->
          <div class="form-row">
            <div class="form-group">
              <label>Side of Puck <button class="btn-sm" onclick="autoSideOfPuck()" title="Auto-detect from zone">‚ö°</button></label>
              <select id="pdSideOfPuck" onchange="updatePlayerDetail('sideOfPuck', this.value)">
                <option value="">--</option>
                <option value="Offensive">Offensive</option>
                <option value="Defensive">Defensive</option>
              </select>
            </div>
            <div class="form-group"><label>&nbsp;</label><span style="font-size:8px;color:var(--muted);line-height:26px;">Relative to player's team</span></div>
          </div>
        </div>
        <!-- Linked Event & Highlight -->
        <div class="linked-event-bar" style="background:var(--card);padding:4px 8px;border-radius:4px;margin-top:6px;font-size:9px;display:flex;align-items:center;gap:8px;">
          <span style="color:var(--muted);">Link:</span>
          <select id="linkedEvtSelect" style="flex:1;" onchange="onLinkedEvtChange()">
            <option value="">-- None --</option>
          </select>
          <span id="linkedEvtInfo" style="color:var(--accent);font-size:8px;"></span>
          <label style="display:flex;align-items:center;gap:4px;cursor:pointer;margin-left:auto;">
            <input type="checkbox" id="isHighlight"> ‚≠ê Highlight
          </label>
        </div>
        <!-- Quick Time Buttons (v5) + Time Nudge (v6) -->
        <div style="display:flex;gap:4px;margin-top:4px;align-items:center;flex-wrap:wrap;">
          <button class="btn-sm" onclick="copyClockToStart()" title="Copy clock to start time">‚è±Ô∏è‚ÜíStart</button>
          <button class="btn-sm" onclick="copyClockToEnd()" title="Copy clock to end time">‚è±Ô∏è‚ÜíEnd</button>
          <button class="btn-sm" onclick="copyLastEventTime()" title="Copy last event's end time">üìã Last</button>
          <!-- v6: Time nudge buttons with variable increment -->
          <span style="color:var(--muted);font-size:8px;margin-left:4px;">¬±</span>
          <input type="number" id="timeNudgeAmount" value="5" min="1" max="60" style="width:30px;font-size:9px;padding:2px;" title="Nudge seconds">
          <button class="btn-sm" onclick="nudgeStartTime(-1)" title="Subtract from start time">-S</button>
          <button class="btn-sm" onclick="nudgeStartTime(1)" title="Add to start time">+S</button>
          <button class="btn-sm" onclick="nudgeEndTime(-1)" title="Subtract from end time">-E</button>
          <button class="btn-sm" onclick="nudgeEndTime(1)" title="Add to end time">+E</button>
          <label style="display:flex;align-items:center;gap:4px;font-size:8px;margin-left:8px;cursor:pointer;" title="Skip confirmation popup">
            <input type="checkbox" id="skipConfirm"> Quick log
          </label>
          <label style="display:flex;align-items:center;gap:4px;font-size:8px;margin-left:auto;cursor:pointer;">
            <input type="checkbox" id="autoEditNext"> Auto-edit next
          </label>
        </div>
        <!-- Actions -->
        <div class="log-actions">
          <button class="btn-success" onclick="logEvent()">Log Event <kbd>Enter</kbd></button>
          <button onclick="clearEvent()">Clear <kbd>Esc</kbd></button>
          <button class="btn-sm" onclick="duplicateLastEvent()" title="Duplicate last event">üìã Dup</button>
          <button class="btn-sm" onclick="logEventDirect()" title="Log without confirmation (Shift+Enter)">‚ö° Quick</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Settings Modal -->
<div class="overlay" id="settingsModal">
  <div class="modal">
    <h3>‚öôÔ∏è Settings</h3>
    <div class="form-group" style="margin-bottom:8px;">
      <label>Supabase URL</label>
      <input type="text" id="sbUrl" placeholder="https://xxx.supabase.co" style="width:100%;">
    </div>
    <div class="form-group" style="margin-bottom:8px;">
      <label>Supabase Anon Key</label>
      <input type="password" id="sbKey" placeholder="eyJ..." style="width:100%;">
    </div>
    <div class="form-row">
      <div class="form-group"><label>Auto-save (sec)</label><input type="number" id="autoSaveInt" value="30"></div>
      <div class="form-group"><label>Pressure Distance (ft)</label><input type="number" id="pressureDist" value="10"></div>
    </div>
    <!-- v23.5: Per-period lengths -->
    <div style="margin:8px 0;">
      <label style="font-size:10px;color:var(--muted);display:block;margin-bottom:4px;">Period Lengths (minutes)</label>
      <div style="display:flex;gap:8px;">
        <div class="form-group" style="flex:1;">
          <label style="font-size:9px;">P1</label>
          <input type="number" id="periodLength1" value="18" min="5" max="25" style="width:100%;" onchange="updatePeriodLengthsFromUI()">
        </div>
        <div class="form-group" style="flex:1;">
          <label style="font-size:9px;">P2</label>
          <input type="number" id="periodLength2" value="18" min="5" max="25" style="width:100%;" onchange="updatePeriodLengthsFromUI()">
        </div>
        <div class="form-group" style="flex:1;">
          <label style="font-size:9px;">P3</label>
          <input type="number" id="periodLength3" value="18" min="5" max="25" style="width:100%;" onchange="updatePeriodLengthsFromUI()">
        </div>
        <div class="form-group" style="flex:1;">
          <label style="font-size:9px;">OT</label>
          <input type="number" id="periodLengthOT" value="5" min="3" max="20" style="width:100%;" onchange="updatePeriodLengthsFromUI()">
        </div>
      </div>
    </div>
    <!-- Hidden for backward compatibility -->
    <input type="hidden" id="periodLength" value="18">
    <input type="hidden" id="otLength" value="5">
    <div class="form-group" style="margin-bottom:8px;">
      <label>Save Location</label>
      <div class="save-location-box">
        <div class="folder-display">
          <div class="folder-path empty" id="saveFolderPath">No folder selected - exports download to browser default</div>
          <div class="folder-actions">
            <button class="btn-sm btn-primary" onclick="pickSaveFolder()" title="Pick Folder">üìÅ Choose</button>
            <button class="btn-sm" onclick="clearSaveFolder()" title="Clear">‚úï</button>
          </div>
        </div>
        <div class="folder-status" id="saveFolderStatus">
          üí° Select a folder to enable Quick Save directly to that location
        </div>
        <div style="margin-top:8px;display:flex;gap:4px;">
          <button class="btn-sm btn-success" onclick="quickSaveToFolder()" id="quickSaveBtn" disabled style="flex:1;">
            üíæ Quick Save to Folder
          </button>
        </div>
      </div>
      <p style="font-size:8px;color:var(--muted);margin-top:4px;">
        <strong>Note:</strong> Game data auto-saves to browser storage every <span id="autoSaveDisplay">30</span>s. 
        Use "Quick Save" or "Export" to create an Excel file.
      </p>
    </div>
    <div style="margin-top:12px;padding-top:8px;border-top:1px solid var(--border);">
      <button class="btn-danger" onclick="clearAllData()" style="width:100%;">üóëÔ∏è Clear All Game Data</button>
      <p style="font-size:8px;color:var(--muted);margin-top:4px;">Removes all events, shifts, and saved data for current game</p>
    </div>
    <div class="modal-actions">
      <button onclick="testConn()">Test Connection</button>
      <button class="btn-primary" onclick="saveSettings()">Save</button>
      <button onclick="closeSettings()">Cancel</button>
    </div>
  </div>
</div>

<!-- Help/Instructions Modal -->
<div class="overlay" id="helpModal">
  <div class="modal" style="min-width:600px;max-height:80vh;overflow-y:auto;">
    <h3>‚ùì Instructions & Hotkeys (v23.4)</h3>
    
    <!-- User Guide Link -->
    <div style="background:linear-gradient(90deg,var(--accent),var(--home));padding:10px 15px;border-radius:6px;margin-bottom:12px;display:flex;justify-content:space-between;align-items:center;">
      <div>
        <span style="font-size:12px;font-weight:bold;color:#000;">üìñ Complete User Guide Available</span>
        <p style="font-size:9px;color:#000;margin:2px 0 0 0;opacity:0.8;">Full documentation with workflows, tips & best practices</p>
      </div>
      <button class="btn-sm" onclick="window.open('TRACKER_USER_GUIDE_v23.4.md', '_blank')" style="background:#000;color:#fff;font-size:10px;">Open Guide</button>
    </div>
    
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;">
      <!-- Keyboard Shortcuts -->
      <div>
        <h4 style="color:var(--accent);margin-bottom:8px;font-size:12px;">‚å®Ô∏è Keyboard Shortcuts</h4>
        <table style="font-size:10px;width:100%;">
          <tr><td style="padding:2px 8px;"><kbd>Enter</kbd></td><td>Save current event</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Shift+Enter</kbd></td><td>Quick log (no confirmation)</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Escape</kbd></td><td>Cancel / Close modals</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>L</kbd></td><td>Log shift</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>E</kbd></td><td>End shift (set end time)</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Q</kbd></td><td>Quick line change</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Tab</kbd></td><td>Toggle Puck/Player mode</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>`</kbd></td><td>Switch to Puck XY mode</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>H</kbd> / <kbd>A</kbd></td><td>Set team Home/Away</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Shift+S</kbd></td><td>Swap Event/Opp Teams</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>1-6</kbd></td><td>Select Event Player 1-6</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Alt+1-6</kbd></td><td>Select Opp Player 1-6</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Backspace</kbd></td><td>Undo last XY point</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>‚Üê/‚Üí</kbd></td><td>Navigate events in edit modal</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>?</kbd></td><td>Open this help</td></tr>
        </table>
        <h5 style="color:var(--accent);margin:8px 0 4px;font-size:10px;">Event Type Hotkeys:</h5>
        <div style="font-size:9px;color:var(--muted);">F=Faceoff, S=Shot, P=Pass, G=Goal, T=Turnover, Z=Zone, N=Penalty, X=Stoppage, O=Possession, V=Save, R=Rebound, D=DeadIce</div>
        <h5 style="color:var(--accent);margin:8px 0 4px;font-size:10px;">Zone / Success:</h5>
        <div style="font-size:9px;color:var(--muted);">Q=Offensive, W=Neutral, E=Defensive | Y=Success, U=Unsuccess</div>
      </div>
      
      <!-- Video Controls -->
      <div>
        <h4 style="color:var(--accent);margin-bottom:8px;font-size:12px;">üé¨ Video Controls</h4>
        <table style="font-size:10px;width:100%;">
          <tr><td style="padding:2px 8px;"><kbd>Space</kbd></td><td>Play/Pause</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>‚Üê</kbd> / <kbd>‚Üí</kbd></td><td>Seek ¬±1 second</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Shift+‚Üê/‚Üí</kbd></td><td>Seek ¬±10 seconds</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>‚Üë</kbd> / <kbd>‚Üì</kbd></td><td>Speed up/down</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>;</kbd> / <kbd>'</kbd></td><td>Frame back/forward</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>+</kbd> / <kbd>-</kbd></td><td>Zoom in/out</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>0</kbd></td><td>Reset zoom</td></tr>
          <tr><td style="padding:2px 8px;"><kbd>Ctrl+1-9</kbd></td><td>Switch video source</td></tr>
        </table>
        
        <h4 style="color:var(--accent);margin:12px 0 8px;font-size:12px;">üÜï v23.4 Features</h4>
        <div style="font-size:9px;line-height:1.5;color:var(--muted);">
          <p>‚Ä¢ <strong>Drag to Create</strong> - Drag on rink for pass/shot</p>
          <p>‚Ä¢ <strong>Smart XY Linking</strong> - Puck auto-links to players</p>
          <p>‚Ä¢ <strong>Quick Chains</strong> - Entry, Dump, Shot+, Break, PP</p>
          <p>‚Ä¢ <strong>üìç All Here</strong> - Place all players at puck</p>
          <p>‚Ä¢ <strong>Multi-Video</strong> - Ctrl+1-9 to switch sources</p>
        </div>
        
        <h4 style="color:var(--warn);margin:12px 0 8px;font-size:12px;">üöÄ v23.5 Speed Features</h4>
        <div style="font-size:9px;line-height:1.4;color:var(--muted);display:grid;grid-template-columns:1fr 1fr;gap:4px;">
          <p>‚Ä¢ <strong>üîÑ Mirror</strong> - Auto-flip XY for P2</p>
          <p>‚Ä¢ <strong>üéØ AutoZ</strong> - Zone from click position</p>
          <p>‚Ä¢ <strong>ü•Ö AutoG</strong> - Auto-add goalie on shots</p>
          <p>‚Ä¢ <strong>üî¢ Numpad</strong> - Use numpad for players</p>
          <p>‚Ä¢ <strong>Quick Queue</strong> - Mark now, fill later</p>
          <p>‚Ä¢ <strong>‚è∫ Macros</strong> - Record event sequences</p>
          <p>‚Ä¢ <strong>üìç Shots</strong> - Overlay on rink</p>
          <p>‚Ä¢ <strong>üì∫ Float</strong> - Draggable video</p>
          <p>‚Ä¢ <strong>üîç Gaps</strong> - Find missing events</p>
          <p>‚Ä¢ <strong>‚úÖ Check</strong> - Consistency checker</p>
          <p>‚Ä¢ <strong>EN-H/A</strong> - Empty net toggle</p>
          <p>‚Ä¢ <strong>Ice/Offside</strong> - One-click stoppages</p>
        </div>
      </div>
    </div>
    
    <hr style="margin:12px 0;border-color:var(--border);">
    
    <!-- Quick Guide -->
    <div>
      <h4 style="color:var(--accent);margin-bottom:8px;font-size:12px;">üìã Quick Workflow</h4>
      <div style="font-size:10px;display:grid;grid-template-columns:repeat(4,1fr);gap:8px;">
        <div style="background:var(--panel);padding:8px;border-radius:4px;text-align:center;">
          <div style="font-size:16px;">1Ô∏è‚É£</div>
          <div><strong>Load Video</strong></div>
          <div style="font-size:9px;color:var(--muted);">+ or üìÅ button</div>
        </div>
        <div style="background:var(--panel);padding:8px;border-radius:4px;text-align:center;">
          <div style="font-size:16px;">2Ô∏è‚É£</div>
          <div><strong>Set Markers</strong></div>
          <div style="font-size:9px;color:var(--muted);">P1üèí at puck drop</div>
        </div>
        <div style="background:var(--panel);padding:8px;border-radius:4px;text-align:center;">
          <div style="font-size:16px;">3Ô∏è‚É£</div>
          <div><strong>Track Events</strong></div>
          <div style="font-size:9px;color:var(--muted);">Type ‚Üí XY ‚Üí Enter</div>
        </div>
        <div style="background:var(--panel);padding:8px;border-radius:4px;text-align:center;">
          <div style="font-size:16px;">4Ô∏è‚É£</div>
          <div><strong>Export</strong></div>
          <div style="font-size:9px;color:var(--muted);">Download Excel</div>
        </div>
      </div>
    </div>
    
    <hr style="margin:12px 0;border-color:var(--border);">
    
    <!-- Video Timing -->
    <div>
      <h4 style="color:var(--accent);margin-bottom:8px;font-size:12px;">üé¨ Video & Time Sync</h4>
      <div style="font-size:10px;line-height:1.6;">
        <p><strong>Video Time Calculation:</strong></p>
        <ul style="margin:4px 0 4px 16px;">
          <li><strong>event_running_start</strong> = (period-1) √ó period_seconds + (period_seconds - time_remaining)</li>
          <li><strong>running_video_time</strong> = event_running_start + intermission_offset</li>
          <li>Period seconds = periodLength √ó 60 (default 18 min = 1080 sec for NORAD)</li>
        </ul>
        <p><strong>Stoppages:</strong> Stoppage events are tracked with duration. You do NOT need to cut 
           stoppages from video - the tracker calculates running time including them.</p>
        <p><strong>Shift Stoppage Time:</strong> Each shift automatically calculates total stoppage duration 
           from Stoppage/Clockstop events that occur within the shift time window.</p>
      </div>
    </div>
    
    <hr style="margin:12px 0;border-color:var(--border);">
    
    <!-- Highlights -->
    <div>
      <h4 style="color:var(--accent);margin-bottom:8px;font-size:12px;">‚≠ê Highlights & Video Clips</h4>
      <div style="font-size:10px;line-height:1.6;">
        <p><strong>Marking Highlights:</strong></p>
        <ul style="margin:4px 0 4px 16px;">
          <li>Press <kbd>H</kbd> while recording to mark as highlight</li>
          <li>Goals are automatically marked as highlights</li>
          <li>Double-click event ‚Üí Edit Highlight field</li>
        </ul>
        <p><strong>ETL Export:</strong></p>
        <ul style="margin:4px 0 4px 16px;">
          <li><code>is_highlight</code> column = 1 for highlights, 0 otherwise</li>
          <li>Use <code>running_video_time</code> to find clip start in video</li>
          <li>Clip duration = event duration or default (10 sec for goals)</li>
        </ul>
        <p><strong>Creating Highlight Reels:</strong></p>
        <ul style="margin:4px 0 4px 16px;">
          <li>Query: <code>SELECT * FROM fact_events WHERE is_highlight = 1 ORDER BY running_video_time</code></li>
          <li>Use video editor to extract clips at running_video_time timestamps</li>
        </ul>
      </div>
    </div>
    
    <hr style="margin:12px 0;border-color:var(--border);">
    
    <!-- Event Log -->
    <div>
      <h4 style="color:var(--accent);margin-bottom:8px;font-size:12px;">üìù Event Log Columns</h4>
      <div style="font-size:10px;display:grid;grid-template-columns:repeat(3,1fr);gap:4px;">
        <span><strong>Idx:</strong> Event index (1-based)</span>
        <span><strong>Link:</strong> Linked event index</span>
        <span><strong>Seq/Play:</strong> Sequence/Play index</span>
        <span><strong>Time:</strong> Period + game time</span>
        <span><strong>Type:</strong> Event type</span>
        <span><strong>Detail:</strong> Event detail 1</span>
        <span><strong>Zone:</strong> Off/Neu/Def</span>
        <span><strong>‚úì/‚úó:</strong> Success flag</span>
        <span><strong>Players:</strong> Player numbers</span>
        <span><strong>‚óè:</strong> Has XY data</span>
        <span><strong>‚≠ê:</strong> Highlight</span>
      </div>
      <p style="font-size:9px;color:var(--muted);margin-top:4px;">Double-click any event to quick edit (Type, Detail, Zone, Success, Linked, Highlight, Time)</p>
    </div>
    
    <div class="modal-actions" style="display:flex;justify-content:space-between;align-items:center;">
      <a href="TRACKER_USER_GUIDE_v23.4.md" download style="font-size:10px;color:var(--accent);">üì• Download Full User Guide (Markdown)</a>
      <button class="btn-primary" onclick="closeHelp()">Close</button>
    </div>
  </div>
</div>

<!-- Player Picker Modal -->
<div class="overlay" id="playerPickerModal">
  <div class="modal" style="min-width:400px;">
    <h3>üë§ Select Player</h3>
    <div class="form-row">
      <div class="form-group">
        <label>Team</label>
        <select id="pickerTeam" onchange="renderPlayerPicker()">
          <option value="home">Home</option>
          <option value="away">Away</option>
        </select>
      </div>
      <div class="form-group">
        <label>Role</label>
        <select id="pickerRole">
          <option value="event_team_player">Event Team</option>
          <option value="opp_team_player">Opposing Team</option>
        </select>
      </div>
    </div>
    <div id="playerPickerList" style="max-height:250px;overflow-y:auto;margin:8px 0;"></div>
    <div class="modal-actions">
      <button onclick="closePlayerPicker()">Cancel</button>
    </div>
  </div>
</div>

<!-- Verification Panel Modal -->
<div class="overlay" id="verifyModal">
  <div class="modal" style="min-width:600px;max-height:90vh;overflow-y:auto;">
    <h3>‚úÖ Verification Panel</h3>
    
    <!-- Tracked Goals (Blue) -->
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:12px;">
      <div style="background:rgba(59,130,246,0.2);border:2px solid var(--home);padding:12px;border-radius:4px;text-align:center;">
        <div style="font-size:24px;font-weight:bold;color:var(--home);" id="verifyHomeGoals">0</div>
        <div style="font-size:10px;color:var(--muted);">Tracked Home Goals</div>
        <div style="font-size:9px;color:var(--accent);margin-top:4px;" id="verifyHomeByPeriod">P1: 0 | P2: 0 | P3: 0</div>
      </div>
      <div style="background:rgba(239,68,68,0.2);border:2px solid var(--away);padding:12px;border-radius:4px;text-align:center;">
        <div style="font-size:24px;font-weight:bold;color:var(--away);" id="verifyAwayGoals">0</div>
        <div style="font-size:10px;color:var(--muted);">Tracked Away Goals</div>
        <div style="font-size:9px;color:var(--accent);margin-top:4px;" id="verifyAwayByPeriod">P1: 0 | P2: 0 | P3: 0</div>
      </div>
    </div>
    
    <!-- Official Score (Purple - Auto from dim_schedule) -->
    <div style="background:rgba(168,85,247,0.15);border:2px solid #a855f7;padding:12px;border-radius:4px;margin-bottom:12px;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <span style="font-size:11px;color:#a855f7;font-weight:bold;">üìä OFFICIAL SCORE (from dim_schedule)</span>
        <a id="noradGameLink" href="#" target="_blank" style="font-size:9px;color:var(--accent);">View on noradhockey.com ‚Üó</a>
      </div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;">
        <div style="text-align:center;">
          <div style="font-size:24px;font-weight:bold;color:#a855f7;" id="officialHomeGoalsDisplay">-</div>
          <div style="font-size:9px;color:var(--muted);" id="officialHomeByPeriod">P1: - | P2: - | P3: -</div>
        </div>
        <div style="text-align:center;">
          <div style="font-size:24px;font-weight:bold;color:#a855f7;" id="officialAwayGoalsDisplay">-</div>
          <div style="font-size:9px;color:var(--muted);" id="officialAwayByPeriod">P1: - | P2: - | P3: -</div>
        </div>
      </div>
      <input type="hidden" id="officialHomeGoals" value="0">
      <input type="hidden" id="officialAwayGoals" value="0">
    </div>
    
    <!-- Verification Result -->
    <div id="verifyResult" style="padding:12px;border-radius:4px;text-align:center;font-weight:bold;font-size:14px;margin-bottom:12px;"></div>
    
    <!-- Warnings -->
    <div id="verifyWarnings" style="display:none;background:rgba(245,158,11,0.2);border:1px solid var(--warn);padding:8px;border-radius:4px;margin-bottom:12px;font-size:10px;">
      <div style="font-weight:bold;color:var(--warn);margin-bottom:4px;">‚ö†Ô∏è WARNINGS</div>
      <div id="verifyWarningsList"></div>
    </div>
    
    <!-- Goal Breakdown -->
    <div style="margin-bottom:12px;">
      <div style="font-size:9px;color:var(--muted);margin-bottom:4px;">GOAL BREAKDOWN (Scorer #, Assist # from play_details)</div>
      <table style="width:100%;font-size:10px;border-collapse:collapse;">
        <thead><tr style="background:var(--card);">
          <th style="text-align:left;padding:4px;">P</th>
          <th style="text-align:left;padding:4px;">Time</th>
          <th style="text-align:left;padding:4px;">Team</th>
          <th style="text-align:left;padding:4px;">Scorer</th>
          <th style="text-align:left;padding:4px;">Assists</th>
          <th style="text-align:left;padding:4px;">‚úì</th>
        </tr></thead>
        <tbody id="verifyGoalsList"></tbody>
      </table>
    </div>
    
    <div class="modal-actions">
      <button onclick="runVerification()">üîÑ Verify</button>
      <button onclick="closeVerifyModal()">Close</button>
    </div>
  </div>
</div>

<!-- Video Timing Modal -->
<div class="overlay" id="videoTimingModal">
  <div class="modal" style="min-width:500px;max-height:80vh;overflow-y:auto;">
    <h3>üé¨ Video Timing Setup</h3>
    <p style="font-size:10px;color:var(--muted);margin-bottom:12px;">Configure video offsets for accurate timestamp calculations</p>
    
    <!-- Basic Settings -->
    <div style="background:var(--card);padding:12px;border-radius:4px;margin-bottom:12px;">
      <h4 style="font-size:11px;color:var(--accent);margin-bottom:8px;">Basic Settings</h4>
      <div class="form-group">
        <label>Video Start Offset (sec)</label>
        <input type="number" id="vtVideoStartOffset" value="0" min="0" placeholder="Skip warmups etc" oninput="updateVideoTimingPreview()">
      </div>
      <div style="margin-top:8px;">
        <label style="font-size:10px;color:var(--muted);display:block;margin-bottom:4px;">Period Lengths (minutes) - synced with Settings</label>
        <div style="display:flex;gap:8px;">
          <div class="form-group" style="flex:1;">
            <label style="font-size:9px;">P1</label>
            <input type="number" id="vtPeriodLength1" value="18" min="5" max="25" style="width:100%;" oninput="syncPeriodLengthsFromVT()">
          </div>
          <div class="form-group" style="flex:1;">
            <label style="font-size:9px;">P2</label>
            <input type="number" id="vtPeriodLength2" value="18" min="5" max="25" style="width:100%;" oninput="syncPeriodLengthsFromVT()">
          </div>
          <div class="form-group" style="flex:1;">
            <label style="font-size:9px;">P3</label>
            <input type="number" id="vtPeriodLength3" value="18" min="5" max="25" style="width:100%;" oninput="syncPeriodLengthsFromVT()">
          </div>
          <div class="form-group" style="flex:1;">
            <label style="font-size:9px;">OT</label>
            <input type="number" id="vtPeriodLengthOT" value="5" min="3" max="20" style="width:100%;" oninput="syncPeriodLengthsFromVT()">
          </div>
        </div>
      </div>
      <div class="form-group" style="margin-top:8px;">
        <label>YouTube URL (optional)</label>
        <input type="text" id="vtYoutubeUrl" placeholder="https://youtube.com/watch?v=...">
      </div>
    </div>
    
    <!-- Intermissions -->
    <div style="background:var(--card);padding:12px;border-radius:4px;margin-bottom:12px;">
      <h4 style="font-size:11px;color:var(--accent);margin-bottom:8px;">Intermission Durations</h4>
      <p style="font-size:9px;color:var(--muted);margin-bottom:8px;">Enter actual video time of intermissions (not game clock)</p>
      <div class="form-row">
        <div class="form-group">
          <label>After Period 1 (sec)</label>
          <input type="number" id="vtIntermission1" value="900" min="0" placeholder="900 = 15 min" oninput="updateVideoTimingPreview()">
        </div>
        <div class="form-group">
          <label>After Period 2 (sec)</label>
          <input type="number" id="vtIntermission2" value="900" min="0" placeholder="900 = 15 min" oninput="updateVideoTimingPreview()">
        </div>
        <div class="form-group">
          <label>After Period 3 / OT (sec)</label>
          <input type="number" id="vtIntermission3" value="300" min="0" placeholder="300 = 5 min" oninput="updateVideoTimingPreview()">
        </div>
      </div>
    </div>
    
    <!-- Timeouts/Stoppages -->
    <div style="background:var(--card);padding:12px;border-radius:4px;margin-bottom:12px;">
      <h4 style="font-size:11px;color:var(--accent);margin-bottom:8px;">Timeouts & Extended Stoppages</h4>
      <p style="font-size:9px;color:var(--muted);margin-bottom:8px;">Add stoppages that add extra video time (injuries, TV timeouts, etc)</p>
      <div id="vtTimeoutsList" style="margin-bottom:8px;max-height:150px;overflow-y:auto;"></div>
      <div class="form-row" style="align-items:flex-end;">
        <div class="form-group" style="flex:0.5;">
          <label>Period</label>
          <select id="vtNewTimeoutPeriod"><option>1</option><option>2</option><option>3</option><option>OT</option></select>
        </div>
        <div class="form-group" style="flex:1;">
          <label>Game Time</label>
          <input type="text" id="vtNewTimeoutTime" placeholder="15:30">
        </div>
        <div class="form-group" style="flex:1;">
          <label>Duration (sec)</label>
          <input type="number" id="vtNewTimeoutDuration" value="60" min="1">
        </div>
        <button class="btn-sm btn-success" onclick="addVideoTimeout()" style="margin-bottom:4px;">+ Add</button>
      </div>
    </div>
    
    <!-- Running Time Preview -->
    <div style="background:var(--panel);padding:12px;border-radius:4px;margin-bottom:12px;border:1px solid var(--accent);">
      <h4 style="font-size:11px;color:var(--accent);margin-bottom:8px;">‚è±Ô∏è Running Time Preview</h4>
      <div style="font-size:10px;display:grid;grid-template-columns:1fr 1fr;gap:4px;">
        <span>Period 1 Start:</span><span id="vtPreviewP1Start">0:00</span>
        <span>Period 1 End:</span><span id="vtPreviewP1End">18:00</span>
        <span>Period 2 Start:</span><span id="vtPreviewP2Start">33:00</span>
        <span>Period 2 End:</span><span id="vtPreviewP2End">51:00</span>
        <span>Period 3 Start:</span><span id="vtPreviewP3Start">66:00</span>
        <span>Period 3 End:</span><span id="vtPreviewP3End">84:00</span>
        <span>OT Start:</span><span id="vtPreviewOTStart">89:00</span>
        <span>OT End:</span><span id="vtPreviewOTEnd">94:00</span>
      </div>
    </div>
    
    <div class="modal-actions">
      <button class="btn-primary" onclick="saveVideoTiming()">üíæ Save</button>
      <button onclick="closeVideoTimingModal()">Cancel</button>
    </div>
  </div>
</div>

<!-- Load Existing Game Modal -->
<div class="overlay" id="loadGameModal">
  <div class="modal" style="min-width:500px;">
    <h3>üìÇ Load Existing Game</h3>
    <p style="font-size:10px;color:var(--muted);margin-bottom:12px;">Load tracked events from Supabase for editing</p>
    <div class="form-group" style="margin-bottom:8px;">
      <label>Select Game</label>
      <select id="loadGameSelect" style="width:100%;" onchange="previewLoadGame()"></select>
    </div>
    <div id="loadGamePreview" style="background:var(--card);padding:8px;border-radius:4px;font-size:10px;margin-bottom:8px;">
      <div>Events: <span id="loadPreviewEvents">--</span></div>
      <div>Shifts: <span id="loadPreviewShifts">--</span></div>
    </div>
    <div class="modal-actions">
      <button class="btn-primary" onclick="confirmLoadGame()">Load Game</button>
      <button onclick="closeLoadGameModal()">Cancel</button>
    </div>
  </div>
</div>
<div class="overlay" id="editModal">
  <div class="modal" style="min-width:650px;max-height:90vh;overflow-y:auto;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
      <button class="btn-sm" onclick="navEditEvent(-1)" title="Previous Event (‚Üê)">‚óÄ Prev</button>
      <h3 style="margin:0;">‚úèÔ∏è Event #<span id="editEvtIdx"></span> <span id="editHighlightBadge" style="color:gold;"></span></h3>
      <button class="btn-sm" onclick="navEditEvent(1)" title="Next Event (‚Üí)">Next ‚ñ∂</button>
    </div>
    <div class="form-row">
      <div class="form-group"><label>Event Type</label><select id="editType" onchange="onEditTypeChange()"></select></div>
      <div class="form-group"><label>Team</label><select id="editTeam"><option value="home">Home</option><option value="away">Away</option></select></div>
    </div>
    <div class="form-row">
      <div class="form-group"><label>Detail 1</label><select id="editD1" onchange="onEditD1Change()"></select></div>
      <div class="form-group"><label>Detail 2</label><select id="editD2"></select></div>
    </div>
    <div class="form-row tri">
      <div class="form-group"><label>Zone <button class="btn-sm" onclick="autoEditZone()" title="Auto from XY">‚ö°</button></label><select id="editZone"><option value="">--</option><option value="o">O</option><option value="d">D</option><option value="n">N</option></select></div>
      <div class="form-group"><label>Success <button class="btn-sm" onclick="autoEditSuccess()" title="Auto from detail">‚ö°</button></label><select id="editSuccess"><option value="">--</option><option value="s">S</option><option value="u">U</option></select></div>
      <div class="form-group"><label>Strength <button class="btn-sm" onclick="autoEditStrength()" title="Auto from shift">‚ö°</button></label><select id="editStrength"><option value="5v5">5v5</option><option value="5v4">5v4</option><option value="4v5">4v5</option><option value="4v4">4v4</option><option value="3v3">3v3</option><option value="ENG">ENG</option></select></div>
    </div>
    <div class="form-row">
      <div class="form-group"><label>Start Time</label><input type="text" id="editStartTime" oninput="autoFormatTime(this)"></div>
      <div class="form-group"><label>End Time</label><input type="text" id="editEndTime" oninput="autoFormatTime(this)"></div>
    </div>
    <div class="form-row">
      <div class="form-group">
        <label style="display:flex;align-items:center;gap:4px;">
          <input type="checkbox" id="editHighlight"> ‚≠ê Highlight (for video)
        </label>
      </div>
      <div class="form-group">
        <label>Linked Event #</label>
        <input type="number" id="editLinkedIdx" style="width:60px;" placeholder="--" title="Enter event # to link to">
      </div>
    </div>
    <div class="form-row" style="background:var(--panel);padding:4px 8px;border-radius:4px;margin-bottom:8px;">
      <!-- v15: Added event_id and event_index info -->
      <div class="form-group" style="margin-bottom:0;">
        <label style="font-size:8px;color:var(--muted);">Event ID</label>
        <span id="editEventId" style="font-size:9px;color:var(--accent);font-family:monospace;">--</span>
      </div>
      <div class="form-group" style="margin-bottom:0;">
        <label style="font-size:8px;color:var(--muted);">Event Index</label>
        <span id="editEventIndex" style="font-size:10px;color:var(--accent);">--</span>
      </div>
      <div class="form-group" style="margin-bottom:0;">
        <label style="font-size:8px;color:var(--muted);">Sequence Key</label>
        <span id="editSeqKey" style="font-size:10px;color:var(--accent);">--</span>
      </div>
      <div class="form-group" style="margin-bottom:0;">
        <label style="font-size:8px;color:var(--muted);">Play Key</label>
        <span id="editPlayKey" style="font-size:10px;color:var(--accent);">--</span>
      </div>
      <div class="form-group" style="margin-bottom:0;">
        <label style="font-size:8px;color:var(--muted);">Linked Chain</label>
        <span id="editLinkedChain" style="font-size:9px;color:var(--warn);">--</span>
      </div>
    </div>
    <div class="section-title" style="margin-top:8px;"><span>Players</span><button class="btn-sm" onclick="addPlayerToEdit()">+ Add</button></div>
    <div id="editPlayersContainer" style="max-height:200px;overflow-y:auto;"></div>
    <div class="section-title" style="margin-top:8px;"><span>Puck XY</span></div>
    <div id="editPuckXY" style="display:flex;flex-wrap:wrap;gap:4px;"></div>
    <div class="section-title" style="margin-top:8px;"><span>Edit XY on Rink</span></div>
    <svg id="editRinkSvg" viewBox="0 0 200 85" width="100%" style="cursor:crosshair;background:var(--card);border-radius:4px;max-height:150px;" onclick="handleEditRinkClick(event)">
      <!-- Ice surface -->
      <rect x="0" y="0" width="200" height="85" fill="#f0f9ff" rx="14" ry="14" stroke="#1e293b" stroke-width="0.5"/>
      
      <!-- Blue lines -->
      <line x1="75" y1="0" x2="75" y2="85" stroke="#1d4ed8" stroke-width="1.5"/>
      <line x1="125" y1="0" x2="125" y2="85" stroke="#1d4ed8" stroke-width="1.5"/>
      
      <!-- Red center line (dashed) -->
      <line x1="100" y1="0" x2="100" y2="85" stroke="#dc2626" stroke-width="0.8" stroke-dasharray="3,2"/>
      
      <!-- Goal lines -->
      <line x1="11" y1="0" x2="11" y2="85" stroke="#dc2626" stroke-width="0.5"/>
      <line x1="189" y1="0" x2="189" y2="85" stroke="#dc2626" stroke-width="0.5"/>
      
      <!-- Center circle -->
      <circle cx="100" cy="42.5" r="15" fill="none" stroke="#1d4ed8" stroke-width="0.5"/>
      <circle cx="100" cy="42.5" r="1" fill="#1d4ed8"/>
      
      <!-- Offensive zone faceoff circles (left) -->
      <circle cx="31" cy="22" r="15" fill="none" stroke="#dc2626" stroke-width="0.4"/>
      <circle cx="31" cy="22" r="1" fill="#dc2626"/>
      <circle cx="31" cy="63" r="15" fill="none" stroke="#dc2626" stroke-width="0.4"/>
      <circle cx="31" cy="63" r="1" fill="#dc2626"/>
      
      <!-- Offensive zone faceoff circles (right) -->
      <circle cx="169" cy="22" r="15" fill="none" stroke="#dc2626" stroke-width="0.4"/>
      <circle cx="169" cy="22" r="1" fill="#dc2626"/>
      <circle cx="169" cy="63" r="15" fill="none" stroke="#dc2626" stroke-width="0.4"/>
      <circle cx="169" cy="63" r="1" fill="#dc2626"/>
      
      <!-- Neutral zone dots -->
      <circle cx="80" cy="22" r="0.8" fill="#dc2626"/>
      <circle cx="80" cy="63" r="0.8" fill="#dc2626"/>
      <circle cx="120" cy="22" r="0.8" fill="#dc2626"/>
      <circle cx="120" cy="63" r="0.8" fill="#dc2626"/>
      
      <!-- Creases (simplified) -->
      <path d="M 11 38.5 L 15 38.5 A 4 4 0 0 1 15 46.5 L 11 46.5" fill="rgba(59,130,246,0.15)" stroke="#3b82f6" stroke-width="0.4"/>
      <path d="M 189 38.5 L 185 38.5 A 4 4 0 0 0 185 46.5 L 189 46.5" fill="rgba(59,130,246,0.15)" stroke="#3b82f6" stroke-width="0.4"/>
      
      <!-- Goals -->
      <rect x="7" y="39" width="4" height="7" fill="#222" stroke="#fff" stroke-width="0.3"/>
      <rect x="189" y="39" width="4" height="7" fill="#222" stroke="#fff" stroke-width="0.3"/>
      
      <!-- High danger zone (slot area) -->
      <path d="M 11 30 L 45 30 L 45 55 L 11 55 Z" fill="rgba(239,68,68,0.08)" stroke="none"/>
      <path d="M 189 30 L 155 30 L 155 55 L 189 55 Z" fill="rgba(239,68,68,0.08)" stroke="none"/>
      
      <!-- Zone labels -->
      <text x="43" y="82" font-size="3" fill="#64748b" text-anchor="middle">OFF</text>
      <text x="100" y="82" font-size="3" fill="#64748b" text-anchor="middle">NEU</text>
      <text x="157" y="82" font-size="3" fill="#64748b" text-anchor="middle">OFF</text>
      
      <g id="editRinkMarkers"></g>
    </svg>
    <div id="editXYControls" style="font-size:9px;color:var(--muted);margin-top:4px;">
      Editing: <select id="editXYTarget" onchange="renderEditRinkMarkers()" style="font-size:9px;"></select>
      <button class="btn-sm" onclick="addEditXYPoint()">+ Add Point</button>
    </div>
    <!-- Net Location for Shots/Goals -->
    <div id="editNetSection" style="display:none;margin-top:8px;">
      <div class="section-title"><span>Net Location (Shot/Goal)</span></div>
      <div style="display:flex;gap:16px;align-items:center;">
        <svg id="editNetSvg" viewBox="0 0 72 48" width="160" style="cursor:crosshair;background:#1f2937;border-radius:4px;" onclick="handleEditNetClick(event)">
          <rect x="1" y="1" width="70" height="46" fill="#111" stroke="#fff" stroke-width="1"/>
          <line x1="1" y1="1" x2="71" y2="47" stroke="#444" stroke-width="0.5"/>
          <line x1="71" y1="1" x2="1" y2="47" stroke="#444" stroke-width="0.5"/>
          <line x1="36" y1="1" x2="36" y2="47" stroke="#444" stroke-width="0.5"/>
          <line x1="1" y1="24" x2="71" y2="24" stroke="#444" stroke-width="0.5"/>
          <text x="12" y="12" font-size="5" fill="#666">Top L</text>
          <text x="50" y="12" font-size="5" fill="#666">Top R</text>
          <text x="12" y="42" font-size="5" fill="#666">Low L</text>
          <text x="50" y="42" font-size="5" fill="#666">Low R</text>
          <text x="26" y="26" font-size="5" fill="#666">5-Hole</text>
          <g id="editNetMarker"></g>
        </svg>
        <div style="font-size:10px;">
          <div style="color:var(--muted);margin-bottom:4px;">Click to set location</div>
          <div>Current: <span id="editNetLocation" style="color:var(--accent);">--</span></div>
          <button class="btn-sm" onclick="clearEditNetXY()" style="margin-top:4px;">Clear</button>
        </div>
      </div>
    </div>
    <!-- v20.7: Insert/Delete actions -->
    <div style="display:flex;gap:4px;margin-top:8px;padding-top:8px;border-top:1px solid var(--border);">
      <button class="btn-sm" onclick="insertEventBefore()" title="Insert new event before this one" style="flex:1;background:var(--accent2);">‚ûï Insert Before</button>
      <button class="btn-sm" onclick="insertEventAfter()" title="Insert new event after this one" style="flex:1;background:var(--accent2);">‚ûï Insert After</button>
      <button class="btn-sm" onclick="duplicateEvent()" title="Duplicate this event" style="flex:1;">üìã Duplicate</button>
    </div>
    <div class="modal-actions">
      <button class="btn-danger" onclick="deleteEvent()">Delete</button>
      <button class="btn-primary" onclick="saveEditEvent()">Save</button>
      <button onclick="closeEditModal()">Cancel</button>
    </div>
  </div>
</div>

<!-- Net Location Modal -->
<div class="overlay" id="netModal">
  <div class="modal" style="min-width:200px;">
    <h3>ü•Ö Net Location</h3>
    <p style="font-size:9px;color:var(--muted);margin-bottom:8px;">Click where puck entered net</p>
    <svg id="netSvg" viewBox="0 0 72 48" width="200" style="cursor:crosshair;background:#222;border-radius:4px;" onclick="handleNetClick(event)">
      <!-- Net frame -->
      <rect x="1" y="1" width="70" height="46" fill="none" stroke="#fff" stroke-width="1"/>
      <!-- Net mesh -->
      <line x1="1" y1="1" x2="71" y2="47" stroke="#666" stroke-width="0.3"/>
      <line x1="71" y1="1" x2="1" y2="47" stroke="#666" stroke-width="0.3"/>
      <line x1="36" y1="1" x2="36" y2="47" stroke="#666" stroke-width="0.3"/>
      <line x1="1" y1="24" x2="71" y2="24" stroke="#666" stroke-width="0.3"/>
      <!-- Zones -->
      <text x="18" y="14" font-size="6" fill="#888">Top L</text>
      <text x="46" y="14" font-size="6" fill="#888">Top R</text>
      <text x="18" y="38" font-size="6" fill="#888">Low L</text>
      <text x="46" y="38" font-size="6" fill="#888">Low R</text>
      <text x="28" y="26" font-size="6" fill="#888">5-Hole</text>
      <!-- Marker layer -->
      <g id="netMarker"></g>
    </svg>
    <div class="modal-actions">
      <button onclick="clearNetXY()">Clear</button>
      <button class="btn-primary" onclick="closeNetModal()">Done</button>
    </div>
  </div>
</div>

<!-- Edit Shift Modal -->
<div class="overlay" id="editShiftModal">
  <div class="modal" style="min-width:500px;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
      <button class="btn-sm" onclick="navEditShift(-1)" title="Previous Shift (‚Üê)">‚óÄ Prev</button>
      <h3 style="margin:0;">‚úèÔ∏è Shift #<span id="editShiftIdx"></span></h3>
      <button class="btn-sm" onclick="navEditShift(1)" title="Next Shift (‚Üí)">Next ‚ñ∂</button>
    </div>
    <div class="form-row">
      <div class="form-group"><label>Period</label><select id="editShiftPeriod"><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="OT">OT</option></select></div>
      <div class="form-group"><label>Strength</label><input type="text" id="editShiftStrength" readonly></div>
    </div>
    <div class="form-row">
      <div class="form-group"><label>Start Time</label><input type="text" id="editShiftStartTime"></div>
      <div class="form-group"><label>End Time</label><input type="text" id="editShiftEndTime"></div>
    </div>
    <div class="form-row">
      <div class="form-group"><label>Start Type</label><select id="editShiftStartType"></select></div>
      <div class="form-group"><label>Stop Type</label><select id="editShiftStopType"></select></div>
    </div>
    <div class="section-title" style="margin-top:8px;"><span>Players on Ice</span></div>
    <div id="editShiftPlayersContainer" style="background:var(--card);padding:8px;border-radius:4px;"></div>
    <!-- v20.6: Insert/Delete actions -->
    <div style="display:flex;gap:4px;margin-top:8px;padding-top:8px;border-top:1px solid var(--border);">
      <button class="btn-sm" onclick="insertShiftBefore()" title="Insert new shift before this one" style="flex:1;background:var(--accent2);">‚ûï Insert Before</button>
      <button class="btn-sm" onclick="insertShiftAfter()" title="Insert new shift after this one" style="flex:1;background:var(--accent2);">‚ûï Insert After</button>
      <button class="btn-sm" onclick="duplicateShift()" title="Duplicate this shift" style="flex:1;">üìã Duplicate</button>
    </div>
    <div class="modal-actions">
      <button class="btn-danger" onclick="deleteShift()">Delete</button>
      <button class="btn-primary" onclick="saveEditShift()">Save</button>
      <button onclick="closeEditShiftModal()">Cancel</button>
    </div>
  </div>
</div>

<!-- XY Edit Modal -->
<div class="overlay" id="xyEditModal">
  <div class="modal" style="min-width:400px;">
    <h3>üìç Edit XY Position</h3>
    <p style="font-size:9px;color:var(--muted);margin-bottom:8px;">Click on rink to set position</p>
    <svg id="xyEditSvg" viewBox="0 0 200 85" width="350" style="cursor:crosshair;background:var(--card);border-radius:4px;" onclick="handleXYEditClick(event)">
      <rect x="0" y="0" width="200" height="85" fill="#f8fafc" rx="14" ry="14" stroke="#1e293b" stroke-width="1"/>
      <line x1="75" y1="0" x2="75" y2="85" stroke="#1d4ed8" stroke-width="1.5"/>
      <line x1="125" y1="0" x2="125" y2="85" stroke="#1d4ed8" stroke-width="1.5"/>
      <line x1="100" y1="0" x2="100" y2="85" stroke="#dc2626" stroke-width="1" stroke-dasharray="3,2"/>
      <line x1="11" y1="0" x2="11" y2="85" stroke="#dc2626" stroke-width="0.8"/>
      <line x1="189" y1="0" x2="189" y2="85" stroke="#dc2626" stroke-width="0.8"/>
      <circle cx="100" cy="42.5" r="15" fill="none" stroke="#1d4ed8" stroke-width="0.8"/>
      <circle cx="31" cy="22" r="15" fill="none" stroke="#dc2626" stroke-width="0.5"/>
      <circle cx="31" cy="63" r="15" fill="none" stroke="#dc2626" stroke-width="0.5"/>
      <circle cx="169" cy="22" r="15" fill="none" stroke="#dc2626" stroke-width="0.5"/>
      <circle cx="169" cy="63" r="15" fill="none" stroke="#dc2626" stroke-width="0.5"/>
      <g id="xyEditMarker"></g>
    </svg>
    <div class="modal-actions">
      <button class="btn-primary" onclick="closeXYEditModal()">Done</button>
    </div>
  </div>
</div>

<!-- Generic Dynamic Modal (v23.4) -->
<div class="overlay" id="genericModal" onclick="if(event.target===this)closeModal()">
  <div class="modal" id="genericModalContent" style="min-width:400px;">
    <!-- Content will be inserted dynamically -->
  </div>
</div>

<!-- Event Confirmation Modal (v23.3) -->
<div class="overlay" id="confirmEventModal">
  <div class="modal" style="min-width:450px;max-width:550px;">
    <h3>‚úì Confirm Event</h3>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:12px;">
      <div class="form-group">
        <label>Type</label>
        <select id="confirmType" onchange="onConfirmTypeChange()"></select>
      </div>
      <div class="form-group">
        <label>Team</label>
        <select id="confirmTeam">
          <option value="home">Home</option>
          <option value="away">Away</option>
        </select>
      </div>
      <div class="form-group">
        <label>Detail 1</label>
        <select id="confirmD1" onchange="onConfirmD1Change()"></select>
      </div>
      <div class="form-group">
        <label>Detail 2</label>
        <select id="confirmD2"></select>
      </div>
      <div class="form-group">
        <label>Zone</label>
        <select id="confirmZone">
          <option value="">--</option>
          <option value="o">Offensive</option>
          <option value="d">Defensive</option>
          <option value="n">Neutral</option>
        </select>
      </div>
      <div class="form-group">
        <label>Success</label>
        <select id="confirmSuccess">
          <option value="">--</option>
          <option value="s">Successful</option>
          <option value="u">Unsuccessful</option>
        </select>
      </div>
      <div class="form-group">
        <label>Start Time</label>
        <input type="text" id="confirmStartTime" placeholder="MM:SS" oninput="autoFormatTime(this)">
      </div>
      <div class="form-group">
        <label>End Time</label>
        <input type="text" id="confirmEndTime" placeholder="MM:SS" oninput="autoFormatTime(this)">
      </div>
    </div>
    <div style="display:flex;gap:8px;margin-bottom:8px;">
      <div class="form-group" style="flex:1;">
        <label>Strength</label>
        <select id="confirmStrength">
          <option value="5v5">5v5</option>
          <option value="5v4">5v4</option>
          <option value="4v5">4v5</option>
          <option value="4v4">4v4</option>
          <option value="3v3">3v3</option>
          <option value="ENG">ENG</option>
        </select>
      </div>
      <div class="form-group" style="flex:1;">
        <label>Linked Event #</label>
        <input type="number" id="confirmLinked" placeholder="--" style="width:60px;">
      </div>
      <div class="form-group" style="flex:1;display:flex;align-items:center;padding-top:14px;">
        <label style="display:flex;align-items:center;gap:4px;font-size:9px;">
          <input type="checkbox" id="confirmHighlight"> ‚≠ê Highlight
        </label>
      </div>
    </div>
    <div style="background:var(--panel);padding:6px 8px;border-radius:4px;margin-bottom:8px;">
      <label style="font-size:8px;color:var(--muted);">Players</label>
      <div id="confirmPlayers" style="font-size:10px;"></div>
    </div>
    <div class="modal-actions" style="justify-content:space-between;">
      <button onclick="closeConfirmModal()">Cancel</button>
      <div style="display:flex;gap:8px;">
        <button onclick="confirmAndContinue()" style="background:var(--accent);color:#000;">‚úì Log & Continue</button>
        <button onclick="confirmAndLog()" class="btn-primary">‚úì Log Event</button>
      </div>
    </div>
  </div>
</div>

<!-- All Shifts Modal -->
<div class="overlay" id="allShiftsModal">
  <div class="modal" style="min-width:600px;max-width:800px;">
    <h3>üìã All Shifts (<span id="allShiftsCount">0</span>)</h3>
    <div class="table-wrap" style="max-height:400px;overflow-y:auto;">
      <table style="width:100%;font-size:10px;border-collapse:collapse;">
        <thead style="position:sticky;top:0;background:var(--card);">
          <tr><th>#</th><th>Period</th><th>Start</th><th>End</th><th>Start Type</th><th>Stop Type</th><th>Strength</th></tr>
        </thead>
        <tbody id="allShiftsBody"></tbody>
      </table>
    </div>
    <div class="modal-actions">
      <button onclick="document.getElementById('allShiftsModal').classList.remove('show')">Close</button>
    </div>
  </div>
</div>

<!-- All Events Modal -->
<div class="overlay" id="allEventsModal">
  <div class="modal" style="min-width:700px;max-width:900px;">
    <h3>üìã All Events (<span id="allEventsCount">0</span>)</h3>
    <div class="table-wrap" style="max-height:400px;overflow-y:auto;">
      <table style="width:100%;font-size:10px;border-collapse:collapse;">
        <thead style="position:sticky;top:0;background:var(--card);">
          <tr><th>#</th><th>Period</th><th>Time</th><th>Team</th><th>Type</th><th>Detail</th><th>Players</th></tr>
        </thead>
        <tbody id="allEventsBody"></tbody>
      </table>
    </div>
    <div class="modal-actions">
      <button onclick="document.getElementById('allEventsModal').classList.remove('show')">Close</button>
    </div>
  </div>
</div>

<!-- Full Box Score Modal -->
<div class="overlay" id="boxScoreModal">
  <div class="modal" style="min-width:700px;max-width:900px;">
    <h3>üìä Full Box Score</h3>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-bottom:16px;">
      <div style="background:var(--card);padding:12px;border-radius:6px;text-align:center;">
        <div style="font-size:12px;color:var(--muted);" id="boxModalHome">HOME</div>
        <div style="font-size:32px;font-weight:bold;" id="boxModalHomeScore">0</div>
        <div style="font-size:10px;color:var(--muted);">SOG: <span id="boxModalHomeSOG">0</span> | FO: <span id="boxModalHomeFO">0</span></div>
      </div>
      <div style="background:var(--card);padding:12px;border-radius:6px;text-align:center;">
        <div style="font-size:12px;color:var(--muted);" id="boxModalAway">AWAY</div>
        <div style="font-size:32px;font-weight:bold;" id="boxModalAwayScore">0</div>
        <div style="font-size:10px;color:var(--muted);">SOG: <span id="boxModalAwaySOG">0</span> | FO: <span id="boxModalAwayFO">0</span></div>
      </div>
    </div>
    <div class="table-wrap" style="max-height:300px;overflow-y:auto;">
      <table style="width:100%;font-size:11px;border-collapse:collapse;">
        <thead style="position:sticky;top:0;background:var(--card);">
          <tr><th>#</th><th>Player</th><th>Team</th><th>G</th><th>A</th><th>PTS</th><th>SOG</th><th>FO%</th><th>TOI</th></tr>
        </thead>
        <tbody id="boxModalBody"></tbody>
      </table>
    </div>
    <div class="modal-actions">
      <button onclick="document.getElementById('boxScoreModal').classList.remove('show')">Close</button>
    </div>
  </div>
</div>

<!-- Player Detail Modal -->
<div class="overlay" id="playerDetailModal">
  <div class="modal" style="min-width:400px;">
    <h3>üë§ <span id="playerDetailName">Player</span></h3>
    <div style="display:grid;grid-template-columns:repeat(4, 1fr);gap:8px;margin-bottom:16px;">
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:20px;font-weight:bold;" id="pdGoals">0</div>
        <div style="font-size:9px;color:var(--muted);">Goals</div>
      </div>
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:20px;font-weight:bold;" id="pdAssists">0</div>
        <div style="font-size:9px;color:var(--muted);">Assists</div>
      </div>
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:20px;font-weight:bold;" id="pdShots">0</div>
        <div style="font-size:9px;color:var(--muted);">SOG</div>
      </div>
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:20px;font-weight:bold;" id="pdFO">0%</div>
        <div style="font-size:9px;color:var(--muted);">FO%</div>
      </div>
    </div>
    <div style="display:grid;grid-template-columns:repeat(3, 1fr);gap:8px;margin-bottom:16px;">
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:16px;font-weight:bold;" id="pdTOI">--:--</div>
        <div style="font-size:9px;color:var(--muted);">TOI</div>
      </div>
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:16px;font-weight:bold;" id="pdHits">0</div>
        <div style="font-size:9px;color:var(--muted);">Hits</div>
      </div>
      <div style="background:var(--card);padding:8px;border-radius:4px;text-align:center;">
        <div style="font-size:16px;font-weight:bold;" id="pdBlocks">0</div>
        <div style="font-size:9px;color:var(--muted);">Blocks</div>
      </div>
    </div>
    <div style="font-size:10px;color:var(--muted);margin-bottom:8px;">Recent Events:</div>
    <div id="pdRecentEvents" style="max-height:150px;overflow-y:auto;background:var(--card);border-radius:4px;padding:8px;font-size:9px;"></div>
    <div class="modal-actions">
      <button onclick="document.getElementById('playerDetailModal').classList.remove('show')">Close</button>
    </div>
  </div>
</div>

<!-- Toast -->
<div class="toast" id="toast"></div>

<script>
// ============================================================
// STATE
// ============================================================
const S = {
  sb: null, connected: false,
  gameId: null, games: [], rosters: { home: [], away: [] },
  homeTeam: 'Home', awayTeam: 'Away', homeColor: '#3b82f6', awayColor: '#ef4444',
  homeLogo: null, awayLogo: null,
  teams: {},  // v15.01: Team data from dim_team
  // Reference data from Supabase
  playDetails1: [],  // dim_play_detail
  playDetails2: [],  // dim_play_detail_2
  eventDetails1: [], // dim_event_detail (v16.06)
  eventDetails2: [], // dim_event_detail_2 (v16.06)
  eventTypesDB: [],  // dim_event_type (v22.1)
  showAllEventTypes: false, // v22.1: Toggle for showing all event types
  playerRoles: [],   // dim_player_role
  period: 1, evtTeam: 'home', 
  // v23.5: Per-period lengths (NORAD default varies)
  periodLengths: { 1: 18, 2: 18, 3: 18, OT: 5 },
  periodLength: 18, // Legacy - use getPeriodLength() instead
  homeAttacksRightP1: true, // v19: Configurable per game - which end home attacks in P1
  slots: { home: {F1:null,F2:null,F3:null,D1:null,D2:null,G:null,X:null}, away: {F1:null,F2:null,F3:null,D1:null,D2:null,G:null,X:null} },
  selectedSlot: null, events: [], shifts: [], evtIdx: 0, shiftIdx: 0,
  curr: { type: null, players: [], puckXY: [], netXY: null },
  selectedPlayer: null, xyMode: 'puck', xySlot: 1,
  editingEvtIdx: null, editingShiftIdx: null, lastEndTime: '18:00',
  editingXYType: null, editingXYIdx: null, // For XY editing in modal
  xyHistory: [], // For undo
  lastSave: null, saveTimer: null,
  linkedEventIdx: null, // For linked plays
  // Video timing - variable intermissions and stoppages
  videoTiming: {
    videoStartOffset: 0,        // Seconds to skip at video start (pre-game, warmups)
    intermission1: 900,         // Seconds after P1 (default 15 min)
    intermission2: 900,         // Seconds after P2 (default 15 min)
    intermission3: 300,         // Seconds after P3 if OT (default 5 min)
    timeouts: [],               // Array of {period, gameTime, duration} objects
    youtubeUrl: ''              // Optional YouTube link for this game
  },
  // v15.01: Video player state
  videoPlayer: {
    sources: [],                // Array of {id, name, type:'youtube'|'file', url, hotkey}
    currentSourceIdx: 0,
    isPlaying: false,
    currentTime: 0,
    speed: 1,
    autoSync: true,             // Auto-populate start/end times from video
    ytPlayer: null,             // YouTube IFrame API player instance
    gameMarkers: {              // Video timestamps for game events (in seconds)
      P1Start: null, P1End: null,
      P2Start: null, P2End: null,
      P3Start: null, P3End: null,
      OTStart: null, OTEnd: null,
      stoppages: []             // Array of {startTime, endTime, type, note}
    }
  }
};

// ============================================================
// v23.5: PERIOD LENGTH HELPERS
// ============================================================

/**
 * Get the length of a specific period in minutes
 * @param {number|string} period - Period number (1, 2, 3) or 'OT'
 * @returns {number} Period length in minutes
 */
function getPeriodLength(period) {
  const p = String(period).toUpperCase();
  if (p === 'OT' || p === '4') {
    return S.periodLengths?.OT || 5;
  }
  const num = parseInt(period) || 1;
  return S.periodLengths?.[num] || S.periodLength || 18;
}

/**
 * Get the length of a specific period in seconds
 */
function getPeriodLengthSeconds(period) {
  return getPeriodLength(period) * 60;
}

/**
 * Update periodLengths from UI inputs
 */
function updatePeriodLengthsFromUI() {
  S.periodLengths = {
    1: parseInt(document.getElementById('periodLength1')?.value) || 18,
    2: parseInt(document.getElementById('periodLength2')?.value) || 18,
    3: parseInt(document.getElementById('periodLength3')?.value) || 18,
    OT: parseInt(document.getElementById('periodLengthOT')?.value) || 5
  };
  // Keep legacy field in sync with P1 for compatibility
  S.periodLength = S.periodLengths[1];
  document.getElementById('periodLength').value = S.periodLength;
  
  // Update the period length indicator for current period
  updatePeriodLengthIndicator();
  
  // Update clock if it shows full period time
  const clock = document.getElementById('clock').value;
  const oldLen = parseInt(clock.split(':')[0]);
  if (oldLen >= 15 && oldLen <= 25) {
    // Looks like start of period - update to new length
    const currentLen = getPeriodLength(S.period);
    document.getElementById('clock').value = `${currentLen}:00`;
  }
  
  toast('Period lengths updated', 'info');
}

/**
 * Update the period length indicator in header
 */
function updatePeriodLengthIndicator() {
  const indicator = document.getElementById('periodLengthIndicator');
  if (indicator) {
    const currentLen = getPeriodLength(S.period);
    const lengths = S.periodLengths || { 1: 18, 2: 18, 3: 18, OT: 5 };
    
    // Show all period lengths if they differ
    const allSame = lengths[1] === lengths[2] && lengths[2] === lengths[3];
    if (allSame) {
      indicator.textContent = `(${currentLen}m)`;
      indicator.title = `All periods: ${lengths[1]}m, OT: ${lengths.OT}m`;
    } else {
      indicator.textContent = `(P${S.period}: ${currentLen}m)`;
      indicator.title = `P1: ${lengths[1]}m, P2: ${lengths[2]}m, P3: ${lengths[3]}m, OT: ${lengths.OT}m`;
    }
  }
}

/**
 * Update UI inputs from periodLengths
 */
function updatePeriodLengthsUI() {
  if (S.periodLengths) {
    document.getElementById('periodLength1').value = S.periodLengths[1] || 18;
    document.getElementById('periodLength2').value = S.periodLengths[2] || 18;
    document.getElementById('periodLength3').value = S.periodLengths[3] || 18;
    document.getElementById('periodLengthOT').value = S.periodLengths.OT || 5;
  }
  updatePeriodLengthIndicator();
}

/**
 * Get total elapsed time at start of a period (for video sync)
 * Accounts for variable period lengths and intermissions
 */
function getElapsedAtPeriodStart(period) {
  const p = parseInt(period) || 1;
  let elapsed = 0;
  
  for (let i = 1; i < p; i++) {
    elapsed += getPeriodLengthSeconds(i);
    // Add intermission after each period
    if (i === 1) elapsed += (S.videoTiming?.intermission1 || 900);
    if (i === 2) elapsed += (S.videoTiming?.intermission2 || 900);
    if (i === 3) elapsed += (S.videoTiming?.intermission3 || 300);
  }
  
  return elapsed;
}

// ============================================================
// DROPDOWN OPTIONS
// ============================================================
const LISTS = {
  eventTypes: ['Faceoff','Shot','Pass','Goal','Turnover','Zone_Entry_Exit','Penalty','Stoppage','Possession','Save','Rebound','DeadIce','Play','Intermission','Clockstop','Timeout'],
  hotkeys: { Faceoff:'F', Shot:'S', Pass:'P', Goal:'G', Turnover:'T', Zone_Entry_Exit:'Z', Penalty:'N', Stoppage:'X', Possession:'O', Save:'V', Rebound:'R', DeadIce:'D', Play:'Y', Intermission:'I', Clockstop:'C' },
  details: {
    Shot: { d1: ['Shot_OnNetSaved','Shot_Missed','Shot_Blocked','Shot_BlockedSameTeam','Shot_Deflected','Shot_OnNetGoal'], d2: ['Shot-Wrist','Shot-Slap','Shot-Backhand','Shot-Snap','Shot-WrapAround','Shot-Bat','Shot-Poke','Shot-OneTime','Shot-Tip','Shot-Deflection','Shot-Other'] },
    Pass: { d1: ['Pass_Completed','Pass_Missed','Pass_Deflected','Pass_Intercepted'], d2: ['Pass-Stretch','Pass-Rim/Wrap','Pass-Backhand','Pass-Forehand','Pass-Bank','Pass-Dump','Pass-Drop','Pass-OneTouch','Pass-Other'] },
    Goal: { d1: ['Goal_Scored','Goal_Shootout','Goal_PenaltyShot'], d2: ['Goal-Wrist','Goal-Slap','Goal-Backhand','Goal-Tip','Goal-Snap','Goal-WrapAround','Goal-Deflection','Goal-OneTime','Goal-Other'] },
    Faceoff: { d1: ['Faceoff_PeriodStart','Faceoff_GameStart','Faceoff_AfterGoal','Faceoff_AfterPenalty','Faceoff_AfterStoppage'], d2: [] },
    Turnover: { d1: ['Turnover_Giveaway','Turnover_Takeaway'], d2_Giveaway: ['Giveaway-Misplayed','Giveaway-BattleLost','Giveaway-PassIntercepted','Giveaway-Other'], d2_Takeaway: ['Takeaway-BattleWon','Takeaway-PokeCheck','Takeaway-PassIntercepted','Takeaway-Other'] },
    Zone_Entry_Exit: { d1: ['Zone_Entry','Zone_Exit','Zone_Keepin','Zone_EntryFailed','Zone_ExitFailed'], d2_Entry: ['ZoneEntry-Rush','ZoneEntry-Pass','ZoneEntry-DumpIn','ZoneEntry-Chip'], d2_Exit: ['ZoneExit-Rush','ZoneExit-Pass','ZoneExit-Clear','ZoneExit-Chip'] },
    Save: { d1: ['Save_Rebound','Save_Freeze','Save_Played'], d2: ['Save-Glove','Save-Blocker','Save-Pad','Save-Stick','Save-Butterfly','Save-Other'] },
    Stoppage: { d1: ['Stoppage_PeriodEnd','Stoppage_Play','Stoppage_Other','Stoppage_GameEnd'], d2_Play: ['Stoppage-Icing','Stoppage-Offsides','Stoppage-GoalieStoppage','Stoppage-PuckOut','Stoppage-Penalty','Stoppage-Goal'] },
    Penalty: { d1: ['Penalty_Minor','Penalty_Major','Penalty_Misconduct'], d2: ['Penalty-Tripping','Penalty-Hooking','Penalty-Slashing','Penalty-Interference','Penalty-Holding','Penalty-Roughing','Penalty-HighSticking','Penalty-CrossChecking','Penalty-Boarding','Penalty-Other'] },
    Possession: { d1: ['Breakaway','PuckRetrieval','PuckRecovery','Regroup','LoosePuck'], d2: [] },
    Rebound: { d1: ['Rebound_TeamRecovered','Rebound_OppRecovered','Rebound_ShotGenerated'], d2: [] },
    DeadIce: { d1: ['DeadIce_Icing','DeadIce_Offside','DeadIce_PuckOut','DeadIce_NetOff','DeadIce_Other'], d2: [] },
    Play: { d1: ['Play_Offensive','Play_Defensive'], d2_Offensive: ['Play-DriveMiddle','Play-DriveWide','Play-CrashNet','Play-Deke','Play-DumpChase','Play-Forecheck'], d2_Defensive: ['Play-PokeCheck','Play-Backcheck','Play-Contain','Play-BoxOut'] },
    Intermission: { d1: ['Intermission_Period1','Intermission_Period2','Intermission_Period3','Intermission_OT'], d2: [] },
    Clockstop: { d1: ['Clockstop_Injury','Clockstop_Equipment','Clockstop_IceRepair','Clockstop_Other'], d2: [] },
    Timeout: { d1: ['Timeout_Home','Timeout_Away'], d2: [] }
  },
  shiftStart: ['GameStart','PeriodStart','FaceoffAfterGoal','FaceoffAfterPenalty','OtherFaceoff','Stoppage','Intermission','OnTheFly'],
  shiftStop: ['','OnTheFly','PeriodEnd','Period End','GoalScored','Home Goal','Away Goal','Penalty','Stoppage','OtherFaceoff','Intermission','GameEnd','High Stick','Away Icing','Home Icing','Away Offside','Home Offside','Puck Out of Play','Away Goalie Stopped (after Home SOG)','Home Goalie Stopped (after Away SOG)'],
  playOffensive: ['Play-DriveMiddle','Play-DriveWide','Play-CrashNet','Play-Delay','Play-Deke','Play-DumpChase','Play-Forecheck','Play-Other'],
  playDefensive: ['Play-PokeCheck','Play-Backcheck','Play-Contain','Play-BoxOut','Play-Other'],
  // Events where puck XY = event_player_1 XY
  possessionEvents: ['Possession','Zone_Entry_Exit'],
  possessionDetails: ['ZoneEntry-Rush','ZoneExit-Rush','Breakaway','PuckRetrieval','PuckRecovery','Regroup'],
  // Suggested next events based on current event
  nextEventSuggestions: {
    'Faceoff': ['Pass', 'Possession', 'Turnover'],
    'Pass': ['Shot', 'Pass', 'Turnover', 'Zone_Entry_Exit'],
    'Shot': ['Save', 'Goal', 'Rebound'],
    'Save': ['Rebound', 'Pass', 'Stoppage'],
    'Goal': ['Faceoff', 'Stoppage'],
    'Rebound': ['Shot', 'Possession', 'Turnover'],
    'Zone_Entry_Exit': ['Pass', 'Shot', 'Possession'],
    'Turnover': ['Pass', 'Shot', 'Zone_Entry_Exit'],
    'Possession': ['Pass', 'Shot', 'Zone_Entry_Exit'],
    'Penalty': ['Faceoff', 'Stoppage'],
    'Stoppage': ['Faceoff', 'Intermission']
  },
  // Events that can be linked (sequence)
  linkedEvents: {
    'Shot': ['Pass', 'Rebound'], // Shot can link to preceding Pass or following Rebound
    'Goal': ['Shot', 'Pass'], // Goal links to Shot (the goal shot) or Pass (assist)
    'Save': ['Shot'], // Save links to Shot
    'Rebound': ['Shot', 'Save'] // Rebound links to Shot or Save
  }
};

// ============================================================
// INIT
// ============================================================
async function init() {
  console.log('BenchSight v23.4 initializing...');
  loadSettings();
  initSaveFolderUI();  // Initialize save folder UI
  setupRinkEventListeners(); // v23.4: Attach rink mouse handlers
  loadVideoSources(); // v23.4: Load saved video sources
  await tryConnect();
  buildUI();
  loadFromStorage();
  setupKeys();
  setupTimeInputs(); // v5: Auto-format time inputs
  startAutoSave();
  await loadGames();
  if (S.gameId) await selectGame(S.gameId);
  updateSaveIndicator();
  updateNextPlaySuggestions();
  updateZoneLabels();
  console.log('Ready:', S.events.length, 'events,', S.shifts.length, 'shifts');
}

/**
 * v23.4: Attach event listeners to rink SVG
 */
function setupRinkEventListeners() {
  const svg = document.getElementById('rinkSvg');
  if (!svg) return;
  
  svg.addEventListener('mousedown', handleRinkMouseDown);
  svg.addEventListener('mousemove', (e) => {
    handleRinkMouseMove(e);
    handleRinkHover(e);
  });
  svg.addEventListener('mouseup', handleRinkMouseUp);
  svg.addEventListener('mouseleave', () => {
    hideXYTooltip();
    hideDragPreview();
  });
}

function loadSettings() {
  try {
    const s = JSON.parse(localStorage.getItem('bs_settings') || '{}');
    if (s.sbUrl) document.getElementById('sbUrl').value = s.sbUrl;
    if (s.sbKey) document.getElementById('sbKey').value = s.sbKey;
    if (s.autoSaveInt) document.getElementById('autoSaveInt').value = s.autoSaveInt;
    if (s.pressureDist) document.getElementById('pressureDist').value = s.pressureDist;
    if (s.xyHistCnt) document.getElementById('xyHistCnt').value = s.xyHistCnt;
    if (s.periodLength) {
      document.getElementById('periodLength').value = s.periodLength;
      S.periodLength = parseInt(s.periodLength);
    }
    if (s.otLength) document.getElementById('otLength').value = s.otLength;
  } catch(e) {}
}

function saveSettings() {
  const s = {
    sbUrl: document.getElementById('sbUrl').value,
    sbKey: document.getElementById('sbKey').value,
    autoSaveInt: document.getElementById('autoSaveInt').value,
    pressureDist: document.getElementById('pressureDist').value,
    xyHistCnt: document.getElementById('xyHistCnt').value,
    periodLength: document.getElementById('periodLength').value,
    otLength: document.getElementById('otLength').value
  };
  localStorage.setItem('bs_settings', JSON.stringify(s));
  S.periodLength = parseInt(s.periodLength) || 18;
  
  // Update clock to match period length
  if (S.period !== 'OT') {
    document.getElementById('clock').value = S.periodLength + ':00';
  }
  
  closeSettings();
  toast('Settings saved', 'success');
  tryConnect();
  startAutoSave();
}

async function tryConnect() {
  const url = document.getElementById('sbUrl').value;
  const key = document.getElementById('sbKey').value;
  if (!url || !key) { 
    updateConn(false); 
    return; 
  }
  try {
    S.sb = supabase.createClient(url, key);
    // Try to query a table that exists
    const { data, error } = await S.sb.from('dim_schedule').select('game_id').limit(1);
    if (error) {
      console.error('Supabase query error:', error);
      // Provide helpful error messages
      if (error.message?.includes('permission denied') || error.code === '42501') {
        toast('RLS is blocking queries. Disable RLS in Supabase SQL Editor.', 'error');
      } else if (error.message?.includes('does not exist') || error.code === '42P01') {
        toast('Tables not found. Run upload.py --schema then upload.py', 'error');
      } else {
        toast('Connection error: ' + (error.message || error.code), 'error');
      }
      throw error;
    }
    S.connected = true;
    updateConn(true);
    
    // Load reference data (play details, player roles)
    await loadReferenceData();
  } catch(e) { 
    console.error('Connection failed:', e);
    S.sb = null; S.connected = false; updateConn(false); 
  }
}

/**
 * Load reference data from Supabase (dim tables)
 */
async function loadReferenceData() {
  if (!S.connected) return;
  
  try {
    // Load dim_play_detail
    const { data: pd1, error: e1 } = await S.sb.from('dim_play_detail')
      .select('play_detail_id,play_detail_name,play_category')
      .order('play_detail_name');
    
    if (!e1 && pd1) {
      S.playDetails1 = pd1.map(p => ({
        id: p.play_detail_id,
        name: p.play_detail_name,
        category: p.play_category
      }));
      console.log('Loaded', S.playDetails1.length, 'play details 1');
    }
    
    // Load dim_play_detail_2
    const { data: pd2, error: e2 } = await S.sb.from('dim_play_detail_2')
      .select('play_detail_2_id,play_detail_2_name,play_category')
      .order('play_detail_2_name');
    
    if (!e2 && pd2) {
      S.playDetails2 = pd2.map(p => ({
        id: p.play_detail_2_id,
        name: p.play_detail_2_name,
        category: p.play_category
      }));
      console.log('Loaded', S.playDetails2.length, 'play details 2');
    }
    
    // v16.06: Load dim_event_detail for event detail 1 dropdown
    const { data: ed1, error: e2a } = await S.sb.from('dim_event_detail')
      .select('event_detail_id,event_detail_name,event_type')
      .order('event_type,event_detail_name');
    
    if (!e2a && ed1) {
      S.eventDetails1 = ed1.map(e => ({
        id: e.event_detail_id,
        name: e.event_detail_name,
        eventType: e.event_type
      }));
      console.log('Loaded', S.eventDetails1.length, 'event details 1');
    }
    
    // v16.08: Load dim_event_detail_2 for event detail 2 dropdown
    // Note: category is "other" for most entries, so we filter by code prefix
    const { data: ed2, error: e2b } = await S.sb.from('dim_event_detail_2')
      .select('event_detail_2_id,event_detail_2_code,event_detail_2_name,category')
      .order('event_detail_2_code');
    
    if (!e2b && ed2) {
      S.eventDetails2 = ed2.map(e => ({
        id: e.event_detail_2_id,
        code: e.event_detail_2_code,  // e.g., "ZoneEntry_Rush"
        name: e.event_detail_2_name,   // e.g., "ZoneEntry Rush"
        category: e.category
      }));
      console.log('Loaded', S.eventDetails2.length, 'event details 2');
    }
    
    // v22.1: Load dim_event_type for event type buttons
    const { data: et, error: etErr } = await S.sb.from('dim_event_type')
      .select('event_type_id,event_type_code,event_type_name,event_category')
      .order('event_type_code');
    
    if (!etErr && et) {
      S.eventTypesDB = et.map(e => ({
        id: e.event_type_id,
        code: e.event_type_code,
        name: e.event_type_name,
        category: e.event_category
      }));
      console.log('Loaded', S.eventTypesDB.length, 'event types from dim_event_type');
      // Rebuild UI to use dynamic event types
      buildEventTypeButtons();
    }
    
    // Load dim_player_role
    const { data: roles, error: e3 } = await S.sb.from('dim_player_role')
      .select('role_id,role_code,role_name,role_type,sort_order')
      .order('sort_order');
    
    if (!e3 && roles) {
      S.playerRoles = roles.map(r => ({
        id: r.role_id,
        code: r.role_code,
        name: r.role_name,
        type: r.role_type,
        order: r.sort_order
      }));
      console.log('Loaded', S.playerRoles.length, 'player roles');
    }
    
    // v15.01: Load dim_team for colors and logos
    const { data: teams, error: e4 } = await S.sb.from('dim_team')
      .select('team_id,team_name,team_color1,team_color2,team_logo');
    
    if (!e4 && teams) {
      S.teams = {};
      teams.forEach(t => {
        S.teams[t.team_name] = {
          id: t.team_id,
          name: t.team_name,
          color1: t.team_color1 || '#3b82f6',
          color2: t.team_color2 || '#1e40af',
          logo: t.team_logo || null
        };
      });
      console.log('Loaded', Object.keys(S.teams).length, 'teams');
    }
    
  } catch(e) {
    console.error('Error loading reference data:', e);
  }
}

async function testConn() {
  await tryConnect();
  toast(S.connected ? '‚úÖ Connected to Supabase!' : '‚ùå Connection failed', S.connected ? 'success' : 'error');
}

function updateConn(on) {
  const el = document.getElementById('connStatus');
  el.textContent = on ? 'ONLINE' : 'OFFLINE';
  el.className = 'conn ' + (on ? 'on' : 'off');
}

function openSettings() { document.getElementById('settingsModal').classList.add('show'); }
function closeSettings() { document.getElementById('settingsModal').classList.remove('show'); }
function openHelp() { document.getElementById('helpModal').classList.add('show'); }
function closeHelp() { document.getElementById('helpModal').classList.remove('show'); }

/**
 * Open the full user guide in a new tab
 */
function openUserGuide() {
  // Try to open the guide file
  const guideUrl = 'TRACKER_USER_GUIDE_v23.4.md';
  
  // Create a modal with the guide content if file not accessible
  const html = `
    <h3>üìñ BenchSight Tracker v23.4 User Guide</h3>
    <p style="font-size:11px;color:var(--muted);margin-bottom:12px;">
      The complete user guide covers all features in detail.
    </p>
    
    <div style="max-height:400px;overflow-y:auto;background:var(--panel);padding:12px;border-radius:4px;font-size:10px;line-height:1.6;">
      <h4 style="color:var(--accent);margin-bottom:8px;">üìã Table of Contents</h4>
      <ol style="margin-left:16px;">
        <li><strong>Quick Start</strong> - First time setup, basic workflow</li>
        <li><strong>Interface Overview</strong> - Layout diagram, color coding</li>
        <li><strong>Video Playback</strong> - Loading, controls, multi-source, clock sync</li>
        <li><strong>Event Tracking</strong> - Types, details, players, logging</li>
        <li><strong>XY Positioning</strong> - Modes, smart linking, drag creation</li>
        <li><strong>Shift Tracking</strong> - Recording, line presets</li>
        <li><strong>Workflow Automation</strong> - Chains, templates, auto-features</li>
        <li><strong>Data Management</strong> - Saving, export/import, rosters</li>
        <li><strong>Keyboard Shortcuts</strong> - Complete reference table</li>
        <li><strong>Tips & Best Practices</strong> - Workflows, troubleshooting</li>
      </ol>
      
      <h4 style="color:var(--accent);margin:16px 0 8px;">üé¨ Video Hotkeys (v23.4)</h4>
      <table style="width:100%;border-collapse:collapse;">
        <tr><td style="padding:2px 8px;border-bottom:1px solid var(--border);"><kbd>Space</kbd></td><td>Play/Pause</td></tr>
        <tr><td style="padding:2px 8px;border-bottom:1px solid var(--border);"><kbd>‚Üê</kbd> / <kbd>‚Üí</kbd></td><td>Seek ¬±1s</td></tr>
        <tr><td style="padding:2px 8px;border-bottom:1px solid var(--border);"><kbd>Shift+‚Üê/‚Üí</kbd></td><td>Seek ¬±10s</td></tr>
        <tr><td style="padding:2px 8px;border-bottom:1px solid var(--border);"><kbd>‚Üë</kbd> / <kbd>‚Üì</kbd></td><td>Speed up/down</td></tr>
        <tr><td style="padding:2px 8px;border-bottom:1px solid var(--border);"><kbd>;</kbd> / <kbd>'</kbd></td><td>Frame step</td></tr>
        <tr><td style="padding:2px 8px;border-bottom:1px solid var(--border);"><kbd>+</kbd> / <kbd>-</kbd></td><td>Zoom in/out</td></tr>
        <tr><td style="padding:2px 8px;"><kbd>Ctrl+1-9</kbd></td><td>Switch video source</td></tr>
      </table>
      
      <h4 style="color:var(--accent);margin:16px 0 8px;">‚ö° Quick Workflows</h4>
      <p><strong>Shot:</strong> Drag from shooter toward net ‚Üí Auto-creates shot with XY</p>
      <p><strong>Pass:</strong> Drag from passer to receiver ‚Üí Auto-creates pass with XY</p>
      <p><strong>Hit:</strong> Add players ‚Üí Click puck ‚Üí üìç All Here</p>
      <p><strong>Faceoff:</strong> Click faceoff dot ‚Üí Auto-positions players</p>
    </div>
    
    <div class="modal-actions" style="margin-top:12px;display:flex;justify-content:space-between;">
      <a href="TRACKER_USER_GUIDE_v23.4.md" download class="btn-sm" style="background:var(--accent);color:#000;text-decoration:none;padding:6px 12px;">üì• Download Guide (Markdown)</a>
      <button class="btn-primary" onclick="closeModal()">Close</button>
    </div>
  `;
  
  showModal(html);
}

// ============================================================
// VIDEO TIMING FUNCTIONS
// ============================================================
function openVideoTimingModal() {
  // Populate fields from S.videoTiming and S.periodLengths
  document.getElementById('vtVideoStartOffset').value = S.videoTiming.videoStartOffset || 0;
  
  // Populate per-period lengths
  document.getElementById('vtPeriodLength1').value = S.periodLengths?.[1] || 18;
  document.getElementById('vtPeriodLength2').value = S.periodLengths?.[2] || 18;
  document.getElementById('vtPeriodLength3').value = S.periodLengths?.[3] || 18;
  document.getElementById('vtPeriodLengthOT').value = S.periodLengths?.OT || 5;
  
  document.getElementById('vtIntermission1').value = S.videoTiming.intermission1 || 900;
  document.getElementById('vtIntermission2').value = S.videoTiming.intermission2 || 900;
  document.getElementById('vtIntermission3').value = S.videoTiming.intermission3 || 300;
  document.getElementById('vtYoutubeUrl').value = S.videoTiming.youtubeUrl || '';
  
  renderVideoTimeouts();
  updateVideoTimingPreview();
  document.getElementById('videoTimingModal').classList.add('show');
}

function closeVideoTimingModal() {
  document.getElementById('videoTimingModal').classList.remove('show');
}

/**
 * Sync period lengths from Video Timing modal to Settings
 */
function syncPeriodLengthsFromVT() {
  S.periodLengths = {
    1: parseInt(document.getElementById('vtPeriodLength1')?.value) || 18,
    2: parseInt(document.getElementById('vtPeriodLength2')?.value) || 18,
    3: parseInt(document.getElementById('vtPeriodLength3')?.value) || 18,
    OT: parseInt(document.getElementById('vtPeriodLengthOT')?.value) || 5
  };
  S.periodLength = S.periodLengths[1];
  
  // Sync to Settings modal inputs
  document.getElementById('periodLength1').value = S.periodLengths[1];
  document.getElementById('periodLength2').value = S.periodLengths[2];
  document.getElementById('periodLength3').value = S.periodLengths[3];
  document.getElementById('periodLengthOT').value = S.periodLengths.OT;
  document.getElementById('periodLength').value = S.periodLength;
  
  updateVideoTimingPreview();
  updatePeriodLengthIndicator();
}

function renderVideoTimeouts() {
  const list = document.getElementById('vtTimeoutsList');
  if (!S.videoTiming.timeouts || S.videoTiming.timeouts.length === 0) {
    list.innerHTML = '<div style="font-size:9px;color:var(--muted);text-align:center;padding:8px;">No timeouts added</div>';
    return;
  }
  
  list.innerHTML = S.videoTiming.timeouts.map((t, i) => `
    <div style="display:flex;justify-content:space-between;align-items:center;padding:4px;background:var(--panel);border-radius:2px;margin:2px 0;font-size:10px;">
      <span>P${t.period} @ ${t.gameTime} - ${t.duration}s</span>
      <button class="btn-sm" onclick="removeVideoTimeout(${i})" style="padding:1px 4px;font-size:8px;">‚úï</button>
    </div>
  `).join('');
}

function addVideoTimeout() {
  const period = document.getElementById('vtNewTimeoutPeriod').value;
  const gameTime = document.getElementById('vtNewTimeoutTime').value;
  const duration = parseInt(document.getElementById('vtNewTimeoutDuration').value) || 60;
  
  if (!gameTime) {
    toast('Enter game time', 'error');
    return;
  }
  
  if (!S.videoTiming.timeouts) S.videoTiming.timeouts = [];
  S.videoTiming.timeouts.push({ period, gameTime, duration });
  
  // Sort by period then time
  S.videoTiming.timeouts.sort((a, b) => {
    if (a.period !== b.period) return a.period - b.period;
    return b.gameTime.localeCompare(a.gameTime); // Higher time = earlier in period
  });
  
  renderVideoTimeouts();
  updateVideoTimingPreview();
  
  // Clear inputs
  document.getElementById('vtNewTimeoutTime').value = '';
}

function removeVideoTimeout(idx) {
  S.videoTiming.timeouts.splice(idx, 1);
  renderVideoTimeouts();
  updateVideoTimingPreview();
}

function saveVideoTiming() {
  S.videoTiming.videoStartOffset = parseInt(document.getElementById('vtVideoStartOffset').value) || 0;
  
  // Save per-period lengths
  S.periodLengths = {
    1: parseInt(document.getElementById('vtPeriodLength1').value) || 18,
    2: parseInt(document.getElementById('vtPeriodLength2').value) || 18,
    3: parseInt(document.getElementById('vtPeriodLength3').value) || 18,
    OT: parseInt(document.getElementById('vtPeriodLengthOT').value) || 5
  };
  S.periodLength = S.periodLengths[1];
  
  S.videoTiming.intermission1 = parseInt(document.getElementById('vtIntermission1').value) || 900;
  S.videoTiming.intermission2 = parseInt(document.getElementById('vtIntermission2').value) || 900;
  S.videoTiming.intermission3 = parseInt(document.getElementById('vtIntermission3').value) || 300;
  S.videoTiming.youtubeUrl = document.getElementById('vtYoutubeUrl').value || '';
  
  // Sync to Settings modal
  updatePeriodLengthsUI();
  updatePeriodLengthIndicator();
  
  saveGameData();
  toast('Video timing saved', 'success');
  closeVideoTimingModal();
}

function updateVideoTimingPreview() {
  // Get per-period lengths
  const p1Sec = (parseInt(document.getElementById('vtPeriodLength1')?.value) || 18) * 60;
  const p2Sec = (parseInt(document.getElementById('vtPeriodLength2')?.value) || 18) * 60;
  const p3Sec = (parseInt(document.getElementById('vtPeriodLength3')?.value) || 18) * 60;
  const otSec = (parseInt(document.getElementById('vtPeriodLengthOT')?.value) || 5) * 60;
  
  const int1 = parseInt(document.getElementById('vtIntermission1').value) || 0;
  const int2 = parseInt(document.getElementById('vtIntermission2').value) || 0;
  const int3 = parseInt(document.getElementById('vtIntermission3').value) || 0;
  const offset = parseInt(document.getElementById('vtVideoStartOffset').value) || 0;
  
  const p1Start = offset;
  const p1End = p1Start + p1Sec;
  const p2Start = p1End + int1;
  const p2End = p2Start + p2Sec;
  const p3Start = p2End + int2;
  const p3End = p3Start + p3Sec;
  const otStart = p3End + int3;
  const otEnd = otStart + otSec;
  
  const fmt = (s) => `${Math.floor(s/60)}:${String(s%60).padStart(2,'0')}`;
  
  document.getElementById('vtPreviewP1Start').textContent = fmt(p1Start);
  document.getElementById('vtPreviewP1End').textContent = fmt(p1End);
  document.getElementById('vtPreviewP2Start').textContent = fmt(p2Start);
  document.getElementById('vtPreviewP2End').textContent = fmt(p2End);
  document.getElementById('vtPreviewP3Start').textContent = fmt(p3Start);
  document.getElementById('vtPreviewP3End').textContent = fmt(p3End);
  document.getElementById('vtPreviewOTStart').textContent = fmt(otStart);
  document.getElementById('vtPreviewOTEnd').textContent = fmt(otEnd);
}

/**
 * Calculate running video time for an event
 * @param {number} period - Period number (1, 2, 3, OT)
 * @param {string} gameTime - Game clock time (e.g., "15:30")
 * @returns {number} - Seconds from video start
 */
function calculateRunningVideoTime(period, gameTime) {
  // v23.5: Use per-period lengths
  const currentPeriodSec = getPeriodLengthSeconds(period);
  const int1 = S.videoTiming.intermission1 || 0;
  const int2 = S.videoTiming.intermission2 || 0;
  const int3 = S.videoTiming.intermission3 || 0;
  const offset = S.videoTiming.videoStartOffset || 0;
  
  // Parse game time (MM:SS) - time remaining in period
  let timeRemaining = 0;
  if (gameTime) {
    const parts = gameTime.split(':');
    timeRemaining = parseInt(parts[0] || 0) * 60 + parseInt(parts[1] || 0);
  }
  
  // Calculate elapsed time in current period
  const elapsedInPeriod = currentPeriodSec - timeRemaining;
  
  // Calculate base running time (without timeouts)
  let runningTime = offset;
  
  if (period >= 1) {
    runningTime += elapsedInPeriod;
  }
  if (period >= 2) {
    runningTime += int1 + getPeriodLengthSeconds(1); // Full P1
  }
  if (period >= 3) {
    runningTime += int2 + getPeriodLengthSeconds(2); // Full P2
  }
  if (period >= 4) { // OT
    runningTime += int3 + getPeriodLengthSeconds(3); // Full P3
  }
  
  // Add timeout durations that occurred before this point
  const timeouts = S.videoTiming.timeouts || [];
  timeouts.forEach(t => {
    const tPeriod = t.period === 'OT' ? 4 : parseInt(t.period);
    if (tPeriod < period) {
      runningTime += t.duration;
    } else if (tPeriod === period) {
      // Timeout in same period - only add if it happened before current time
      // Higher gameTime = earlier in period
      if (t.gameTime > gameTime) {
        runningTime += t.duration;
      }
    }
  });
  
  return runningTime;
}

// ============================================================
// v23.4: VIDEO PLAYER CONTROLS
// ============================================================

// Video state
let currentVideoSource = null; // 'youtube' or 'local'
let ytPlayer = null; // YouTube player instance
let videoSyncEnabled = true;
let currentVideoZoom = 1;
let videoSources = []; // Multiple video sources with hotkeys

/**
 * Load a video from URL (YouTube or direct file)
 */
function loadVideo(url, name = 'Video') {
  if (!url) {
    toast('Enter a video URL', 'warning');
    return;
  }
  
  const youtubeId = extractYouTubeId(url);
  
  if (youtubeId) {
    loadYouTubeVideo(youtubeId);
    currentVideoSource = 'youtube';
  } else {
    loadLocalVideo(url);
    currentVideoSource = 'local';
  }
  
  // Hide placeholder
  document.getElementById('videoPlaceholder').style.display = 'none';
  
  toast(`Loaded: ${name}`, 'success');
}

/**
 * Extract YouTube video ID from URL
 */
function extractYouTubeId(url) {
  const patterns = [
    /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})/,
    /^([a-zA-Z0-9_-]{11})$/ // Direct ID
  ];
  
  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) return match[1];
  }
  return null;
}

/**
 * Load YouTube video using IFrame API
 */
function loadYouTubeVideo(videoId) {
  const container = document.getElementById('youtubePlayer');
  container.style.display = 'block';
  document.getElementById('localVideoPlayer').style.display = 'none';
  
  // Load YouTube API if not already loaded
  if (!window.YT) {
    const tag = document.createElement('script');
    tag.src = 'https://www.youtube.com/iframe_api';
    document.head.appendChild(tag);
    
    window.onYouTubeIframeAPIReady = () => {
      createYouTubePlayer(videoId);
    };
  } else {
    createYouTubePlayer(videoId);
  }
}

/**
 * Create YouTube player instance
 */
function createYouTubePlayer(videoId) {
  // Destroy existing player if any
  if (ytPlayer && ytPlayer.destroy) {
    ytPlayer.destroy();
  }
  
  const container = document.getElementById('youtubePlayer');
  container.innerHTML = '<div id="ytPlayerFrame"></div>';
  
  ytPlayer = new YT.Player('ytPlayerFrame', {
    height: '100%',
    width: '100%',
    videoId: videoId,
    playerVars: {
      'playsinline': 1,
      'enablejsapi': 1,
      'modestbranding': 1,
      'rel': 0
    },
    events: {
      'onReady': onYouTubePlayerReady,
      'onStateChange': onYouTubePlayerStateChange
    }
  });
}

function onYouTubePlayerReady(event) {
  console.log('YouTube player ready');
  startVideoTimeUpdate();
}

function onYouTubePlayerStateChange(event) {
  const playBtn = document.getElementById('videoPlayBtn');
  if (event.data === YT.PlayerState.PLAYING) {
    playBtn.textContent = '‚è∏';
  } else {
    playBtn.textContent = '‚ñ∂';
  }
}

/**
 * Load local/direct video file
 */
function loadLocalVideo(url) {
  const video = document.getElementById('localVideoPlayer');
  video.style.display = 'block';
  document.getElementById('youtubePlayer').style.display = 'none';
  
  video.src = url;
  video.load();
  
  video.onloadedmetadata = () => {
    console.log('Local video loaded, duration:', video.duration);
    startVideoTimeUpdate();
  };
  
  video.onplay = () => document.getElementById('videoPlayBtn').textContent = '‚è∏';
  video.onpause = () => document.getElementById('videoPlayBtn').textContent = '‚ñ∂';
}

/**
 * Load video from file input
 */
function loadVideoFromFile(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  const url = URL.createObjectURL(file);
  loadLocalVideo(url);
  toast(`Loaded: ${file.name}`, 'success');
}

/**
 * Play/Pause video
 */
function videoPlayPause() {
  if (currentVideoSource === 'youtube' && ytPlayer) {
    const state = ytPlayer.getPlayerState();
    if (state === YT.PlayerState.PLAYING) {
      ytPlayer.pauseVideo();
    } else {
      ytPlayer.playVideo();
    }
  } else if (currentVideoSource === 'local') {
    const video = document.getElementById('localVideoPlayer');
    if (video.paused) {
      video.play();
    } else {
      video.pause();
    }
  }
}

/**
 * Seek video by delta seconds
 */
function videoSeek(deltaSec) {
  if (currentVideoSource === 'youtube' && ytPlayer) {
    const current = ytPlayer.getCurrentTime();
    ytPlayer.seekTo(current + deltaSec, true);
  } else if (currentVideoSource === 'local') {
    const video = document.getElementById('localVideoPlayer');
    video.currentTime = Math.max(0, video.currentTime + deltaSec);
  }
}

/**
 * Seek to specific time in seconds
 */
function videoSeekTo(timeSec) {
  if (currentVideoSource === 'youtube' && ytPlayer) {
    ytPlayer.seekTo(timeSec, true);
  } else if (currentVideoSource === 'local') {
    const video = document.getElementById('localVideoPlayer');
    video.currentTime = timeSec;
  }
}

/**
 * Frame step (approximate - 1/30 sec)
 */
function videoFrameStep(frames) {
  const frameDuration = 1 / 30; // Assume 30fps
  videoSeek(frames * frameDuration);
}

/**
 * Set video playback speed
 */
function setVideoSpeed(speed) {
  if (currentVideoSource === 'youtube' && ytPlayer) {
    ytPlayer.setPlaybackRate(speed);
  } else if (currentVideoSource === 'local') {
    const video = document.getElementById('localVideoPlayer');
    video.playbackRate = speed;
  }
  
  // Update UI
  document.querySelectorAll('.speed-btn').forEach(btn => {
    btn.classList.toggle('active', parseFloat(btn.dataset.speed) === speed);
  });
  
  toast(`Speed: ${speed}x`, 'info');
}

/**
 * Get current video playback speed
 */
function getVideoSpeed() {
  if (currentVideoSource === 'youtube' && ytPlayer && ytPlayer.getPlaybackRate) {
    return ytPlayer.getPlaybackRate();
  } else if (currentVideoSource === 'local') {
    return document.getElementById('localVideoPlayer').playbackRate;
  }
  return 1;
}

/**
 * Toggle video section visibility
 */
function toggleVideoSection() {
  const section = document.getElementById('videoSection');
  const toggleBar = document.getElementById('videoToggleBar');
  
  if (section.style.display === 'none') {
    section.style.display = 'block';
    toggleBar.style.display = 'none';
  } else {
    section.style.display = 'none';
    toggleBar.style.display = 'flex';
  }
}

/**
 * Show video section
 */
function showVideoSection() {
  document.getElementById('videoSection').style.display = 'block';
  document.getElementById('videoToggleBar').style.display = 'none';
}

/**
 * Get current video time in seconds
 */
function getVideoCurrentTime() {
  if (currentVideoSource === 'youtube' && ytPlayer && ytPlayer.getCurrentTime) {
    return ytPlayer.getCurrentTime();
  } else if (currentVideoSource === 'local') {
    return document.getElementById('localVideoPlayer').currentTime;
  }
  return 0;
}

/**
 * Get video duration
 */
function getVideoDuration() {
  if (currentVideoSource === 'youtube' && ytPlayer && ytPlayer.getDuration) {
    return ytPlayer.getDuration();
  } else if (currentVideoSource === 'local') {
    return document.getElementById('localVideoPlayer').duration || 0;
  }
  return 0;
}

/**
 * Update video time display continuously
 */
function startVideoTimeUpdate() {
  setInterval(() => {
    const currentTime = getVideoCurrentTime();
    const duration = getVideoDuration();
    
    // Format time
    const formatTime = (sec) => {
      const h = Math.floor(sec / 3600);
      const m = Math.floor((sec % 3600) / 60);
      const s = Math.floor(sec % 60);
      return h > 0 
        ? `${h}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`
        : `${m}:${String(s).padStart(2,'0')}`;
    };
    
    // Update displays
    const videoTimeEl = document.getElementById('videoTime');
    if (videoTimeEl) {
      videoTimeEl.textContent = `${formatTime(currentTime)} / ${formatTime(duration)}`;
    }
    
    const miniTimeEl = document.getElementById('videoMiniTime');
    if (miniTimeEl) {
      miniTimeEl.textContent = formatTime(currentTime);
    }
    
    // Calculate and display game clock time
    if (videoSyncEnabled) {
      const gameTime = calculateGameTimeFromVideo(currentTime);
      const gameTimeEl = document.getElementById('gameTimeFromVideo');
      if (gameTimeEl && gameTime) {
        gameTimeEl.textContent = `P${gameTime.period} ${gameTime.clock}`;
      }
    }
  }, 250);
}

/**
 * Calculate game clock from video time
 */
function calculateGameTimeFromVideo(videoSec) {
  const offset = S.videoTiming?.videoStartOffset || 0;
  const int1 = S.videoTiming?.intermission1 || 900;
  const int2 = S.videoTiming?.intermission2 || 900;
  const int3 = S.videoTiming?.intermission3 || 300;
  
  // Use game markers if set
  const markers = S.videoPlayer?.gameMarkers || {};
  
  // v23.5: Get per-period lengths
  const p1Sec = getPeriodLengthSeconds(1);
  const p2Sec = getPeriodLengthSeconds(2);
  const p3Sec = getPeriodLengthSeconds(3);
  const otSec = getPeriodLengthSeconds('OT');
  
  // Determine which period we're in
  let period = 1;
  let periodSec = p1Sec;
  let periodStartVideo = markers.P1Start || offset;
  let periodEndVideo = markers.P1End || (offset + p1Sec);
  
  if (markers.P2Start && videoSec >= markers.P2Start) {
    period = 2;
    periodSec = p2Sec;
    periodStartVideo = markers.P2Start;
    periodEndVideo = markers.P2End || (markers.P2Start + p2Sec);
  }
  if (markers.P3Start && videoSec >= markers.P3Start) {
    period = 3;
    periodSec = p3Sec;
    periodStartVideo = markers.P3Start;
    periodEndVideo = markers.P3End || (markers.P3Start + p3Sec);
  }
  if (markers.OTStart && videoSec >= markers.OTStart) {
    period = 4;
    periodSec = otSec;
    periodStartVideo = markers.OTStart;
    periodEndVideo = markers.OTEnd || (markers.OTStart + otSec);
  }
  
  // Calculate time elapsed in current period
  const elapsedInPeriod = videoSec - periodStartVideo;
  const timeRemaining = Math.max(0, periodSec - elapsedInPeriod);
  
  const min = Math.floor(timeRemaining / 60);
  const sec = Math.floor(timeRemaining % 60);
  
  return {
    period: period === 4 ? 'OT' : period,
    clock: `${min}:${String(sec).padStart(2, '0')}`,
    elapsed: elapsedInPeriod
  };
}

/**
 * Capture start time from video to event/shift
 */
function captureStartTime() {
  const videoTime = getVideoCurrentTime();
  const gameTime = calculateGameTimeFromVideo(videoTime);
  
  if (gameTime) {
    document.getElementById('evtStartTime').value = gameTime.clock;
    
    // Also set period if different
    if (gameTime.period && gameTime.period !== S.period) {
      toast(`Note: Video is in P${gameTime.period}, tracker in P${S.period}`, 'warning');
    }
    
    toast(`Start: ${gameTime.clock} (P${gameTime.period})`, 'success');
  }
}

/**
 * Capture end time from video to event/shift
 */
function captureEndTime() {
  const videoTime = getVideoCurrentTime();
  const gameTime = calculateGameTimeFromVideo(videoTime);
  
  if (gameTime) {
    document.getElementById('evtEndTime').value = gameTime.clock;
    toast(`End: ${gameTime.clock} (P${gameTime.period})`, 'success');
  }
}

/**
 * Toggle video auto-sync
 */
function toggleVideoAutoSync() {
  videoSyncEnabled = document.getElementById('videoAutoSync').checked;
}

/**
 * Set game marker from current video position
 */
function setGameMarker(markerName) {
  const videoTime = getVideoCurrentTime();
  
  if (!S.videoPlayer) S.videoPlayer = { sources: [], gameMarkers: {} };
  if (!S.videoPlayer.gameMarkers) S.videoPlayer.gameMarkers = {};
  
  S.videoPlayer.gameMarkers[markerName] = videoTime;
  
  updateMarkerStatus();
  saveGameData();
  
  const formattedTime = formatVideoTime(videoTime);
  toast(`Marker set: ${markerName} @ ${formattedTime}`, 'success');
}

function formatVideoTime(sec) {
  const m = Math.floor(sec / 60);
  const s = Math.floor(sec % 60);
  return `${m}:${String(s).padStart(2, '0')}`;
}

/**
 * Update marker status display
 */
function updateMarkerStatus() {
  const markers = S.videoPlayer?.gameMarkers || {};
  const count = Object.keys(markers).length;
  
  const statusEl = document.getElementById('markerStatus');
  if (statusEl) {
    if (count === 0) {
      statusEl.textContent = 'No markers set';
    } else {
      const markerList = Object.entries(markers)
        .map(([k, v]) => `${k}:${formatVideoTime(v)}`)
        .join(' | ');
      statusEl.textContent = markerList;
    }
  }
}

/**
 * Jump to a specific game marker
 */
function jumpToMarker(markerName) {
  const time = S.videoPlayer?.gameMarkers?.[markerName];
  if (time !== undefined) {
    videoSeekTo(time);
    toast(`Jumped to ${markerName}`, 'info');
  }
}

/**
 * Add stoppage marker at current position
 */
function addStoppageMarker() {
  const videoTime = getVideoCurrentTime();
  const gameTime = calculateGameTimeFromVideo(videoTime);
  
  const name = prompt('Stoppage name (e.g., "Timeout", "Injury"):', 'Stoppage');
  if (!name) return;
  
  if (!S.videoTiming.timeouts) S.videoTiming.timeouts = [];
  
  S.videoTiming.timeouts.push({
    period: gameTime?.period || S.period,
    gameTime: gameTime?.clock || '10:00',
    duration: 60, // Default 1 minute
    name: name,
    videoTime: videoTime
  });
  
  saveGameData();
  toast(`Added stoppage: ${name}`, 'success');
}

// ============================================================
// v23.4: VIDEO ZOOM
// ============================================================

/**
 * Set video zoom level
 */
function setVideoZoom(zoom) {
  currentVideoZoom = zoom;
  
  const container = document.getElementById('videoPlayerContainer');
  const videoEl = currentVideoSource === 'youtube' 
    ? document.getElementById('youtubePlayer')
    : document.getElementById('localVideoPlayer');
  
  if (videoEl) {
    videoEl.style.transform = `scale(${zoom})`;
    videoEl.style.transformOrigin = 'center center';
  }
  
  toast(`Zoom: ${Math.round(zoom * 100)}%`, 'info');
}

/**
 * Zoom in
 */
function videoZoomIn() {
  setVideoZoom(Math.min(currentVideoZoom + 0.25, 3));
}

/**
 * Zoom out
 */
function videoZoomOut() {
  setVideoZoom(Math.max(currentVideoZoom - 0.25, 0.5));
}

/**
 * Reset zoom
 */
function videoZoomReset() {
  setVideoZoom(1);
}

// ============================================================
// v23.4: VIDEO SOURCE SWITCHING
// ============================================================

/**
 * Add a video source with hotkey
 */
function addVideoSource(name, url, hotkey) {
  const source = { 
    id: Date.now(), 
    name, 
    url, 
    hotkey,
    type: extractYouTubeId(url) ? 'youtube' : 'local'
  };
  videoSources.push(source);
  
  updateVideoSourcesUI();
  saveVideoSources();
  toast(`Added source: ${name} (${hotkey})`, 'success');
  
  return source;
}

/**
 * Switch to video source by hotkey
 */
function switchVideoByHotkey(key) {
  const source = videoSources.find(s => s.hotkey === key);
  if (source) {
    loadVideo(source.url, source.name);
    setActiveVideoSource(source.id);
    toast(`Switched to: ${source.name} (Ctrl+${key})`, 'info');
  }
}

/**
 * Switch video source from dropdown
 */
function switchVideoSource() {
  const select = document.getElementById('videoSourceSelect');
  const sourceId = select.value;
  
  if (!sourceId) return;
  
  const source = videoSources.find(s => s.id == sourceId);
  if (source) {
    loadVideo(source.url, source.name);
    setActiveVideoSource(source.id);
  }
}

/**
 * Set active video source indicator
 */
function setActiveVideoSource(sourceId) {
  // Update dropdown
  const select = document.getElementById('videoSourceSelect');
  if (select) select.value = sourceId;
  
  // Store active source
  S.activeVideoSourceId = sourceId;
}

/**
 * Update video sources dropdown
 */
function updateVideoSourcesUI() {
  const select = document.getElementById('videoSourceSelect');
  if (!select) return;
  
  select.innerHTML = '<option value="">-- Sources --</option>' +
    videoSources.map(s => 
      `<option value="${s.id}">${s.name} (${s.hotkey || '-'})</option>`
    ).join('');
  
  // Also update hotkey bar
  renderVideoHotkeyBar();
}

/**
 * Render video hotkey bar showing quick-switch buttons
 */
function renderVideoHotkeyBar() {
  const bar = document.getElementById('videoHotkeyBar');
  if (!bar) return;
  
  if (videoSources.length === 0) {
    bar.innerHTML = '<span style="font-size:8px;color:var(--muted);">No sources</span>';
    return;
  }
  
  bar.innerHTML = videoSources.map(s => {
    const isActive = S.activeVideoSourceId === s.id;
    const bg = isActive ? 'var(--accent)' : 'var(--panel)';
    const color = isActive ? '#000' : 'var(--text)';
    return `<button class="btn-sm" onclick="switchVideoByHotkey('${s.hotkey}')" 
      title="${s.name} (Ctrl+${s.hotkey})" 
      style="min-width:20px;padding:2px 4px;font-size:9px;font-weight:bold;background:${bg};color:${color};">
      ${s.hotkey}
    </button>`;
  }).join('');
}

/**
 * Show video sources manager modal
 */
function showVideoSourcesManager() {
  const sourcesHtml = videoSources.length === 0 
    ? '<p style="color:var(--muted);font-size:11px;text-align:center;">No video sources added yet</p>'
    : `<table style="width:100%;font-size:11px;border-collapse:collapse;">
        <thead><tr style="background:var(--panel);"><th>Key</th><th>Name</th><th>Type</th><th></th></tr></thead>
        <tbody>
          ${videoSources.map(s => `
            <tr>
              <td style="padding:4px;text-align:center;"><kbd>${s.hotkey || '-'}</kbd></td>
              <td style="padding:4px;">${s.name}</td>
              <td style="padding:4px;">${s.type || 'local'}</td>
              <td style="padding:4px;">
                <button class="btn-sm btn-danger" onclick="removeVideoSource(${s.id})" style="padding:1px 4px;font-size:8px;">‚úï</button>
              </td>
            </tr>
          `).join('')}
        </tbody>
      </table>`;
  
  const html = `
    <h3>üé¨ Video Sources</h3>
    <p style="font-size:10px;color:var(--muted);margin-bottom:10px;">
      Press Ctrl+hotkey (Ctrl+1 to Ctrl+9) to instantly switch between video feeds
    </p>
    <div style="max-height:200px;overflow-y:auto;margin-bottom:15px;">
      ${sourcesHtml}
    </div>
    <div style="border-top:1px solid var(--border);padding-top:10px;">
      <button class="btn-sm btn-primary" onclick="closeModal();showAddVideoModal();" style="width:100%;">+ Add New Source</button>
    </div>
    <div style="margin-top:10px;text-align:right;">
      <button class="btn-sm" onclick="closeModal()">Close</button>
    </div>
  `;
  
  showModal(html);
}

/**
 * Remove a video source
 */
function removeVideoSource(id) {
  videoSources = videoSources.filter(s => s.id !== id);
  updateVideoSourcesUI();
  saveVideoSources();
  toast('Video source removed', 'info');
  
  // Refresh modal if open
  if (document.getElementById('genericModal').classList.contains('show')) {
    showVideoSourcesManager();
  }
}

/**
 * Show add video modal
 */
function showAddVideoModal() {
  const html = `
    <h3>üé¨ Add Video Source</h3>
    <div class="form-group" style="margin-bottom:8px;">
      <label>Video Name</label>
      <input type="text" id="addVideoName" placeholder="e.g., Main Camera, Overhead" style="width:100%;">
    </div>
    <div class="form-group" style="margin-bottom:8px;">
      <label>URL or YouTube Link</label>
      <input type="text" id="addVideoUrl" placeholder="https://youtube.com/watch?v=... or video file URL" style="width:100%;">
    </div>
    <div style="margin-bottom:8px;">
      <label style="font-size:10px;">Or load local file:</label>
      <input type="file" id="addVideoFile" accept="video/*" onchange="handleVideoFileSelect(event)" style="font-size:10px;">
    </div>
    <div class="form-group" style="margin-bottom:8px;">
      <label>Hotkey (1-9)</label>
      <input type="text" id="addVideoHotkey" placeholder="e.g., 1" maxlength="1" style="width:50px;">
    </div>
    <div class="modal-actions">
      <button class="btn-primary" onclick="confirmAddVideo()">Add Video</button>
      <button onclick="closeModal()">Cancel</button>
    </div>
  `;
  
  showModal(html);
}

function handleVideoFileSelect(event) {
  const file = event.target.files[0];
  if (file) {
    document.getElementById('addVideoUrl').value = URL.createObjectURL(file);
    if (!document.getElementById('addVideoName').value) {
      document.getElementById('addVideoName').value = file.name;
    }
  }
}

function confirmAddVideo() {
  const name = document.getElementById('addVideoName').value || 'Video';
  const url = document.getElementById('addVideoUrl').value;
  const hotkey = document.getElementById('addVideoHotkey').value;
  
  if (!url) {
    toast('Enter a video URL or select a file', 'warning');
    return;
  }
  
  // Add to sources list
  const sourceId = Date.now();
  const source = { 
    id: sourceId, 
    name, 
    url, 
    hotkey: hotkey || null,
    type: extractYouTubeId(url) ? 'youtube' : 'local'
  };
  videoSources.push(source);
  
  // Load the video
  loadVideo(url, name);
  setActiveVideoSource(sourceId);
  
  // Update UI
  updateVideoSourcesUI();
  saveVideoSources();
  
  closeModal();
  showVideoSection();
  
  toast(`Added: ${name}${hotkey ? ` (Ctrl+${hotkey} to switch)` : ''}`, 'success');
}

/**
 * Save video sources to localStorage
 */
function saveVideoSources() {
  localStorage.setItem('benchsight_videoSources', JSON.stringify(videoSources));
}

/**
 * Load video sources from localStorage
 */
function loadVideoSources() {
  try {
    const saved = localStorage.getItem('benchsight_videoSources');
    if (saved) {
      videoSources = JSON.parse(saved);
      updateVideoSourcesUI();
    }
  } catch (e) {
    console.error('Error loading video sources:', e);
  }
}

// ============================================================
// v23.4: VIDEO SCRUB BAR
// ============================================================

/**
 * Render video scrub bar with event markers
 */
function renderVideoScrubBar() {
  const container = document.getElementById('videoScrubBar');
  if (!container) return;
  
  const duration = getVideoDuration();
  if (!duration) return;
  
  // Get events and convert to video times
  const eventMarkers = S.events.map(evt => {
    const videoTime = calculateRunningVideoTime(
      evt.period === 'OT' ? 4 : parseInt(evt.period) || 1,
      evt.start_time
    );
    return {
      time: videoTime,
      type: evt.type,
      idx: evt.idx
    };
  }).filter(m => m.time <= duration);
  
  // Render scrub bar with markers
  container.innerHTML = `
    <div style="position:relative;height:20px;background:var(--panel);border-radius:3px;cursor:pointer;" onclick="handleScrubClick(event)">
      <div id="scrubProgress" style="position:absolute;height:100%;background:var(--accent);opacity:0.3;border-radius:3px;width:0%;"></div>
      ${eventMarkers.map(m => {
        const pct = (m.time / duration) * 100;
        const color = m.type === 'Goal' ? '#22c55e' : m.type === 'Shot' ? '#ef4444' : '#3b82f6';
        return `<div style="position:absolute;left:${pct}%;width:3px;height:100%;background:${color};" title="${m.type} #${m.idx}"></div>`;
      }).join('')}
    </div>
  `;
}

function handleScrubClick(event) {
  const rect = event.currentTarget.getBoundingClientRect();
  const pct = (event.clientX - rect.left) / rect.width;
  const duration = getVideoDuration();
  videoSeekTo(pct * duration);
}

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  // Don't trigger if typing in input (unless arrow keys in edit modal)
  const inInput = e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA';
  
  // Arrow keys work in modals for navigation
  if (document.getElementById('editModal').classList.contains('show')) {
    if (e.key === 'ArrowLeft') { navEditEvent(-1); e.preventDefault(); return; }
    if (e.key === 'ArrowRight') { navEditEvent(1); e.preventDefault(); return; }
  }
  if (document.getElementById('editShiftModal').classList.contains('show')) {
    if (e.key === 'ArrowLeft') { navEditShift(-1); e.preventDefault(); return; }
    if (e.key === 'ArrowRight') { navEditShift(1); e.preventDefault(); return; }
  }
  
  if (inInput) return;
  
  switch(e.key) {
    case '?': openHelp(); break;
    case 'Escape': 
      closeSettings(); closeHelp(); 
      document.querySelectorAll('.overlay.show').forEach(m => m.classList.remove('show'));
      break;
    
    // Event type hotkeys
    case 'f': case 'F': setEvtType('Faceoff'); break;
    case 's': case 'S': setEvtType('Shot'); break;
    case 'p': case 'P': setEvtType('Pass'); break;
    case 'g': case 'G': setEvtType('Goal'); break;
    case 't': case 'T': setEvtType('Turnover'); break;
    case 'z': case 'Z': setEvtType('Zone_Entry_Exit'); break;
    case 'n': case 'N': setEvtType('Penalty'); break;
    case 'x': case 'X': setEvtType('Stoppage'); break;
    case 'o': case 'O': setEvtType('Possession'); break;
    case 'v': case 'V': setEvtType('Save'); break;
    case 'r': case 'R': setEvtType('Rebound'); break;
    case 'd': case 'D': setEvtType('DeadIce'); break;
    
    // Quick actions
    case 'h': case 'H': document.getElementById('evtHighlight').checked = !document.getElementById('evtHighlight').checked; break;
    case 'l': case 'L': logEvent(); break;  // Log current event
    case 'Enter': logEvent(); break;  // Also log with Enter
    
    // Team toggle - removed 1/2, now use H/A (v16.06)
    // 1-6 handled in setupKeys() for player selection
    
    // Zone
    case 'q': setZone('o'); break;  // Offensive
    case 'w': setZone('n'); break;  // Neutral
    case 'e': setZone('d'); break;  // Defensive
    
    // Success
    case 'y': case 'Y': document.getElementById('evtSuccess').value = 's'; break;
    case 'u': case 'U': document.getElementById('evtSuccess').value = 'u'; break;
    
    // Period
    case '!': setPeriod(1); break;
    case '@': setPeriod(2); break;
    case '#': setPeriod(3); break;
    case '$': setPeriod('OT'); break;
    
    // Undo XY
    case 'Backspace': undoLastXY(); break;
    
    // Shift actions
    case '[': logShift(); toast('Shift logged', 'success'); break;
    case ']': 
      document.getElementById('shiftStart').value = document.getElementById('clock').value;
      toast('Shift start set', 'info'); 
      break;
    
    // Edit last event
    case 'i': case 'I': 
      if (S.events.length > 0) editEvent(S.events.length - 1);
      break;
    
    // Quick nav
    case ',': if (S.events.length > 0) editEvent(0); break;  // First event
    case '.': if (S.events.length > 0) editEvent(S.events.length - 1); break;  // Last event
    
    // v23.4: Video controls
    case ' ': // Space = play/pause
      e.preventDefault();
      videoPlayPause();
      break;
    case 'ArrowLeft':
      e.preventDefault();
      videoSeek(e.shiftKey ? -10 : -1); // Shift+Left = -10s
      break;
    case 'ArrowRight':
      e.preventDefault();
      videoSeek(e.shiftKey ? 10 : 1); // Shift+Right = +10s
      break;
    case 'ArrowUp':
      e.preventDefault();
      setVideoSpeed(Math.min(2, (getVideoSpeed() || 1) + 0.25));
      break;
    case 'ArrowDown':
      e.preventDefault();
      setVideoSpeed(Math.max(0.25, (getVideoSpeed() || 1) - 0.25));
      break;
    case ';': // Frame back
      videoFrameStep(-1);
      break;
    case "'": // Frame forward
      videoFrameStep(1);
      break;
    case '+': case '=':
      videoZoomIn();
      break;
    case '-': case '_':
      videoZoomOut();
      break;
    case '0':
      videoZoomReset();
      break;
  }
  
  // Video source switching: Ctrl+1-9 (avoids conflict with player 1-6)
  if (!inInput && e.key >= '1' && e.key <= '9' && e.ctrlKey && !e.altKey) {
    e.preventDefault(); // Prevent browser tab switching
    switchVideoByHotkey(e.key);
  }
});

// ============================================================
// v23.5: WORKFLOW IMPROVEMENTS
// ============================================================

// --- 1. QUICK REPLAY (rewind 5s on pause) ---
let quickReplayEnabled = true;
let wasPlayingBeforePause = false;

function videoPlayPauseWithReplay() {
  const isPlaying = currentVideoSource === 'youtube' 
    ? (ytPlayer && ytPlayer.getPlayerState() === YT.PlayerState.PLAYING)
    : (currentVideoSource === 'local' && !document.getElementById('localVideoPlayer').paused);
  
  if (isPlaying && quickReplayEnabled) {
    // Pausing - rewind 5s for context
    videoSeek(-5);
  }
  videoPlayPause();
}

function toggleQuickReplay() {
  quickReplayEnabled = !quickReplayEnabled;
  toast(`Quick replay: ${quickReplayEnabled ? 'ON' : 'OFF'}`, 'info');
}

// --- 2. EVENT SUGGESTIONS ---
const EVENT_SUGGESTIONS = {
  'Goal': ['Faceoff'],
  'Shot': ['Save', 'Rebound', 'Goal'],
  'Save': ['Rebound', 'Possession', 'Pass'],
  'Rebound': ['Shot', 'Goal', 'Possession'],
  'Faceoff': ['Pass', 'Possession', 'Shot'],
  'Pass': ['Shot', 'Pass', 'Possession'],
  'Turnover': ['Possession', 'Shot', 'Pass'],
  'Zone_Entry_Exit': ['Pass', 'Shot', 'Possession'],
  'Possession': ['Pass', 'Shot', 'Zone_Entry_Exit'],
  'Penalty': ['Faceoff'],
  'Stoppage': ['Faceoff']
};

let suggestionsEnabled = true;

function getSuggestedEvents() {
  if (!suggestionsEnabled || S.events.length === 0) return [];
  
  const lastEvent = S.events[S.events.length - 1];
  return EVENT_SUGGESTIONS[lastEvent.type] || [];
}

function renderEventSuggestions() {
  const container = document.getElementById('eventSuggestions');
  if (!container) return;
  
  const suggestions = getSuggestedEvents();
  if (suggestions.length === 0) {
    container.innerHTML = '';
    return;
  }
  
  container.innerHTML = `
    <span style="font-size:8px;color:var(--muted);">Next:</span>
    ${suggestions.map(s => `
      <button class="btn-sm" onclick="setEvtType('${s}')" 
        style="padding:2px 6px;font-size:9px;background:var(--panel);border:1px dashed var(--accent);">
        ${s.replace('_', ' ').substring(0, 6)}
      </button>
    `).join('')}
  `;
}

function toggleSuggestions() {
  suggestionsEnabled = !suggestionsEnabled;
  toast(`Suggestions: ${suggestionsEnabled ? 'ON' : 'OFF'}`, 'info');
  renderEventSuggestions();
}

// --- 3. POSSESSION TRACKER ---
let possessionTeam = null;
let possessionStartTime = null;
let possessionTimers = { home: 0, away: 0 };
let possessionInterval = null;

function setPossession(team) {
  if (possessionTeam === team) {
    // Toggle off
    stopPossessionTimer();
    possessionTeam = null;
    updatePossessionDisplay();
    return;
  }
  
  // Stop current timer if any
  if (possessionTeam) {
    stopPossessionTimer();
  }
  
  // Start new possession
  possessionTeam = team;
  possessionStartTime = Date.now();
  startPossessionTimer();
  updatePossessionDisplay();
}

function startPossessionTimer() {
  if (possessionInterval) clearInterval(possessionInterval);
  possessionInterval = setInterval(() => {
    if (possessionTeam) {
      possessionTimers[possessionTeam] += 0.1;
      updatePossessionDisplay();
    }
  }, 100);
}

function stopPossessionTimer() {
  if (possessionInterval) {
    clearInterval(possessionInterval);
    possessionInterval = null;
  }
}

function resetPossessionTimers() {
  possessionTimers = { home: 0, away: 0 };
  possessionTeam = null;
  stopPossessionTimer();
  updatePossessionDisplay();
}

function updatePossessionDisplay() {
  const display = document.getElementById('possessionDisplay');
  if (!display) return;
  
  const total = possessionTimers.home + possessionTimers.away;
  const homePct = total > 0 ? Math.round((possessionTimers.home / total) * 100) : 50;
  const awayPct = 100 - homePct;
  
  const homeActive = possessionTeam === 'home' ? 'font-weight:bold;' : '';
  const awayActive = possessionTeam === 'away' ? 'font-weight:bold;' : '';
  
  display.innerHTML = `
    <span style="color:var(--home);${homeActive}">${homePct}%</span>
    <div style="flex:1;height:6px;background:var(--away);border-radius:3px;margin:0 4px;overflow:hidden;">
      <div style="width:${homePct}%;height:100%;background:var(--home);"></div>
    </div>
    <span style="color:var(--away);${awayActive}">${awayPct}%</span>
  `;
}

function formatPossessionTime(sec) {
  const m = Math.floor(sec / 60);
  const s = Math.floor(sec % 60);
  return `${m}:${String(s).padStart(2, '0')}`;
}

// --- 4. PENALTY BOX MANAGER ---
let activePenalties = [];

function addPenalty(team, playerNum, minutes, startTime) {
  const penalty = {
    id: Date.now(),
    team,
    playerNum,
    minutes: minutes || 2,
    startTime: startTime || document.getElementById('clock').value,
    startTimestamp: Date.now()
  };
  activePenalties.push(penalty);
  updatePenaltyBox();
  startPenaltyCountdown();
}

function removePenalty(id) {
  activePenalties = activePenalties.filter(p => p.id !== id);
  updatePenaltyBox();
}

function startPenaltyCountdown() {
  // Update every second
  setInterval(updatePenaltyBox, 1000);
}

function updatePenaltyBox() {
  const container = document.getElementById('penaltyBoxDisplay');
  if (!container) return;
  
  if (activePenalties.length === 0) {
    container.innerHTML = '<span style="font-size:9px;color:var(--muted);">No penalties</span>';
    return;
  }
  
  const now = Date.now();
  
  container.innerHTML = activePenalties.map(p => {
    const elapsed = (now - p.startTimestamp) / 1000;
    const remaining = Math.max(0, (p.minutes * 60) - elapsed);
    const remainMin = Math.floor(remaining / 60);
    const remainSec = Math.floor(remaining % 60);
    const color = p.team === 'home' ? 'var(--home)' : 'var(--away)';
    
    // Auto-remove expired penalties
    if (remaining <= 0) {
      setTimeout(() => removePenalty(p.id), 100);
      return '';
    }
    
    return `
      <div style="display:inline-flex;align-items:center;gap:4px;background:${color};color:#fff;padding:2px 6px;border-radius:3px;font-size:9px;">
        <span>#${p.playerNum}</span>
        <span style="font-family:monospace;">${remainMin}:${String(remainSec).padStart(2,'0')}</span>
        <button onclick="removePenalty(${p.id})" style="background:none;border:none;color:#fff;cursor:pointer;font-size:8px;">‚úï</button>
      </div>
    `;
  }).join('');
  
  // Update strength indicator
  updateStrengthFromPenalties();
}

function updateStrengthFromPenalties() {
  const homePens = activePenalties.filter(p => p.team === 'home').length;
  const awayPens = activePenalties.filter(p => p.team === 'away').length;
  
  const homeStr = 5 - Math.min(homePens, 2);
  const awayStr = 5 - Math.min(awayPens, 2);
  
  const strengthEl = document.getElementById('qsStrength');
  if (strengthEl) {
    strengthEl.textContent = `${homeStr}v${awayStr}`;
    strengthEl.className = 'value strength-indicator';
    if (homeStr > awayStr) strengthEl.classList.add('pp');
    else if (awayStr > homeStr) strengthEl.classList.add('pk');
    else strengthEl.classList.add('even');
  }
}

// --- 5. STICKY RECENT PLAYERS ---
let recentPlayers = [];
const MAX_RECENT_PLAYERS = 8;

function addToRecentPlayers(player) {
  if (!player || !player.num) return;
  
  // Remove if already exists
  recentPlayers = recentPlayers.filter(p => 
    !(p.num === player.num && p.team === player.team)
  );
  
  // Add to front
  recentPlayers.unshift({
    num: player.num,
    name: player.name,
    team: player.team
  });
  
  // Limit size
  if (recentPlayers.length > MAX_RECENT_PLAYERS) {
    recentPlayers = recentPlayers.slice(0, MAX_RECENT_PLAYERS);
  }
  
  renderRecentPlayers();
}

function renderRecentPlayers() {
  const container = document.getElementById('recentPlayersBar');
  if (!container) return;
  
  if (recentPlayers.length === 0) {
    container.innerHTML = '<span style="font-size:8px;color:var(--muted);">Recent players appear here</span>';
    return;
  }
  
  container.innerHTML = recentPlayers.map(p => {
    const color = p.team === 'home' ? 'var(--home)' : 'var(--away)';
    return `
      <button class="btn-sm" onclick="quickAddRecentPlayer(${p.num}, '${p.team}')"
        style="padding:2px 6px;font-size:9px;border-left:3px solid ${color};">
        #${p.num}
      </button>
    `;
  }).join('');
}

function quickAddRecentPlayer(num, team) {
  const roster = team === 'home' ? S.homeRoster : S.awayRoster;
  const player = roster.find(p => p.num == num);
  if (player) {
    addEventPlayer({ ...player, team });
    toast(`Added #${num}`, 'success');
  }
}

// --- 6. QUICK NOTES ---
function addQuickNote() {
  const note = prompt('Add note to current event:');
  if (note) {
    S.curr.note = note;
    toast('Note added', 'success');
  }
}

function showEventNotes(idx) {
  const evt = S.events[idx];
  if (evt && evt.note) {
    alert(`Event #${idx + 1} Note:\n${evt.note}`);
  }
}

// --- 7. MULTI-LEVEL UNDO ---
const undoStack = [];
const MAX_UNDO = 20;

function pushUndoState(action) {
  undoStack.push({
    action,
    events: JSON.parse(JSON.stringify(S.events)),
    shifts: JSON.parse(JSON.stringify(S.shifts)),
    timestamp: Date.now()
  });
  
  if (undoStack.length > MAX_UNDO) {
    undoStack.shift();
  }
  
  updateUndoButton();
}

function undo() {
  if (undoStack.length === 0) {
    toast('Nothing to undo', 'warning');
    return;
  }
  
  const state = undoStack.pop();
  S.events = state.events;
  S.shifts = state.shifts;
  
  renderEvents();
  renderShifts();
  updateQuickStats();
  
  toast(`Undone: ${state.action}`, 'info');
  updateUndoButton();
}

function updateUndoButton() {
  const btn = document.getElementById('undoBtn');
  if (btn) {
    btn.disabled = undoStack.length === 0;
    btn.title = undoStack.length > 0 
      ? `Undo: ${undoStack[undoStack.length - 1].action} (${undoStack.length})`
      : 'Nothing to undo';
  }
}

// --- 8. BATCH EDIT ---
let selectedEventIds = [];
let batchSelectMode = false;

function toggleBatchSelectMode() {
  batchSelectMode = !batchSelectMode;
  selectedEventIds = [];
  
  document.getElementById('batchSelectBtn').classList.toggle('active', batchSelectMode);
  
  if (batchSelectMode) {
    toast('Click events to select. Click again to apply changes.', 'info');
  } else {
    renderEvents();
  }
}

function toggleEventSelection(idx) {
  if (!batchSelectMode) return false;
  
  const eventIdx = selectedEventIds.indexOf(idx);
  if (eventIdx >= 0) {
    selectedEventIds.splice(eventIdx, 1);
  } else {
    selectedEventIds.push(idx);
  }
  
  renderEvents();
  return true; // Prevent normal click behavior
}

function applyBatchEdit() {
  if (selectedEventIds.length === 0) {
    toast('No events selected', 'warning');
    return;
  }
  
  const html = `
    <h3>üìù Batch Edit (${selectedEventIds.length} events)</h3>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
      <div class="form-group">
        <label>Zone</label>
        <select id="batchZone">
          <option value="">-- No change --</option>
          <option value="o">Offensive</option>
          <option value="n">Neutral</option>
          <option value="d">Defensive</option>
        </select>
      </div>
      <div class="form-group">
        <label>Success</label>
        <select id="batchSuccess">
          <option value="">-- No change --</option>
          <option value="s">Success</option>
          <option value="u">Unsuccess</option>
        </select>
      </div>
      <div class="form-group">
        <label>Highlight</label>
        <select id="batchHighlight">
          <option value="">-- No change --</option>
          <option value="true">Yes ‚≠ê</option>
          <option value="false">No</option>
        </select>
      </div>
      <div class="form-group">
        <label>Team</label>
        <select id="batchTeam">
          <option value="">-- No change --</option>
          <option value="home">Home</option>
          <option value="away">Away</option>
        </select>
      </div>
    </div>
    <div class="modal-actions">
      <button class="btn-primary" onclick="confirmBatchEdit()">Apply to ${selectedEventIds.length} Events</button>
      <button onclick="closeModal();toggleBatchSelectMode();">Cancel</button>
    </div>
  `;
  
  showModal(html);
}

function confirmBatchEdit() {
  const zone = document.getElementById('batchZone').value;
  const success = document.getElementById('batchSuccess').value;
  const highlight = document.getElementById('batchHighlight').value;
  const team = document.getElementById('batchTeam').value;
  
  pushUndoState('Batch edit');
  
  selectedEventIds.forEach(idx => {
    const evt = S.events.find(e => e.idx === idx);
    if (evt) {
      if (zone) evt.zone = zone;
      if (success) evt.success = success === 's';
      if (highlight !== '') evt.isHighlight = highlight === 'true';
      if (team) evt.team = team;
    }
  });
  
  closeModal();
  toggleBatchSelectMode();
  renderEvents();
  toast(`Updated ${selectedEventIds.length} events`, 'success');
}

// --- 9. GOAL REVIEW MODE ---
function startGoalReview(idx) {
  const evt = S.events.find(e => e.idx === idx);
  if (!evt || evt.type !== 'Goal') {
    toast('Select a goal event first', 'warning');
    return;
  }
  
  // Find video time for goal
  const videoTime = calculateRunningVideoTime(
    evt.period === 'OT' ? 4 : parseInt(evt.period) || 1,
    evt.start_time
  );
  
  // Seek to 10 seconds before goal
  videoSeekTo(Math.max(0, videoTime - 10));
  setVideoSpeed(0.5);
  
  toast('Goal review: Playing at 0.5x from 10s before', 'info');
  
  // Highlight related events
  highlightGoalSequence(idx);
}

function highlightGoalSequence(goalIdx) {
  // Find events within 30 seconds before goal
  const goal = S.events.find(e => e.idx === goalIdx);
  if (!goal) return;
  
  const goalTime = parseGameTime(goal.start_time);
  const relatedEvents = S.events.filter(e => {
    if (e.period !== goal.period) return false;
    const evtTime = parseGameTime(e.start_time);
    const diff = goalTime - evtTime; // Positive = before goal
    return diff >= 0 && diff <= 30;
  });
  
  // Mark these in UI
  relatedEvents.forEach(e => {
    const row = document.querySelector(`[data-evt-idx="${e.idx}"]`);
    if (row) row.classList.add('goal-sequence');
  });
}

function parseGameTime(timeStr) {
  if (!timeStr) return 0;
  const parts = timeStr.split(':');
  return parseInt(parts[0] || 0) * 60 + parseInt(parts[1] || 0);
}

// --- 10. KEYBOARD-ONLY XY MODE (WASD) ---
let keyboardXYMode = false;
let keyboardXYPosition = { x: 100, y: 42.5 }; // Center of rink

function toggleKeyboardXYMode() {
  keyboardXYMode = !keyboardXYMode;
  
  if (keyboardXYMode) {
    toast('Keyboard XY: WASD to move, Enter to place', 'info');
    showKeyboardCursor();
  } else {
    hideKeyboardCursor();
  }
}

function showKeyboardCursor() {
  let cursor = document.getElementById('keyboardXYCursor');
  if (!cursor) {
    cursor = document.createElement('div');
    cursor.id = 'keyboardXYCursor';
    cursor.style.cssText = `
      position: absolute;
      width: 12px;
      height: 12px;
      border: 2px solid var(--accent);
      border-radius: 50%;
      pointer-events: none;
      z-index: 100;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 8px var(--accent);
    `;
    document.querySelector('.rink-wrap').appendChild(cursor);
  }
  updateKeyboardCursor();
  cursor.style.display = 'block';
}

function hideKeyboardCursor() {
  const cursor = document.getElementById('keyboardXYCursor');
  if (cursor) cursor.style.display = 'none';
}

function updateKeyboardCursor() {
  const cursor = document.getElementById('keyboardXYCursor');
  if (!cursor) return;
  
  const svg = document.getElementById('rinkSvg');
  const rect = svg.getBoundingClientRect();
  
  // Convert SVG coords to screen coords
  const scaleX = rect.width / 200;
  const scaleY = rect.height / 85;
  
  cursor.style.left = `${keyboardXYPosition.x * scaleX}px`;
  cursor.style.top = `${keyboardXYPosition.y * scaleY}px`;
}

function moveKeyboardXY(dx, dy) {
  keyboardXYPosition.x = Math.max(0, Math.min(200, keyboardXYPosition.x + dx));
  keyboardXYPosition.y = Math.max(0, Math.min(85, keyboardXYPosition.y + dy));
  updateKeyboardCursor();
}

function placeKeyboardXY() {
  if (!keyboardXYMode) return;
  
  // Simulate click at current position
  handleXYPlacement(keyboardXYPosition.x, keyboardXYPosition.y);
  toast(`Placed at (${Math.round(keyboardXYPosition.x)}, ${Math.round(keyboardXYPosition.y)})`, 'success');
}

// Add keyboard handlers for WASD
document.addEventListener('keydown', (e) => {
  if (!keyboardXYMode) return;
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') return;
  
  const step = e.shiftKey ? 10 : 3;
  
  switch(e.key.toLowerCase()) {
    case 'w': moveKeyboardXY(0, -step); e.preventDefault(); break;
    case 'a': moveKeyboardXY(-step, 0); e.preventDefault(); break;
    case 's': moveKeyboardXY(0, step); e.preventDefault(); break;
    case 'd': moveKeyboardXY(step, 0); e.preventDefault(); break;
    case 'enter': placeKeyboardXY(); e.preventDefault(); break;
    case 'escape': toggleKeyboardXYMode(); e.preventDefault(); break;
  }
});

// --- 11. EVENT QUEUE (quick log, fill later) ---
let eventQueue = [];

function quickQueueEvent(type) {
  const videoTime = getVideoCurrentTime();
  const gameTime = calculateGameTimeFromVideo(videoTime);
  
  const evt = {
    id: Date.now(),
    type,
    period: gameTime?.period || S.period,
    start_time: gameTime?.clock || document.getElementById('clock').value,
    videoTime,
    team: document.getElementById('evtTeam').value,
    queued: true
  };
  
  eventQueue.push(evt);
  renderEventQueue();
  toast(`Queued: ${type}`, 'info');
}

function renderEventQueue() {
  const container = document.getElementById('eventQueueDisplay');
  if (!container) return;
  
  if (eventQueue.length === 0) {
    container.innerHTML = '';
    return;
  }
  
  container.innerHTML = `
    <div style="font-size:9px;color:var(--warn);margin-bottom:4px;">
      üìã Queue (${eventQueue.length}) - click to complete
    </div>
    ${eventQueue.map((e, i) => `
      <button class="btn-sm" onclick="processQueuedEvent(${i})"
        style="padding:2px 6px;font-size:9px;background:var(--warn);color:#000;margin:1px;">
        ${e.type.substring(0,4)} P${e.period} ${e.start_time}
      </button>
    `).join('')}
  `;
}

function processQueuedEvent(idx) {
  const evt = eventQueue[idx];
  if (!evt) return;
  
  // Load into current event form
  setEvtType(evt.type);
  document.getElementById('evtStartTime').value = evt.start_time;
  document.getElementById('evtTeam').value = evt.team;
  S.period = evt.period;
  document.querySelector('.period-btn.active')?.classList.remove('active');
  document.querySelector(`.period-btn[onclick*="${evt.period}"]`)?.classList.add('active');
  
  // Seek video to that time
  if (evt.videoTime) {
    videoSeekTo(evt.videoTime);
  }
  
  // Remove from queue
  eventQueue.splice(idx, 1);
  renderEventQueue();
  
  toast('Complete the event details and log', 'info');
}

function clearEventQueue() {
  if (eventQueue.length === 0) return;
  if (confirm(`Clear ${eventQueue.length} queued events?`)) {
    eventQueue = [];
    renderEventQueue();
  }
}

// --- 12. LIVE STATS OVERLAY ---
function toggleStatsOverlay() {
  let overlay = document.getElementById('liveStatsOverlay');
  
  if (overlay) {
    overlay.style.display = overlay.style.display === 'none' ? 'block' : 'none';
    return;
  }
  
  // Create overlay
  overlay = document.createElement('div');
  overlay.id = 'liveStatsOverlay';
  overlay.style.cssText = `
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(0,0,0,0.8);
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 10px;
    color: #fff;
    z-index: 50;
    pointer-events: none;
  `;
  
  document.getElementById('videoPlayerContainer').appendChild(overlay);
  updateStatsOverlay();
  
  // Update every second
  setInterval(updateStatsOverlay, 1000);
}

function updateStatsOverlay() {
  const overlay = document.getElementById('liveStatsOverlay');
  if (!overlay || overlay.style.display === 'none') return;
  
  const homeShots = S.events.filter(e => e.type === 'Shot' && e.team === 'home').length;
  const awayShots = S.events.filter(e => e.type === 'Shot' && e.team === 'away').length;
  const homeGoals = S.events.filter(e => e.type === 'Goal' && e.team === 'home').length;
  const awayGoals = S.events.filter(e => e.type === 'Goal' && e.team === 'away').length;
  
  overlay.innerHTML = `
    <div style="display:grid;grid-template-columns:1fr auto 1fr;gap:4px;text-align:center;">
      <span style="color:var(--home);">${S.homeTeam || 'HOME'}</span>
      <span></span>
      <span style="color:var(--away);">${S.awayTeam || 'AWAY'}</span>
      <span style="font-size:16px;font-weight:bold;">${homeGoals}</span>
      <span style="font-size:12px;">SCORE</span>
      <span style="font-size:16px;font-weight:bold;">${awayGoals}</span>
      <span>${homeShots}</span>
      <span style="font-size:8px;">SOG</span>
      <span>${awayShots}</span>
    </div>
  `;
}

// Hook into logEventDirect to track recent players and suggestions
const originalLogEventDirectV25 = typeof logEventDirect === 'function' ? logEventDirect : null;

// --- Initialize new features ---
function initV25Features() {
  renderEventSuggestions();
  renderRecentPlayers();
  renderEventQueue();
  updatePenaltyBox();
  updatePossessionDisplay();
  updateUndoButton();
  
  // Add CSS for goal sequence highlighting
  const style = document.createElement('style');
  style.textContent = `
    .goal-sequence { background: rgba(34, 197, 94, 0.2) !important; }
    .batch-selected { background: rgba(59, 130, 246, 0.3) !important; outline: 2px solid var(--accent); }
  `;
  document.head.appendChild(style);
}

// Call on init
setTimeout(initV25Features, 500);

// ============================================================
// v23.5: SPEED & WORKFLOW FEATURES
// ============================================================

// --- 1. MIRROR MODE (Auto-flip XY for period 2) ---
let mirrorModeEnabled = true;

function toggleMirrorMode() {
  mirrorModeEnabled = !mirrorModeEnabled;
  toast(`Mirror Mode: ${mirrorModeEnabled ? 'ON' : 'OFF'}`, 'info');
  updateMirrorModeIndicator();
}

function updateMirrorModeIndicator() {
  const btn = document.getElementById('mirrorModeBtn');
  if (btn) btn.classList.toggle('active', mirrorModeEnabled);
}

function shouldMirrorXY() {
  if (!mirrorModeEnabled) return false;
  // Mirror in periods 2, 4 (OT if even periods played)
  const period = S.period;
  return period === 2 || period === '2';
}

function applyMirror(x, y) {
  if (shouldMirrorXY()) {
    return { x: 200 - x, y: 85 - y }; // Flip both axes
  }
  return { x, y };
}

// --- 2. AUTO ZONE FROM XY ---
let autoZoneEnabled = true;

function toggleAutoZone() {
  autoZoneEnabled = !autoZoneEnabled;
  toast(`Auto Zone: ${autoZoneEnabled ? 'ON' : 'OFF'}`, 'info');
}

function getZoneFromXY(x) {
  // Rink is 200 units wide
  // Home attacks right in P1 (default)
  const homeAttacksRight = S.homeAttacksRightP1 !== false;
  const isHome = S.evtTeam === 'home';
  const mirrorPeriod = shouldMirrorXY();
  
  let attacksRight = (isHome === homeAttacksRight);
  if (mirrorPeriod) attacksRight = !attacksRight;
  
  if (attacksRight) {
    // Offensive = right side (x > 140), Defensive = left (x < 60)
    if (x > 140) return 'o';
    if (x < 60) return 'd';
    return 'n';
  } else {
    // Offensive = left side (x < 60), Defensive = right (x > 140)
    if (x < 60) return 'o';
    if (x > 140) return 'd';
    return 'n';
  }
}

function autoSetZoneFromXY(x) {
  if (!autoZoneEnabled) return;
  const zone = getZoneFromXY(x);
  setZone(zone);
}

// --- 3. GOALIE AUTO-ADD ---
let goalieAutoAddEnabled = true;

function toggleGoalieAutoAdd() {
  goalieAutoAddEnabled = !goalieAutoAddEnabled;
  toast(`Goalie Auto-Add: ${goalieAutoAddEnabled ? 'ON' : 'OFF'}`, 'info');
}

function autoAddGoalie() {
  if (!goalieAutoAddEnabled) return;
  
  const evtType = document.getElementById('evtType').value;
  if (!['Shot', 'Goal', 'Save', 'Rebound'].includes(evtType)) return;
  
  // Find opposing goalie
  const oppTeam = S.evtTeam === 'home' ? 'away' : 'home';
  const roster = oppTeam === 'home' ? S.homeRoster : S.awayRoster;
  const goalie = roster.find(p => p.pos === 'G' || p.position === 'G' || p.position === 'Goalie');
  
  if (goalie) {
    // Check if already added
    const alreadyAdded = S.curr.players?.some(p => p.num == goalie.num && p.team === oppTeam);
    if (!alreadyAdded) {
      addEventPlayer({ ...goalie, team: oppTeam, role: 'opp_team_player_1' });
    }
  }
}

// --- 4. QUICK STRENGTH BUTTONS ---
function setStrength(strength) {
  document.getElementById('evtStrength').value = strength;
  
  // Update button states
  document.querySelectorAll('.strength-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.strength === strength);
  });
  
  toast(`Strength: ${strength}`, 'info');
}

// --- 5. ENHANCED FACEOFF PRESETS ---
function setupFaceoffWithPlayers(dotName, homeCenter, awayCenter) {
  // Set faceoff type
  setEvtType('Faceoff');
  
  // Position at dot
  if (typeof positionAtFaceoffDot === 'function') {
    const dot = FACEOFF_DOTS?.find(d => d.name === dotName);
    if (dot) {
      handleFaceoffDotClick(dot);
    }
  }
  
  // Add centers if provided
  if (homeCenter) {
    const homePlayer = S.homeRoster.find(p => p.num == homeCenter);
    if (homePlayer) addEventPlayer({ ...homePlayer, team: 'home' });
  }
  if (awayCenter) {
    const awayPlayer = S.awayRoster.find(p => p.num == awayCenter);
    if (awayPlayer) addEventPlayer({ ...awayPlayer, team: 'away', role: 'opp_team_player_1' });
  }
}

// --- 6. GAP FINDER ---
function findEventGaps() {
  const events = S.events || [];
  if (events.length < 2) {
    toast('Need at least 2 events to find gaps', 'warning');
    return;
  }
  
  const gaps = [];
  const minGapSeconds = 60; // Report gaps > 1 minute
  
  for (let i = 1; i < events.length; i++) {
    const prev = events[i - 1];
    const curr = events[i];
    
    if (prev.period !== curr.period) continue;
    
    const prevTime = parseGameTime(prev.start_time);
    const currTime = parseGameTime(curr.start_time);
    const gapSec = prevTime - currTime; // Clock counts down
    
    if (gapSec > minGapSeconds) {
      gaps.push({
        period: curr.period,
        from: curr.start_time,
        to: prev.start_time,
        duration: gapSec,
        afterEvent: i - 1
      });
    }
  }
  
  if (gaps.length === 0) {
    toast('No significant gaps found!', 'success');
    return;
  }
  
  // Show gaps
  const html = `
    <h3>üîç Event Gaps Found (>${minGapSeconds}s)</h3>
    <div style="max-height:300px;overflow-y:auto;">
      <table style="width:100%;font-size:10px;border-collapse:collapse;">
        <thead>
          <tr style="background:var(--panel);">
            <th style="padding:4px;">Period</th>
            <th style="padding:4px;">From</th>
            <th style="padding:4px;">To</th>
            <th style="padding:4px;">Gap</th>
            <th style="padding:4px;">Action</th>
          </tr>
        </thead>
        <tbody>
          ${gaps.map(g => `
            <tr>
              <td style="padding:4px;text-align:center;">P${g.period}</td>
              <td style="padding:4px;text-align:center;">${g.from}</td>
              <td style="padding:4px;text-align:center;">${g.to}</td>
              <td style="padding:4px;text-align:center;color:var(--warn);">${Math.floor(g.duration / 60)}:${String(g.duration % 60).padStart(2, '0')}</td>
              <td style="padding:4px;text-align:center;">
                <button class="btn-sm" onclick="jumpToGap(${g.period}, '${g.from}')" style="font-size:8px;">Go</button>
              </td>
            </tr>
          `).join('')}
        </tbody>
      </table>
    </div>
    <div style="margin-top:10px;font-size:9px;color:var(--muted);">
      Found ${gaps.length} gap(s). Click "Go" to seek video to that time.
    </div>
    <div class="modal-actions">
      <button onclick="closeModal()">Close</button>
    </div>
  `;
  
  showModal(html);
}

function jumpToGap(period, time) {
  const videoTime = calculateRunningVideoTime(period, time);
  videoSeekTo(videoTime);
  closeModal();
  toast(`Jumped to P${period} ${time}`, 'info');
}

// --- 7. DUPLICATE DETECTION ---
let duplicateCheckEnabled = true;

function checkForDuplicate() {
  if (!duplicateCheckEnabled || S.events.length === 0) return null;
  
  const curr = S.curr;
  const type = document.getElementById('evtType').value;
  const time = document.getElementById('evtStartTime').value;
  const team = document.getElementById('evtTeam').value;
  
  if (!type || !time) return null;
  
  // Look for similar event in last 10 events
  const recent = S.events.slice(-10);
  
  for (const evt of recent) {
    if (evt.type !== type) continue;
    if (evt.team !== team) continue;
    if (evt.period !== S.period) continue;
    
    // Check if time is within 5 seconds
    const evtTimeSec = parseGameTime(evt.start_time);
    const currTimeSec = parseGameTime(time);
    
    if (Math.abs(evtTimeSec - currTimeSec) <= 5) {
      return evt;
    }
  }
  
  return null;
}

function warnIfDuplicate() {
  const dup = checkForDuplicate();
  if (dup) {
    const idx = S.events.indexOf(dup);
    toast(`‚ö†Ô∏è Similar to event #${idx + 1} (${dup.type} @ ${dup.start_time})`, 'warning');
    return true;
  }
  return false;
}

// --- 8. AUTO-LINK SUGGESTIONS ---
function suggestEventLink() {
  const type = document.getElementById('evtType').value;
  if (!type || S.events.length === 0) return;
  
  // Types that should link to previous
  const linkTypes = {
    'Save': ['Shot'],
    'Rebound': ['Shot', 'Save'],
    'Goal': ['Shot', 'Rebound'],
    'Turnover': ['Pass', 'Possession'],
    'Possession': ['Turnover', 'Faceoff', 'Save']
  };
  
  const shouldLinkTo = linkTypes[type];
  if (!shouldLinkTo) return;
  
  // Find last event of matching type
  for (let i = S.events.length - 1; i >= Math.max(0, S.events.length - 5); i--) {
    const evt = S.events[i];
    if (shouldLinkTo.includes(evt.type) && evt.period === S.period) {
      // Suggest link
      const linkEl = document.getElementById('evtLinked');
      if (linkEl && !linkEl.value) {
        linkEl.value = i + 1;
        toast(`Auto-linked to #${i + 1} (${evt.type})`, 'info');
      }
      return;
    }
  }
}

// --- 9. SHIFT LENGTH ALERT ---
let shiftAlertThreshold = 45; // seconds
let shiftCriticalThreshold = 60;
let shiftAlertInterval = null;

function startShiftAlerts() {
  if (shiftAlertInterval) clearInterval(shiftAlertInterval);
  
  shiftAlertInterval = setInterval(() => {
    checkShiftLengths();
  }, 5000);
}

function checkShiftLengths() {
  // Find active shifts (started but not ended)
  const currentTime = document.getElementById('clock').value;
  const currentTimeSec = parseGameTime(currentTime);
  
  S.shifts?.forEach((shift, idx) => {
    if (shift.end_time) return; // Already ended
    if (shift.period !== S.period) return;
    
    const startSec = parseGameTime(shift.start_time);
    const duration = startSec - currentTimeSec;
    
    if (duration >= shiftCriticalThreshold) {
      // Critical - highlight in red
      highlightShift(idx, 'critical');
    } else if (duration >= shiftAlertThreshold) {
      // Warning - highlight in yellow
      highlightShift(idx, 'warning');
    }
  });
}

function highlightShift(idx, level) {
  const row = document.querySelector(`[data-shift-idx="${idx}"]`);
  if (row) {
    row.classList.remove('shift-warning', 'shift-critical');
    row.classList.add(`shift-${level}`);
  }
}

// --- 10. NUMPAD MODE ---
let numpadModeEnabled = false;

function toggleNumpadMode() {
  numpadModeEnabled = !numpadModeEnabled;
  toast(`Numpad Mode: ${numpadModeEnabled ? 'ON - Use numpad for players' : 'OFF'}`, 'info');
}

// Numpad handler (separate from main keyboard)
document.addEventListener('keydown', (e) => {
  if (!numpadModeEnabled) return;
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') return;
  
  // Numpad keys
  const numpadMap = {
    'Numpad1': 1, 'Numpad2': 2, 'Numpad3': 3,
    'Numpad4': 4, 'Numpad5': 5, 'Numpad6': 6,
    'Numpad7': 7, 'Numpad8': 8, 'Numpad9': 9,
    'Numpad0': 10
  };
  
  if (numpadMap[e.code]) {
    e.preventDefault();
    const slot = numpadMap[e.code];
    
    if (e.shiftKey) {
      // Opponent player
      selectEventPlayerSlot('opp', Math.min(slot, 6));
    } else {
      // Event player
      selectEventPlayerSlot('evt', Math.min(slot, 6));
    }
  }
  
  // NumpadEnter = log event
  if (e.code === 'NumpadEnter') {
    e.preventDefault();
    logEvent();
  }
  
  // NumpadAdd = highlight
  if (e.code === 'NumpadAdd') {
    e.preventDefault();
    document.getElementById('evtHighlight').checked = true;
  }
});

// --- 11. ICING/OFFSIDE QUICK BUTTONS ---
function quickIcing(team) {
  setEvtType('Stoppage');
  document.getElementById('evtD1').value = 'Stoppage_Icing';
  document.getElementById('evtTeam').value = team;
  toast('Icing - ready to log', 'info');
}

function quickOffside() {
  setEvtType('Stoppage');
  document.getElementById('evtD1').value = 'Stoppage_Offside';
  toast('Offside - ready to log', 'info');
}

// --- 12. EMPTY NET TOGGLE ---
let emptyNetTeam = null;

function toggleEmptyNet(team) {
  if (emptyNetTeam === team) {
    emptyNetTeam = null;
    toast('Empty net cleared', 'info');
  } else {
    emptyNetTeam = team;
    toast(`Empty net: ${team.toUpperCase()}`, 'warn');
  }
  updateEmptyNetIndicator();
}

function updateEmptyNetIndicator() {
  const indicator = document.getElementById('emptyNetIndicator');
  if (indicator) {
    if (emptyNetTeam) {
      indicator.textContent = `EN: ${emptyNetTeam.toUpperCase()}`;
      indicator.style.display = 'inline';
      indicator.style.color = emptyNetTeam === 'home' ? 'var(--home)' : 'var(--away)';
    } else {
      indicator.style.display = 'none';
    }
  }
}

// --- Hook into setEvtType to auto-add goalie and suggest links ---
const originalSetEvtType = typeof setEvtType === 'function' ? setEvtType : null;
if (originalSetEvtType) {
  setEvtType = function(type) {
    originalSetEvtType(type);
    
    // Auto-add goalie
    setTimeout(() => {
      autoAddGoalie();
      suggestEventLink();
    }, 100);
  };
}

// --- Hook into handleXYPlacement to auto-set zone ---
function enhanceXYPlacement(x, y) {
  // Apply mirror
  const mirrored = applyMirror(x, y);
  
  // Auto-set zone
  autoSetZoneFromXY(mirrored.x);
  
  return mirrored;
}

// --- Initialize shift alerts ---
setTimeout(startShiftAlerts, 1000);

// --- Add CSS for shift alerts ---
const shiftAlertStyle = document.createElement('style');
shiftAlertStyle.textContent = `
  .shift-warning { background: rgba(245, 158, 11, 0.3) !important; }
  .shift-critical { background: rgba(239, 68, 68, 0.4) !important; animation: pulse 0.5s infinite; }
  @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
  .mode-btn.active { background: var(--accent) !important; color: #000 !important; }
`;
document.head.appendChild(shiftAlertStyle);

// ============================================================
// v23.5: ADDITIONAL SPEED FEATURES
// ============================================================

// --- 13. SMART DEFAULTS (Learn patterns) ---
let eventPatterns = {};

function learnEventPattern() {
  const type = document.getElementById('evtType').value;
  const d1 = document.getElementById('evtD1').value;
  const d2 = document.getElementById('evtD2').value;
  const zone = document.getElementById('evtZone').value;
  
  if (!type) return;
  
  if (!eventPatterns[type]) {
    eventPatterns[type] = { d1: {}, d2: {}, zone: {} };
  }
  
  // Count occurrences
  if (d1) eventPatterns[type].d1[d1] = (eventPatterns[type].d1[d1] || 0) + 1;
  if (d2) eventPatterns[type].d2[d2] = (eventPatterns[type].d2[d2] || 0) + 1;
  if (zone) eventPatterns[type].zone[zone] = (eventPatterns[type].zone[zone] || 0) + 1;
}

function applySmartDefaults(type) {
  const pattern = eventPatterns[type];
  if (!pattern) return;
  
  // Find most common d1
  const topD1 = Object.entries(pattern.d1).sort((a, b) => b[1] - a[1])[0];
  if (topD1 && topD1[1] >= 3) {
    document.getElementById('evtD1').value = topD1[0];
  }
  
  // Find most common zone
  const topZone = Object.entries(pattern.zone).sort((a, b) => b[1] - a[1])[0];
  if (topZone && topZone[1] >= 3) {
    setZone(topZone[0]);
  }
}

// --- 14. EVENT MACROS ---
let eventMacros = [];
let recordingMacro = false;
let currentMacroEvents = [];

function startRecordingMacro() {
  recordingMacro = true;
  currentMacroEvents = [];
  toast('Recording macro... Log events, then click Stop', 'info');
  updateMacroRecordingUI();
}

function stopRecordingMacro() {
  recordingMacro = false;
  
  if (currentMacroEvents.length === 0) {
    toast('No events recorded', 'warning');
    updateMacroRecordingUI();
    return;
  }
  
  const name = prompt(`Name this macro (${currentMacroEvents.length} events):`);
  if (name) {
    eventMacros.push({
      name,
      events: currentMacroEvents,
      created: new Date().toISOString()
    });
    saveMacros();
    toast(`Macro "${name}" saved`, 'success');
  }
  
  currentMacroEvents = [];
  updateMacroRecordingUI();
}

function recordEventForMacro(evt) {
  if (!recordingMacro) return;
  
  currentMacroEvents.push({
    type: evt.type,
    detail1: evt.detail1 || evt.detail,
    detail2: evt.detail2,
    zone: evt.zone,
    success: evt.success,
    playerCount: (evt.players || []).length
  });
}

function playMacro(macroIdx) {
  const macro = eventMacros[macroIdx];
  if (!macro) return;
  
  toast(`Playing macro: ${macro.name}`, 'info');
  
  macro.events.forEach((evt, i) => {
    setTimeout(() => {
      setEvtType(evt.type);
      if (evt.detail1) document.getElementById('evtD1').value = evt.detail1;
      if (evt.detail2) document.getElementById('evtD2').value = evt.detail2;
      if (evt.zone) setZone(evt.zone);
      
      toast(`Macro step ${i + 1}/${macro.events.length}: ${evt.type}`, 'info');
    }, i * 500);
  });
}

function saveMacros() {
  localStorage.setItem('benchsight_macros', JSON.stringify(eventMacros));
}

function loadMacros() {
  const saved = localStorage.getItem('benchsight_macros');
  if (saved) {
    try {
      eventMacros = JSON.parse(saved);
    } catch (e) {
      eventMacros = [];
    }
  }
}

function updateMacroRecordingUI() {
  const btn = document.getElementById('macroRecordBtn');
  if (btn) {
    btn.textContent = recordingMacro ? '‚èπ Stop' : '‚è∫ Rec';
    btn.style.background = recordingMacro ? 'var(--danger)' : '';
  }
}

function showMacroManager() {
  loadMacros();
  
  const html = `
    <h3>üé¨ Event Macros</h3>
    <div style="margin-bottom:10px;">
      <button class="btn-sm" id="macroRecordBtn" onclick="${recordingMacro ? 'stopRecordingMacro()' : 'startRecordingMacro()'}">
        ${recordingMacro ? '‚èπ Stop Recording' : '‚è∫ Record New'}
      </button>
    </div>
    <div style="max-height:250px;overflow-y:auto;">
      ${eventMacros.length === 0 ? '<p style="color:var(--muted);">No macros saved</p>' : 
        eventMacros.map((m, i) => `
          <div style="display:flex;justify-content:space-between;align-items:center;padding:6px;background:var(--panel);margin:4px 0;border-radius:4px;">
            <span><strong>${m.name}</strong> (${m.events.length} events)</span>
            <div>
              <button class="btn-sm" onclick="playMacro(${i})" style="font-size:9px;">‚ñ∂ Play</button>
              <button class="btn-sm" onclick="deleteMacro(${i})" style="font-size:9px;background:var(--danger);">‚úï</button>
            </div>
          </div>
        `).join('')
      }
    </div>
    <div class="modal-actions">
      <button onclick="closeModal()">Close</button>
    </div>
  `;
  
  showModal(html);
}

function deleteMacro(idx) {
  if (confirm(`Delete macro "${eventMacros[idx].name}"?`)) {
    eventMacros.splice(idx, 1);
    saveMacros();
    showMacroManager();
  }
}

// Load macros on init
setTimeout(loadMacros, 100);

// --- 15. SHOT CHART OVERLAY ---
let shotChartOverlayEnabled = false;

function toggleShotChartOverlay() {
  shotChartOverlayEnabled = !shotChartOverlayEnabled;
  
  if (shotChartOverlayEnabled) {
    renderShotChartOverlay();
    toast('Shot chart overlay ON', 'info');
  } else {
    clearShotChartOverlay();
    toast('Shot chart overlay OFF', 'info');
  }
}

function renderShotChartOverlay() {
  clearShotChartOverlay();
  
  const svg = document.getElementById('rinkSvg');
  if (!svg) return;
  
  // Get all shots and goals with XY
  const shots = (S.events || []).filter(e => 
    ['Shot', 'Goal'].includes(e.type) && e.puckXY && e.puckXY.length > 0
  );
  
  shots.forEach(shot => {
    const xy = shot.puckXY[0];
    const isGoal = shot.type === 'Goal';
    const color = shot.team === 'home' ? 'var(--home)' : 'var(--away)';
    
    const marker = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    marker.setAttribute('cx', xy.x);
    marker.setAttribute('cy', xy.y);
    marker.setAttribute('r', isGoal ? 4 : 3);
    marker.setAttribute('fill', isGoal ? '#22c55e' : color);
    marker.setAttribute('stroke', '#fff');
    marker.setAttribute('stroke-width', '1');
    marker.setAttribute('opacity', '0.7');
    marker.setAttribute('class', 'shot-overlay-marker');
    marker.setAttribute('data-event-idx', S.events.indexOf(shot));
    
    // Tooltip
    marker.setAttribute('title', `${shot.type} #${S.events.indexOf(shot) + 1}`);
    
    svg.appendChild(marker);
  });
}

function clearShotChartOverlay() {
  document.querySelectorAll('.shot-overlay-marker').forEach(el => el.remove());
}

// Update overlay when events change
function refreshShotChartOverlay() {
  if (shotChartOverlayEnabled) {
    renderShotChartOverlay();
  }
}

// --- 16. PROGRESS ESTIMATOR ---
function getProgressEstimate() {
  const events = S.events || [];
  const period = S.period;
  
  // Estimate based on typical event count per period
  const eventsPerPeriod = 50; // Rough estimate
  const totalPeriods = 3;
  
  const periodEvents = events.filter(e => e.period == period).length;
  const completedPeriods = (parseInt(period) || 1) - 1;
  
  const estimatedTotal = eventsPerPeriod * totalPeriods;
  const currentCount = events.length;
  
  // Time-based estimate
  const currentTime = document.getElementById('clock').value;
  const timeParts = currentTime.split(':').map(Number);
  const timeRemaining = timeParts[0] * 60 + timeParts[1];
  const periodLengthSec = getPeriodLengthSeconds(period);
  const timeElapsed = periodLengthSec - timeRemaining;
  const periodProgress = timeElapsed / periodLengthSec;
  
  const overallProgress = (completedPeriods + periodProgress) / totalPeriods;
  
  return {
    events: currentCount,
    estimated: estimatedTotal,
    progress: Math.round(overallProgress * 100),
    periodEvents,
    period
  };
}

function updateProgressBar() {
  const progress = getProgressEstimate();
  const bar = document.getElementById('progressBar');
  if (bar) {
    bar.innerHTML = `
      <div style="display:flex;align-items:center;gap:4px;font-size:9px;">
        <span>${progress.events} events</span>
        <div style="flex:1;height:4px;background:var(--border);border-radius:2px;min-width:60px;">
          <div style="width:${progress.progress}%;height:100%;background:var(--accent);border-radius:2px;"></div>
        </div>
        <span>~${progress.progress}%</span>
      </div>
    `;
  }
}

// --- 17. FLOATING VIDEO ---
let floatingVideoEnabled = false;

function toggleFloatingVideo() {
  floatingVideoEnabled = !floatingVideoEnabled;
  
  const container = document.getElementById('videoSection');
  if (!container) return;
  
  if (floatingVideoEnabled) {
    container.style.cssText = `
      position: fixed !important;
      top: 60px;
      right: 20px;
      width: 400px;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
      border-radius: 8px;
      resize: both;
      overflow: auto;
    `;
    toast('Floating video ON - drag to move', 'info');
    makeVideoDraggable();
  } else {
    container.style.cssText = '';
    toast('Floating video OFF', 'info');
  }
}

function makeVideoDraggable() {
  const container = document.getElementById('videoSection');
  if (!container) return;
  
  let isDragging = false;
  let startX, startY, startLeft, startTop;
  
  const header = container.querySelector('.video-header') || container;
  
  header.style.cursor = 'move';
  
  header.addEventListener('mousedown', (e) => {
    if (e.target.tagName === 'BUTTON' || e.target.tagName === 'SELECT') return;
    isDragging = true;
    startX = e.clientX;
    startY = e.clientY;
    startLeft = container.offsetLeft;
    startTop = container.offsetTop;
  });
  
  document.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    container.style.left = `${startLeft + dx}px`;
    container.style.top = `${startTop + dy}px`;
    container.style.right = 'auto';
  });
  
  document.addEventListener('mouseup', () => {
    isDragging = false;
  });
}

// --- 18. QUICK EVENT BUTTONS (Most common) ---
function addQuickEventButtons() {
  // Count most common event types
  const typeCounts = {};
  (S.events || []).forEach(e => {
    typeCounts[e.type] = (typeCounts[e.type] || 0) + 1;
  });
  
  const topTypes = Object.entries(typeCounts)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5)
    .map(([type]) => type);
  
  return topTypes;
}

// --- 19. PERIOD PROGRESS RING ---
function renderPeriodProgress() {
  const ring = document.getElementById('periodProgressRing');
  if (!ring) return;
  
  const currentTime = document.getElementById('clock').value;
  const timeParts = currentTime.split(':').map(Number);
  const timeRemaining = timeParts[0] * 60 + timeParts[1];
  const periodLengthSec = getPeriodLengthSeconds(S.period);
  const progress = 1 - (timeRemaining / periodLengthSec);
  
  // SVG ring
  const radius = 12;
  const circumference = 2 * Math.PI * radius;
  const offset = circumference * (1 - progress);
  
  ring.innerHTML = `
    <svg width="30" height="30" style="transform:rotate(-90deg);">
      <circle cx="15" cy="15" r="${radius}" fill="none" stroke="var(--border)" stroke-width="3"/>
      <circle cx="15" cy="15" r="${radius}" fill="none" stroke="var(--accent)" stroke-width="3"
        stroke-dasharray="${circumference}" stroke-dashoffset="${offset}"/>
    </svg>
  `;
}

// --- 20. CONSISTENCY CHECKER ---
function runConsistencyCheck() {
  const issues = [];
  
  S.events?.forEach((evt, idx) => {
    // Shot without save/goal following
    if (evt.type === 'Shot') {
      const next = S.events[idx + 1];
      if (next && !['Save', 'Goal', 'Rebound', 'Stoppage'].includes(next.type)) {
        issues.push({
          idx,
          type: 'warning',
          msg: `Shot #${idx + 1} not followed by Save/Goal/Rebound`
        });
      }
    }
    
    // Goal without shot before
    if (evt.type === 'Goal') {
      const prev = S.events[idx - 1];
      if (prev && !['Shot', 'Rebound'].includes(prev.type)) {
        issues.push({
          idx,
          type: 'warning',
          msg: `Goal #${idx + 1} not preceded by Shot/Rebound`
        });
      }
    }
    
    // Penalty without faceoff after
    if (evt.type === 'Penalty') {
      const next = S.events[idx + 1];
      if (next && next.type !== 'Faceoff' && next.type !== 'Stoppage') {
        issues.push({
          idx,
          type: 'info',
          msg: `Penalty #${idx + 1} not followed by Faceoff`
        });
      }
    }
    
    // Event without players
    if (['Shot', 'Pass', 'Goal', 'Faceoff'].includes(evt.type)) {
      if (!evt.players || evt.players.length === 0) {
        issues.push({
          idx,
          type: 'error',
          msg: `${evt.type} #${idx + 1} has no players`
        });
      }
    }
  });
  
  if (issues.length === 0) {
    toast('No consistency issues found!', 'success');
    return;
  }
  
  const html = `
    <h3>‚ö†Ô∏è Consistency Check (${issues.length} issues)</h3>
    <div style="max-height:300px;overflow-y:auto;">
      ${issues.map(i => `
        <div style="padding:6px;margin:4px 0;background:${
          i.type === 'error' ? 'rgba(239,68,68,0.2)' : 
          i.type === 'warning' ? 'rgba(245,158,11,0.2)' : 
          'rgba(59,130,246,0.2)'
        };border-radius:4px;font-size:10px;display:flex;justify-content:space-between;align-items:center;">
          <span>${i.msg}</span>
          <button class="btn-sm" onclick="editEvent(${i.idx});closeModal();" style="font-size:8px;">Fix</button>
        </div>
      `).join('')}
    </div>
    <div class="modal-actions">
      <button onclick="closeModal()">Close</button>
    </div>
  `;
  
  showModal(html);
}

// ============================================================
// v23.5: HOOK UPDATES
// ============================================================

// Update logEventDirect hook to include new features
const hookLogEventDirect = () => {
  // This runs after each event is logged
  learnEventPattern();
  
  if (recordingMacro && S.events.length > 0) {
    recordEventForMacro(S.events[S.events.length - 1]);
  }
  
  refreshShotChartOverlay();
  updateProgressBar();
};

// Add to existing logEventDirect hook chain
const existingLogHook = logEventDirect;
logEventDirect = function() {
  existingLogHook.apply(this, arguments);
  hookLogEventDirect();
};

// ============================================================
// AUTO-SAVE
// ============================================================
function startAutoSave() {
  if (S.saveTimer) clearInterval(S.saveTimer);
  const interval = (parseInt(document.getElementById('autoSaveInt').value) || 30) * 1000;
  S.saveTimer = setInterval(autoSave, interval);
}

function autoSave() {
  if (!S.gameId) return;
  const key = `bs_${S.gameId}`;
  const data = { 
    events: S.events, 
    shifts: S.shifts, 
    evtIdx: S.evtIdx, 
    shiftIdx: S.shiftIdx, 
    videoTiming: S.videoTiming,  // Save video timing per game
    periodLength: S.periodLength, // Legacy
    periodLengths: S.periodLengths, // v23.5: Period-specific lengths
    homeAttacksRightP1: S.homeAttacksRightP1, // v19: Zone orientation per game
    savedAt: new Date().toISOString() 
  };
  localStorage.setItem(key, JSON.stringify(data));
  S.lastSave = new Date();
  updateSaveIndicator('saved');
  setTimeout(() => updateSaveIndicator(), 2000);
}

function saveGameData() {
  autoSave(); // Trigger save immediately
}

function updateSaveIndicator(status) {
  const el = document.getElementById('saveInd');
  if (status === 'saving') { el.textContent = 'Saving...'; el.className = 'save-ind saving'; }
  else if (status === 'saved') { el.textContent = 'Saved ‚úì'; el.className = 'save-ind saved'; }
  else if (S.lastSave) {
    const ago = Math.round((new Date() - S.lastSave) / 1000);
    el.textContent = ago < 60 ? `${ago}s ago` : `${Math.round(ago/60)}m ago`;
    el.className = 'save-ind';
  } else { el.textContent = '--'; el.className = 'save-ind'; }
}

function loadFromStorage() {
  try {
    const last = localStorage.getItem('bs_lastGame');
    if (last) S.gameId = parseInt(last);
    
    // Check for saved game data
    if (S.gameId) {
      const key = `bs_${S.gameId}`;
      const saved = localStorage.getItem(key);
      if (saved) {
        const data = JSON.parse(saved);
        if (data.events?.length || data.shifts?.length) {
          // Show resume prompt
          showResumePrompt(data);
        }
      }
    }
  } catch(e) { console.log('Error loading from storage:', e); }
}

function showResumePrompt(data) {
  const evtCount = data.events?.length || 0;
  const shiftCount = data.shifts?.length || 0;
  const savedAt = data.savedAt ? new Date(data.savedAt).toLocaleString() : 'unknown';
  
  // Create resume modal dynamically
  const modal = document.createElement('div');
  modal.className = 'overlay show';
  modal.id = 'resumeModal';
  modal.innerHTML = `
    <div class="modal" style="min-width:350px;">
      <h3>üìÇ Resume Session?</h3>
      <p style="font-size:12px;color:var(--muted);margin:12px 0;">Found saved data for this game:</p>
      <div style="background:var(--card);padding:12px;border-radius:4px;margin:12px 0;">
        <div style="display:flex;justify-content:space-between;margin:4px 0;"><span>Events:</span><strong>${evtCount}</strong></div>
        <div style="display:flex;justify-content:space-between;margin:4px 0;"><span>Shifts:</span><strong>${shiftCount}</strong></div>
        <div style="display:flex;justify-content:space-between;margin:4px 0;"><span>Saved:</span><strong>${savedAt}</strong></div>
      </div>
      <div class="modal-actions">
        <button class="btn-success" onclick="resumeSession()">Resume</button>
        <button class="btn-danger" onclick="startNewSession()">Start New</button>
      </div>
    </div>
  `;
  document.body.appendChild(modal);
}

function resumeSession() {
  const key = `bs_${S.gameId}`;
  const saved = localStorage.getItem(key);
  if (saved) {
    const data = JSON.parse(saved);
    S.events = data.events || [];
    S.shifts = data.shifts || [];
    S.evtIdx = data.evtIdx || S.events.length;
    S.shiftIdx = data.shiftIdx || S.shifts.length;
    S.lastSave = data.savedAt ? new Date(data.savedAt) : null;
    
    // v19: Restore zone orientation
    if (data.homeAttacksRightP1 !== undefined) {
      S.homeAttacksRightP1 = data.homeAttacksRightP1;
    }
    if (data.periodLength) {
      S.periodLength = data.periodLength;
    }
    // v23.5: Load period-specific lengths
    if (data.periodLengths) {
      S.periodLengths = data.periodLengths;
      updatePeriodLengthsUI();
    }
    if (data.videoTiming) {
      S.videoTiming = data.videoTiming;
    }
    
    // Update zone labels with restored orientation
    updateZoneLabels();
    
    // Update flip button visual
    const btn = document.getElementById('flipZonesBtn');
    if (btn) {
      btn.style.background = S.homeAttacksRightP1 ? '#374151' : '#7c3aed';
    }
    
    toast(`Restored ${S.events.length} events, ${S.shifts.length} shifts`, 'success');
    renderAll();
    updateSaveIndicator();
    updateNextPlaySuggestions();
  }
  closeResumeModal();
}

function startNewSession() {
  S.events = [];
  S.shifts = [];
  S.evtIdx = 0;
  S.shiftIdx = 0;
  S.lastSave = null;
  
  // Clear saved data
  const key = `bs_${S.gameId}`;
  localStorage.removeItem(key);
  
  toast('Starting new session', 'success');
  renderAll();
  closeResumeModal();
}

function closeResumeModal() {
  const modal = document.getElementById('resumeModal');
  if (modal) modal.remove();
}

function manualSave() {
  if (!S.gameId) { toast('No game loaded', 'error'); return; }
  updateSaveIndicator('saving');
  autoSave();
  toast('Game saved!', 'success');
}

function clearSavedData() {
  if (!S.gameId) return;
  if (!confirm('Clear all saved data for this game? This cannot be undone.')) return;
  
  const key = `bs_${S.gameId}`;
  localStorage.removeItem(key);
  S.events = [];
  S.shifts = [];
  S.evtIdx = 0;
  S.shiftIdx = 0;
  
  toast('Saved data cleared', 'success');
  renderAll();
}

// ============================================================
// BUILD UI
// ============================================================
function buildUI() {
  const grid = document.getElementById('evtTypeGrid');
  // v22.1: Use dynamic event types from Supabase, with "Show More" toggle
  buildEventTypeButtons();
  
  document.getElementById('shiftStartType').innerHTML = LISTS.shiftStart.map(t => `<option value="${t}">${t}</option>`).join('');
  document.getElementById('shiftStopType').innerHTML = LISTS.shiftStop.map(t => `<option value="${t}">${t}</option>`).join('');
  
  ['home','away'].forEach(team => {
    document.getElementById(`${team}F`).innerHTML = ['F1','F2','F3'].map(p => `<div class="slot" data-team="${team}" data-pos="${p}" onclick="selectSlot(this)"><span class="num">${p}</span></div>`).join('');
    document.getElementById(`${team}D`).innerHTML = ['D1','D2'].map(p => `<div class="slot" data-team="${team}" data-pos="${p}" onclick="selectSlot(this)"><span class="num">${p}</span></div>`).join('');
    document.getElementById(`${team}G`).innerHTML = ['G','X'].map(p => `<div class="slot" data-team="${team}" data-pos="${p}" onclick="selectSlot(this)"><span class="num">${p}</span></div>`).join('');
  });
  
  // v23.3: Setup drag and drop for shift slots
  setupSlotDragDrop();
  
  // Edit type dropdown - use dynamic types if available
  buildEditTypeDropdown();
  
  renderXYSlots();
}

// v22.1: Build event type buttons dynamically from dim_event_type
function buildEventTypeButtons() {
  const grid = document.getElementById('evtTypeGrid');
  
  // Main types always shown (common event types)
  const mainTypeCodes = ['Faceoff','Shot','Pass','Goal','Turnover','Zone_Entry_Exit','Stoppage','Penalty','Possession','Save','Rebound','Play'];
  
  // Get types from Supabase or fall back to LISTS.eventTypes
  let allTypes = S.eventTypesDB.length > 0 
    ? S.eventTypesDB.map(e => e.code) 
    : LISTS.eventTypes;
  
  // Separate main and extra types
  const mainTypes = allTypes.filter(t => mainTypeCodes.includes(t));
  const extraTypes = allTypes.filter(t => !mainTypeCodes.includes(t));
  
  // Build main type buttons
  let html = mainTypes.map(t => 
    `<button class="evt-btn" data-type="${t}" onclick="setEvtType('${t}')">${t.replace('_Entry_Exit','')}<kbd>${LISTS.hotkeys[t]||''}</kbd></button>`
  ).join('');
  
  // Add "Show More" button if there are extra types
  if (extraTypes.length > 0) {
    html += `<button class="evt-btn" id="showMoreTypesBtn" onclick="toggleMoreEventTypes()" style="background:var(--surface);border:1px dashed var(--muted);">
      ${S.showAllEventTypes ? '‚óÄ Less' : 'More ‚ñ∂'}
    </button>`;
    
    // Add extra types (hidden by default)
    html += `<div id="extraEventTypes" style="display:${S.showAllEventTypes ? 'contents' : 'none'};">`;
    html += extraTypes.map(t => 
      `<button class="evt-btn" data-type="${t}" onclick="setEvtType('${t}')">${t}<kbd>${LISTS.hotkeys[t]||''}</kbd></button>`
    ).join('');
    html += '</div>';
  }
  
  grid.innerHTML = html;
}

// v22.1: Toggle showing all event types
function toggleMoreEventTypes() {
  S.showAllEventTypes = !S.showAllEventTypes;
  buildEventTypeButtons();
}

// v22.1: Build edit type dropdown with dynamic types
function buildEditTypeDropdown() {
  const dropdown = document.getElementById('editType');
  
  // Get types from Supabase or fall back to LISTS.eventTypes
  const types = S.eventTypesDB.length > 0 
    ? S.eventTypesDB.map(e => e.code) 
    : LISTS.eventTypes;
  
  dropdown.innerHTML = types.map(t => `<option value="${t}">${t}</option>`).join('');
}

// ============================================================
// GAMES & ROSTERS - SUPABASE CONNECTED
// ============================================================
async function loadGames() {
  console.log('loadGames called, S.connected:', S.connected);
  if (S.connected) {
    try {
      console.log('Loading ALL games from dim_schedule...');
      
      // Load ALL games from dim_schedule (not just tracked)
      // Paginate through in case there are many games
      let allGames = [];
      let offset = 0;
      const pageSize = 1000;
      let hasMore = true;
      
      while (hasMore && offset < 50000) {
        console.log(`  Fetching page at offset ${offset}...`);
        const { data, error } = await S.sb.from('dim_schedule')
          .select('game_id,date,home_team_name,away_team_name')
          .order('date', {ascending: false})
          .range(offset, offset + pageSize - 1);
        
        if (error) {
          console.error('Error at offset', offset, ':', error);
          toast('Error loading games: ' + (error.message || error.code), 'error');
          break;
        }
        
        console.log(`  Got ${data?.length || 0} games`);
        
        if (!data || data.length === 0) {
          hasMore = false;
        } else {
          allGames = allGames.concat(data);
          console.log(`  Page ${offset/pageSize + 1}: ${data.length} games (total: ${allGames.length})`);
          offset += pageSize;
          if (data.length < pageSize) hasMore = false;
        }
      }
      
      console.log('Total games from schedule:', allGames.length);
      
      // Dedupe by game_id (in case of any duplicates)
      const gameMap = new Map();
      allGames.forEach(g => {
        if (!gameMap.has(g.game_id)) {
          gameMap.set(g.game_id, {
            game_id: g.game_id,
            game_date: g.date?.split('T')[0] || g.date,
            home_team_name: g.home_team_name,
            away_team_name: g.away_team_name,
            home_team_color: '#3b82f6',
            away_team_color: '#ef4444'
          });
        }
      });
      
      S.games = Array.from(gameMap.values()).sort((a, b) => {
        // Sort by date descending, then by game_id descending
        if (a.game_date !== b.game_date) return b.game_date.localeCompare(a.game_date);
        return b.game_id - a.game_id;
      });
      
      console.log('Final games list:', S.games.length, 'games');
      
      toast(`${S.games.length} games loaded`, 'success');
    } catch(e) { 
      console.error('Failed to load games from Supabase:', e);
      toast('Failed to load games: ' + e.message, 'error');
      S.games = []; 
    }
  } else { 
    S.games = []; 
    toast('Connect to Supabase to load games', 'info');
  }
  
  renderGameSelect(S.games);
  if (S.gameId) document.getElementById('gameSelect').value = S.gameId;
}

function renderGameSelect(games) {
  const sel = document.getElementById('gameSelect');
  sel.innerHTML = '<option value="">-- Select Game (' + games.length + ') --</option>' + games.slice(0, 100).map(g => 
    `<option value="${g.game_id}">${g.game_id}: ${g.home_team_name} vs ${g.away_team_name} (${g.game_date})</option>`
  ).join('');
}

function filterGames(query) {
  if (!query) {
    renderGameSelect(S.games);
    return;
  }
  const q = query.toLowerCase();
  const filtered = S.games.filter(g => 
    g.game_id.toString().includes(q) ||
    g.home_team_name?.toLowerCase().includes(q) ||
    g.away_team_name?.toLowerCase().includes(q) ||
    g.game_date?.includes(q)
  );
  renderGameSelect(filtered);
}

async function selectGame(gid) {
  if (!gid) return;
  S.gameId = parseInt(gid);
  localStorage.setItem('bs_lastGame', gid);
  
  const g = S.games.find(x => x.game_id == gid);
  if (!g) { toast('Game not found', 'error'); return; }
  
  S.homeTeam = g.home_team_name; S.awayTeam = g.away_team_name;
  
  // v15.01: Use cached team data if available, otherwise load from Supabase
  const homeTeamData = S.teams[g.home_team_name];
  const awayTeamData = S.teams[g.away_team_name];
  
  if (homeTeamData && awayTeamData) {
    S.homeColor = homeTeamData.color1 || '#3b82f6';
    S.awayColor = awayTeamData.color1 || '#ef4444';
    S.homeLogo = homeTeamData.logo || null;
    S.awayLogo = awayTeamData.logo || null;
  } else if (S.connected) {
    try {
      const { data: teamData } = await S.sb.from('dim_team')
        .select('team_name,team_color1,team_logo')
        .in('team_name', [g.home_team_name, g.away_team_name]);
      
      if (teamData?.length) {
        const homeTeam = teamData.find(t => t.team_name === g.home_team_name);
        const awayTeam = teamData.find(t => t.team_name === g.away_team_name);
        S.homeColor = homeTeam?.team_color1 || '#3b82f6';
        S.awayColor = awayTeam?.team_color1 || '#ef4444';
        S.homeLogo = homeTeam?.team_logo || null;
        S.awayLogo = awayTeam?.team_logo || null;
      }
    } catch(e) { console.log('Failed to load team colors:', e); }
  }
  console.log('Team colors:', S.homeColor, S.awayColor);
  
  // Update UI with team names (not just Home/Away)
  document.getElementById('homeLbl').textContent = S.homeTeam;
  document.getElementById('awayLbl').textContent = S.awayTeam;
  document.getElementById('evtHomeLbl').textContent = S.homeTeam;
  document.getElementById('evtAwayLbl').textContent = S.awayTeam;
  document.getElementById('homeDot').style.background = S.homeColor;
  document.getElementById('awayDot').style.background = S.awayColor;
  document.documentElement.style.setProperty('--home', S.homeColor);
  document.documentElement.style.setProperty('--away', S.awayColor);
  
  // Update filter dropdown with team names
  const filterTeamSel = document.getElementById('filterEvtTeam');
  if (filterTeamSel) {
    filterTeamSel.innerHTML = `<option value="">All</option><option value="home">${S.homeTeam}</option><option value="away">${S.awayTeam}</option>`;
  }
  
  // v15.01: Update team logos if elements exist
  const homeLogoEl = document.getElementById('homeLogoImg');
  const awayLogoEl = document.getElementById('awayLogoImg');
  if (homeLogoEl) homeLogoEl.src = S.homeLogo || '';
  if (awayLogoEl) awayLogoEl.src = S.awayLogo || '';
  
  // Update zone labels on rink (based on current period)
  updateZoneLabels();
  
  await loadRosters(gid);
  loadGameData(gid);
  renderAll();
  toast(`Loaded: ${S.homeTeam} vs ${S.awayTeam}`, 'success');
}

async function loadRosters(gid) {
  if (!S.connected) { 
    generateDemoRosters(); 
    toast('Demo rosters loaded (not connected)', 'info');
    return;
  }
  
  try {
    // Query fact_gameroster for this game
    // Note: player_rating not in table, will be null
    const { data, error } = await S.sb.from('fact_gameroster')
      .select('player_id,player_game_number,player_full_name,player_position,team_venue')
      .eq('game_id', gid)
      .order('player_game_number');
    
    if (error) {
      console.error('Roster query error:', error);
      throw error;
    }
    
    console.log('Raw roster data for game', gid, ':', data?.length, 'players');
    
    if (!data || data.length === 0) {
      // Try alternate column names
      console.log('No data with standard columns, trying alternate...');
      const { data: altData, error: altErr } = await S.sb.from('fact_gameroster')
        .select('*')
        .eq('game_id', gid)
        .limit(50);
      
      if (altErr) throw altErr;
      
      if (altData?.length > 0) {
        console.log('Alt data columns:', Object.keys(altData[0]));
        
        // Try to map alternate column names
        const homeMap = new Map();
        const awayMap = new Map();
        
        altData.forEach(p => {
          const venue = p.team_venue || p.venue || p.team || '';
          const isHome = venue.toLowerCase().includes('home');
          const map = isHome ? homeMap : awayMap;
          const playerId = p.player_id || p.id || '';
          
          if (!map.has(playerId)) {
            map.set(playerId, {
              id: playerId,
              num: String(p.player_game_number || p.jersey_number || p.number || '?'),
              name: p.player_full_name || p.full_name || p.name || 'Unknown',
              pos: normalizePosition(p.player_position || p.position),
              rating: p.player_rating || p.rating || null
            });
          }
        });
        
        S.rosters = {
          home: Array.from(homeMap.values()).sort((a,b) => parseInt(a.num) - parseInt(b.num)),
          away: Array.from(awayMap.values()).sort((a,b) => parseInt(a.num) - parseInt(b.num))
        };
      } else {
        console.log('No roster data found for game', gid);
        generateDemoRosters();
        toast('No roster data - using demo', 'warning');
        return;
      }
    } else {
      // Standard processing - v15: Case-insensitive team_venue check
      const homeMap = new Map();
      const awayMap = new Map();
      
      data.forEach(p => {
        const venue = (p.team_venue || '').toLowerCase();
        const map = venue === 'home' ? homeMap : awayMap;
        if (!map.has(p.player_id)) {
          map.set(p.player_id, { 
            id: p.player_id, 
            num: String(p.player_game_number), 
            name: p.player_full_name, 
            pos: normalizePosition(p.player_position),
            rating: null  // Not in fact_gameroster
          });
        }
      });
      
      S.rosters = { 
        home: Array.from(homeMap.values()).sort((a,b) => parseInt(a.num) - parseInt(b.num)),
        away: Array.from(awayMap.values()).sort((a,b) => parseInt(a.num) - parseInt(b.num))
      };
    }
    
    console.log('Final rosters:', S.rosters.home.length, 'home,', S.rosters.away.length, 'away');
    
    if (S.rosters.home.length === 0 && S.rosters.away.length === 0) {
      toast('No players found for this game', 'warning');
      generateDemoRosters();
    } else {
      toast(`Loaded ${S.rosters.home.length + S.rosters.away.length} players`, 'success');
    }
  } catch(e) { 
    console.error('Failed to load rosters:', e);
    toast('Roster load failed: ' + e.message, 'error');
    generateDemoRosters(); 
  }
}

function generateDemoRosters() {
  S.rosters = {
    home: Array.from({length:12}, (_,i) => ({id:'H'+(i+1), num:String(i+1), name:'Home'+i, pos:i<6?'F':i<10?'D':'G'})),
    away: Array.from({length:12}, (_,i) => ({id:'A'+(i+1), num:String(i+11), name:'Away'+i, pos:i<6?'F':i<10?'D':'G'}))
  };
}

/**
 * Normalize position string to F/D/G format
 * @param {string} pos - Raw position string from database
 * @returns {string} - Normalized position (F, D, or G)
 */
function normalizePosition(pos) {
  if (!pos) return 'F';
  const p = String(pos).toLowerCase().trim();
  if (p === 'g' || p === 'goal' || p === 'goalie' || p === 'goalkeeper' || p === 'goaltender') return 'G';
  if (p === 'd' || p === 'def' || p === 'defense' || p === 'defenseman' || p === 'defenceman') return 'D';
  return 'F'; // Forward by default
}

function loadGameData(gid) {
  try {
    const saved = localStorage.getItem(`bs_${gid}`);
    if (saved) {
      const d = JSON.parse(saved);
      S.events = d.events || []; 
      S.shifts = d.shifts || [];
      S.evtIdx = d.evtIdx || S.events.length; 
      S.shiftIdx = d.shiftIdx || S.shifts.length;
      
      // Restore video timing if saved
      if (d.videoTiming) {
        S.videoTiming = { ...S.videoTiming, ...d.videoTiming };
      }
      if (d.periodLength) {
        S.periodLength = d.periodLength;
      }
    } else {
      S.events = []; S.shifts = []; S.evtIdx = 0; S.shiftIdx = 0;
      // Reset video timing to defaults for new game
      S.videoTiming = {
        videoStartOffset: 0,
        intermission1: 900,
        intermission2: 900,
        timeouts: [],
        youtubeUrl: ''
      };
    }
  } catch(e) { 
    S.events = []; S.shifts = []; S.evtIdx = 0; S.shiftIdx = 0; 
  }
}

// ============================================================
// ZONE AUTO-CALCULATION (switches by period)
// ============================================================
function calculateZone() {
  // Get event_player_1's last XY position
  const evtP1 = S.curr.players.find(p => p.role === 'event_team_player_1');
  if (!evtP1?.xy?.length) return '';
  
  const lastXY = evtP1.xy[evtP1.xy.length - 1];
  if (!lastXY) return '';
  
  // NHL Rink: 200 wide
  // Blue lines at x=75 and x=125 (correct NHL dimensions)
  // 0-75 = left zone, 75-125 = neutral, 125-200 = right zone
  // Use S.homeAttacksRightP1 to determine initial orientation
  // Odd periods (1, 3, OT): Use P1 setting
  // Even periods (2): Flip from P1 setting
  const x = lastXY.x;
  const isOddPeriod = S.period === 1 || S.period === 3 || S.period === 'OT';
  
  // Determine which end is offensive for each team based on configurable setting
  const homeOffensiveRight = isOddPeriod ? S.homeAttacksRightP1 : !S.homeAttacksRightP1;
  
  if (S.evtTeam === 'home') {
    if (homeOffensiveRight) {
      if (x > 125) return 'o';      // Home offensive (right in odd periods)
      else if (x < 75) return 'd';  // Home defensive (left in odd periods)
      else return 'n';
    } else {
      if (x < 75) return 'o';       // Home offensive (left in even periods)
      else if (x > 125) return 'd'; // Home defensive (right in even periods)
      else return 'n';
    }
  } else {
    // Away team is opposite
    if (homeOffensiveRight) {
      if (x < 75) return 'o';       // Away offensive (left in odd periods)
      else if (x > 125) return 'd'; // Away defensive (right in odd periods)
      else return 'n';
    } else {
      if (x > 125) return 'o';      // Away offensive (right in even periods)
      else if (x < 75) return 'd';  // Away defensive (left in even periods)
      else return 'n';
    }
  }
}

function updateZoneLabels() {
  // Update zone labels on rink based on period and configurable setting
  const isOddPeriod = S.period === 1 || S.period === 3 || S.period === 'OT';
  const homeOffensiveRight = isOddPeriod ? S.homeAttacksRightP1 : !S.homeAttacksRightP1;
  const homeShort = (S.homeTeam || 'HOME').toUpperCase().slice(0,6);
  const awayShort = (S.awayTeam || 'AWAY').toUpperCase().slice(0,6);
  
  if (homeOffensiveRight) {
    // Home attacks right
    document.getElementById('leftZoneLbl').textContent = awayShort + ' OFF';
    document.getElementById('rightZoneLbl').textContent = homeShort + ' OFF';
  } else {
    // Home attacks left
    document.getElementById('leftZoneLbl').textContent = homeShort + ' OFF';
    document.getElementById('rightZoneLbl').textContent = awayShort + ' OFF';
  }
}

/**
 * v16: Update team logos in UI
 */
function updateTeamLogos() {
  // Update existing logo img elements
  const homeLogoImg = document.getElementById('homeLogoImg');
  const awayLogoImg = document.getElementById('awayLogoImg');
  
  if (homeLogoImg) {
    if (S.homeLogo) {
      homeLogoImg.src = S.homeLogo;
      homeLogoImg.alt = S.homeTeam;
      homeLogoImg.style.display = 'inline';
    } else {
      homeLogoImg.style.display = 'none';
    }
  }
  
  if (awayLogoImg) {
    if (S.awayLogo) {
      awayLogoImg.src = S.awayLogo;
      awayLogoImg.alt = S.awayTeam;
      awayLogoImg.style.display = 'inline';
    } else {
      awayLogoImg.style.display = 'none';
    }
  }
  
  // Update team dots with team colors
  const homeDot = document.getElementById('homeDot');
  const awayDot = document.getElementById('awayDot');
  if (homeDot) homeDot.style.backgroundColor = S.homeColor || '#3b82f6';
  if (awayDot) awayDot.style.backgroundColor = S.awayColor || '#ef4444';
}

function updateZoneDisplay() {
  const zone = document.getElementById('evtZone').value || calculateZone();
  const el = document.getElementById('zoneDisplay');
  if (zone) {
    const labels = { o: 'OFFENSIVE', d: 'DEFENSIVE', n: 'NEUTRAL' };
    el.innerHTML = `<span class="zone-ind ${zone}">${labels[zone]}</span>`;
  } else { el.innerHTML = ''; }
}

// ============================================================
// SUCCESS AUTO-DERIVATION
// ============================================================
function deriveSuccess() {
  const type = S.curr.type;
  const d1 = document.getElementById('evtD1').value;
  
  // Auto-derive based on event type and detail
  if (type === 'Shot') {
    if (d1.includes('OnNet') || d1.includes('Goal')) return 's';
    if (d1.includes('Missed') || d1.includes('Blocked')) return 'u';
  }
  if (type === 'Pass') {
    if (d1.includes('Completed')) return 's';
    if (d1.includes('Missed') || d1.includes('Intercepted')) return 'u';
  }
  if (type === 'Zone_Entry_Exit') {
    if (d1.includes('Failed')) return 'u';
    if (d1.includes('Entry') || d1.includes('Exit') || d1.includes('Keepin')) return 's';
  }
  if (type === 'Turnover') {
    if (d1.includes('Takeaway')) return 's';
    if (d1.includes('Giveaway')) return 'u';
  }
  if (type === 'Goal') return 's';
  if (type === 'Save') return 's';
  
  return '';
}

/**
 * v16.06: Auto-derive play success for all players based on event success
 * Event team player 1 gets the event success
 * Opposing players get inverse if applicable
 */
function derivePlayerSuccess() {
  const evtSuccess = document.getElementById('evtSuccess').value;
  if (!evtSuccess) return;
  
  S.curr.players.forEach(p => {
    if (p.role === 'event_player_1') {
      // Primary player gets event success
      p.playSuccess = evtSuccess;
    } else if (p.role?.startsWith('event')) {
      // Secondary event players - often also successful if event was
      p.playSuccess = evtSuccess;
    } else if (p.role?.startsWith('opp')) {
      // Opponent players - inverse success for turnovers
      const type = S.curr.type;
      if (type === 'Turnover') {
        p.playSuccess = evtSuccess === 's' ? 'u' : 's';
      }
    }
  });
  
  renderQuickAdd();
  toast('Play success auto-derived from event success', 'info');
}

/**
 * v16.06: Auto-calc pressure for selected player
 */
function autoCalcPressure() {
  detectPressure();
  if (S.selectedPlayer) {
    const pressureSel = document.getElementById('pdPressure');
    if (pressureSel && S.selectedPlayer.pressure) {
      pressureSel.value = S.selectedPlayer.pressure;
      toast(`Pressure set to #${S.selectedPlayer.pressure}`, 'info');
    } else {
      toast('No opponent within pressure distance', 'warning');
    }
  }
}

// ============================================================
// PRESSURE AUTO-DETECTION
// ============================================================
function detectPressure() {
  const pressureDist = parseInt(document.getElementById('pressureDist').value) || 10;
  const pixelsPerFoot = 1; // Adjust based on rink scale (200px = 200ft)
  const threshold = pressureDist * pixelsPerFoot;
  
  // For each event player, check distance to opposing players
  const evtPlayers = S.curr.players.filter(p => p.role?.startsWith('event'));
  const oppPlayers = S.curr.players.filter(p => p.role?.startsWith('opp'));
  
  evtPlayers.forEach(ep => {
    if (!ep.xy?.length) return;
    const epPos = ep.xy[ep.xy.length - 1];
    
    let closestOpp = null;
    let closestDist = Infinity;
    
    oppPlayers.forEach(op => {
      if (!op.xy?.length) return;
      const opPos = op.xy[op.xy.length - 1];
      
      const dist = Math.sqrt(Math.pow(epPos.x - opPos.x, 2) + Math.pow(epPos.y - opPos.y, 2));
      if (dist <= threshold && dist < closestDist) {
        closestDist = dist;
        closestOpp = op;
      }
    });
    
    // v16.06: Auto-set pressure if closest opponent is within threshold
    if (closestOpp) {
      ep.pressure = closestOpp.num;
    }
  });
  
  // Update pressure dropdown if a player is selected
  if (S.selectedPlayer && S.selectedPlayer.role?.startsWith('event')) {
    const pressureSel = document.getElementById('pdPressure');
    if (pressureSel && S.selectedPlayer.pressure) {
      pressureSel.value = S.selectedPlayer.pressure;
    }
  }
}

// ============================================================
// RENDER FUNCTIONS
// ============================================================
function renderAll() {
  renderSlots(); 
  renderRosters(); 
  renderQuickAdd(); 
  renderEvents(); 
  renderMarkers(); 
  updateScores(); 
  updateZoneDisplay(); 
  renderShiftLog(); 
  updateBoxScore();
  updateNextPlaySuggestions();
  updateZoneLabels();
}

function renderShiftLog() {
  const body = document.getElementById('shiftLogBody');
  if (!body) return;
  
  // v6: Filter by period
  let filteredShifts = S.shifts;
  if (S.shiftLogFilter && S.shiftLogFilter !== 'all') {
    filteredShifts = S.shifts.filter(s => String(s.period) === S.shiftLogFilter);
  }
  
  // v6: Show up to 50 shifts (scrollable) in ASCENDING order (oldest to newest)
  const displayShifts = filteredShifts.slice(-50);
  const startIdx = filteredShifts.length - displayShifts.length;
  
  body.innerHTML = displayShifts.map((s, i) => {
    const actualIdx = S.shifts.indexOf(s); // Get actual index in full array
    const stoppageTime = s.stoppageTime || 0;
    const stoppageDisplay = stoppageTime > 0 ? `<span style="color:var(--warn);font-size:7px;">${stoppageTime}s</span>` : '';
    
    // Count players
    const homeCount = ['F1','F2','F3','D1','D2','X'].filter(p => s.home?.[p]?.num).length;
    const awayCount = ['F1','F2','F3','D1','D2','X'].filter(p => s.away?.[p]?.num).length;
    const strength = s.strength || `${homeCount}v${awayCount}`;
    
    return `<div class="log-item" style="grid-template-columns: 20px 20px 32px 32px 35px 40px 20px;font-size:8px;cursor:pointer;" onclick="editShift(${actualIdx})" title="Shift #${actualIdx+1} | ${strength} | Stoppage: ${stoppageTime}s">
      <span>${actualIdx + 1}</span>
      <span>P${s.period}</span>
      <span>${s.start_time}</span>
      <span>${s.end_time}</span>
      <span style="color:var(--accent);">${strength}</span>
      <span style="overflow:hidden;text-overflow:ellipsis;font-size:7px;">${s.stop_type || ''}</span>
      ${stoppageDisplay}
    </div>`;
  }).join('') || '<div style="color:var(--muted);font-size:8px;padding:4px;">No shifts</div>';
}

function editShift(idx) {
  S.editingShiftIdx = idx;
  const shift = S.shifts[idx];
  if (!shift) return;
  
  // Populate dropdowns first
  document.getElementById('editShiftStartType').innerHTML = LISTS.shiftStart.map(t => 
    `<option value="${t}" ${shift.start_type === t ? 'selected' : ''}>${t}</option>`
  ).join('');
  document.getElementById('editShiftStopType').innerHTML = LISTS.shiftStop.map(t => 
    `<option value="${t}" ${shift.stop_type === t ? 'selected' : ''}>${t}</option>`
  ).join('');
  
  // Populate edit shift modal
  document.getElementById('editShiftIdx').textContent = idx + 1;
  document.getElementById('editShiftPeriod').value = shift.period;
  document.getElementById('editShiftStartTime').value = shift.start_time;
  document.getElementById('editShiftEndTime').value = shift.end_time;
  document.getElementById('editShiftStrength').value = shift.strength || '5v5';
  
  // Render players
  renderEditShiftPlayers(shift);
  
  document.getElementById('editShiftModal').classList.add('show');
}

function deriveShiftStartType(idx) {
  // Auto-derive start type from previous event/shift
  if (idx === 0) return 'GameStart';
  
  const prevShift = S.shifts[idx - 1];
  if (prevShift?.stop_type === 'GoalScored') return 'FaceoffAfterGoal';
  if (prevShift?.stop_type === 'Penalty') return 'FaceoffAfterPenalty';
  if (prevShift?.stop_type === 'PeriodEnd') return 'PeriodStart';
  if (prevShift?.stop_type === 'Intermission') return 'PeriodStart';
  
  // Check last event
  const lastEvt = S.events.filter(e => e.period === S.period).slice(-1)[0];
  if (lastEvt?.type === 'Goal') return 'FaceoffAfterGoal';
  if (lastEvt?.type === 'Penalty') return 'FaceoffAfterPenalty';
  if (lastEvt?.type === 'Stoppage') return 'Stoppage';
  
  return 'OnTheFly';
}

function deriveShiftStopType() {
  // Auto-derive stop type from last event in shift
  const lastEvt = S.events.filter(e => e.period === S.period).slice(-1)[0];
  if (!lastEvt) return 'OnTheFly';
  
  if (lastEvt.type === 'Goal' && lastEvt.detail1 === 'Goal_Scored') return 'GoalScored';
  if (lastEvt.type === 'Penalty') return 'Penalty';
  if (lastEvt.type === 'Stoppage') return 'Stoppage';
  if (lastEvt.type === 'Intermission') return 'Intermission';
  
  return 'OnTheFly';
}

function saveEditShift() {
  if (S.editingShiftIdx === null) return;
  const shift = S.shifts[S.editingShiftIdx];
  
  shift.period = parseInt(document.getElementById('editShiftPeriod').value);
  shift.start_time = document.getElementById('editShiftStartTime').value;
  shift.end_time = document.getElementById('editShiftEndTime').value;
  shift.start_type = document.getElementById('editShiftStartType').value;
  shift.stop_type = document.getElementById('editShiftStopType').value;
  
  closeEditShiftModal();
  renderShiftLog();
  autoSave();
  toast('Shift updated', 'success');
}

function deleteShift() {
  if (S.editingShiftIdx === null) return;
  if (!confirm('Delete this shift?')) return;
  
  S.shifts.splice(S.editingShiftIdx, 1);
  closeEditShiftModal();
  renderShiftLog();
  autoSave();
  toast('Shift deleted', 'success');
}

/**
 * v20.6: Insert a new shift BEFORE the current one
 */
function insertShiftBefore() {
  if (S.editingShiftIdx === null) return;
  
  const currentShift = S.shifts[S.editingShiftIdx];
  const prevShift = S.editingShiftIdx > 0 ? S.shifts[S.editingShiftIdx - 1] : null;
  
  // Create new shift with interpolated times
  const newShift = {
    period: currentShift.period,
    start_time: prevShift ? prevShift.end_time : currentShift.start_time,
    end_time: currentShift.start_time,
    start_type: prevShift ? deriveShiftStartType(S.editingShiftIdx) : 'OnTheFly',
    stop_type: 'OnTheFly',
    strength: '5v5',
    home: { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null },
    away: { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null }
  };
  
  // Insert at position
  S.shifts.splice(S.editingShiftIdx, 0, newShift);
  
  // Update current index to point to newly inserted shift
  const newIdx = S.editingShiftIdx;
  S.editingShiftIdx = null; // Clear to allow re-edit
  
  closeEditShiftModal();
  renderShiftLog();
  autoSave();
  toast(`Inserted shift #${newIdx + 1}`, 'success');
  
  // Open the new shift for editing
  setTimeout(() => editShift(newIdx), 100);
}

/**
 * v20.6: Insert a new shift AFTER the current one
 */
function insertShiftAfter() {
  if (S.editingShiftIdx === null) return;
  
  const currentShift = S.shifts[S.editingShiftIdx];
  const nextShift = S.editingShiftIdx < S.shifts.length - 1 ? S.shifts[S.editingShiftIdx + 1] : null;
  
  // Create new shift with interpolated times
  const newShift = {
    period: currentShift.period,
    start_time: currentShift.end_time,
    end_time: nextShift ? nextShift.start_time : currentShift.end_time,
    start_type: deriveShiftStartType(S.editingShiftIdx + 1),
    stop_type: 'OnTheFly',
    strength: '5v5',
    home: { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null },
    away: { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null }
  };
  
  // Insert after current position
  const insertIdx = S.editingShiftIdx + 1;
  S.shifts.splice(insertIdx, 0, newShift);
  
  S.editingShiftIdx = null; // Clear to allow re-edit
  
  closeEditShiftModal();
  renderShiftLog();
  autoSave();
  toast(`Inserted shift #${insertIdx + 1}`, 'success');
  
  // Open the new shift for editing
  setTimeout(() => editShift(insertIdx), 100);
}

/**
 * v20.6: Duplicate the current shift
 */
function duplicateShift() {
  if (S.editingShiftIdx === null) return;
  
  const currentShift = S.shifts[S.editingShiftIdx];
  
  // Deep clone the shift
  const newShift = JSON.parse(JSON.stringify(currentShift));
  
  // Insert after current position
  const insertIdx = S.editingShiftIdx + 1;
  S.shifts.splice(insertIdx, 0, newShift);
  
  S.editingShiftIdx = null;
  
  closeEditShiftModal();
  renderShiftLog();
  autoSave();
  toast(`Duplicated shift ‚Üí #${insertIdx + 1}`, 'success');
  
  // Open the new shift for editing
  setTimeout(() => editShift(insertIdx), 100);
}

/**
 * v20.6: Add a new shift at the end of the list
 */
function addNewShift() {
  const lastShift = S.shifts.length > 0 ? S.shifts[S.shifts.length - 1] : null;
  
  // Create new shift
  const newShift = {
    period: lastShift ? lastShift.period : S.period || 1,
    start_time: lastShift ? lastShift.end_time : '20:00',
    end_time: '',
    start_type: lastShift ? deriveShiftStartType(S.shifts.length) : 'GameStart',
    stop_type: '',
    strength: '5v5',
    home: { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null },
    away: { F1: null, F2: null, F3: null, D1: null, D2: null, G: null, X: null }
  };
  
  // Add to end
  S.shifts.push(newShift);
  const newIdx = S.shifts.length - 1;
  
  renderShiftLog();
  autoSave();
  toast(`Added shift #${newIdx + 1}`, 'success');
  
  // Open the new shift for editing
  setTimeout(() => editShift(newIdx), 100);
}

function closeEditShiftModal() {
  document.getElementById('editShiftModal').classList.remove('show');
  S.editingShiftIdx = null;
}

function showAllShifts() {
  // Show all shifts modal
  const body = document.getElementById('allShiftsBody');
  body.innerHTML = S.shifts.map((s, i) => `
    <tr onclick="editShift(${i})" style="cursor:pointer;">
      <td>${i + 1}</td>
      <td>P${s.period}</td>
      <td>${s.start_time}</td>
      <td>${s.end_time}</td>
      <td>${s.start_type}</td>
      <td>${s.stop_type}</td>
      <td>${s.strength || '-'}</td>
    </tr>
  `).join('') || '<tr><td colspan="7">No shifts</td></tr>';
  
  document.getElementById('allShiftsModal').classList.add('show');
}

function showAllEvents() {
  // Show all events modal
  const body = document.getElementById('allEventsBody');
  body.innerHTML = S.events.map((e, i) => `
    <tr onclick="editEvent(${i})" style="cursor:pointer;">
      <td>${i + 1}</td>
      <td>P${e.period}</td>
      <td>${e.start_time || e.time}</td>
      <td>${e.team === 'home' ? S.homeTeam : S.awayTeam}</td>
      <td>${e.type}</td>
      <td>${e.detail1 || ''}</td>
      <td>${e.players?.map(p => p.num).join(',') || ''}</td>
    </tr>
  `).join('') || '<tr><td colspan="7">No events</td></tr>';
  
  document.getElementById('allEventsModal').classList.add('show');
}

function updateBoxScore() {
  // Update team names
  document.getElementById('teamSumHome').textContent = S.homeTeam?.slice(0,8) || 'HOME';
  document.getElementById('teamSumAway').textContent = S.awayTeam?.slice(0,8) || 'AWAY';
  
  // v7: Calculate player stats - ONLY count event_player_1 for most stats
  const playerStats = {};
  
  // Initialize players from rosters with their correct team
  [...(S.rosters?.home || [])].forEach(p => {
    if (p?.num && !playerStats[p.num]) {
      playerStats[p.num] = { 
        num: p.num, name: p.name?.split(' ').pop() || p.name, team: 'home',
        goals: 0, assists: 0, shots: 0, faceoffs: 0, foWins: 0, foLosses: 0
      };
    }
  });
  [...(S.rosters?.away || [])].forEach(p => {
    if (p?.num && !playerStats[p.num]) {
      playerStats[p.num] = { 
        num: p.num, name: p.name?.split(' ').pop() || p.name, team: 'away',
        goals: 0, assists: 0, shots: 0, faceoffs: 0, foWins: 0, foLosses: 0
      };
    }
  });
  
  S.events.forEach(evt => {
    // v7: ONLY count event_player_1 for goals, shots
    const player1 = evt.players?.find(p => 
      p.role === 'event_team_player_1' || p.role === 'event_player_1'
    );
    const oppPlayer1 = evt.players?.find(p => 
      p.role === 'opp_team_player_1' || p.role === 'opp_player_1'
    );
    
    // Initialize player1 stats if needed
    if (player1?.num && !playerStats[player1.num]) {
      playerStats[player1.num] = { 
        num: player1.num, name: player1.name?.split(' ').pop() || player1.name, team: evt.team,
        goals: 0, assists: 0, shots: 0, faceoffs: 0, foWins: 0, foLosses: 0
      };
    }
    
    if (player1?.num) {
      const ps = playerStats[player1.num];
      // Goals - only event_player_1 on Goal events where detail1 = Goal_Scored
      if (evt.type === 'Goal' && (evt.detail1 === 'Goal_Scored' || evt.detail1 === 'Goal_Shootout' || evt.detail1 === 'Goal_PenaltyShot')) ps.goals++;
      // v15.01: SOG - only shots that reached the net (Shot_OnNetSaved, Shot_OnNetGoal) or Goals
      const d1 = (evt.detail1 || '').toLowerCase();
      if (d1.includes('shot_onnetsaved') || d1.includes('shot_onnetgoal') || d1.includes('goal_scored') || d1.includes('goal_shootout') || d1.includes('goal_penaltyshot')) {
        ps.shots++;
      }
      // v7: Faceoffs - event_player_1 gets FO WIN
      if (evt.type === 'Faceoff') { ps.faceoffs++; ps.foWins++; }
    }
    
    // v7: Faceoff LOSS for opp_player_1
    if (evt.type === 'Faceoff' && oppPlayer1?.num) {
      if (!playerStats[oppPlayer1.num]) {
        const oppTeam = evt.team === 'home' ? 'away' : 'home';
        playerStats[oppPlayer1.num] = { 
          num: oppPlayer1.num, name: oppPlayer1.name?.split(' ').pop() || oppPlayer1.name, team: oppTeam,
          goals: 0, assists: 0, shots: 0, faceoffs: 0, foWins: 0, foLosses: 0
        };
      }
      playerStats[oppPlayer1.num].faceoffs++;
      playerStats[oppPlayer1.num].foLosses++;
    }
    
    // v7: Assists - check for '%assist%' in play_detail_1 or play_detail_2
    evt.players?.forEach(p => {
      if (!p?.num) return;
      const pd1 = (p.playD1 || '').toLowerCase();
      const pd2 = (p.playD2 || '').toLowerCase();
      if (pd1.includes('assist') || pd2.includes('assist')) {
        if (!playerStats[p.num]) {
          playerStats[p.num] = { 
            num: p.num, name: p.name?.split(' ').pop() || p.name, team: evt.team,
            goals: 0, assists: 0, shots: 0, faceoffs: 0, foWins: 0, foLosses: 0
          };
        }
        playerStats[p.num].assists++;
      }
    });
  });
  
  // v7: Organize by team, sort by points
  const homePlayers = Object.values(playerStats)
    .filter(p => p.team === 'home' && (p.goals > 0 || p.assists > 0 || p.shots > 0 || p.faceoffs > 0))
    .sort((a, b) => (b.goals + b.assists) - (a.goals + a.assists) || b.goals - a.goals);
  const awayPlayers = Object.values(playerStats)
    .filter(p => p.team === 'away' && (p.goals > 0 || p.assists > 0 || p.shots > 0 || p.faceoffs > 0))
    .sort((a, b) => (b.goals + b.assists) - (a.goals + a.assists) || b.goals - a.goals);
  
  // Render player box score organized by team
  const tbody = document.getElementById('playerBoxBody');
  let html = '';
  
  // Home players section
  if (homePlayers.length > 0) {
    html += `<tr style="background:rgba(59,130,246,0.15);"><td colspan="6" style="font-size:9px;color:var(--home);font-weight:bold;">${S.homeTeam || 'HOME'}</td></tr>`;
    html += homePlayers.slice(0, 5).map(p => {
      const foPct = p.faceoffs > 0 ? `${p.foWins}/${p.faceoffs}` : '-';
      return `<tr onclick="showPlayerDetail('${p.num}')" style="cursor:pointer;">
        <td>${p.num}</td>
        <td style="max-width:50px;overflow:hidden;text-overflow:ellipsis;">${p.name}</td>
        <td style="font-weight:${p.goals>0?'bold':'normal'};">${p.goals}</td>
        <td>${p.assists}</td>
        <td>${p.shots}</td>
        <td style="font-size:9px;">${foPct}</td>
      </tr>`;
    }).join('');
  }
  
  // Away players section
  if (awayPlayers.length > 0) {
    html += `<tr style="background:rgba(239,68,68,0.15);"><td colspan="6" style="font-size:9px;color:var(--away);font-weight:bold;">${S.awayTeam || 'AWAY'}</td></tr>`;
    html += awayPlayers.slice(0, 5).map(p => {
      const foPct = p.faceoffs > 0 ? `${p.foWins}/${p.faceoffs}` : '-';
      return `<tr onclick="showPlayerDetail('${p.num}')" style="cursor:pointer;">
        <td>${p.num}</td>
        <td style="max-width:50px;overflow:hidden;text-overflow:ellipsis;">${p.name}</td>
        <td style="font-weight:${p.goals>0?'bold':'normal'};">${p.goals}</td>
        <td>${p.assists}</td>
        <td>${p.shots}</td>
        <td style="font-size:9px;">${foPct}</td>
      </tr>`;
    }).join('');
  }
  
  tbody.innerHTML = html || '<tr><td colspan="6" style="color:var(--muted);">No stats yet</td></tr>';
  
  // v16: Team SOG totals - only shots that reached the net (Shot_OnNetSaved, Shot_OnNetGoal) or Goals
  // SOG = event_player_1 events where event_detail = "shot_onnetsaved" OR "shot_onnetgoal" OR goal
  const isSOG = (e) => {
    const d1 = (e.detail1 || '').toLowerCase();
    return d1.includes('shot_onnetsaved') || d1.includes('shot_onnetgoal') || 
           d1.includes('goal_scored') || d1.includes('goal_shootout') || d1.includes('goal_penaltyshot');
  };
  const isGoal = (e) => {
    const d1 = (e.detail1 || '').toLowerCase();
    return e.type === 'Goal' && (d1.includes('goal_scored') || d1.includes('goal_shootout') || d1.includes('goal_penaltyshot'));
  };
  const homeGoals = S.events.filter(e => isGoal(e) && e.team === 'home').length;
  const awayGoals = S.events.filter(e => isGoal(e) && e.team === 'away').length;
  const homeShots = S.events.filter(e => isSOG(e) && e.team === 'home').length;
  const awayShots = S.events.filter(e => isSOG(e) && e.team === 'away').length;
  
  document.getElementById('teamSumHomeScore').textContent = homeGoals;
  document.getElementById('teamSumAwayScore').textContent = awayGoals;
  document.getElementById('teamSumHomeSOG').textContent = homeShots;
  document.getElementById('teamSumAwaySOG').textContent = awayShots;
  
  // v16.02: Update center box score (below events)
  const centerBoxHome = document.getElementById('centerBoxHome');
  const centerBoxAway = document.getElementById('centerBoxAway');
  if (centerBoxHome) centerBoxHome.textContent = S.homeTeam?.slice(0,8) || 'HOME';
  if (centerBoxAway) centerBoxAway.textContent = S.awayTeam?.slice(0,8) || 'AWAY';
  const centerBoxHomeScore = document.getElementById('centerBoxHomeScore');
  const centerBoxAwayScore = document.getElementById('centerBoxAwayScore');
  if (centerBoxHomeScore) centerBoxHomeScore.textContent = homeGoals;
  if (centerBoxAwayScore) centerBoxAwayScore.textContent = awayGoals;
  const centerBoxHomeSOG = document.getElementById('centerBoxHomeSOG');
  const centerBoxAwaySOG = document.getElementById('centerBoxAwaySOG');
  if (centerBoxHomeSOG) centerBoxHomeSOG.textContent = homeShots;
  if (centerBoxAwaySOG) centerBoxAwaySOG.textContent = awayShots;
  
  // Also update header score
  document.getElementById('scoreH').textContent = homeGoals;
  document.getElementById('scoreA').textContent = awayGoals;
}

function showPlayerDetail(num) {
  // Calculate player stats
  const playerStats = calculatePlayerStats();
  const ps = playerStats[num];
  if (!ps) { toast('Player not found', 'error'); return; }
  
  document.getElementById('playerDetailName').textContent = `#${ps.num} ${ps.name}`;
  document.getElementById('pdGoals').textContent = ps.goals;
  document.getElementById('pdAssists').textContent = ps.assists;
  document.getElementById('pdShots').textContent = ps.shots;
  document.getElementById('pdFO').textContent = ps.faceoffs ? Math.round(ps.foWins / ps.faceoffs * 100) + '%' : '-';
  document.getElementById('pdTOI').textContent = formatTOI(ps.toi || 0);
  document.getElementById('pdHits').textContent = ps.hits || 0;
  document.getElementById('pdBlocks').textContent = ps.blocks || 0;
  
  // Recent events for this player
  const recentEvts = S.events.filter(e => e.players?.some(p => p.num === num)).slice(-10);
  document.getElementById('pdRecentEvents').innerHTML = recentEvts.map(e => {
    const role = e.players.find(p => p.num === num)?.role || '';
    return `<div style="padding:2px 0;border-bottom:1px solid var(--border);">P${e.period} ${e.start_time || e.time} - ${e.type} (${role.replace('_team_player_','')})</div>`;
  }).join('') || '<div style="color:var(--muted);">No events</div>';
  
  document.getElementById('playerDetailModal').classList.add('show');
}

function showFullBoxScore() {
  const playerStats = calculatePlayerStats();
  
  // v16: Team totals - only count Goal_Scored for goals, proper SOG calculation
  const isGoal = (e) => {
    const d1 = (e.detail1 || '').toLowerCase();
    return e.type === 'Goal' && (d1.includes('goal_scored') || d1.includes('goal_shootout') || d1.includes('goal_penaltyshot'));
  };
  const isSOG = (e) => {
    const d1 = (e.detail1 || '').toLowerCase();
    return d1.includes('shot_onnetsaved') || d1.includes('shot_onnetgoal') || 
           d1.includes('goal_scored') || d1.includes('goal_shootout') || d1.includes('goal_penaltyshot');
  };
  const homeGoals = S.events.filter(e => isGoal(e) && e.team === 'home').length;
  const awayGoals = S.events.filter(e => isGoal(e) && e.team === 'away').length;
  const homeShots = S.events.filter(e => isSOG(e) && e.team === 'home').length;
  const awayShots = S.events.filter(e => isSOG(e) && e.team === 'away').length;
  const homeFO = S.events.filter(e => e.type === 'Faceoff' && e.team === 'home' && (e.success === 's' || e.success === 'Y')).length;
  const awayFO = S.events.filter(e => e.type === 'Faceoff' && e.team === 'away' && (e.success === 's' || e.success === 'Y')).length;
  
  document.getElementById('boxModalHome').textContent = S.homeTeam;
  document.getElementById('boxModalAway').textContent = S.awayTeam;
  document.getElementById('boxModalHomeScore').textContent = homeGoals;
  document.getElementById('boxModalAwayScore').textContent = awayGoals;
  document.getElementById('boxModalHomeSOG').textContent = homeShots;
  document.getElementById('boxModalAwaySOG').textContent = awayShots;
  document.getElementById('boxModalHomeFO').textContent = homeFO;
  document.getElementById('boxModalAwayFO').textContent = awayFO;
  
  // v6: Organize player table by team (home first, then away), then by points
  const allStats = Object.values(playerStats);
  const homeStats = allStats.filter(p => p.team === 'home').sort((a, b) => 
    (b.goals + b.assists) - (a.goals + a.assists) || b.goals - a.goals
  );
  const awayStats = allStats.filter(p => p.team === 'away').sort((a, b) => 
    (b.goals + b.assists) - (a.goals + a.assists) || b.goals - a.goals
  );
  
  // Build table HTML with team headers
  let tableHtml = '';
  
  // Home team section
  if (homeStats.length > 0) {
    tableHtml += `<tr style="background:var(--home);color:#fff;"><td colspan="9" style="padding:4px 8px;font-weight:bold;">${S.homeTeam || 'HOME'}</td></tr>`;
    tableHtml += homeStats.map(p => {
      const foPct = p.faceoffs ? Math.round(p.foWins / p.faceoffs * 100) : '-';
      return `<tr onclick="showPlayerDetail('${p.num}')" style="cursor:pointer;border-left:3px solid var(--home);">
        <td>${p.num}</td>
        <td>${p.name}</td>
        <td>-</td>
        <td style="font-weight:${p.goals>0?'bold':'normal'};">${p.goals}</td>
        <td>${p.assists}</td>
        <td style="font-weight:bold;">${p.goals + p.assists}</td>
        <td>${p.shots}</td>
        <td>${foPct}${foPct !== '-' ? '%' : ''}</td>
        <td>${formatTOI(p.toi || 0)}</td>
      </tr>`;
    }).join('');
  }
  
  // Away team section
  if (awayStats.length > 0) {
    tableHtml += `<tr style="background:var(--away);color:#fff;"><td colspan="9" style="padding:4px 8px;font-weight:bold;">${S.awayTeam || 'AWAY'}</td></tr>`;
    tableHtml += awayStats.map(p => {
      const foPct = p.faceoffs ? Math.round(p.foWins / p.faceoffs * 100) : '-';
      return `<tr onclick="showPlayerDetail('${p.num}')" style="cursor:pointer;border-left:3px solid var(--away);">
        <td>${p.num}</td>
        <td>${p.name}</td>
        <td>-</td>
        <td style="font-weight:${p.goals>0?'bold':'normal'};">${p.goals}</td>
        <td>${p.assists}</td>
        <td style="font-weight:bold;">${p.goals + p.assists}</td>
        <td>${p.shots}</td>
        <td>${foPct}${foPct !== '-' ? '%' : ''}</td>
        <td>${formatTOI(p.toi || 0)}</td>
      </tr>`;
    }).join('');
  }
  
  document.getElementById('boxModalBody').innerHTML = tableHtml || '<tr><td colspan="9">No stats</td></tr>';
  
  document.getElementById('boxScoreModal').classList.add('show');
}

function calculatePlayerStats() {
  const stats = {};
  
  // Initialize from rosters
  [...S.rosters.home, ...S.rosters.away].forEach(p => {
    stats[p.num] = {
      num: p.num,
      name: p.name,
      team: S.rosters.home.includes(p) ? 'home' : 'away',
      goals: 0, assists: 0, shots: 0, faceoffs: 0, foWins: 0, foLosses: 0, hits: 0, blocks: 0, toi: 0
    };
  });
  
  // v6: Calculate from events - only count event_player_1 for most stats
  S.events.forEach(evt => {
    evt.players?.forEach(p => {
      if (!stats[p.num]) {
        stats[p.num] = { num: p.num, name: p.name, team: evt.team, goals: 0, assists: 0, shots: 0, faceoffs: 0, foWins: 0, foLosses: 0, hits: 0, blocks: 0, toi: 0 };
      }
      const ps = stats[p.num];
      
      // Goals - only event_player_1 is the scorer
      if (evt.type === 'Goal' && evt.detail1 === 'Goal_Scored' && p.role === 'event_player_1') {
        ps.goals++;
      }
      
      // v6: Assists - check for '%assist%' in play_detail1 or play_detail2
      if (evt.type === 'Goal' && evt.detail1 === 'Goal_Scored') {
        const pd1Lower = (p.playD1 || '').toLowerCase();
        const pd2Lower = (p.playD2 || '').toLowerCase();
        if (pd1Lower.includes('assist') || pd2Lower.includes('assist')) {
          ps.assists++;
        }
      }
      
      // Shots - only event_player_1
      if ((evt.type === 'Shot' || evt.type === 'Goal') && p.role === 'event_player_1') {
        ps.shots++;
      }
      
      // v6: Faceoffs - event_player_1 = FO taken for event team
      // FO win = event_player_1 when event success = 's' 
      // FO loss = opp_player_1 on same event (they lost)
      if (evt.type === 'Faceoff') {
        if (p.role === 'event_player_1') {
          ps.faceoffs++;
          if (evt.success === 's' || evt.success === 'Y' || evt.success === true) {
            ps.foWins++;
          } else {
            ps.foLosses++;
          }
        }
        // The opp_player_1 on a faceoff = the opposing center who took the draw
        if (p.role === 'opp_player_1') {
          ps.faceoffs++;
          if (evt.success === 's' || evt.success === 'Y' || evt.success === true) {
            // Event team won, so opp lost
            ps.foLosses++;
          } else {
            // Event team lost, so opp won
            ps.foWins++;
          }
        }
      }
      
      // Hits - only event_player_1
      if (evt.type === 'Hit' && p.role === 'event_player_1') ps.hits++;
      
      // Blocks - opponent blocked the shot
      if (evt.detail1?.includes('Blocked') && p.role?.startsWith('opp')) ps.blocks++;
    });
  });
  
  // Calculate TOI from shifts
  S.shifts.forEach(shift => {
    const duration = parseTime(shift.start_time) - parseTime(shift.end_time);
    if (duration <= 0) return;
    
    ['home', 'away'].forEach(team => {
      ['F1','F2','F3','D1','D2','G','X'].forEach(pos => {
        const p = shift[team]?.[pos];
        if (p?.num && stats[p.num]) {
          stats[p.num].toi += duration;
        }
      });
    });
  });
  
  return stats;
}

function parseTime(timeStr) {
  if (!timeStr) return 0;
  const [min, sec] = timeStr.split(':').map(Number);
  return (min || 0) * 60 + (sec || 0);
}

function formatTOI(seconds) {
  if (!seconds) return '--:--';
  const min = Math.floor(seconds / 60);
  const sec = Math.floor(seconds % 60);
  return `${min}:${sec.toString().padStart(2, '0')}`;
}

function updateNextPlaySuggestions() {
  const lastEvt = S.events[S.events.length - 1];
  const suggestions = lastEvt ? (LISTS.nextEventSuggestions[lastEvt.type] || []) : ['Faceoff'];
  
  document.getElementById('nextPlaySuggestions').innerHTML = suggestions.map(t => 
    `<button class="btn-sm" onclick="selectNextEvent('${t}')" style="margin:0 2px;">${t}</button>`
  ).join('');
  
  // Update linked event dropdown
  updateLinkedEventsDropdown();
  
  // v23.3: Highlight suggested event buttons
  highlightSuggestedEvent();
  
  // v23.3: If sequence mode is on, auto-link to last event
  if (sequenceModeActive && lastEvt) {
    S.linkedEventIdx = lastEvt.idx;
    const linkedEl = document.getElementById('linkedEvt');
    if (linkedEl) linkedEl.value = lastEvt.idx + 1;
    document.getElementById('evtStartTime').value = lastEvt.start_time || lastEvt.end_time || '';
  }
}

function selectNextEvent(type) {
  // Get the last event to carry over data
  const lastEvt = S.events[S.events.length - 1];
  
  // Set the event type
  setEvtType(type);
  
  // Carry over all player data if appropriate
  if (lastEvt) {
    // Carry over all players on ice (keep XY positions)
    if (LISTS.linkedEvents[type]?.includes(lastEvt.type)) {
      // Auto-link
      S.linkedEventIdx = lastEvt.idx;
      document.getElementById('linkedEvtSelect').value = lastEvt.idx;
      
      // Copy players with XY
      S.curr.players = lastEvt.players.map(p => ({
        ...p,
        xy: [...(p.xy || [])] // Clone XY array
      }));
      
      // Copy puck XY
      if (lastEvt.puckXY?.length) {
        S.curr.puckXY = [...lastEvt.puckXY];
      }
      
      // Copy zone and time
      document.getElementById('evtZone').value = lastEvt.zone || '';
      document.getElementById('evtStartTime').value = lastEvt.start_time || lastEvt.end_time || '';
    }
    
    // Special cases for role swaps (Shot‚ÜíSave: shooter becomes opp)
    if (type === 'Save' && lastEvt.type === 'Shot') {
      S.curr.players = lastEvt.players.map(p => ({
        ...p,
        role: p.role?.startsWith('event') ? p.role.replace('event', 'opp') : p.role.replace('opp', 'event'),
        xy: [...(p.xy || [])]
      }));
      // Swap event team
      S.evtTeam = S.evtTeam === 'home' ? 'away' : 'home';
      updateEvtTeamUI();
    }
  }
  
  renderQuickAdd();
  renderMarkers();
  toast(`${type} - data carried over`, 'success');
}

function updateEvtTeamUI() {
  document.querySelectorAll('.team-toggle button').forEach(b => b.classList.remove('active'));
  document.querySelector(`.team-toggle .${S.evtTeam}`).classList.add('active');
}

function updateLinkedEventsDropdown() {
  const sel = document.getElementById('linkedEvtSelect');
  if (!sel) return;
  
  // Show last 10 events for linking
  const recentEvents = S.events.slice(-10).reverse();
  sel.innerHTML = '<option value="">-- None --</option>' + recentEvents.map(e => {
    const time = e.start_time || e.time || '';
    const players = e.players?.map(p => p.num).join(',') || '';
    return `<option value="${e.idx}">#${e.idx + 1} ${e.type} ${time} [${players}]</option>`;
  }).join('');
  
  // Auto-suggest link based on current event type
  if (S.curr.type && recentEvents.length) {
    const lastEvt = recentEvents[0];
    const canLink = LISTS.linkedEvents[S.curr.type];
    if (canLink && canLink.includes(lastEvt.type)) {
      sel.value = lastEvt.idx;
      S.linkedEventIdx = lastEvt.idx;
      document.getElementById('linkedEvtInfo').textContent = `‚Üê Auto-linked to ${lastEvt.type}`;
      // Apply linked data
      applyLinkedEventData();
    } else {
      document.getElementById('linkedEvtInfo').textContent = '';
    }
  }
}

function onLinkedEvtChange() {
  const val = document.getElementById('linkedEvtSelect').value;
  S.linkedEventIdx = val ? parseInt(val) : null;
  if (S.linkedEventIdx) {
    applyLinkedEventData();
  }
}

// ============================================================
// AUTO BUTTONS
// ============================================================
function autoZone() {
  const zone = calculateZone();
  if (zone) {
    document.getElementById('evtZone').value = zone;
    toast(`Zone: ${zone === 'o' ? 'Offensive' : zone === 'd' ? 'Defensive' : 'Neutral'}`, 'success');
  } else {
    toast('Add player XY to auto-detect zone', 'error');
  }
}

function autoSuccess() {
  const success = deriveSuccess();
  if (success) {
    document.getElementById('evtSuccess').value = success;
    toast(`Success: ${success === 's' ? 'Successful' : 'Unsuccessful'}`, 'success');
  } else {
    toast('Select event type and detail first', 'error');
  }
}

/**
 * v16: Auto-calculate side of puck based on zone and player team
 */
function autoSideOfPuck() {
  if (!S.selectedPlayer) {
    toast('Select a player first', 'error');
    return;
  }
  
  const zone = document.getElementById('evtZone').value;
  if (!zone) {
    toast('Set zone first', 'error');
    return;
  }
  
  // Determine if player is on event team or opponent
  const isEventTeam = S.selectedPlayer.role?.startsWith('event');
  const eventTeam = S.evtTeam; // 'home' or 'away'
  const playerTeam = isEventTeam ? eventTeam : (eventTeam === 'home' ? 'away' : 'home');
  
  // Calculate side of puck relative to player's team
  // If player is home and zone is offensive (attacking their opponent's goal), they're offensive
  // Zone is always from the event team's perspective
  let sideOfPuck;
  if (playerTeam === eventTeam) {
    // Same team as event - zone matches directly
    sideOfPuck = zone === 'o' ? 'Offensive' : (zone === 'd' ? 'Defensive' : '');
  } else {
    // Opponent team - zone is inverted
    sideOfPuck = zone === 'o' ? 'Defensive' : (zone === 'd' ? 'Offensive' : '');
  }
  
  if (sideOfPuck) {
    document.getElementById('pdSideOfPuck').value = sideOfPuck;
    updatePlayerDetail('sideOfPuck', sideOfPuck);
    toast(`Side of puck: ${sideOfPuck}`, 'success');
  } else {
    toast('Could not determine side (neutral zone)', 'info');
  }
}

function autoStrength() {
  const strength = deriveStrength();
  if (strength) {
    document.getElementById('evtStrength').value = strength;
    toast(`Strength: ${strength}`, 'success');
  } else {
    toast('Fill player slots first', 'error');
  }
}

function updatePlayD2() {
  // Update Play Detail 2 dropdown based on Play Detail 1
  if (!S.selectedPlayer) return;
  
  const d1 = document.getElementById('pdPlayD1').value;
  // v15.02: Use S.playDetails2 from dim_play_detail_2 for second dropdown
  // These are independent of the first dropdown selection
  const pd2Opts = S.playDetails2?.length > 0 
    ? S.playDetails2.map(p => p.name) 
    : [];
  
  // v16.02: Use datalist for searchable dropdown
  document.getElementById('pdPlayD2List').innerHTML = pd2Opts.map(o => `<option value="${o}">`).join('');
}

function deriveStrength() {
  // Count players on ice (excluding empty slots)
  const homeOnIce = Object.values(S.slots.home).filter(Boolean).length;
  const awayOnIce = Object.values(S.slots.away).filter(Boolean).length;
  
  // Check for goalie
  const homeHasGoalie = !!S.slots.home.G;
  const awayHasGoalie = !!S.slots.away.G;
  
  // Calculate skaters
  const homeSkaters = homeOnIce - (homeHasGoalie ? 1 : 0);
  const awaySkaters = awayOnIce - (awayHasGoalie ? 1 : 0);
  
  // Empty net situations
  if (!homeHasGoalie && homeOnIce >= 5) return 'ENA'; // Empty net away (extra attacker for home)
  if (!awayHasGoalie && awayOnIce >= 5) return 'ENH'; // Empty net home
  
  // Standard situations
  if (homeSkaters === 5 && awaySkaters === 5) return '5v5';
  if (homeSkaters === 5 && awaySkaters === 4) return '5v4';
  if (homeSkaters === 4 && awaySkaters === 5) return '4v5';
  if (homeSkaters === 4 && awaySkaters === 4) return '4v4';
  if (homeSkaters === 5 && awaySkaters === 3) return '5v3';
  if (homeSkaters === 3 && awaySkaters === 5) return '3v5';
  if (homeSkaters === 3 && awaySkaters === 3) return '3v3';
  
  return `${homeSkaters}v${awaySkaters}`;
}

function renderSlots() {
  ['home','away'].forEach(team => {
    ['F1','F2','F3','D1','D2','G','X'].forEach(pos => {
      const el = document.querySelector(`.slot[data-team="${team}"][data-pos="${pos}"]`);
      if (!el) return;
      const p = S.slots[team][pos];
      if (p) { 
        el.innerHTML = `<span class="clear-x" onclick="event.stopPropagation();clearSlot('${team}','${pos}')" title="Remove ${p.name}">‚úï</span><span class="num">${p.num}</span><span class="name">${p.name}</span>`; 
        el.classList.add('filled');
        el.draggable = true;
      }
      else { 
        el.innerHTML = `<span class="num">${pos}</span>`; 
        el.classList.remove('filled'); 
        el.draggable = false;
      }
    });
  });
}

// ============================================================
// SLOT DRAG AND DROP
// ============================================================
let draggedSlot = null;

function setupSlotDragDrop() {
  document.querySelectorAll('.slot').forEach(slot => {
    slot.addEventListener('dragstart', handleSlotDragStart);
    slot.addEventListener('dragend', handleSlotDragEnd);
    slot.addEventListener('dragover', handleSlotDragOver);
    slot.addEventListener('dragleave', handleSlotDragLeave);
    slot.addEventListener('drop', handleSlotDrop);
  });
}

function handleSlotDragStart(e) {
  const team = this.dataset.team;
  const pos = this.dataset.pos;
  if (!S.slots[team][pos]) return; // Can't drag empty slot
  
  draggedSlot = { team, pos, player: S.slots[team][pos] };
  this.classList.add('dragging');
  e.dataTransfer.effectAllowed = 'move';
  e.dataTransfer.setData('text/plain', JSON.stringify(draggedSlot));
}

function handleSlotDragEnd(e) {
  this.classList.remove('dragging');
  document.querySelectorAll('.slot').forEach(s => s.classList.remove('drag-over'));
  draggedSlot = null;
}

function handleSlotDragOver(e) {
  e.preventDefault();
  if (!draggedSlot) return;
  e.dataTransfer.dropEffect = 'move';
  this.classList.add('drag-over');
}

function handleSlotDragLeave(e) {
  this.classList.remove('drag-over');
}

function handleSlotDrop(e) {
  e.preventDefault();
  this.classList.remove('drag-over');
  
  if (!draggedSlot) return;
  
  const targetTeam = this.dataset.team;
  const targetPos = this.dataset.pos;
  const sourceTeam = draggedSlot.team;
  const sourcePos = draggedSlot.pos;
  
  // Get what's in the target slot (if anything)
  const targetPlayer = S.slots[targetTeam][targetPos];
  
  // Swap the players
  S.slots[targetTeam][targetPos] = draggedSlot.player;
  S.slots[sourceTeam][sourcePos] = targetPlayer; // Will be null if target was empty
  
  renderSlots();
  renderRosters();
  renderQuickAdd();
  onSlotsChanged();
  
  // Show feedback
  if (sourceTeam !== targetTeam) {
    toast(`Moved #${draggedSlot.player.num} to ${targetTeam.toUpperCase()} ${targetPos}`, 'info');
  }
}

function renderRosters() {
  ['home','away'].forEach(team => {
    const onIce = Object.values(S.slots[team]).filter(Boolean).map(p => p.num);
    const roster = S.rosters[team];
    
    // Group by position
    const groups = { F: [], D: [], G: [] };
    roster.forEach(p => {
      const pos = (p.pos || 'F').toUpperCase();
      if (pos === 'G') groups.G.push(p);
      else if (pos === 'D' || pos === 'LD' || pos === 'RD') groups.D.push(p);
      else groups.F.push(p);
    });
    
    // Render grouped roster
    let html = '';
    ['F', 'D', 'G'].forEach(grp => {
      if (groups[grp].length === 0) return;
      html += `<div class="roster-group"><span class="roster-group-label">${grp === 'F' ? 'Forwards' : grp === 'D' ? 'Defense' : 'Goalie'}</span>`;
      html += groups[grp].map(p => {
        const used = onIce.includes(p.num);
        const lastName = getLastName(p.name);
        const rating = p.rating ? `<span class="rating">${p.rating}</span>` : '';
        return `<button class="roster-btn ${used?'on-ice':''}" onclick="assignPlayer('${team}','${p.num}')"><span class="num">${p.num}</span><span class="name">${lastName}</span>${rating}</button>`;
      }).join('');
      html += '</div>';
    });
    
    document.getElementById(`${team}Roster`).innerHTML = html;
  });
}

function getLastName(fullName) {
  if (!fullName) return '?';
  const parts = fullName.trim().split(' ');
  return parts[parts.length - 1];
}

function renderQuickAdd() {
  const evtTeam = S.evtTeam;
  const oppTeam = evtTeam === 'home' ? 'away' : 'home';
  const onIce = num => Object.values(S.slots[evtTeam]).some(p => p?.num === num);
  const oppOnIce = num => Object.values(S.slots[oppTeam]).some(p => p?.num === num);
  const inEvt = num => S.curr.players.some(p => p.num === num);
  
  // v23.4: Get recent players for highlighting
  const recentPlayers = getRecentPlayers();
  const isRecent = num => recentPlayers.includes(num);
  
  // Event quick add - players on ice for event team (recent players first)
  const evtOnIcePlayers = S.rosters[evtTeam].filter(p => onIce(p.num));
  const evtSorted = [...evtOnIcePlayers].sort((a, b) => {
    const aRecent = isRecent(a.num) ? 0 : 1;
    const bRecent = isRecent(b.num) ? 0 : 1;
    return aRecent - bRecent;
  });
  
  document.getElementById('evtQuickAdd').innerHTML = evtSorted
    .map(p => `<button class="${inEvt(p.num)?'in-evt':''} ${isRecent(p.num)?'recent':''}" onclick="togglePlayer('${p.num}','evt')" title="${p.name}${isRecent(p.num)?' (recent)':''}">${p.num}</button>`).join('');
  
  // Opp quick add (recent players first)
  const oppOnIcePlayers = S.rosters[oppTeam].filter(p => oppOnIce(p.num));
  const oppSorted = [...oppOnIcePlayers].sort((a, b) => {
    const aRecent = isRecent(a.num) ? 0 : 1;
    const bRecent = isRecent(b.num) ? 0 : 1;
    return aRecent - bRecent;
  });
  
  document.getElementById('oppQuickAdd').innerHTML = oppSorted
    .map(p => `<button class="${inEvt(p.num)?'in-evt':''} ${isRecent(p.num)?'recent':''}" onclick="togglePlayer('${p.num}','opp')" title="${p.name}${isRecent(p.num)?' (recent)':''}">${p.num}</button>`).join('');
  
  // Event players display
  const evtPs = S.curr.players.filter(p => p.role?.startsWith('event'));
  document.getElementById('evtPlayers').innerHTML = evtPs.map((p, idx) => {
    const sel = S.selectedPlayer?.num === p.num;
    const xyCount = p.xy?.length || 0;
    const suClass = p.playSuccess ? (p.playSuccess === 's' ? 's' : 'u') : '';
    const roleLabel = p.roleNum || '?';
    return `<span class="player-chip evt ${sel?'selected':''}" draggable="true" data-num="${p.num}" data-role="evt" data-idx="${idx}" onclick="selectPlayer('${p.num}')" ondragstart="handlePlayerDragStart(event)" ondragend="handlePlayerDragEnd(event)" ondragover="handlePlayerDragOver(event)" ondrop="handlePlayerDrop(event)"><span class="role-num">E${roleLabel}</span><span class="num">${p.num}</span>${p.name}${xyCount?`<span style="color:var(--accent);font-size:7px;">‚óè${xyCount}</span>`:''}${p.playSuccess?`<span class="su ${suClass}">${p.playSuccess}</span>`:''}<span class="remove" onclick="event.stopPropagation();removePlayer('${p.num}')">‚úï</span></span>`;
  }).join('') || '<span style="color:var(--muted);font-size:8px;">Click players below</span>';
  
  // Opp players display
  const oppPs = S.curr.players.filter(p => p.role?.startsWith('opp'));
  document.getElementById('oppPlayers').innerHTML = oppPs.map((p, idx) => {
    const sel = S.selectedPlayer?.num === p.num;
    const xyCount = p.xy?.length || 0;
    const suClass = p.playSuccess ? (p.playSuccess === 's' ? 's' : 'u') : '';
    const roleLabel = p.roleNum || '?';
    return `<span class="player-chip opp ${sel?'selected':''}" draggable="true" data-num="${p.num}" data-role="opp" data-idx="${idx}" onclick="selectPlayer('${p.num}')" ondragstart="handlePlayerDragStart(event)" ondragend="handlePlayerDragEnd(event)" ondragover="handlePlayerDragOver(event)" ondrop="handlePlayerDrop(event)"><span class="role-num">O${roleLabel}</span><span class="num">${p.num}</span>${p.name}${xyCount?`<span style="color:var(--accent);font-size:7px;">‚óè${xyCount}</span>`:''}${p.playSuccess?`<span class="su ${suClass}">${p.playSuccess}</span>`:''}<span class="remove" onclick="event.stopPropagation();removePlayer('${p.num}')">‚úï</span></span>`;
  }).join('') || '<span style="color:var(--muted);font-size:8px;">Click players below</span>';
  
  // Player selector for XY - v23.4: Always show when players exist, clearer options
  const sel = document.getElementById('xyPlayerSel');
  if (S.curr.players.length > 0) {
    sel.style.display = 'inline-block';
    const puckOption = S.xyMode === 'puck' 
      ? '<option value="" selected>üèí Puck mode</option>'
      : '<option value="">üèí Switch to Puck</option>';
    sel.innerHTML = puckOption + 
      S.curr.players.map(p => {
        const xyCount = p.xy?.length || 0;
        const selected = S.selectedPlayer?.num === p.num;
        return `<option value="${p.num}" ${selected?'selected':''}>#${p.num} ${p.name}${xyCount ? ` (${xyCount}pt)` : ''}</option>`;
      }).join('');
  } else { 
    sel.style.display = 'none'; 
  }
  
  // Player details panel
  const pdEl = document.getElementById('playerDetails');
  if (S.selectedPlayer) {
    pdEl.style.display = 'block';
    document.getElementById('pdPlayerNum').textContent = '#' + S.selectedPlayer.num + ' ' + S.selectedPlayer.name;
    // v15.01: Use S.playDetails1 from dim_play_detail for first dropdown
    const pd1Opts = S.playDetails1?.length > 0 
      ? S.playDetails1.map(p => p.name) 
      : (document.getElementById('evtZone').value === 'd' ? LISTS.playDefensive : LISTS.playOffensive);
    // v16.02: Use datalist for searchable dropdowns
    document.getElementById('pdPlayD1List').innerHTML = pd1Opts.map(o => `<option value="${o}">`).join('');
    document.getElementById('pdPlayD1').value = S.selectedPlayer.playD1 || '';
    // v15.01: Use S.playDetails2 from dim_play_detail_2 for second dropdown
    const pd2Opts = S.playDetails2?.length > 0 
      ? S.playDetails2.map(p => p.name) 
      : [];
    document.getElementById('pdPlayD2List').innerHTML = pd2Opts.map(o => `<option value="${o}">`).join('');
    document.getElementById('pdPlayD2').value = S.selectedPlayer.playD2 || '';
    document.getElementById('pdPlaySuccess').value = S.selectedPlayer.playSuccess || '';
    // v16: Side of puck dropdown
    document.getElementById('pdSideOfPuck').value = S.selectedPlayer.sideOfPuck || '';
    
    // Pressure dropdown - opposing players
    const oppTeam = S.evtTeam === 'home' ? 'away' : 'home';
    const oppInEvt = S.curr.players.filter(p => p.role?.startsWith('opp'));
    document.getElementById('pdPressure').innerHTML = '<option value="">--</option>' + oppInEvt.map(p => `<option value="${p.num}" ${S.selectedPlayer.pressure===p.num?'selected':''}>#${p.num}</option>`).join('');
  } else { pdEl.style.display = 'none'; }
}

function renderXYSlots() {
  const el = document.getElementById('xySlots');
  const max = 6;
  let data = S.xyMode === 'puck' ? S.curr.puckXY : (S.selectedPlayer?.xy || []);
  el.innerHTML = Array.from({length: max}, (_, i) => {
    const has = data[i];
    const active = S.xySlot === i + 1;
    return `<button class="xy-slot ${has?'has':''} ${active?'active':''}" onclick="setXYSlot(${i+1})" title="Slot ${i+1}${has?' (filled)':' (empty)'}">${i+1}</button>`;
  }).join('');
  
  // v23.4: Update slot indicator
  const indicator = document.getElementById('xySlotIndicator');
  if (indicator) {
    const filledCount = data.filter(Boolean).length;
    indicator.textContent = filledCount > 0 ? `(${filledCount} pts)` : '‚Üí click rink';
  }
}

function renderEvents() {
  const body = document.getElementById('evtListBody');
  if (!body) {
    console.error('evtListBody element not found!');
    return;
  }
  
  // v20.4: Populate filter dropdowns with current values
  populateEventFilterDropdowns();
  
  // v16.04: Debug - log event periods
  console.log('renderEvents called');
  console.log('  S.events count:', S.events?.length || 0);
  console.log('  S.eventLogFilter:', S.eventLogFilter);
  
  // v15.02: Period filter
  let filteredEvents = S.events || [];
  const periodFilter = (S.eventLogFilter || 'all').toLowerCase();
  
  if (periodFilter && periodFilter !== 'all') {
    filteredEvents = filteredEvents.filter(e => {
      const evtPeriod = String(e.period || '').toLowerCase();
      if (periodFilter === 'ot') {
        return evtPeriod === 'ot' || evtPeriod === '4' || parseInt(evtPeriod) > 3;
      }
      return evtPeriod === periodFilter;
    });
  }
  
  // v20.4: Apply advanced filters
  const f = S.eventFilters || {};
  
  if (f.type) {
    filteredEvents = filteredEvents.filter(e => e.type === f.type);
  }
  if (f.detail1) {
    filteredEvents = filteredEvents.filter(e => (e.detail1 || e.detail) === f.detail1);
  }
  if (f.detail2) {
    filteredEvents = filteredEvents.filter(e => e.detail2 === f.detail2);
  }
  if (f.playDetail1) {
    filteredEvents = filteredEvents.filter(e => {
      const p1 = (e.players || []).find(p => p.role?.startsWith('event') || !p.role?.startsWith('opp'));
      return p1?.playD1 === f.playDetail1;
    });
  }
  if (f.playDetail2) {
    filteredEvents = filteredEvents.filter(e => {
      const p1 = (e.players || []).find(p => p.role?.startsWith('event') || !p.role?.startsWith('opp'));
      return p1?.playD2 === f.playDetail2;
    });
  }
  if (f.team) {
    filteredEvents = filteredEvents.filter(e => e.team === f.team);
  }
  if (f.eventIdx !== null && f.eventIdx !== undefined) {
    filteredEvents = filteredEvents.filter(e => S.events.indexOf(e) + 1 === f.eventIdx);
  }
  if (f.linkedIdx !== null && f.linkedIdx !== undefined) {
    filteredEvents = filteredEvents.filter(e => e.linkedEventIdx !== null && e.linkedEventIdx + 1 === f.linkedIdx);
  }
  if (f.shiftIdx !== null && f.shiftIdx !== undefined) {
    filteredEvents = filteredEvents.filter(e => e.shiftIdx === f.shiftIdx || e.shift_index === f.shiftIdx);
  }
  
  // Debug log
  console.log('  After filters: ' + filteredEvents.length + ' events to display');
  
  body.innerHTML = filteredEvents.map((e) => {
    const i = S.events.indexOf(e); // Get actual index in full array
    
    // Get event players and opp players
    const evtPlayers = (e.players || []).filter(p => p.role?.startsWith('event') || !p.role?.startsWith('opp'));
    const oppPlayers = (e.players || []).filter(p => p.role?.startsWith('opp'));
    
    const evtPlayerStr = evtPlayers.map(p => p.num).join(',') || '-';
    const oppPlayerStr = oppPlayers.map(p => p.num).join(',') || '-';
    
    // Get primary player info
    const primaryPlayer = evtPlayers[0];
    const primaryPD1 = primaryPlayer?.playD1?.replace('Play-','').replace(/_/g,' ').substring(0,10) || '';
    const primaryPD2 = primaryPlayer?.playD2?.replace('Play-','').replace(/_/g,' ').substring(0,10) || '';
    const primarySuccess = primaryPlayer?.playSuccess || '';
    
    // Other display values
    const hasXY = e.puckXY?.length || e.players?.some(p => p.xy?.length);
    const timeDisplay = e.start_time || e.time || '';
    const highlight = e.isHighlight ? '‚≠ê' : '';
    const linked = e.linkedEventIdx !== null && e.linkedEventIdx !== undefined ? e.linkedEventIdx + 1 : '';
    const detail = e.detail1 || e.detail || '';
    const detail2 = e.detail2 || '';
    const zone = e.zone ? e.zone.substring(0,1).toUpperCase() : '';
    const success = e.success === true || e.success === 1 || e.success === 's' || e.success === 'Y' ? '‚úì' : 
                   (e.success === false || e.success === 0 || e.success === 'u' || e.success === 'N' ? '‚úó' : '');
    const team = e.team === 'home' ? 'H' : 'A';
    const shiftIdx = e.shiftIdx || e.shift_index || '';
    
    // Build title for hover
    const hoverTitle = [
      'Event #' + (i+1),
      'Type: ' + e.type,
      'Detail: ' + detail + (detail2 ? ' / ' + detail2 : ''),
      'Team: ' + e.team,
      'Shift: ' + (shiftIdx || 'none'),
      'Event Players: ' + (evtPlayers.map(p => '#' + p.num + ' ' + p.name).join(', ') || 'none'),
      'Opp Players: ' + (oppPlayers.map(p => '#' + p.num + ' ' + p.name).join(', ') || 'none'),
      primaryPlayer ? 'P1 Play: ' + primaryPD1 + (primaryPD2 ? ' / ' + primaryPD2 : '') + ' ' + primarySuccess : '',
      e.linkedEventIdx != null ? 'Linked to #' + (e.linkedEventIdx + 1) : '',
      hasXY ? 'Has XY: Yes' : ''
    ].filter(Boolean).join('\\n');
    
    // v20.4: Expanded columns - #, Sh, Lnk, Time, T, Type, Detail1, Detail2, Z, S, EvtP, OppP, PD1, PD2, PS, XY, star
    // v23.5: Add batch-selected class and goal review button
    const isBatchSelected = batchSelectMode && selectedEventIds.includes(i);
    const batchClass = isBatchSelected ? ' batch-selected' : '';
    const goalReviewBtn = e.type === 'Goal' ? '<span class="goal-review" onclick="event.stopPropagation();startGoalReview(' + i + ')" title="Review goal sequence">üé¨</span>' : '';
    
    // v23.5: Handle batch select click
    const clickHandler = batchSelectMode ? 'toggleEventSelection(' + i + ')' : 'editEvent(' + i + ')';
    
    return '<div class="evt-item' + batchClass + '" data-evt-idx="' + i + '" onclick="' + clickHandler + '" ondblclick="quickEditEvent(' + i + ')" title="' + hoverTitle + '">' +
      '<span class="idx">' + (i+1) + '</span>' +
      '<span class="seq" title="Shift #' + shiftIdx + '">' + shiftIdx + '</span>' +
      '<span class="link" title="Linked Event #' + linked + '">' + linked + '</span>' +
      '<span class="time">P' + e.period + ' ' + timeDisplay + '</span>' +
      '<span class="team">' + team + '</span>' +
      '<span class="type">' + e.type + '</span>' +
      '<span class="detail" title="' + detail + '">' + detail.substring(0,12) + '</span>' +
      '<span class="detail" title="' + detail2 + '">' + detail2.substring(0,12) + '</span>' +
      '<span class="zone">' + zone + '</span>' +
      '<span class="success">' + success + '</span>' +
      '<span class="evtp" title="Event Players: ' + evtPlayers.map(p => p.num + ':' + p.name).join(', ') + '">' + evtPlayerStr + '</span>' +
      '<span class="oppp" title="Opp Players: ' + oppPlayers.map(p => p.num + ':' + p.name).join(', ') + '">' + oppPlayerStr + '</span>' +
      '<span class="pd1" title="' + primaryPD1 + '">' + primaryPD1.substring(0,8) + '</span>' +
      '<span class="pd1" title="' + primaryPD2 + '">' + primaryPD2.substring(0,8) + '</span>' +
      '<span class="psucc">' + primarySuccess + '</span>' +
      '<span class="xy-dot">' + (hasXY?'‚óè':'') + '</span>' +
      '<span class="hl">' + highlight + goalReviewBtn + '</span>' +
    '</div>';
  }).join('') || '<div style="color:var(--muted);padding:10px;text-align:center;font-size:10px;">No events to display</div>';
  
  // Debug log
  console.log('  renderEvents complete. Filtered count:', filteredEvents.length);
  
  // v23.4: Update timeline scrub
  renderTimeline();
}
// Quick inline edit for event
function quickEditEvent(idx) {
  const evt = S.events[idx];
  
  // Build edit options
  const fields = [
    { name: 'Type', key: 'type', value: evt.type },
    { name: 'Detail 1', key: 'detail1', value: evt.detail1 || evt.detail || '' },
    { name: 'Detail 2', key: 'detail2', value: evt.detail2 || '' },
    { name: 'Linked Index', key: 'linkedEventIdx', value: evt.linkedEventIdx || '' },
    { name: 'Zone (Off/Neu/Def)', key: 'zone', value: evt.zone || '' },
    { name: 'Success (Y/N)', key: 'success', value: evt.success === true ? 'Y' : evt.success === false ? 'N' : '' },
    { name: 'Start Time', key: 'start_time', value: evt.start_time || '' },
    { name: 'Highlight (Y/N)', key: 'isHighlight', value: evt.isHighlight ? 'Y' : 'N' },
  ];
  
  const choice = prompt(
    `Quick Edit Event #${idx+1}\nEnter field number to edit:\n` +
    fields.map((f, i) => `${i+1}. ${f.name}: ${f.value}`).join('\n') +
    '\n\n(or 0 to cancel)'
  );
  
  if (!choice || choice === '0') return;
  
  const fieldIdx = parseInt(choice) - 1;
  if (fieldIdx < 0 || fieldIdx >= fields.length) {
    toast('Invalid selection', 'error');
    return;
  }
  
  const field = fields[fieldIdx];
  const newValue = prompt(`${field.name}:`, field.value);
  
  if (newValue !== null) {
    if (field.key === 'linkedEventIdx') {
      evt.linkedEventIdx = newValue ? parseInt(newValue) : null;
    } else if (field.key === 'success') {
      evt.success = newValue.toUpperCase() === 'Y' ? true : newValue.toUpperCase() === 'N' ? false : null;
    } else if (field.key === 'isHighlight') {
      evt.isHighlight = newValue.toUpperCase() === 'Y';
    } else if (field.key === 'detail1') {
      evt.detail1 = newValue;
      evt.detail = newValue; // Also update legacy field
    } else {
      evt[field.key] = newValue;
    }
    saveGameData();
    renderEvents();
    toast(`Updated ${field.name}`, 'success');
  }
}

function renderMarkers() {
  const layer = document.getElementById('markers');
  layer.innerHTML = '';
  const histCnt = parseInt(document.getElementById('xyHistCnt').value) || 5;
  
  // Historical events
  const recent = S.events.slice(-histCnt);
  recent.forEach((evt, ei) => {
    const opacity = 0.2 + (ei / histCnt) * 0.6;
    const extraData = { evtNum: evt.idx, evtType: evt.type };
    if (evt.puckXY?.length) drawPath(evt.puckXY, '#000', '#fff', opacity, layer, null, false, extraData);
    evt.players?.forEach(p => {
      if (p.xy?.length) {
        // v23.3: Use home/away team colors (not event/opp)
        const color = p.team === 'home' ? S.homeColor : S.awayColor;
        drawPath(p.xy, color, '#fff', opacity, layer, p.num, false, { ...extraData, playerName: p.name, playerNum: p.num });
      }
    });
  });
  
  // Current event
  if (S.curr.puckXY?.length) drawPath(S.curr.puckXY, '#00d4aa', '#fff', 1, layer, 'üèí', true);
  S.curr.players?.forEach(p => {
    if (p.xy?.length) {
      // v23.3: Use home/away team colors (not event/opp)
      const color = p.team === 'home' ? S.homeColor : S.awayColor;
      const sel = S.selectedPlayer?.num === p.num;
      drawPath(p.xy, color, sel ? '#fff' : '#000', 1, layer, p.num, true, { playerName: p.name, playerNum: p.num });
    }
  });
}

function drawPath(points, fill, stroke, opacity, layer, label, current, extraData = {}) {
  if (!points?.length) return;
  
  // v16.06: Convert center-relative coords to SVG coords for display
  // Stored: (0,0) = center ice. SVG: (100, 42.5) = center ice
  const toSvg = (pt) => ({
    x: pt.x + 100,
    y: pt.y + 42.5,
    seq: pt.seq,
    origX: pt.x,  // Keep original for tooltip
    origY: pt.y
  });
  
  const sorted = [...points].map(toSvg).sort((a,b) => a.seq - b.seq);
  
  for (let i = 0; i < sorted.length - 1; i++) {
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', sorted[i].x); line.setAttribute('y1', sorted[i].y);
    line.setAttribute('x2', sorted[i+1].x); line.setAttribute('y2', sorted[i+1].y);
    line.setAttribute('stroke', fill); line.setAttribute('stroke-width', current ? 1 : 0.5);
    line.setAttribute('stroke-dasharray', current ? 'none' : '2,1'); line.setAttribute('opacity', opacity * 0.7);
    layer.appendChild(line);
  }
  
  sorted.forEach((pt, i) => {
    const last = i === sorted.length - 1;
    // v16.06: Reduced marker size - current last=2.5, current other=1.5, history last=2, history other=1.2
    const r = current ? (last ? 2.5 : 1.5) : (last ? 2 : 1.2);
    const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    c.setAttribute('cx', pt.x); c.setAttribute('cy', pt.y); c.setAttribute('r', r);
    c.setAttribute('fill', fill); c.setAttribute('stroke', stroke);
    c.setAttribute('stroke-width', last ? 0.5 : 0.3); c.setAttribute('opacity', opacity);
    
    // v23.3: Make last marker of current players clickable to select them
    // Other markers: pointer-events:none to click through
    if (current && last && extraData.playerNum) {
      c.style.pointerEvents = 'auto';
      c.style.cursor = 'pointer';
      c.onclick = (e) => {
        e.stopPropagation();
        selectPlayer(extraData.playerNum);
        toast(`Selected #${extraData.playerNum}`, 'info');
      };
    } else {
      c.style.pointerEvents = 'none';
    }
    
    // Add data attributes for tooltip - use center-relative coords
    c.dataset.x = Math.round(pt.origX * 10) / 10;
    c.dataset.y = Math.round(pt.origY * 10) / 10;
    if (label === 'üèí') {
      c.dataset.type = 'puck';
    } else if (label && !isNaN(parseInt(label))) {
      c.dataset.type = 'player';
      c.dataset.num = label;
      c.dataset.name = extraData.playerName || '';
    } else if (extraData.evtNum) {
      c.dataset.type = 'history';
      c.dataset.evtnum = extraData.evtNum;
      c.dataset.evttype = extraData.evtType || '';
    }
    
    layer.appendChild(c);
    
    if (last && label) {
      const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      t.setAttribute('x', pt.x); t.setAttribute('y', pt.y + 1);
      t.setAttribute('fill', stroke); t.setAttribute('font-size', current ? '3.5' : '3');
      t.setAttribute('font-weight', 'bold'); t.setAttribute('text-anchor', 'middle');
      t.setAttribute('dominant-baseline', 'middle'); t.setAttribute('opacity', opacity);
      t.textContent = label;
      t.style.pointerEvents = 'none'; // Let events pass through to circle
      layer.appendChild(t);
    }
  });
}

function updateScores() {
  const goals = S.events.filter(e => e.type === 'Goal' && e.detail1?.includes('Scored'));
  document.getElementById('scoreH').textContent = goals.filter(e => e.team === 'home').length;
  document.getElementById('scoreA').textContent = goals.filter(e => e.team === 'away').length;
  updateQuickStats(); // v5
}

/**
 * Update quick stats bar (v5)
 */
function updateQuickStats() {
  // Event & shift counts
  document.getElementById('qsEvents').textContent = S.events.length;
  document.getElementById('qsShifts').textContent = S.shifts.length;
  
  // v16: SOG (shots on goal) - only shots that reached the net or goals
  const isSOG = (e) => {
    const d1 = (e.detail1 || '').toLowerCase();
    return d1.includes('shot_onnetsaved') || d1.includes('shot_onnetgoal') || 
           d1.includes('goal_scored') || d1.includes('goal_shootout') || d1.includes('goal_penaltyshot');
  };
  const homeSOG = S.events.filter(e => isSOG(e) && e.team === 'home').length;
  const awaySOG = S.events.filter(e => isSOG(e) && e.team === 'away').length;
  document.getElementById('qsSOG').textContent = `${homeSOG}-${awaySOG}`;
  
  // Faceoffs
  const faceoffs = S.events.filter(e => e.type === 'Faceoff');
  const homeFO = faceoffs.filter(e => e.team === 'home' && e.success === 's').length;
  const awayFO = faceoffs.filter(e => e.team === 'away' && e.success === 's').length;
  document.getElementById('qsFO').textContent = `${homeFO}-${awayFO}`;
  
  // Penalties
  const penalties = S.events.filter(e => e.type === 'Penalty');
  const homePEN = penalties.filter(e => e.team === 'home').length;
  const awayPEN = penalties.filter(e => e.team === 'away').length;
  document.getElementById('qsPEN').textContent = `${homePEN}-${awayPEN}`;
  
  // Current strength from slots
  const homeCount = ['F1','F2','F3','D1','D2','X'].filter(p => S.slots.home?.[p]?.num).length;
  const awayCount = ['F1','F2','F3','D1','D2','X'].filter(p => S.slots.away?.[p]?.num).length;
  const strength = `${homeCount}v${awayCount}`;
  const strengthEl = document.getElementById('qsStrength');
  strengthEl.textContent = strength;
  strengthEl.className = 'value strength-indicator';
  if (homeCount > awayCount) strengthEl.classList.add('pp');
  else if (homeCount < awayCount) strengthEl.classList.add('pk');
  else strengthEl.classList.add('even');
}

// ============================================================
// SLOTS & ROSTERS
// ============================================================
function selectSlot(el) {
  document.querySelectorAll('.slot').forEach(s => s.classList.remove('selected'));
  el.classList.add('selected');
  S.selectedSlot = { team: el.dataset.team, pos: el.dataset.pos };
}

function assignPlayer(team, num) {
  if (!S.selectedSlot || S.selectedSlot.team !== team) {
    const positions = ['F1','F2','F3','D1','D2','G','X'];
    for (const pos of positions) { if (!S.slots[team][pos]) { S.selectedSlot = { team, pos }; break; } }
  }
  if (!S.selectedSlot) return;
  const p = S.rosters[team].find(x => x.num === num);
  if (!p) return;
  S.slots[team][S.selectedSlot.pos] = p;
  S.selectedSlot = null;
  renderSlots(); renderRosters(); renderQuickAdd();
  onSlotsChanged(); // Update strength
}

function clearSlots(team) {
  Object.keys(S.slots[team]).forEach(pos => S.slots[team][pos] = null);
  renderSlots(); renderRosters(); renderQuickAdd();
  onSlotsChanged(); // Update strength
}

function clearSlot(team, pos) {
  S.slots[team][pos] = null;
  S.selectedSlot = null;
  renderSlots(); renderRosters(); renderQuickAdd();
  onSlotsChanged(); // Update strength
}

// ============================================================
// EVENT ENTRY
// ============================================================
function setEvtTeam(team) {
  S.evtTeam = team;
  document.querySelectorAll('.team-toggle button.home, .team-toggle button.away').forEach(b => b.classList.remove('active'));
  document.querySelector(`.team-toggle .${team}`).classList.add('active');
  renderQuickAdd();
  updateZoneDisplay();
}

function swapEvtTeam() {
  // Swap the event team
  const newTeam = S.evtTeam === 'home' ? 'away' : 'home';
  
  // Also swap players between event and opp roles
  const evtPlayers = S.curr.players.filter(p => p.role?.startsWith('event'));
  const oppPlayers = S.curr.players.filter(p => p.role?.startsWith('opp'));
  
  // Swap roles - use consistent format event_team_player_N / opp_team_player_N
  evtPlayers.forEach((p, i) => {
    p.role = `opp_team_player_${i + 1}`;
    p.roleNum = i + 1;
  });
  oppPlayers.forEach((p, i) => {
    p.role = `event_team_player_${i + 1}`;
    p.roleNum = i + 1;
  });
  
  // Merge back - new event players first
  S.curr.players = [...oppPlayers, ...evtPlayers];
  
  // Set new team
  setEvtTeam(newTeam);
  renderQuickAdd();
  toast(`Swapped to ${newTeam.toUpperCase()}`, 'info');
}

function setEvtType(type) {
  S.curr.type = type;
  document.querySelectorAll('.evt-btn').forEach(b => b.classList.remove('active'));
  document.querySelector(`.evt-btn[data-type="${type}"]`)?.classList.add('active');
  
  // v23.3: Auto-link and setup for follow-up events (Shot ‚Üí Save, etc.)
  autoLinkFollowUp(type);
  
  // v16.06: Use S.eventDetails1 from dim_event_detail if available
  let d1Options = [];
  if (S.eventDetails1?.length > 0) {
    d1Options = S.eventDetails1
      .filter(e => e.eventType === type)
      .map(e => e.name);
  }
  
  // Fall back to LISTS.details if no Supabase data
  if (d1Options.length === 0) {
    const opts = LISTS.details[type] || { d1: [], d2: [] };
    d1Options = opts.d1 || [];
  }
  
  document.getElementById('evtD1').innerHTML = '<option value="">--</option>' + 
    d1Options.map(o => `<option value="${o}">${o}</option>`).join('');
  document.getElementById('evtD2').innerHTML = '<option value="">--</option>';
  
  // v23.4: Render quick detail buttons
  renderQuickDetails(type, d1Options);
  
  // Update linked events dropdown based on current type
  updateLinkedEventsDropdown();
  
  // Apply linked event data if linked
  applyLinkedEventData();
  
  // Auto-derive zone from position if we have XY
  const zone = calculateZone();
  if (zone) document.getElementById('evtZone').value = zone;
  
  // Auto-derive strength from slots
  const strength = deriveStrength();
  if (strength) document.getElementById('evtStrength').value = strength;
  
  // v23.3: Auto-populate goalie for Save events
  if (type === 'Save') {
    autoPopulateGoalie();
  }
}

// ============================================================
// v23.4: QUICK DETAIL BUTTONS
// ============================================================

// Most common details by event type for quick buttons
const QUICK_DETAILS = {
  Shot: ['Shot_OnNet', 'Shot_Missed', 'Shot_Blocked', 'Shot_Goal'],
  Goal: ['Goal_Scored', 'Goal_Disallowed'],
  Pass: ['Pass_Completed', 'Pass_Incomplete', 'Pass_Intercepted'],
  Faceoff: ['Faceoff_Won', 'Faceoff_Lost'],
  Turnover: ['Turnover_Giveaway', 'Turnover_Takeaway'],
  Zone_Entry_Exit: ['Zone_Entry', 'Zone_Exit'],
  Save: ['Save_Made', 'Save_Rebound'],
  Possession: ['Possession_Gained', 'Possession_Lost', 'Possession_Cycle'],
  Stoppage: ['Stoppage_Icing', 'Stoppage_Offside', 'Stoppage_GoalieFreeze'],
  Penalty: ['Penalty_Tripping', 'Penalty_Hooking', 'Penalty_Slashing', 'Penalty_Holding']
};

/**
 * Render quick detail buttons for current event type
 */
function renderQuickDetails(type, allOptions) {
  const row = document.getElementById('quickDetailRow');
  if (!row) return;
  
  // Get quick details for this type, or use first 4 from all options
  const quickOptions = QUICK_DETAILS[type] || allOptions.slice(0, 4);
  
  if (quickOptions.length === 0) {
    row.style.display = 'none';
    return;
  }
  
  row.style.display = 'flex';
  row.innerHTML = quickOptions.map(opt => {
    const label = opt.replace(`${type}_`, '').replace(/_/g, ' ');
    const isActive = document.getElementById('evtD1').value === opt;
    return `<button class="btn-sm ${isActive ? 'active' : ''}" onclick="quickSetDetail1('${opt}')" style="font-size:8px;padding:2px 6px;">${label}</button>`;
  }).join('');
}

/**
 * Quick set Detail 1 value
 */
function quickSetDetail1(value) {
  document.getElementById('evtD1').value = value;
  onD1Change();
  
  // Update button states
  document.querySelectorAll('#quickDetailRow button').forEach(btn => {
    btn.classList.remove('active');
  });
  event.target.classList.add('active');
}

/**
 * Set zone via button click
 */
function setZone(zone) {
  document.getElementById('evtZone').value = zone;
  
  // Update button states
  document.querySelectorAll('.zone-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.zone === zone);
    btn.style.background = btn.dataset.zone === zone ? 
      (zone === 'o' ? 'var(--success)' : zone === 'd' ? 'var(--danger)' : 'var(--muted)') : '';
    btn.style.color = btn.dataset.zone === zone ? '#fff' : '';
  });
}

/**
 * Set success via button click
 */
function setSuccess(success) {
  document.getElementById('evtSuccess').value = success;
  
  // Update button states
  document.querySelectorAll('.success-btn').forEach(btn => {
    const isActive = btn.dataset.success === success;
    btn.style.opacity = isActive ? '1' : '0.5';
    btn.style.transform = isActive ? 'scale(1.1)' : 'scale(1)';
  });
}

function onD1Change() {
  const type = S.curr.type;
  const d1 = document.getElementById('evtD1').value;
  
  let d2Opts = [];
  
  // v16.08: Use S.eventDetails2 from dim_event_detail_2 - filter by code prefix
  if (S.eventDetails2?.length > 0) {
    // Determine code prefix based on detail1 value
    let codePrefix = null;
    if (d1.startsWith('Shot_')) codePrefix = 'Shot_';
    else if (d1.startsWith('Pass_')) codePrefix = 'Pass_';
    else if (d1.startsWith('Goal_')) codePrefix = 'Goal_';
    else if (d1.startsWith('Save_')) codePrefix = 'Save_';
    else if (d1.startsWith('Penalty_')) codePrefix = 'Penalty_';
    else if (d1.includes('Giveaway')) codePrefix = 'Giveaway_';
    else if (d1.includes('Takeaway')) codePrefix = 'Takeaway_';
    else if (d1.includes('Entry')) codePrefix = 'ZoneEntry_';
    else if (d1.includes('Exit') || d1.includes('Keepin')) codePrefix = 'ZoneExit_';
    else if (d1 === 'Stoppage_Play') codePrefix = 'Stoppage_';
    else if (d1 === 'Play_Offensive') codePrefix = 'PlayOffensive_';
    else if (d1 === 'Play_Defensive') codePrefix = 'PlayDefensive_';
    else if (d1.startsWith('Faceoff_')) codePrefix = 'Faceoff_';
    else if (d1.startsWith('Possession_')) codePrefix = 'Possession_';
    else if (d1.startsWith('Rebound_')) codePrefix = 'Rebound_';
    
    if (codePrefix) {
      d2Opts = S.eventDetails2
        .filter(e => e.code && e.code.startsWith(codePrefix))
        .map(e => e.name);
      console.log('Detail2 filter:', codePrefix, '‚Üí', d2Opts.length, 'options');
    }
  }
  
  // Fall back to LISTS.details if no Supabase data
  if (d2Opts.length === 0) {
    const opts = LISTS.details[type] || {};
    d2Opts = opts.d2 || [];
    if (d1.includes('Giveaway') && opts.d2_Giveaway) d2Opts = opts.d2_Giveaway;
    else if (d1.includes('Takeaway') && opts.d2_Takeaway) d2Opts = opts.d2_Takeaway;
    else if (d1.includes('Entry') && opts.d2_Entry) d2Opts = opts.d2_Entry;
    else if (d1.includes('Exit') && opts.d2_Exit) d2Opts = opts.d2_Exit;
    else if (d1.includes('Play') && opts.d2_Play) d2Opts = opts.d2_Play;
    else if (d1.includes('Offensive') && opts.d2_Offensive) d2Opts = opts.d2_Offensive;
    else if (d1.includes('Defensive') && opts.d2_Defensive) d2Opts = opts.d2_Defensive;
    else if (d1.includes('Keepin') && opts.d2_Exit) d2Opts = opts.d2_Exit;
  }
  
  document.getElementById('evtD2').innerHTML = '<option value="">--</option>' + d2Opts.map(o => `<option value="${o}">${o}</option>`).join('');
  
  // Auto-derive success
  const success = deriveSuccess();
  if (success) document.getElementById('evtSuccess').value = success;
  
  // v23.3: Check if this is a shot on net or goal - prompt for net location
  const needsNetLocation = (type === 'Shot' && (d1.includes('OnNet') || d1.includes('Goal'))) || 
                           type === 'Goal' || 
                           (d1 && d1.includes('Goal_Scored'));
  if (needsNetLocation) {
    setTimeout(() => document.getElementById('netModal').classList.add('show'), 100);
    // v23.3: Auto-add opposing goalie for shots on net
    autoPopulateGoalie();
  }
}

function togglePlayer(num, role) {
  const team = role === 'evt' ? S.evtTeam : (S.evtTeam === 'home' ? 'away' : 'home');
  const p = S.rosters[team]?.find(x => x.num === num);
  
  // v23.3: Guard - can't add player from wrong team
  if (!p) {
    // Check if player is from opposite team
    const otherTeam = team === 'home' ? 'away' : 'home';
    const otherPlayer = S.rosters[otherTeam]?.find(x => x.num === num);
    if (otherPlayer) {
      toast(`#${num} is on ${otherTeam} team - use ${role === 'evt' ? 'Opp' : 'Event'} side`, 'warning');
    }
    return;
  }
  
  // v23.3: Guard - check if adding this player would create mixed teams in event/opp
  const existingEvtPlayers = S.curr.players.filter(x => x.role?.startsWith('event'));
  const existingOppPlayers = S.curr.players.filter(x => x.role?.startsWith('opp'));
  
  if (role === 'evt' && existingEvtPlayers.length > 0) {
    const existingTeam = existingEvtPlayers[0].team;
    if (existingTeam !== team) {
      toast(`Event players must all be from same team (${existingTeam})`, 'error');
      return;
    }
  }
  if (role === 'opp' && existingOppPlayers.length > 0) {
    const existingTeam = existingOppPlayers[0].team;
    if (existingTeam !== team) {
      toast(`Opp players must all be from same team (${existingTeam})`, 'error');
      return;
    }
  }
  
  const existingIdx = S.curr.players.findIndex(x => x.num === num);
  if (existingIdx >= 0) {
    S.curr.players.splice(existingIdx, 1);
    if (S.selectedPlayer?.num === num) S.selectedPlayer = null;
  } else {
    const roleNum = S.curr.players.filter(x => x.role?.startsWith(role === 'evt' ? 'event' : 'opp')).length + 1;
    S.curr.players.push({
      ...p, role: `${role === 'evt' ? 'event' : 'opp'}_team_player_${roleNum}`,
      roleNum, xy: [], playD1: '', playD2: '', playSuccess: '', pressure: '', sideOfPuck: ''
    });
  }
  renumberPlayers();
  renderQuickAdd(); renderMarkers();
}

function removePlayer(num) {
  S.curr.players = S.curr.players.filter(p => p.num !== num);
  if (S.selectedPlayer?.num === num) S.selectedPlayer = null;
  renumberPlayers();
  renderQuickAdd(); renderMarkers();
}

function renumberPlayers() {
  let evtN = 1, oppN = 1;
  S.curr.players.forEach(p => {
    if (p.role?.startsWith('event')) { p.role = `event_team_player_${evtN}`; p.roleNum = evtN++; }
    else { p.role = `opp_team_player_${oppN}`; p.roleNum = oppN++; }
  });
}

// ============================================================
// PLAYER CHIP DRAG AND DROP
// ============================================================
let draggedPlayer = null;

function handlePlayerDragStart(e) {
  const chip = e.target.closest('.player-chip');
  if (!chip) return;
  
  draggedPlayer = {
    num: chip.dataset.num,
    role: chip.dataset.role,
    idx: parseInt(chip.dataset.idx)
  };
  chip.classList.add('dragging');
  e.dataTransfer.effectAllowed = 'move';
  e.dataTransfer.setData('text/plain', JSON.stringify(draggedPlayer));
}

function handlePlayerDragEnd(e) {
  const chip = e.target.closest('.player-chip');
  if (chip) chip.classList.remove('dragging');
  document.querySelectorAll('.player-chip').forEach(c => c.classList.remove('drag-over'));
  document.querySelectorAll('.player-list').forEach(l => l.classList.remove('drag-target'));
  draggedPlayer = null;
}

function handlePlayerDragOver(e) {
  e.preventDefault();
  if (!draggedPlayer) return;
  
  const chip = e.target.closest('.player-chip');
  if (chip && chip.dataset.num !== draggedPlayer.num) {
    chip.classList.add('drag-over');
  }
  
  // Also highlight the player list container for cross-list drops
  const list = e.target.closest('.player-list');
  if (list) list.classList.add('drag-target');
  
  e.dataTransfer.dropEffect = 'move';
}

function handlePlayerDrop(e) {
  e.preventDefault();
  const chip = e.target.closest('.player-chip');
  
  document.querySelectorAll('.player-chip').forEach(c => c.classList.remove('drag-over'));
  document.querySelectorAll('.player-list').forEach(l => l.classList.remove('drag-target'));
  
  if (!draggedPlayer) return;
  
  const sourceNum = draggedPlayer.num;
  const sourceRole = draggedPlayer.role; // 'evt' or 'opp'
  
  // Find the source player
  const sourcePlayer = S.curr.players.find(p => p.num === sourceNum);
  if (!sourcePlayer) return;
  
  // Determine target role from drop location
  let targetRole = sourceRole;
  const list = e.target.closest('.player-list');
  if (list) {
    if (list.id === 'evtPlayers') targetRole = 'evt';
    else if (list.id === 'oppPlayers') targetRole = 'opp';
  }
  
  // If dropping on another chip in the SAME list, swap positions
  if (chip && chip.dataset.num !== sourceNum) {
    const targetNum = chip.dataset.num;
    const targetPlayer = S.curr.players.find(p => p.num === targetNum);
    const targetChipRole = chip.dataset.role;
    
    if (targetPlayer && sourceRole === targetChipRole) {
      // Same list - just swap positions
      const sourceIdx = S.curr.players.indexOf(sourcePlayer);
      const targetIdx = S.curr.players.indexOf(targetPlayer);
      S.curr.players[sourceIdx] = targetPlayer;
      S.curr.players[targetIdx] = sourcePlayer;
      renumberPlayers();
      renderQuickAdd();
      renderMarkers();
      toast('Swapped player positions', 'info');
      return;
    }
  }
  
  // v23.3: If dropping on opposite list (not on a chip), swap ALL players and team
  if (sourceRole !== targetRole) {
    // Swap ALL players: event becomes opp, opp becomes event
    S.curr.players.forEach(p => {
      if (p.role?.startsWith('event')) {
        p.role = p.role.replace('event', 'opp');
      } else if (p.role?.startsWith('opp')) {
        p.role = p.role.replace('opp', 'event');
      }
    });
    
    // Swap event team
    const newTeam = S.evtTeam === 'home' ? 'away' : 'home';
    setEvtTeam(newTeam);
    
    renumberPlayers();
    renderQuickAdd();
    renderMarkers();
    toast(`Swapped Event‚ÜîOpp (${S.homeTeam || 'Home'} is now ${newTeam === 'home' ? 'Event' : 'Opp'})`, 'success');
  }
}

function handleListDragOver(e) {
  e.preventDefault();
  if (!draggedPlayer) return;
  e.currentTarget.classList.add('drag-target');
  e.dataTransfer.dropEffect = 'move';
}

function handleListDragLeave(e) {
  e.currentTarget.classList.remove('drag-target');
}

function handleListDrop(e, targetRole) {
  e.preventDefault();
  e.currentTarget.classList.remove('drag-target');
  
  if (!draggedPlayer) return;
  
  // Check if we dropped directly on a chip (handled by chip handler)
  if (e.target.closest('.player-chip')) return;
  
  const sourceNum = draggedPlayer.num;
  const sourceRole = draggedPlayer.role;
  
  // Find the source player
  const sourcePlayer = S.curr.players.find(p => p.num === sourceNum);
  if (!sourcePlayer) return;
  
  // v23.3: When dragging to opposite list, swap ALL players and the event team
  if (sourceRole !== targetRole) {
    // Swap ALL players: event becomes opp, opp becomes event
    S.curr.players.forEach(p => {
      if (p.role?.startsWith('event')) {
        p.role = p.role.replace('event', 'opp');
      } else if (p.role?.startsWith('opp')) {
        p.role = p.role.replace('opp', 'event');
      }
    });
    
    // Swap event team
    const newTeam = S.evtTeam === 'home' ? 'away' : 'home';
    setEvtTeam(newTeam);
    
    renumberPlayers();
    renderQuickAdd();
    renderMarkers();
    toast(`Swapped Event‚ÜîOpp (now ${S.homeTeam || 'Home'} is ${newTeam === 'home' ? 'Event' : 'Opp'})`, 'success');
  }
}

function selectPlayer(num) {
  S.selectedPlayer = S.curr.players.find(p => p.num === num) || null;
  if (S.selectedPlayer && S.xyMode !== 'player') setXYMode('player');
  renderQuickAdd(); renderXYSlots();
}

function updatePlayerDetail(field, val) {
  if (!S.selectedPlayer) return;
  S.selectedPlayer[field] = val;
  renderQuickAdd();
}

// ============================================================
// XY HANDLING
// ============================================================
function setXYMode(mode) {
  S.xyMode = mode;
  document.getElementById('puckModeBtn').classList.toggle('active', mode === 'puck');
  document.getElementById('playerModeBtn').classList.toggle('active', mode === 'player');
  document.getElementById('modeInd').textContent = mode === 'puck' ? 'üèí PUCK' : 'üë§ PLAYER';
  document.getElementById('modeInd').className = 'mode-ind ' + mode;
  S.xySlot = 1;
  renderXYSlots(); renderQuickAdd();
}

function setXYSlot(n) {
  S.xySlot = n;
  renderXYSlots();
}

function selectXYPlayer(num) {
  if (!num || num === '') {
    // User selected puck option - switch to puck mode
    S.selectedPlayer = null;
    setXYMode('puck');
    S.xySlot = (S.curr.puckXY?.filter(Boolean).length || 0) + 1;
    if (S.xySlot > 6) S.xySlot = 1;
    renderXYSlots(); renderQuickAdd();
    return;
  }
  
  S.selectedPlayer = S.curr.players.find(p => p.num == num) || null;
  
  if (S.selectedPlayer) {
    // Only switch to player mode if we actually found the player
    setXYMode('player');
    // Set slot to next available
    S.xySlot = (S.selectedPlayer.xy?.length || 0) + 1;
    if (S.xySlot > 6) S.xySlot = 1; // Wrap around
    toast(`#${num} selected - click rink to place`, 'info');
  } else {
    S.xySlot = 1;
  }
  
  renderXYSlots(); renderQuickAdd();
}

// ============================================================
// v23.4: DRAG FOR PASSES/SHOTS
// ============================================================
let dragStartXY = null;
let isDragging = false;

function handleRinkMouseDown(event) {
  const svg = document.getElementById('rinkSvg');
  const pt = svg.createSVGPoint();
  pt.x = event.clientX; pt.y = event.clientY;
  const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
  
  const relX = Math.round((svgPt.x - 100) * 100) / 100;
  const relY = Math.round((svgPt.y - 42.5) * 100) / 100;
  
  dragStartXY = { x: relX, y: relY, svgX: svgPt.x, svgY: svgPt.y };
  isDragging = false;
}

function handleRinkMouseMove(event) {
  if (!dragStartXY) return;
  
  const svg = document.getElementById('rinkSvg');
  const pt = svg.createSVGPoint();
  pt.x = event.clientX; pt.y = event.clientY;
  const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
  
  const dist = Math.sqrt(Math.pow(svgPt.x - dragStartXY.svgX, 2) + Math.pow(svgPt.y - dragStartXY.svgY, 2));
  
  // If moved more than 10px, we're dragging
  if (dist > 10) {
    isDragging = true;
    // Show drag preview line
    showDragPreview(dragStartXY, svgPt);
  }
}

function handleRinkMouseUp(event) {
  if (!dragStartXY) return;
  
  const svg = document.getElementById('rinkSvg');
  const pt = svg.createSVGPoint();
  pt.x = event.clientX; pt.y = event.clientY;
  const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
  
  const relX = Math.round((svgPt.x - 100) * 100) / 100;
  const relY = Math.round((svgPt.y - 42.5) * 100) / 100;
  
  hideDragPreview();
  
  if (isDragging) {
    // Handle drag as pass or shot
    handleDragEvent(dragStartXY, { x: relX, y: relY, svgX: svgPt.x, svgY: svgPt.y });
  } else {
    // Regular click - use existing handler
    handleRinkClickInternal(event, dragStartXY.x, dragStartXY.y, dragStartXY.svgX, dragStartXY.svgY);
  }
  
  dragStartXY = null;
  isDragging = false;
}

/**
 * Show drag preview line on rink
 */
function showDragPreview(start, end) {
  let preview = document.getElementById('dragPreviewLine');
  if (!preview) {
    const svg = document.getElementById('rinkSvg');
    preview = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    preview.id = 'dragPreviewLine';
    preview.setAttribute('stroke', '#00d4aa');
    preview.setAttribute('stroke-width', '2');
    preview.setAttribute('stroke-dasharray', '5,5');
    preview.setAttribute('pointer-events', 'none');
    svg.appendChild(preview);
  }
  preview.setAttribute('x1', start.svgX);
  preview.setAttribute('y1', start.svgY);
  preview.setAttribute('x2', end.x);
  preview.setAttribute('y2', end.y);
  preview.style.display = 'block';
}

function hideDragPreview() {
  const preview = document.getElementById('dragPreviewLine');
  if (preview) preview.style.display = 'none';
}

/**
 * Handle drag as pass or shot based on direction and end location
 */
function handleDragEvent(start, end) {
  // Determine if drag ends near net (shot) or not (pass)
  const isTowardNet = end.svgX > 170 || end.svgX < 30; // Near either net
  const zone = getZoneFromClick(start.svgX);
  
  // Set puck XY to start and end points
  S.curr.puckXY = [
    { x: start.x, y: start.y, seq: 1 },
    { x: end.x, y: end.y, seq: 2 }
  ];
  
  if (isTowardNet && zone === 'o') {
    // Shot toward net
    if (!S.curr.type) setEvtType('Shot');
    document.getElementById('evtZone').value = 'o';
    
    // Set net location if we have it
    if (end.svgX > 170) {
      S.curr.netXY = { x: end.x, y: end.y };
    }
    
    // Auto-link: E1 at start (shooter position)
    const e1 = S.curr.players.find(p => p.role === 'event_team_player_1');
    if (e1) e1.xy = [{ x: start.x, y: start.y, seq: 1 }];
    
    toast('Shot created from drag', 'success');
  } else {
    // Pass
    if (!S.curr.type) setEvtType('Pass');
    document.getElementById('evtZone').value = zone || 'n';
    
    // Auto-link: E1 at start (passer), E2 at end (receiver)
    const e1 = S.curr.players.find(p => p.role === 'event_team_player_1');
    const e2 = S.curr.players.find(p => p.role === 'event_team_player_2');
    if (e1) e1.xy = [{ x: start.x, y: start.y, seq: 1 }];
    if (e2) e2.xy = [{ x: end.x, y: end.y, seq: 1 }];
    
    toast('Pass created from drag', 'success');
  }
  
  S.xySlot = 3;
  renderXYSlots(); renderMarkers(); updateZoneDisplay(); renderQuickAdd();
}

// ============================================================
// v23.4: KEYBOARD MODIFIERS FOR XY PLACEMENT
// ============================================================
let xyKeyModifier = null; // null, 1, 2, 3... for which player

document.addEventListener('keydown', (e) => {
  // Number keys 1-6 while on rink = assign to that player slot
  if (e.key >= '1' && e.key <= '6' && !e.ctrlKey && !e.altKey) {
    const activeEl = document.activeElement;
    if (activeEl.tagName !== 'INPUT' && activeEl.tagName !== 'SELECT' && activeEl.tagName !== 'TEXTAREA') {
      xyKeyModifier = parseInt(e.key);
    }
  }
});

document.addEventListener('keyup', (e) => {
  if (e.key >= '1' && e.key <= '6') {
    xyKeyModifier = null;
  }
});

function handleRinkClick(event) {
  // Delegate to mousedown/up for drag support
  // This is now called internally after drag detection
}

function handleRinkClickInternal(event, relX, relY, svgX, svgY) {
  const xy = { x: relX, y: relY, seq: S.xySlot };
  
  // v23.4: Keyboard modifier - hold number key to place specific player
  if (xyKeyModifier && S.curr.players.length >= xyKeyModifier) {
    const player = S.curr.players[xyKeyModifier - 1];
    if (player) {
      player.xy = player.xy || [];
      player.xy.push(xy);
      toast(`Placed #${player.num} (key ${xyKeyModifier})`, 'info');
      renderXYSlots(); renderMarkers(); renderQuickAdd();
      return;
    }
  }
  
  // v23.3: Shot chart mode - create shot at click location
  if (shotChartModeActive) {
    if (handleShotChartClick(svgX, svgY, relX, relY)) return;
  }
  
  // v23.3: Batch placement mode
  if (batchPlacementPlayers.length > 0) {
    if (placeBatchPlayers(relX, relY)) return;
  }
  
  // v23.3: Detect faceoff dot clicks - auto-assign E1 and O1 positions
  const faceoffDot = detectFaceoffDot(svgX, svgY);
  if (faceoffDot && S.curr.type === 'Faceoff') {
    handleFaceoffDotClick(faceoffDot, relX, relY);
    return;
  }
  
  // v23.4: One-click event creation - if no type, suggest based on zone
  if (!S.curr.type) {
    const zone = getZoneFromClick(svgX);
    handleZoneClickNoType(zone, relX, relY);
    return;
  }
  
  // v23.3: Auto-set zone from click position (if zone not already set)
  if (!document.getElementById('evtZone').value) {
    const zone = getZoneFromClick(svgX);
    if (zone) {
      document.getElementById('evtZone').value = zone;
      setZone(zone);
    }
  }
  
  // v23.3: Smart first click - if player mode but no players, place puck first
  if (S.xyMode === 'player' && S.curr.players.length === 0) {
    S.curr.puckXY[0] = xy;
    S.xySlot = 2;
    setXYMode('puck');
    renderXYSlots(); renderMarkers(); updateZoneDisplay();
    toast('Placed puck (add players next)', 'info');
    return;
  }
  
  // Store for undo
  S.xyHistory.push({ mode: S.xyMode, player: S.selectedPlayer?.num, slot: S.xySlot, prev: null });
  
  if (S.xyMode === 'puck') {
    const d2 = document.getElementById('evtD2').value;
    const isPossession = LISTS.possessionEvents.includes(S.curr.type) || LISTS.possessionDetails.includes(d2);
    
    S.curr.puckXY[S.xySlot - 1] = xy;
    
    // v23.4: Smart XY auto-linking based on event type
    smartAutoLinkXY(xy, S.xySlot);
    
    S.xySlot = Math.min(S.xySlot + 1, 10);
  } else if (S.xyMode === 'player') {
    if (!S.selectedPlayer) {
      S.curr.puckXY[S.xySlot - 1] = xy;
      S.xySlot = Math.min(S.xySlot + 1, 10);
      toast('No player selected - placed puck instead', 'info');
    } else {
      S.selectedPlayer.xy[S.xySlot - 1] = xy;
      S.xySlot = Math.min(S.xySlot + 1, 10);
    }
  }
  
  renderXYSlots(); renderMarkers(); updateZoneDisplay(); detectPressure(); renderQuickAdd();
}

/**
 * v23.4: Smart auto-link XY based on event type
 */
function smartAutoLinkXY(xy, slot) {
  const type = S.curr.type;
  const e1 = S.curr.players.find(p => p.role === 'event_team_player_1');
  const e2 = S.curr.players.find(p => p.role === 'event_team_player_2');
  const o1 = S.curr.players.find(p => p.role === 'opp_team_player_1');
  
  switch(type) {
    case 'Shot':
      // Slot 1 = shooter position (E1)
      if (slot === 1 && e1) {
        e1.xy = e1.xy || [];
        e1.xy[0] = {...xy};
      }
      break;
      
    case 'Pass':
      // Slot 1 = passer (E1), Slot 2 = receiver (E2)
      if (slot === 1 && e1) {
        e1.xy = e1.xy || [];
        e1.xy[0] = {...xy};
      } else if (slot === 2 && e2) {
        e2.xy = e2.xy || [];
        e2.xy[0] = {...xy};
      }
      break;
      
    case 'Hit':
    case 'Battle':
      // Both players at puck location
      if (slot === 1) {
        if (e1) { e1.xy = e1.xy || []; e1.xy[0] = {...xy}; }
        if (o1) { o1.xy = o1.xy || []; o1.xy[0] = {...xy}; }
      }
      break;
      
    case 'Possession':
    case 'Turnover':
      // E1 at puck
      if (slot === 1 && e1) {
        e1.xy = e1.xy || [];
        e1.xy[0] = {...xy};
      }
      break;
      
    case 'Zone_Entry_Exit':
      // E1 carries puck
      if (slot === 1 && e1) {
        e1.xy = e1.xy || [];
        e1.xy[0] = {...xy};
      }
      break;
  }
}

/**
 * v23.4: Handle zone click when no event type selected - suggest event
 */
function handleZoneClickNoType(zone, relX, relY) {
  const xy = { x: relX, y: relY, seq: 1 };
  
  // Show zone-based suggestions
  let suggestedType = 'Possession';
  let detail1 = '';
  
  if (zone === 'o') {
    // Offensive zone - likely shot or cycle
    suggestedType = 'Shot';
    detail1 = 'Shot_OnNet';
  } else if (zone === 'd') {
    // Defensive zone - likely possession/breakout
    suggestedType = 'Possession';
    detail1 = 'Possession_Breakout';
  } else {
    // Neutral zone - likely zone entry
    suggestedType = 'Zone_Entry_Exit';
    detail1 = 'Zone_Entry';
  }
  
  // Set it up
  setEvtType(suggestedType);
  setTimeout(() => {
    document.getElementById('evtD1').value = detail1;
    document.getElementById('evtZone').value = zone;
    setZone(zone);
    
    // Place puck
    S.curr.puckXY[0] = xy;
    S.xySlot = 2;
    
    renderXYSlots(); renderMarkers(); updateZoneDisplay(); renderQuickAdd();
    toast(`${zone === 'o' ? 'Offensive' : zone === 'd' ? 'Defensive' : 'Neutral'} zone ‚Üí ${suggestedType}`, 'info');
  }, 50);
}

/**
 * v23.3: Detect if click is on a faceoff dot
 * Returns dot info or null
 */
function detectFaceoffDot(svgX, svgY) {
  // Faceoff dot positions in SVG coordinates (200x85 rink)
  // Center ice: (100, 42.5)
  // Zone circles: approximately at (31, 22), (31, 63), (169, 22), (169, 63)
  // Neutral zone dots: (80, 22), (80, 63), (120, 22), (120, 63)
  
  const dots = [
    { name: 'center', svgX: 100, svgY: 42.5, relX: 0, relY: 0, zone: 'n' },
    { name: 'left_top', svgX: 31, svgY: 22, relX: -69, relY: -20.5, zone: 'left' },
    { name: 'left_bot', svgX: 31, svgY: 63, relX: -69, relY: 20.5, zone: 'left' },
    { name: 'right_top', svgX: 169, svgY: 22, relX: 69, relY: -20.5, zone: 'right' },
    { name: 'right_bot', svgX: 169, svgY: 63, relX: 69, relY: 20.5, zone: 'right' },
    { name: 'neut_left_top', svgX: 80, svgY: 22, relX: -20, relY: -20.5, zone: 'n' },
    { name: 'neut_left_bot', svgX: 80, svgY: 63, relX: -20, relY: 20.5, zone: 'n' },
    { name: 'neut_right_top', svgX: 120, svgY: 22, relX: 20, relY: -20.5, zone: 'n' },
    { name: 'neut_right_bot', svgX: 120, svgY: 63, relX: 20, relY: 20.5, zone: 'n' },
  ];
  
  const RADIUS = 8; // Click tolerance radius
  
  for (const dot of dots) {
    const dist = Math.sqrt(Math.pow(svgX - dot.svgX, 2) + Math.pow(svgY - dot.svgY, 2));
    if (dist <= RADIUS) {
      return dot;
    }
  }
  
  return null;
}

/**
 * v23.3: Handle faceoff dot click - auto-assign positions
 */
function handleFaceoffDotClick(dot, relX, relY) {
  // Set puck position at the dot
  S.curr.puckXY = [{ x: dot.relX, y: dot.relY, seq: 1 }];
  
  // Find E1 and O1
  const e1 = S.curr.players.find(p => p.role === 'event_team_player_1');
  const o1 = S.curr.players.find(p => p.role === 'opp_team_player_1');
  
  // Set E1 and O1 positions at the dot
  if (e1) {
    e1.xy = [{ x: dot.relX, y: dot.relY, seq: 1 }];
  }
  if (o1) {
    o1.xy = [{ x: dot.relX, y: dot.relY, seq: 1 }];
  }
  
  // Set zone based on dot location
  let zone = 'n';
  if (dot.zone === 'left' || dot.zone === 'right') {
    zone = getZoneFromClick(dot.svgX);
  }
  document.getElementById('evtZone').value = zone;
  
  // Update zone display
  const zoneName = zone === 'o' ? 'Offensive' : zone === 'd' ? 'Defensive' : 'Neutral';
  document.getElementById('zoneDisplay').innerHTML = `<span style="background:${zone === 'o' ? 'var(--success)' : zone === 'd' ? 'var(--danger)' : 'var(--muted)'};color:#fff;padding:1px 6px;border-radius:3px;font-size:9px;">${zoneName.toUpperCase()}</span>`;
  
  renderXYSlots();
  renderMarkers();
  
  const playersSet = [e1 ? 'E1' : '', o1 ? 'O1' : ''].filter(Boolean).join(', ');
  toast(`Faceoff at ${dot.name.replace('_', ' ')}: Puck${playersSet ? ' + ' + playersSet : ''} positioned`, 'success');
}

/**
 * v23.3: Get zone from rink X position
 */
function getZoneFromClick(svgX) {
  // svgX is 0-200, blue lines at 75 and 125
  const period = S.period || 1;
  const isOddPeriod = period === 1 || period === 3 || period === 'OT';
  const homeOffensiveRight = isOddPeriod ? S.homeAttacksRightP1 : !S.homeAttacksRightP1;
  
  let rawZone = '';
  if (svgX < 75) rawZone = 'left';
  else if (svgX > 125) rawZone = 'right';
  else rawZone = 'neutral';
  
  if (rawZone === 'neutral') return 'n';
  
  // Convert to offensive/defensive based on event team
  if (S.evtTeam === 'home') {
    if (homeOffensiveRight) {
      return rawZone === 'right' ? 'o' : 'd';
    } else {
      return rawZone === 'left' ? 'o' : 'd';
    }
  } else {
    if (homeOffensiveRight) {
      return rawZone === 'left' ? 'o' : 'd';
    } else {
      return rawZone === 'right' ? 'o' : 'd';
    }
  }
}

function undoLastXY() {
  if (!S.xyHistory.length) return;
  const last = S.xyHistory.pop();
  
  if (last.mode === 'puck') {
    S.curr.puckXY.pop();
    S.xySlot = Math.max(1, S.curr.puckXY.length + 1);
  } else if (last.player) {
    const p = S.curr.players.find(p => p.num === last.player);
    if (p) {
      p.xy.pop();
      S.xySlot = Math.max(1, p.xy.length + 1);
    }
  }
  
  renderXYSlots(); renderMarkers();
  toast('Undo XY', 'success');
}

function clearCurrentXY() {
  if (S.xyMode === 'puck') S.curr.puckXY = [];
  else if (S.selectedPlayer) S.selectedPlayer.xy = [];
  S.xySlot = 1;
  renderXYSlots(); renderMarkers();
}

function clearRink() {
  S.xyHistory = [];
  renderMarkers();
  toast('Rink cleared', 'success');
}

/**
 * Handle mouse hover over rink for XY tooltips (v5)
 * Shows coordinates on hover, and player info when hovering markers
 */
function handleRinkHover(event) {
  const svg = document.getElementById('rinkSvg');
  const tooltip = document.getElementById('xyTooltip');
  if (!svg || !tooltip) return;
  
  const rect = svg.getBoundingClientRect();
  const pt = svg.createSVGPoint();
  pt.x = event.clientX; pt.y = event.clientY;
  const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
  
  // v16.06: Show center-relative coordinates
  const x = Math.round((svgPt.x - 100) * 10) / 10;
  const y = Math.round((svgPt.y - 42.5) * 10) / 10;
  
  // Check if hovering over a marker
  const target = event.target;
  let tooltipContent = `(${x}, ${y})`;
  
  if (target && target.dataset && target.dataset.type) {
    const type = target.dataset.type;
    const markerX = target.dataset.x || '--';
    const markerY = target.dataset.y || '--';
    
    if (type === 'puck') {
      tooltipContent = `üèí Puck (${markerX}, ${markerY})`;
    } else if (type === 'player') {
      const num = target.dataset.num || '?';
      const name = target.dataset.name || '';
      tooltipContent = `#${num} ${name}\n(${markerX}, ${markerY})`;
    } else if (type === 'history') {
      const evtNum = target.dataset.evtnum || '?';
      const evtType = target.dataset.evttype || '';
      tooltipContent = `Event #${evtNum} - ${evtType}\n(${markerX}, ${markerY})`;
    }
  }
  
  // Position tooltip at cursor
  tooltip.textContent = tooltipContent;
  tooltip.style.display = 'block';
  tooltip.style.left = (event.clientX - rect.left) + 'px';
  tooltip.style.top = (event.clientY - rect.top) + 'px';
}

/**
 * Hide XY tooltip (v5)
 */
function hideXYTooltip() {
  const tooltip = document.getElementById('xyTooltip');
  if (tooltip) tooltip.style.display = 'none';
}

// ============================================================
// NET LOCATION
// ============================================================
function handleNetClick(event) {
  const svg = document.getElementById('netSvg');
  const rect = svg.getBoundingClientRect();
  const x = ((event.clientX - rect.left) / rect.width) * 72;
  const y = ((event.clientY - rect.top) / rect.height) * 48;
  
  S.curr.netXY = { x: Math.round(x * 10) / 10, y: Math.round(y * 10) / 10 };
  
  const marker = document.getElementById('netMarker');
  marker.innerHTML = `<circle cx="${S.curr.netXY.x}" cy="${S.curr.netXY.y}" r="4" fill="#00d4aa" stroke="#fff" stroke-width="1"/>`;
}

function clearNetXY() {
  S.curr.netXY = null;
  document.getElementById('netMarker').innerHTML = '';
}

function closeNetModal() {
  document.getElementById('netModal').classList.remove('show');
}

// ============================================================
// LOG EVENT
// ============================================================
function logEvent() {
  if (!S.curr.type) { toast('Select event type', 'error'); return; }
  
  // v23.3: Check if user wants to skip confirmation
  if (document.getElementById('skipConfirm')?.checked) {
    logEventDirect();
    return;
  }
  
  // Show confirmation modal
  showConfirmModal();
}

/**
 * v23.3: Log event directly without confirmation modal
 */
function logEventDirect() {
  if (!S.curr.type) { toast('Select event type', 'error'); return; }
  
  // Get values directly from the main form
  const startTime = document.getElementById('evtStartTime').value || document.getElementById('clock').value;
  const endTime = document.getElementById('evtEndTime').value || startTime;
  const zone = document.getElementById('evtZone').value || calculateZone();
  const success = document.getElementById('evtSuccess').value || deriveSuccess();
  const strength = document.getElementById('evtStrength').value || deriveStrength();
  const isHighlight = document.getElementById('isHighlight').checked;
  
  // Detect pressure for all event players
  detectPressure();
  
  // For Possession and Zone_Entry_Exit, copy player XY to puck
  const detail1 = document.getElementById('evtD1').value || '';
  const detail2 = document.getElementById('evtD2').value || '';
  const isPossessionEvent = S.curr.type === 'Possession' || 
    (S.curr.type === 'Zone_Entry_Exit' && (detail2.includes('Rush') || detail1.includes('Entry')));
  
  if (isPossessionEvent && S.curr.puckXY.length === 0) {
    const evtPlayer1 = S.curr.players.find(p => 
      p.role === 'event_team_player_1' || p.role === 'event_player_1' || p.roleNum === 1
    );
    if (evtPlayer1?.xy?.length > 0) {
      S.curr.puckXY = evtPlayer1.xy.map(xy => ({...xy}));
    }
  }
  
  // Build linked event chain
  let linkedEventChain = [];
  if (S.linkedEventIdx !== null) {
    linkedEventChain.push(S.linkedEventIdx);
    const linkedEvt = S.events.find(e => e.idx === S.linkedEventIdx);
    if (linkedEvt?.linkedEventChain?.length) {
      linkedEventChain = [...linkedEvt.linkedEventChain, S.linkedEventIdx];
    }
  }
  
  const evt = {
    idx: S.evtIdx++,
    game_id: S.gameId,
    period: S.period,
    start_time: startTime,
    end_time: endTime,
    team: S.evtTeam,
    type: S.curr.type,
    detail1: detail1,
    detail2: detail2,
    zone,
    success,
    strength,
    linkedEventIdx: S.linkedEventIdx,
    linkedEventChain,
    isHighlight,
    puckXY: [...S.curr.puckXY],
    netXY: S.curr.netXY,
    players: S.curr.players.map(p => ({...p, xy: [...(p.xy || [])]}))
  };
  
  S.events.push(evt);
  
  // v23.4: Auto-sort and reindex events by time
  sortAndReindexEvents();
  
  S.lastEndTime = endTime;
  S.linkedEventIdx = null;
  
  const highlightIcon = isHighlight ? ' ‚≠ê' : '';
  toast(`Event #${evt.idx + 1}: ${evt.type}${highlightIcon}`, 'success');
  
  clearEvent();
  document.getElementById('evtStartTime').value = endTime;
  
  renderEvents(); renderMarkers(); updateScores(); updateBoxScore();
  updateNextPlaySuggestions();
  autoSave();
  
  if (document.getElementById('autoEditNext')?.checked) {
    setTimeout(() => editEvent(S.events.length - 1), 100);
  }
}

/**
 * v23.3: Show confirmation modal before logging event
 */
function showConfirmModal() {
  const modal = document.getElementById('confirmEventModal');
  
  // Populate type dropdown with all event types
  const types = Object.keys(LISTS.details);
  document.getElementById('confirmType').innerHTML = types.map(t => 
    `<option value="${t}" ${t === S.curr.type ? 'selected' : ''}>${t}</option>`
  ).join('');
  
  // Team dropdown with team names
  const teamSel = document.getElementById('confirmTeam');
  teamSel.innerHTML = `<option value="home">${S.homeTeam || 'Home'}</option><option value="away">${S.awayTeam || 'Away'}</option>`;
  teamSel.value = S.evtTeam;
  
  // Populate D1 dropdown
  onConfirmTypeChange();
  document.getElementById('confirmD1').value = document.getElementById('evtD1').value || '';
  onConfirmD1Change();
  document.getElementById('confirmD2').value = document.getElementById('evtD2').value || '';
  
  // Other fields
  document.getElementById('confirmZone').value = document.getElementById('evtZone').value || calculateZone() || '';
  document.getElementById('confirmSuccess').value = document.getElementById('evtSuccess').value || deriveSuccess() || '';
  document.getElementById('confirmStrength').value = document.getElementById('evtStrength').value || deriveStrength() || '5v5';
  document.getElementById('confirmStartTime').value = document.getElementById('evtStartTime').value || document.getElementById('clock').value;
  document.getElementById('confirmEndTime').value = document.getElementById('evtEndTime').value || document.getElementById('evtStartTime').value || document.getElementById('clock').value;
  document.getElementById('confirmHighlight').checked = document.getElementById('isHighlight').checked;
  document.getElementById('confirmLinked').value = S.linkedEventIdx !== null ? S.linkedEventIdx + 1 : '';
  
  // Show players
  const evtPlayers = S.curr.players.filter(p => p.role?.startsWith('event'));
  const oppPlayers = S.curr.players.filter(p => p.role?.startsWith('opp'));
  let playersHtml = '';
  if (evtPlayers.length) {
    playersHtml += `<span style="color:var(--accent);">Event: ${evtPlayers.map(p => `#${p.num}`).join(', ')}</span>`;
  }
  if (oppPlayers.length) {
    playersHtml += ` <span style="color:var(--danger);">Opp: ${oppPlayers.map(p => `#${p.num}`).join(', ')}</span>`;
  }
  document.getElementById('confirmPlayers').innerHTML = playersHtml || '<span style="color:var(--muted);">No players</span>';
  
  modal.classList.add('show');
}

function onConfirmTypeChange() {
  const type = document.getElementById('confirmType').value;
  const d1Options = LISTS.details[type]?.d1 || [];
  document.getElementById('confirmD1').innerHTML = '<option value="">--</option>' + 
    d1Options.map(o => `<option value="${o}">${o}</option>`).join('');
  document.getElementById('confirmD2').innerHTML = '<option value="">--</option>';
}

function onConfirmD1Change() {
  const type = document.getElementById('confirmType').value;
  const d1 = document.getElementById('confirmD1').value;
  const opts = LISTS.details[type] || {};
  let d2Opts = opts.d2 || [];
  
  if (d1.includes('Giveaway') && opts.d2_Giveaway) d2Opts = opts.d2_Giveaway;
  else if (d1.includes('Takeaway') && opts.d2_Takeaway) d2Opts = opts.d2_Takeaway;
  else if (d1.includes('Entry') && opts.d2_Entry) d2Opts = opts.d2_Entry;
  else if (d1.includes('Exit') && opts.d2_Exit) d2Opts = opts.d2_Exit;
  
  document.getElementById('confirmD2').innerHTML = '<option value="">--</option>' + 
    d2Opts.map(o => `<option value="${o}">${o}</option>`).join('');
}

function closeConfirmModal() {
  document.getElementById('confirmEventModal').classList.remove('show');
}

/**
 * v23.3: Confirm and log the event, then continue tracking
 */
function confirmAndContinue() {
  doLogEvent();
  closeConfirmModal();
}

/**
 * v23.3: Confirm and log the event
 */
function confirmAndLog() {
  doLogEvent();
  closeConfirmModal();
}

/**
 * v23.3: Actually log the event (called from confirmation modal)
 */
function doLogEvent() {
  // Get values from confirmation modal
  const type = document.getElementById('confirmType').value;
  const team = document.getElementById('confirmTeam').value;
  const detail1 = document.getElementById('confirmD1').value;
  const detail2 = document.getElementById('confirmD2').value;
  const zone = document.getElementById('confirmZone').value;
  const success = document.getElementById('confirmSuccess').value;
  const strength = document.getElementById('confirmStrength').value;
  const startTime = document.getElementById('confirmStartTime').value;
  const endTime = document.getElementById('confirmEndTime').value || startTime;
  const isHighlight = document.getElementById('confirmHighlight').checked;
  const linkedInput = document.getElementById('confirmLinked').value;
  const linkedEventIdx = linkedInput ? parseInt(linkedInput) - 1 : null;
  
  // Detect pressure for all event players
  detectPressure();
  
  // v23.3: For Possession and Zone_Entry_Exit (rush/carry), copy event_player_1's XY to puckXY
  const isPossessionEvent = type === 'Possession' || 
    (type === 'Zone_Entry_Exit' && (detail2.includes('Rush') || detail1.includes('Entry')));
  
  if (isPossessionEvent && S.curr.puckXY.length === 0) {
    const evtPlayer1 = S.curr.players.find(p => 
      p.role === 'event_team_player_1' || p.role === 'event_player_1' || p.roleNum === 1
    );
    if (evtPlayer1?.xy?.length > 0) {
      S.curr.puckXY = evtPlayer1.xy.map(xy => ({...xy}));
      console.log(`Copied #${evtPlayer1.num}'s XY to puckXY for ${type}`);
    }
  }
  
  // Build linked event chain
  let linkedEventChain = [];
  if (linkedEventIdx !== null) {
    linkedEventChain.push(linkedEventIdx);
    const linkedEvt = S.events.find(e => e.idx === linkedEventIdx);
    if (linkedEvt?.linkedEventChain?.length) {
      linkedEventChain = [...linkedEvt.linkedEventChain, linkedEventIdx];
    }
  }
  
  const evt = {
    idx: S.evtIdx++,
    game_id: S.gameId,
    period: S.period,
    start_time: startTime,
    end_time: endTime,
    team: team,
    type: type,
    detail1: detail1,
    detail2: detail2,
    zone,
    success,
    strength,
    linkedEventIdx: linkedEventIdx,
    linkedEventChain,
    isHighlight,
    puckXY: [...S.curr.puckXY],
    netXY: S.curr.netXY,
    players: S.curr.players.map(p => ({...p, xy: [...(p.xy || [])]}))
  };
  
  S.events.push(evt);
  
  // v23.4: Auto-sort and reindex events by time
  sortAndReindexEvents();
  
  S.lastEndTime = endTime;
  S.linkedEventIdx = null;
  
  const highlightIcon = isHighlight ? ' ‚≠ê' : '';
  toast(`Event #${evt.idx + 1}: ${evt.type}${highlightIcon}`, 'success');
  
  clearEvent();
  document.getElementById('evtStartTime').value = endTime;
  
  renderEvents(); renderMarkers(); updateScores(); updateBoxScore();
  updateNextPlaySuggestions();
  autoSave();
  
  if (document.getElementById('autoEditNext')?.checked) {
    setTimeout(() => editEvent(S.events.length - 1), 100);
  }
}

/**
 * v23.3: Auto-populate goalie for Shot/Save events
 * For Shot_OnNet: Add opposing goalie as opp_team_player_1
 * For Save: Add event team goalie as event_team_player_1
 */
function autoPopulateGoalie() {
  const type = S.curr.type;
  const d1 = document.getElementById('evtD1').value;
  
  // Only for shots on net or saves
  const isShotOnNet = type === 'Shot' && (d1.includes('OnNet') || d1.includes('Goal'));
  const isSave = type === 'Save';
  
  if (!isShotOnNet && !isSave) return;
  
  if (isShotOnNet) {
    // Add opposing goalie as opp_team_player_1
    const oppTeam = S.evtTeam === 'home' ? 'away' : 'home';
    const oppGoalie = S.slots[oppTeam]?.G;
    
    if (oppGoalie) {
      // Check if goalie already added
      const existing = S.curr.players.find(p => p.num === oppGoalie.num);
      if (!existing) {
        S.curr.players.push({
          num: oppGoalie.num,
          name: oppGoalie.name,
          team: oppTeam,
          role: 'opp_team_player_1',
          roleNum: 1,
          xy: [],
          playD1: 'Save_Attempt',
          playD2: '',
          playSuccess: '',
          pressuredBy: '',
          sideOfPuck: ''
        });
        renumberPlayers();
        renderQuickAdd();
        toast(`Auto-added goalie #${oppGoalie.num} as O1`, 'info');
      }
    }
  } else if (isSave) {
    // Add event team goalie as event_team_player_1
    const evtGoalie = S.slots[S.evtTeam]?.G;
    
    if (evtGoalie) {
      // Check if goalie already added
      const existing = S.curr.players.find(p => p.num === evtGoalie.num);
      if (!existing) {
        S.curr.players.push({
          num: evtGoalie.num,
          name: evtGoalie.name,
          team: S.evtTeam,
          role: 'event_team_player_1',
          roleNum: 1,
          xy: [],
          playD1: 'Save_Made',
          playD2: '',
          playSuccess: 's',
          pressuredBy: '',
          sideOfPuck: ''
        });
        renumberPlayers();
        renderQuickAdd();
        toast(`Auto-added goalie #${evtGoalie.num} as E1`, 'info');
      } else {
        // Goalie exists, ensure they're E1
        existing.role = 'event_team_player_1';
        existing.roleNum = 1;
        renumberPlayers();
        renderQuickAdd();
      }
    }
  }
}

/**
 * v23.3: Auto-link and setup for follow-up events (Shot ‚Üí Save, etc.)
 */
function autoLinkFollowUp(type) {
  const lastEvt = S.events[S.events.length - 1];
  if (!lastEvt) return;
  
  // Save after Shot_OnNet: auto-link, swap team, setup goalie
  if (type === 'Save' && lastEvt.type === 'Shot' && 
      (lastEvt.detail1?.includes('OnNet') || lastEvt.detail1?.includes('Goal'))) {
    // Auto-link to the shot
    S.linkedEventIdx = lastEvt.idx;
    document.getElementById('linkedEvt').value = lastEvt.idx + 1;
    
    // Swap to the other team (goalie's team)
    const newTeam = lastEvt.team === 'home' ? 'away' : 'home';
    setEvtTeam(newTeam);
    
    // Copy time from shot
    document.getElementById('evtStartTime').value = lastEvt.start_time;
    
    // Copy puck position from shot
    if (lastEvt.puckXY?.length) {
      S.curr.puckXY = lastEvt.puckXY.map(xy => ({...xy}));
    }
    
    // Copy net position from shot
    if (lastEvt.netXY) {
      S.curr.netXY = {...lastEvt.netXY};
    }
    
    toast(`Auto-linked to Shot #${lastEvt.idx + 1}`, 'info');
  }
  
  // Rebound after Save: auto-link
  if (type === 'Rebound' && lastEvt.type === 'Save') {
    S.linkedEventIdx = lastEvt.idx;
    document.getElementById('linkedEvt').value = lastEvt.idx + 1;
    document.getElementById('evtStartTime').value = lastEvt.start_time;
    toast(`Auto-linked to Save #${lastEvt.idx + 1}`, 'info');
  }
}

function clearEvent() {
  const preserveStartTime = document.getElementById('evtStartTime').value;
  S.curr = { type: null, players: [], puckXY: [], netXY: null };
  S.selectedPlayer = null;
  S.xySlot = 1;
  S.xyHistory = [];
  document.querySelectorAll('.evt-btn').forEach(b => b.classList.remove('active'));
  document.getElementById('evtD1').innerHTML = '<option value="">--</option>';
  document.getElementById('evtD2').innerHTML = '<option value="">--</option>';
  document.getElementById('evtZone').value = '';
  document.getElementById('evtSuccess').value = '';
  document.getElementById('evtStartTime').value = preserveStartTime; // Keep for chaining
  document.getElementById('evtEndTime').value = '';
  document.getElementById('isHighlight').checked = false;
  document.getElementById('zoneDisplay').innerHTML = '';
  renderQuickAdd(); renderXYSlots(); renderMarkers();
}

// ============================================================
// QUICK TIME & EVENT HELPERS (v5)
// ============================================================

/**
 * Copy current clock time to start time field
 */
function copyClockToStart() {
  const clock = document.getElementById('clock').value;
  document.getElementById('evtStartTime').value = clock;
  toast(`Start: ${clock}`, 'info');
}

/**
 * Copy current clock time to end time field
 */
function copyClockToEnd() {
  const clock = document.getElementById('clock').value;
  document.getElementById('evtEndTime').value = clock;
  toast(`End: ${clock}`, 'info');
}

/**
 * Copy last event's end time to current start time
 */
function copyLastEventTime() {
  if (S.events.length === 0) {
    toast('No previous events', 'info');
    return;
  }
  const lastEvt = S.events[S.events.length - 1];
  const time = lastEvt.end_time || lastEvt.start_time || '';
  document.getElementById('evtStartTime').value = time;
  toast(`Copied: ${time}`, 'info');
}

/**
 * v6: Nudge start time by variable seconds
 */
function nudgeStartTime(direction) {
  const amount = parseInt(document.getElementById('timeNudgeAmount').value) || 5;
  const startTimeEl = document.getElementById('evtStartTime');
  const newTime = nudgeTime(startTimeEl.value, direction * amount);
  startTimeEl.value = newTime;
  toast(`Start: ${newTime}`, 'info');
}

/**
 * v6: Nudge end time by variable seconds
 */
function nudgeEndTime(direction) {
  const amount = parseInt(document.getElementById('timeNudgeAmount').value) || 5;
  const endTimeEl = document.getElementById('evtEndTime');
  const newTime = nudgeTime(endTimeEl.value, direction * amount);
  endTimeEl.value = newTime;
  toast(`End: ${newTime}`, 'info');
}

/**
 * v6: Helper to add/subtract seconds from a time string (MM:SS)
 * Hockey clock counts DOWN, so adding seconds means earlier in period
 */
function nudgeTime(timeStr, seconds) {
  if (!timeStr) {
    // Use clock if no time set
    timeStr = document.getElementById('clock').value || '20:00';
  }
  const [min, sec] = (timeStr || '20:00').split(':').map(Number);
  let totalSec = (min || 0) * 60 + (sec || 0);
  totalSec += seconds; // Add seconds (hockey clock, so + goes earlier)
  
  // Clamp to 0:00 - 20:00
  totalSec = Math.max(0, Math.min(1200, totalSec));
  
  const newMin = Math.floor(totalSec / 60);
  const newSec = totalSec % 60;
  return `${newMin}:${String(newSec).padStart(2, '0')}`;
}

/**
 * Duplicate the last event with current time
 */
function duplicateLastEvent() {
  if (S.events.length === 0) {
    toast('No events to duplicate', 'info');
    return;
  }
  
  const lastEvt = S.events[S.events.length - 1];
  
  // Set event type
  setEvtType(lastEvt.type);
  
  // Set team
  setEvtTeam(lastEvt.team);
  
  // Set details
  setTimeout(() => {
    document.getElementById('evtD1').value = lastEvt.detail1 || '';
    onD1Change();
    setTimeout(() => {
      document.getElementById('evtD2').value = lastEvt.detail2 || '';
    }, 50);
  }, 50);
  
  // Set zone, success, strength
  document.getElementById('evtZone').value = lastEvt.zone || '';
  document.getElementById('evtSuccess').value = lastEvt.success || '';
  document.getElementById('evtStrength').value = lastEvt.strength || '5v5';
  
  // Copy players
  S.curr.players = lastEvt.players.map(p => ({
    ...p,
    xy: [] // Don't copy XY - needs new positions
  }));
  
  renderQuickAdd();
  toast(`Duplicated: ${lastEvt.type}`, 'success');
}

/**
 * v23.3: Auto-format time as user types
 * 1534 ‚Üí 15:34, 0709 ‚Üí 07:09, 709 ‚Üí 7:09
 */
function autoFormatTime(input) {
  let val = input.value.replace(/[^0-9:]/g, '');
  
  // If already has colon, just clean it
  if (val.includes(':')) {
    input.value = val;
    return;
  }
  
  // Auto-insert colon for 3-4 digit entries
  if (val.length === 3) {
    // 709 ‚Üí 7:09
    val = val.slice(0, 1) + ':' + val.slice(1);
  } else if (val.length === 4) {
    // 1534 ‚Üí 15:34, 0709 ‚Üí 07:09
    val = val.slice(0, 2) + ':' + val.slice(2);
    // Remove leading zero if present (07:09 ‚Üí 7:09)
    if (val.startsWith('0')) val = val.slice(1);
  }
  
  input.value = val;
}

// ============================================================
// v23.3: WORKFLOW AUTOMATION FEATURES
// ============================================================

/**
 * Add all players from current shift slots to the event
 */
function addAllOnIce() {
  const evtTeam = S.evtTeam;
  const oppTeam = evtTeam === 'home' ? 'away' : 'home';
  
  // Add event team players
  Object.entries(S.slots[evtTeam]).forEach(([pos, player]) => {
    if (player && !S.curr.players.find(p => p.num === player.num)) {
      const roleNum = S.curr.players.filter(p => p.role?.startsWith('event')).length + 1;
      S.curr.players.push({
        num: player.num,
        name: player.name,
        team: evtTeam,
        role: `event_team_player_${roleNum}`,
        roleNum,
        xy: [],
        playD1: '',
        playD2: '',
        playSuccess: '',
        pressuredBy: '',
        sideOfPuck: ''
      });
    }
  });
  
  // Add opposing team players
  Object.entries(S.slots[oppTeam]).forEach(([pos, player]) => {
    if (player && !S.curr.players.find(p => p.num === player.num)) {
      const roleNum = S.curr.players.filter(p => p.role?.startsWith('opp')).length + 1;
      S.curr.players.push({
        num: player.num,
        name: player.name,
        team: oppTeam,
        role: `opp_team_player_${roleNum}`,
        roleNum,
        xy: [],
        playD1: '',
        playD2: '',
        playSuccess: '',
        pressuredBy: '',
        sideOfPuck: ''
      });
    }
  });
  
  renumberPlayers();
  renderQuickAdd();
  toast(`Added ${S.curr.players.length} players from ice`, 'success');
}

/**
 * Copy all players from the last event
 */
function copyPlayersFromLast() {
  if (S.events.length === 0) {
    toast('No previous events', 'error');
    return;
  }
  
  const lastEvt = S.events[S.events.length - 1];
  if (!lastEvt.players?.length) {
    toast('Last event has no players', 'error');
    return;
  }
  
  // Copy players without XY
  S.curr.players = lastEvt.players.map(p => ({
    ...p,
    xy: [] // Clear XY for new positions
  }));
  
  renumberPlayers();
  renderQuickAdd();
  toast(`Copied ${S.curr.players.length} players from event #${lastEvt.idx + 1}`, 'success');
}

/**
 * Quick add player by jersey number
 */
function quickAddByNumber(num, role = 'evt') {
  // Find player in rosters
  const team = role === 'evt' ? S.evtTeam : (S.evtTeam === 'home' ? 'away' : 'home');
  const roster = S.rosters[team] || [];
  const player = roster.find(p => p.num === num || p.num === String(num));
  
  if (!player) {
    // v23.3: Check if player is on opposite team
    const otherTeam = team === 'home' ? 'away' : 'home';
    const otherRoster = S.rosters[otherTeam] || [];
    const otherPlayer = otherRoster.find(p => p.num === num || p.num === String(num));
    if (otherPlayer) {
      toast(`#${num} is on ${otherTeam} team - use ${role === 'evt' ? 'Opp' : 'Event'} side`, 'warning');
    } else {
      toast(`Player #${num} not found in either roster`, 'error');
    }
    return false;
  }
  
  // Check if already added
  if (S.curr.players.find(p => p.num === player.num)) {
    toast(`#${num} already in event`, 'warning');
    return false;
  }
  
  // v23.3: Guard - check if adding this player would create mixed teams
  const existingPlayers = S.curr.players.filter(p => p.role?.startsWith(role === 'evt' ? 'event' : 'opp'));
  if (existingPlayers.length > 0) {
    const existingTeam = existingPlayers[0].team;
    if (existingTeam !== team) {
      toast(`${role === 'evt' ? 'Event' : 'Opp'} players must all be from same team (${existingTeam})`, 'error');
      return false;
    }
  }
  
  const roleNum = S.curr.players.filter(p => p.role?.startsWith(role === 'evt' ? 'event' : 'opp')).length + 1;
  S.curr.players.push({
    num: player.num,
    name: player.name,
    team: team,
    role: `${role === 'evt' ? 'event' : 'opp'}_team_player_${roleNum}`,
    roleNum,
    xy: [],
    playD1: '',
    playD2: '',
    playSuccess: '',
    pressuredBy: '',
    sideOfPuck: ''
  });
  
  renumberPlayers();
  renderQuickAdd();
  toast(`Added #${num} ${player.name} as ${role === 'evt' ? 'E' : 'O'}${roleNum}`, 'success');
  return true;
}

/**
 * Toggle sequence mode - auto-links events and keeps same time
 */
let sequenceModeActive = false;
function toggleSequenceMode() {
  sequenceModeActive = !sequenceModeActive;
  const btn = document.getElementById('seqModeBtn');
  if (btn) {
    btn.classList.toggle('active', sequenceModeActive);
    btn.style.background = sequenceModeActive ? 'var(--accent)' : '';
    btn.style.color = sequenceModeActive ? '#000' : '';
  }
  toast(`Sequence mode: ${sequenceModeActive ? 'ON' : 'OFF'}`, sequenceModeActive ? 'success' : 'info');
  
  if (sequenceModeActive && S.events.length > 0) {
    // Auto-link to last event
    const lastEvt = S.events[S.events.length - 1];
    S.linkedEventIdx = lastEvt.idx;
    document.getElementById('linkedEvt').value = lastEvt.idx + 1;
    document.getElementById('evtStartTime').value = lastEvt.start_time;
  }
}

/**
 * Get suggested next event type based on last event
 */
function getSuggestedNextEvent() {
  if (S.events.length === 0) return null;
  
  const lastEvt = S.events[S.events.length - 1];
  const type = lastEvt.type;
  const d1 = lastEvt.detail1 || '';
  
  // Shot on net ‚Üí Save
  if (type === 'Shot' && (d1.includes('OnNet') || d1.includes('Goal'))) {
    return { type: 'Save', reason: 'after shot on net' };
  }
  
  // Save ‚Üí Rebound or Possession
  if (type === 'Save') {
    return { type: 'Rebound', reason: 'after save', alt: 'Possession' };
  }
  
  // Faceoff ‚Üí Possession
  if (type === 'Faceoff') {
    return { type: 'Possession', reason: 'after faceoff' };
  }
  
  // Zone entry ‚Üí Possession or Shot
  if (type === 'Zone_Entry_Exit' && d1.includes('Entry')) {
    return { type: 'Possession', reason: 'after zone entry', alt: 'Shot' };
  }
  
  // Turnover takeaway ‚Üí Possession
  if (type === 'Turnover' && d1.includes('Takeaway')) {
    return { type: 'Possession', reason: 'after takeaway' };
  }
  
  // Pass completed ‚Üí continue possession or shot
  if (type === 'Pass' && lastEvt.success === 's') {
    return { type: 'Shot', reason: 'after pass', alt: 'Pass' };
  }
  
  return null;
}

/**
 * Highlight suggested next event button
 */
function highlightSuggestedEvent() {
  // Clear previous highlights
  document.querySelectorAll('.evt-btn.suggested').forEach(b => b.classList.remove('suggested'));
  
  const suggestion = getSuggestedNextEvent();
  if (suggestion) {
    const btn = document.querySelector(`.evt-btn[data-type="${suggestion.type}"]`);
    if (btn) {
      btn.classList.add('suggested');
      btn.title = `Suggested: ${suggestion.reason}`;
    }
    if (suggestion.alt) {
      const altBtn = document.querySelector(`.evt-btn[data-type="${suggestion.alt}"]`);
      if (altBtn) altBtn.classList.add('suggested');
    }
  }
}

/**
 * Quick faceoff - click zone and winner
 */
function quickFaceoff(zone, winner) {
  // Set event type
  setEvtType('Faceoff');
  
  // Set zone
  document.getElementById('evtZone').value = zone;
  
  // Set team and detail based on winner
  if (winner === 'evt') {
    document.getElementById('evtD1').value = 'Faceoff_Won';
    document.getElementById('evtSuccess').value = 's';
  } else {
    document.getElementById('evtD1').value = 'Faceoff_Lost';
    document.getElementById('evtSuccess').value = 'u';
  }
  
  // Copy clock time
  document.getElementById('evtStartTime').value = document.getElementById('clock').value;
  
  renderQuickAdd();
  toast(`Faceoff: ${zone.toUpperCase()} zone, ${winner === 'evt' ? 'Won' : 'Lost'}`, 'success');
}

/**
 * Smart first click: if puck mode and no puck XY, place puck; else place player
 * Called from rink click handler
 */
function smartFirstClick() {
  // If in player mode but no players added, switch to puck first
  if (S.xyMode === 'player' && S.curr.players.length === 0 && S.curr.puckXY.length === 0) {
    setXYMode('puck');
    toast('No players - placing puck first', 'info');
    return true; // Handled
  }
  return false; // Let normal handler proceed
}

/**
 * Handle jersey number input (type number to add player)
 */
let jerseyInputBuffer = '';
let jerseyInputTimeout = null;

function handleJerseyInput(key) {
  // Only handle if a digit
  if (!/^\d$/.test(key)) {
    jerseyInputBuffer = '';
    return false;
  }
  
  jerseyInputBuffer += key;
  
  // Clear timeout
  if (jerseyInputTimeout) clearTimeout(jerseyInputTimeout);
  
  // Wait for more digits or timeout
  jerseyInputTimeout = setTimeout(() => {
    if (jerseyInputBuffer.length > 0) {
      const num = parseInt(jerseyInputBuffer);
      if (num > 0 && num < 100) {
        quickAddByNumber(num, 'evt');
      }
      jerseyInputBuffer = '';
    }
  }, 500); // 500ms timeout
  
  return true;
}

// Add CSS for suggested events
const suggestedStyle = document.createElement('style');
suggestedStyle.textContent = `
  .evt-btn.suggested { 
    box-shadow: 0 0 0 2px var(--accent), 0 0 8px var(--accent); 
    animation: pulse-suggest 1s infinite;
  }
  @keyframes pulse-suggest {
    0%, 100% { box-shadow: 0 0 0 2px var(--accent), 0 0 8px var(--accent); }
    50% { box-shadow: 0 0 0 2px var(--accent), 0 0 15px var(--accent); }
  }
  .btn-sm.mode-active {
    background: var(--accent) !important;
    color: #000 !important;
  }
`;
document.head.appendChild(suggestedStyle);

// ============================================================
// v23.3: QUICK PENALTY
// ============================================================

/**
 * Populate quick penalty player dropdown based on event team
 */
function updateQuickPenaltyPlayers() {
  const team = S.evtTeam;
  const roster = S.rosters[team] || [];
  const select = document.getElementById('quickPenPlayer');
  if (!select) return;
  
  select.innerHTML = '<option value="">Player #</option>' + 
    roster.map(p => `<option value="${p.num}">#${p.num} ${p.name}</option>`).join('');
}

/**
 * Log a penalty quickly
 */
function quickPenalty() {
  const playerNum = document.getElementById('quickPenPlayer').value;
  const penType = document.getElementById('quickPenType').value;
  
  if (!playerNum || !penType) {
    toast('Select player and penalty type', 'error');
    return;
  }
  
  // Set event type
  setEvtType('Penalty');
  
  // Set detail
  setTimeout(() => {
    document.getElementById('evtD1').value = penType;
    
    // Add player
    quickAddByNumber(parseInt(playerNum), 'evt');
    
    // Set time
    document.getElementById('evtStartTime').value = document.getElementById('clock').value;
    
    // Auto-log
    logEventDirect();
    
    // Reset dropdowns
    document.getElementById('quickPenPlayer').value = '';
    document.getElementById('quickPenType').value = '';
    
    // v23.4: Start power play timer
    startPowerPlay(S.evtTeam === 'home' ? 'away' : 'home');
    
    toast(`Penalty: #${playerNum} - ${penType.replace('Penalty_', '')}`, 'success');
  }, 50);
}

// ============================================================
// v23.4: QUICK STOPPAGE
// ============================================================

/**
 * Log a stoppage quickly
 */
function quickStoppage(type) {
  setEvtType('Stoppage');
  
  setTimeout(() => {
    document.getElementById('evtD1').value = `Stoppage_${type}`;
    document.getElementById('evtStartTime').value = document.getElementById('clock').value;
    document.getElementById('evtZone').value = type === 'Icing' ? 'd' : 'n';
    
    // Auto-log
    logEventDirect();
    
    toast(`Stoppage: ${type}`, 'success');
  }, 50);
}

// ============================================================
// v23.4: UNDO LAST EVENT
// ============================================================

/**
 * Undo the last logged event
 */
function undoLastEvent() {
  if (S.events.length === 0) {
    toast('No events to undo', 'warning');
    return;
  }
  
  const lastEvt = S.events.pop();
  S.evtIdx = Math.max(0, S.evtIdx - 1);
  
  toast(`Undid event #${lastEvt.idx + 1}: ${lastEvt.type}`, 'success');
  
  renderEvents();
  renderMarkers();
  updateScores();
  updateBoxScore();
  updateNextPlaySuggestions();
  autoSave();
}

// ============================================================
// v23.4: POWER PLAY TIMER
// ============================================================
let ppTimerInterval = null;
let ppTimerSeconds = 180; // Default 3 minutes for rec league
let ppTeam = null;
let penaltyMinutes = 3; // Configurable penalty minutes

/**
 * Update penalty minutes setting
 */
function updatePPMinutes() {
  const input = document.getElementById('ppMinutes');
  if (input) {
    penaltyMinutes = parseInt(input.value) || 3;
    localStorage.setItem('benchsight_penaltyMinutes', penaltyMinutes);
  }
}

/**
 * Start power play timer
 */
function startPowerPlay(team) {
  ppTeam = team;
  
  // Use configurable penalty minutes
  const mins = parseInt(document.getElementById('ppMinutes')?.value) || penaltyMinutes;
  ppTimerSeconds = mins * 60;
  
  const row = document.getElementById('ppTimerRow');
  const teamEl = document.getElementById('ppTimerTeam');
  const displayEl = document.getElementById('ppTimerDisplay');
  
  if (!row) return;
  
  row.style.display = 'flex';
  teamEl.textContent = `${team === 'home' ? (S.homeTeam || 'Home') : (S.awayTeam || 'Away')} PP:`;
  row.style.background = team === 'home' ? 'var(--home)' : 'var(--away)';
  
  // Update display
  displayEl.textContent = `${mins}:00`;
  
  // Update strength dropdown
  document.getElementById('evtStrength').value = team === S.evtTeam ? '5v4' : '4v5';
  
  // Clear existing timer
  if (ppTimerInterval) clearInterval(ppTimerInterval);
  
  // Start countdown
  ppTimerInterval = setInterval(() => {
    ppTimerSeconds--;
    const min = Math.floor(ppTimerSeconds / 60);
    const sec = ppTimerSeconds % 60;
    displayEl.textContent = `${min}:${String(sec).padStart(2, '0')}`;
    
    if (ppTimerSeconds <= 0) {
      endPowerPlay();
    }
  }, 1000);
  
  toast(`Power Play started: ${team === 'home' ? S.homeTeam : S.awayTeam} (${mins} min)`, 'info');
}

/**
 * End power play timer
 */
function endPowerPlay() {
  if (ppTimerInterval) {
    clearInterval(ppTimerInterval);
    ppTimerInterval = null;
  }
  
  const row = document.getElementById('ppTimerRow');
  if (row) row.style.display = 'none';
  
  document.getElementById('evtStrength').value = '5v5';
  ppTeam = null;
  
  toast('Power Play ended', 'info');
}

// ============================================================
// v23.4: EVENT TEMPLATES
// ============================================================

const EVENT_TEMPLATES = {
  dumpAndChase: {
    name: 'Dump & Chase',
    events: [
      { type: 'Zone_Entry_Exit', d1: 'Zone_Entry', d2: 'Entry_Dump', zone: 'o' },
      { type: 'Possession', d1: 'Possession_Recovered', zone: 'o' }
    ]
  },
  cyclePlay: {
    name: 'Cycle Play',
    events: [
      { type: 'Possession', d1: 'Possession_Cycle', zone: 'o' },
      { type: 'Pass', d1: 'Pass_Cycle', zone: 'o' }
    ]
  },
  breakout: {
    name: 'Breakout',
    events: [
      { type: 'Possession', d1: 'Possession_Breakout', zone: 'd' },
      { type: 'Zone_Entry_Exit', d1: 'Zone_Exit', d2: 'Exit_Pass', zone: 'd' }
    ]
  },
  forecheck: {
    name: 'Forecheck',
    events: [
      { type: 'Possession', d1: 'Possession_Forecheck', zone: 'o' },
      { type: 'Turnover', d1: 'Turnover_Takeaway', zone: 'o', success: 's' }
    ]
  },
  oddManRush: {
    name: 'Odd-Man Rush',
    events: [
      { type: 'Zone_Entry_Exit', d1: 'Zone_Entry', d2: 'Entry_Rush', zone: 'o' },
      { type: 'Shot', d1: 'Shot_OnNet', zone: 'o' }
    ]
  }
};

/**
 * Apply selected event template
 */
function applyTemplate() {
  const select = document.getElementById('eventTemplates');
  const templateKey = select.value;
  
  if (!templateKey || !EVENT_TEMPLATES[templateKey]) {
    toast('Select a template', 'warning');
    return;
  }
  
  const template = EVENT_TEMPLATES[templateKey];
  const firstEvent = template.events[0];
  
  // Set up first event
  setEvtType(firstEvent.type);
  
  setTimeout(() => {
    if (firstEvent.d1) document.getElementById('evtD1').value = firstEvent.d1;
    if (firstEvent.d2) {
      onD1Change();
      setTimeout(() => {
        document.getElementById('evtD2').value = firstEvent.d2;
      }, 50);
    }
    if (firstEvent.zone) document.getElementById('evtZone').value = firstEvent.zone;
    if (firstEvent.success) document.getElementById('evtSuccess').value = firstEvent.success;
    
    // Enable sequence mode for multi-event templates
    if (template.events.length > 1 && !sequenceModeActive) {
      toggleSequenceMode();
    }
    
    toast(`Template: ${template.name} - ${template.events.length} events`, 'success');
  }, 50);
  
  // Reset dropdown
  select.value = '';
}

// ============================================================
// v23.4: PERIOD END CHECKLIST
// ============================================================

/**
 * Show period end checklist modal
 */
function showPeriodEndChecklist() {
  const issues = [];
  
  // Check goal count
  const homeGoals = S.events.filter(e => e.type === 'Goal' && e.detail1 === 'Goal_Scored' && e.team === 'home').length;
  const awayGoals = S.events.filter(e => e.type === 'Goal' && e.detail1 === 'Goal_Scored' && e.team === 'away').length;
  
  // Check for unclosed shifts
  const currentPeriodShifts = S.shifts.filter(sh => sh.period === S.period);
  const unclosedShifts = currentPeriodShifts.filter(sh => !sh.end_time);
  if (unclosedShifts.length > 0) {
    issues.push(`‚ö†Ô∏è ${unclosedShifts.length} unclosed shift(s) in P${S.period}`);
  }
  
  // Check for events without players
  const eventsWithoutPlayers = S.events.filter(e => e.period === S.period && (!e.players || e.players.length === 0));
  if (eventsWithoutPlayers.length > 0) {
    issues.push(`‚ö†Ô∏è ${eventsWithoutPlayers.length} event(s) without players`);
  }
  
  // Check shot-save ratio
  const shotsOnNet = S.events.filter(e => e.period === S.period && e.type === 'Shot' && 
    (e.detail1?.includes('OnNet') || e.detail1?.includes('Goal'))).length;
  const saves = S.events.filter(e => e.period === S.period && e.type === 'Save').length;
  const goals = S.events.filter(e => e.period === S.period && e.type === 'Goal' && e.detail1 === 'Goal_Scored').length;
  
  if (shotsOnNet > saves + goals) {
    issues.push(`‚ö†Ô∏è ${shotsOnNet - saves - goals} shot(s) on net missing saves`);
  }
  
  // Faceoff balance check
  const foWins = S.events.filter(e => e.period === S.period && e.type === 'Faceoff' && e.detail1?.includes('Won')).length;
  const foLosses = S.events.filter(e => e.period === S.period && e.type === 'Faceoff' && e.detail1?.includes('Lost')).length;
  
  // Build checklist HTML
  let html = `
    <h3>üìã Period ${S.period} Checklist</h3>
    <div style="margin:15px 0;">
      <h4 style="color:var(--accent);">Score</h4>
      <div style="display:flex;justify-content:space-around;margin:10px 0;">
        <div style="text-align:center;">
          <div style="font-size:24px;font-weight:bold;color:var(--home);">${homeGoals}</div>
          <div style="font-size:10px;color:var(--muted);">${S.homeTeam || 'Home'}</div>
        </div>
        <div style="font-size:24px;color:var(--muted);">-</div>
        <div style="text-align:center;">
          <div style="font-size:24px;font-weight:bold;color:var(--away);">${awayGoals}</div>
          <div style="font-size:10px;color:var(--muted);">${S.awayTeam || 'Away'}</div>
        </div>
      </div>
    </div>
    <div style="margin:15px 0;">
      <h4 style="color:var(--accent);">Stats</h4>
      <div style="font-size:11px;color:var(--text);">
        <div>Shots on Net: ${shotsOnNet}</div>
        <div>Saves: ${saves}</div>
        <div>Faceoffs: ${foWins}W - ${foLosses}L (${foWins + foLosses > 0 ? Math.round(foWins / (foWins + foLosses) * 100) : 0}%)</div>
        <div>Events: ${S.events.filter(e => e.period === S.period).length}</div>
        <div>Shifts: ${currentPeriodShifts.length}</div>
      </div>
    </div>
  `;
  
  if (issues.length > 0) {
    html += `
      <div style="margin:15px 0;background:rgba(245,158,11,0.1);padding:10px;border-radius:4px;">
        <h4 style="color:var(--warning);">Issues Found</h4>
        <ul style="font-size:11px;margin:5px 0 0 15px;">
          ${issues.map(i => `<li>${i}</li>`).join('')}
        </ul>
      </div>
    `;
  } else {
    html += `
      <div style="margin:15px 0;background:rgba(34,197,94,0.1);padding:10px;border-radius:4px;">
        <h4 style="color:var(--success);">‚úì All Checks Passed</h4>
      </div>
    `;
  }
  
  html += `
    <div class="modal-actions" style="margin-top:15px;">
      <button onclick="document.getElementById('checklistModal').classList.remove('show')">Close</button>
      <button class="btn-primary" onclick="advancePeriod()">Next Period ‚Üí</button>
    </div>
  `;
  
  // Show in a modal
  let modal = document.getElementById('checklistModal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'checklistModal';
    modal.className = 'overlay';
    modal.innerHTML = `<div class="modal" style="min-width:350px;"></div>`;
    document.body.appendChild(modal);
  }
  modal.querySelector('.modal').innerHTML = html;
  modal.classList.add('show');
}

/**
 * Advance to next period
 */
function advancePeriod() {
  document.getElementById('checklistModal')?.classList.remove('show');
  
  if (S.period === 1) S.period = 2;
  else if (S.period === 2) S.period = 3;
  else if (S.period === 3) S.period = 'OT';
  
  document.querySelectorAll('.period-btn').forEach(b => b.classList.remove('active'));
  document.querySelector(`.period-btn[data-period="${S.period}"]`)?.classList.add('active');
  
  // Reset clock to new period length
  const newPeriodLength = getPeriodLength(S.period);
  document.getElementById('clock').value = `${newPeriodLength}:00`;
  
  toast(`Advanced to Period ${S.period} (${newPeriodLength} min)`, 'success');
}

// ============================================================
// v23.4: SHIFT LENGTH WARNING
// ============================================================
let shiftWarningInterval = null;

/**
 * Start shift length monitoring
 */
function startShiftMonitoring() {
  if (shiftWarningInterval) clearInterval(shiftWarningInterval);
  
  shiftWarningInterval = setInterval(() => {
    const shiftStart = document.getElementById('shiftStart').value;
    const currentClock = document.getElementById('clock').value;
    
    if (!shiftStart || !currentClock) return;
    
    const startParts = shiftStart.split(':').map(Number);
    const currentParts = currentClock.split(':').map(Number);
    
    const startSec = startParts[0] * 60 + startParts[1];
    const currentSec = currentParts[0] * 60 + currentParts[1];
    
    // Clock counts down
    const shiftLength = startSec - currentSec;
    
    if (shiftLength >= 90 && shiftLength < 92) { // Only warn once
      toast('‚ö†Ô∏è Shift is 90+ seconds - consider ending', 'warning');
    }
  }, 2000);
}

// ============================================================
// v23.4: RECENT PLAYERS PINNED
// ============================================================

/**
 * Get recently used players (from last 3 events)
 */
function getRecentPlayers() {
  const recentEvents = S.events.slice(-3);
  const recentNums = new Set();
  
  recentEvents.forEach(evt => {
    evt.players?.forEach(p => {
      recentNums.add(p.num);
    });
  });
  
  return Array.from(recentNums);
}

// ============================================================
// v23.4: VIDEO TIME SYNC
// ============================================================
let videoOffset = 0; // Seconds between video time and game clock

/**
 * Set video offset
 */
function setVideoOffset() {
  const videoTime = prompt('Enter video timestamp (MM:SS) when clock shows current time:');
  if (!videoTime) return;
  
  const videoParts = videoTime.split(':').map(Number);
  const videoSec = videoParts[0] * 60 + videoParts[1];
  
  const clockTime = document.getElementById('clock').value;
  const clockParts = clockTime.split(':').map(Number);
  const clockSec = clockParts[0] * 60 + clockParts[1];
  
  // Video offset = video time when game clock shows current value
  // For period 1 at 18:00, if video shows 2:30, offset = 150 seconds
  videoOffset = videoSec;
  
  localStorage.setItem('benchsight_videoOffset', videoOffset);
  toast(`Video offset set: ${videoTime}`, 'success');
}

/**
 * Get video timestamp for a game clock time
 */
function getVideoTimestamp(clockTime, period) {
  const clockParts = clockTime.split(':').map(Number);
  const clockSec = clockParts[0] * 60 + clockParts[1];
  const periodLengthSec = getPeriodLengthSeconds(period);
  
  // Time elapsed in period = periodLength - clockSec
  const elapsedInPeriod = periodLengthSec - clockSec;
  
  // Add previous periods (using their specific lengths)
  let totalElapsed = elapsedInPeriod;
  if (period >= 2) totalElapsed += getPeriodLengthSeconds(1) + (S.intermission1 || 900);
  if (period >= 3) totalElapsed += getPeriodLengthSeconds(2) + (S.intermission2 || 900);
  if (period === 'OT' || period === 4) totalElapsed += getPeriodLengthSeconds(3) + (S.intermission3 || 300);
  
  // Add video offset
  const videoTime = videoOffset + totalElapsed;
  
  const min = Math.floor(videoTime / 60);
  const sec = videoTime % 60;
  return `${min}:${String(sec).padStart(2, '0')}`;
}

// ============================================================
// v23.4: ZONE CLICK SUGGESTIONS
// ============================================================

/**
 * Suggest event type based on zone clicked
 */
function suggestEventFromZone(zone) {
  if (S.curr.type) return; // Don't suggest if type already set
  
  const suggestions = {
    'o': ['Shot', 'Pass', 'Possession'],
    'd': ['Possession', 'Zone_Entry_Exit', 'Pass'],
    'n': ['Zone_Entry_Exit', 'Faceoff', 'Pass']
  };
  
  const zoneSuggestions = suggestions[zone] || [];
  if (zoneSuggestions.length > 0) {
    // Highlight suggested buttons
    document.querySelectorAll('.evt-btn').forEach(b => b.classList.remove('zone-suggested'));
    zoneSuggestions.forEach(type => {
      const btn = document.querySelector(`.evt-btn[data-type="${type}"]`);
      if (btn) btn.classList.add('zone-suggested');
    });
  }
}

// Add CSS for zone suggestions
const zoneSuggestStyle = document.createElement('style');
zoneSuggestStyle.textContent = `
  .evt-btn.zone-suggested {
    border: 2px dashed var(--accent);
  }
`;
document.head.appendChild(zoneSuggestStyle);

// ============================================================
// v23.4: SORT AND REINDEX EVENTS
// ============================================================

/**
 * Convert time string to seconds for comparison
 */
function timeToSeconds(timeStr) {
  if (!timeStr) return 0;
  const parts = timeStr.split(':').map(Number);
  return parts[0] * 60 + (parts[1] || 0);
}

/**
 * Get period number for sorting (P1=1, P2=2, P3=3, OT=4)
 */
function periodToNumber(period) {
  if (period === 'OT' || period === 'ot') return 4;
  return parseInt(period) || 1;
}

/**
 * Sort events by period and time, then reindex all events and fix linked references
 */
function sortAndReindexEvents() {
  if (!S.events || S.events.length === 0) return;
  
  // Build old->new index mapping before sorting
  const oldIndexes = S.events.map(e => e.idx);
  
  // Sort by period (ascending), then by time (descending - higher time = earlier in period)
  S.events.sort((a, b) => {
    const periodA = periodToNumber(a.period);
    const periodB = periodToNumber(b.period);
    if (periodA !== periodB) return periodA - periodB;
    
    // Within same period, sort by time descending (18:00 before 17:00)
    const timeA = timeToSeconds(a.start_time);
    const timeB = timeToSeconds(b.start_time);
    return timeB - timeA;
  });
  
  // Build old->new index mapping
  const indexMap = {};
  oldIndexes.forEach((oldIdx, i) => {
    const newIdx = S.events.findIndex(e => e.idx === oldIdx);
    if (newIdx >= 0) {
      indexMap[oldIdx] = newIdx;
    }
  });
  
  // Reassign sequential indexes
  S.events.forEach((evt, i) => {
    evt.idx = i;
  });
  
  // Update all linkedEventIdx references
  S.events.forEach(evt => {
    if (evt.linkedEventIdx !== null && evt.linkedEventIdx !== undefined) {
      // Find the new index for the linked event
      const linkedEvt = S.events.find(e => oldIndexes[indexMap[evt.linkedEventIdx]] === e.idx || 
                                           S.events[indexMap[evt.linkedEventIdx]] === e);
      if (linkedEvt) {
        evt.linkedEventIdx = linkedEvt.idx;
      }
    }
    
    // Update linked event chain
    if (evt.linkedEventChain?.length > 0) {
      evt.linkedEventChain = evt.linkedEventChain.map(oldIdx => {
        const newEvt = S.events.find((e, i) => indexMap[oldIdx] === i);
        return newEvt ? newEvt.idx : oldIdx;
      });
    }
  });
  
  // Update evtIdx counter
  S.evtIdx = S.events.length;
}

/**
 * Manual reindex button handler
 */
function manualReindexEvents() {
  sortAndReindexEvents();
  renderEvents();
  toast('Events reindexed by time', 'success');
}

// ============================================================
// v23.4: CUSTOM CHAIN PRESETS
// ============================================================

// User-defined chain presets (saved to localStorage)
let customChainPresets = [];

/**
 * Load custom chain presets from localStorage
 */
function loadCustomChainPresets() {
  try {
    const saved = localStorage.getItem('benchsight_customChains');
    if (saved) {
      customChainPresets = JSON.parse(saved);
      updateChainPresetsUI();
    }
  } catch (e) {
    console.error('Error loading custom chains:', e);
  }
}

/**
 * Save custom chain presets to localStorage
 */
function saveCustomChainPresets() {
  localStorage.setItem('benchsight_customChains', JSON.stringify(customChainPresets));
  updateChainPresetsUI();
}

/**
 * Add current event setup as a new chain preset
 */
function saveAsChainPreset() {
  const name = prompt('Enter preset name (e.g., "Zone Exit Rush"):');
  if (!name) return;
  
  // Get current event configuration
  const currentSetup = {
    type: S.curr.type,
    d1: document.getElementById('evtD1').value,
    d2: document.getElementById('evtD2').value,
    zone: document.getElementById('evtZone').value,
    success: document.getElementById('evtSuccess').value
  };
  
  // Ask for follow-up event
  const followUpType = prompt('Follow-up event type (e.g., "Possession", "Shot"):', '');
  const followUpD1 = followUpType ? prompt('Follow-up Detail 1:', '') : '';
  
  const preset = {
    id: Date.now(),
    name: name,
    events: [
      currentSetup,
      ...(followUpType ? [{ type: followUpType, d1: followUpD1, zone: currentSetup.zone }] : [])
    ]
  };
  
  customChainPresets.push(preset);
  saveCustomChainPresets();
  toast(`Saved chain preset: ${name}`, 'success');
}

/**
 * Delete a custom chain preset
 */
function deleteChainPreset(id) {
  customChainPresets = customChainPresets.filter(p => p.id !== id);
  saveCustomChainPresets();
  toast('Preset deleted', 'info');
}

/**
 * Apply a custom chain preset
 */
function applyCustomChain(id) {
  const preset = customChainPresets.find(p => p.id === id);
  if (!preset || !preset.events.length) return;
  
  const firstEvent = preset.events[0];
  
  setEvtType(firstEvent.type);
  
  setTimeout(() => {
    if (firstEvent.d1) document.getElementById('evtD1').value = firstEvent.d1;
    if (firstEvent.d2) {
      onD1Change();
      setTimeout(() => {
        document.getElementById('evtD2').value = firstEvent.d2;
      }, 50);
    }
    if (firstEvent.zone) document.getElementById('evtZone').value = firstEvent.zone;
    if (firstEvent.success) document.getElementById('evtSuccess').value = firstEvent.success;
    
    // Enable sequence mode for multi-event chains
    if (preset.events.length > 1 && !sequenceModeActive) {
      toggleSequenceMode();
    }
    
    toast(`Applied: ${preset.name}`, 'success');
  }, 50);
}

/**
 * Update the chain presets dropdown
 */
function updateChainPresetsUI() {
  const select = document.getElementById('eventTemplates');
  if (!select) return;
  
  // Keep built-in templates, add custom ones
  const builtInOptions = `
    <option value="">üìã Templates...</option>
    <option value="dumpAndChase">Dump & Chase</option>
    <option value="cyclePlay">Cycle Play</option>
    <option value="breakout">Breakout</option>
    <option value="forecheck">Forecheck</option>
    <option value="oddManRush">Odd-Man Rush</option>
  `;
  
  const customOptions = customChainPresets.length > 0 
    ? `<optgroup label="‚îÄ‚îÄ My Presets ‚îÄ‚îÄ">` + 
      customChainPresets.map(p => `<option value="custom_${p.id}">‚≠ê ${p.name}</option>`).join('') +
      `</optgroup>`
    : '';
  
  select.innerHTML = builtInOptions + customOptions;
}

/**
 * Extended apply template to handle custom presets
 */
const originalApplyTemplate = applyTemplate;
applyTemplate = function() {
  const select = document.getElementById('eventTemplates');
  const value = select.value;
  
  if (value.startsWith('custom_')) {
    const id = parseInt(value.replace('custom_', ''));
    applyCustomChain(id);
    select.value = '';
    return;
  }
  
  originalApplyTemplate();
};

// ============================================================
// v23.4: SETTINGS EXPORT/IMPORT
// ============================================================

/**
 * Export all settings, presets, and configurations to JSON file
 */
function exportSettings() {
  const settings = {
    exportDate: new Date().toISOString(),
    version: '23.4',
    
    // Custom chain presets
    customChainPresets: customChainPresets,
    
    // Penalty minutes
    penaltyMinutes: penaltyMinutes,
    
    // Video offset
    videoOffset: videoOffset,
    
    // BS settings (stored in localStorage)
    bsSettings: JSON.parse(localStorage.getItem('bs_settings') || '{}'),
    
    // Current game rosters (if loaded)
    homeRoster: S.homeRoster || [],
    awayRoster: S.awayRoster || [],
    
    // Team colors
    homeColor: S.homeColor,
    awayColor: S.awayColor,
    
    // Team names
    homeTeam: S.homeTeam,
    awayTeam: S.awayTeam
  };
  
  const blob = new Blob([JSON.stringify(settings, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `benchsight_settings_${new Date().toISOString().slice(0,10)}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  
  toast('Settings exported!', 'success');
}

/**
 * Import settings from JSON file
 */
function importSettings(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const settings = JSON.parse(e.target.result);
      
      // Import custom chain presets
      if (settings.customChainPresets) {
        customChainPresets = settings.customChainPresets;
        saveCustomChainPresets();
      }
      
      // Import penalty minutes
      if (settings.penaltyMinutes) {
        penaltyMinutes = settings.penaltyMinutes;
        localStorage.setItem('benchsight_penaltyMinutes', penaltyMinutes);
        const ppInput = document.getElementById('ppMinutes');
        if (ppInput) ppInput.value = penaltyMinutes;
      }
      
      // Import video offset
      if (settings.videoOffset !== undefined) {
        videoOffset = settings.videoOffset;
        localStorage.setItem('benchsight_videoOffset', videoOffset);
      }
      
      // Import BS settings
      if (settings.bsSettings) {
        localStorage.setItem('bs_settings', JSON.stringify(settings.bsSettings));
      }
      
      // Import rosters if present
      if (settings.homeRoster?.length) {
        S.homeRoster = settings.homeRoster;
        renderQuickAdd();
      }
      if (settings.awayRoster?.length) {
        S.awayRoster = settings.awayRoster;
        renderQuickAdd();
      }
      
      // Import colors
      if (settings.homeColor) S.homeColor = settings.homeColor;
      if (settings.awayColor) S.awayColor = settings.awayColor;
      
      // Import team names
      if (settings.homeTeam) S.homeTeam = settings.homeTeam;
      if (settings.awayTeam) S.awayTeam = settings.awayTeam;
      
      toast(`Imported settings from ${file.name}`, 'success');
    } catch (err) {
      console.error('Import error:', err);
      toast(`Import error: ${err.message}`, 'error');
    }
  };
  reader.readAsText(file);
  
  // Reset file input
  event.target.value = '';
}

// ============================================================
// v23.4: ROSTER IMPORT FROM EXCEL/CSV
// ============================================================

/**
 * Import roster from Excel/CSV file
 */
async function importRosterFromFile(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  const extension = file.name.split('.').pop().toLowerCase();
  
  try {
    if (extension === 'csv') {
      // Parse CSV
      const text = await file.text();
      const roster = parseCSVRoster(text);
      showRosterImportPreview(roster, file.name);
    } else if (extension === 'xlsx' || extension === 'xls') {
      // Parse Excel using SheetJS (must be loaded)
      if (typeof XLSX === 'undefined') {
        // Try to load SheetJS dynamically
        toast('Loading Excel parser...', 'info');
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js';
        script.onload = () => {
          parseExcelFile(file);
        };
        script.onerror = () => {
          toast('Could not load Excel parser. Try CSV format.', 'error');
        };
        document.head.appendChild(script);
      } else {
        parseExcelFile(file);
      }
    } else {
      toast('Unsupported file type. Use .xlsx, .xls, or .csv', 'error');
    }
  } catch (err) {
    console.error('Roster import error:', err);
    toast(`Import error: ${err.message}`, 'error');
  }
  
  // Reset file input
  event.target.value = '';
}

/**
 * Parse Excel file using SheetJS
 */
function parseExcelFile(file) {
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const data = new Uint8Array(e.target.result);
      const workbook = XLSX.read(data, { type: 'array' });
      
      // Get first sheet
      const firstSheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[firstSheetName];
      
      // Convert to JSON
      const json = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
      
      // Parse roster from rows
      const roster = parseRosterRows(json);
      showRosterImportPreview(roster, file.name);
    } catch (err) {
      console.error('Excel parse error:', err);
      toast(`Excel parse error: ${err.message}`, 'error');
    }
  };
  reader.readAsArrayBuffer(file);
}

/**
 * Parse CSV text to roster
 */
function parseCSVRoster(text) {
  const lines = text.split(/\r?\n/).filter(line => line.trim());
  const rows = lines.map(line => {
    // Handle quoted fields
    const result = [];
    let current = '';
    let inQuotes = false;
    
    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      if (char === '"') {
        inQuotes = !inQuotes;
      } else if (char === ',' && !inQuotes) {
        result.push(current.trim());
        current = '';
      } else {
        current += char;
      }
    }
    result.push(current.trim());
    return result;
  });
  
  return parseRosterRows(rows);
}

/**
 * Parse roster from 2D array of rows
 * Expects: jersey_number, first_name, last_name, position (optional)
 */
function parseRosterRows(rows) {
  if (rows.length === 0) return [];
  
  // Try to detect header row
  const headerRow = rows[0].map(h => String(h).toLowerCase().trim());
  
  // Find column indices
  let jerseyCol = -1, firstNameCol = -1, lastNameCol = -1, nameCol = -1, posCol = -1;
  
  headerRow.forEach((h, i) => {
    if (h.includes('jersey') || h.includes('number') || h === '#' || h === 'num') jerseyCol = i;
    if (h.includes('first') || h === 'fname') firstNameCol = i;
    if (h.includes('last') || h === 'lname') lastNameCol = i;
    if (h === 'name' || h === 'player') nameCol = i;
    if (h.includes('pos') || h === 'position') posCol = i;
  });
  
  // If no header detected, assume: jersey, first, last or jersey, name
  const hasHeader = jerseyCol >= 0 || firstNameCol >= 0 || nameCol >= 0;
  const startRow = hasHeader ? 1 : 0;
  
  if (!hasHeader) {
    // Assume first column is jersey number
    jerseyCol = 0;
    if (rows[0].length >= 3) {
      firstNameCol = 1;
      lastNameCol = 2;
    } else if (rows[0].length >= 2) {
      nameCol = 1;
    }
  }
  
  const roster = [];
  
  for (let i = startRow; i < rows.length; i++) {
    const row = rows[i];
    if (!row || row.length === 0) continue;
    
    let jersey = jerseyCol >= 0 ? row[jerseyCol] : null;
    let firstName = firstNameCol >= 0 ? row[firstNameCol] : '';
    let lastName = lastNameCol >= 0 ? row[lastNameCol] : '';
    let fullName = nameCol >= 0 ? row[nameCol] : '';
    let position = posCol >= 0 ? row[posCol] : '';
    
    // Parse jersey number
    jersey = parseInt(String(jersey).replace(/\D/g, ''));
    if (isNaN(jersey) || jersey <= 0) continue;
    
    // Build name
    let name = '';
    if (fullName) {
      name = String(fullName).trim();
    } else if (firstName || lastName) {
      name = `${String(firstName).trim()} ${String(lastName).trim()}`.trim();
    }
    
    if (!name) name = `Player ${jersey}`;
    
    roster.push({
      num: jersey,
      name: name,
      pos: String(position).trim().toUpperCase() || ''
    });
  }
  
  // Sort by jersey number
  roster.sort((a, b) => a.num - b.num);
  
  return roster;
}

/**
 * Show roster import preview modal
 */
function showRosterImportPreview(roster, filename) {
  if (roster.length === 0) {
    toast('No valid roster data found in file', 'error');
    return;
  }
  
  const rosterHtml = roster.map(p => 
    `<tr><td>${p.num}</td><td>${p.name}</td><td>${p.pos || '-'}</td></tr>`
  ).join('');
  
  const html = `
    <h3>üìã Import Roster</h3>
    <p style="font-size:11px;color:var(--muted);">File: ${filename} (${roster.length} players)</p>
    <div style="max-height:300px;overflow-y:auto;margin:10px 0;">
      <table style="width:100%;font-size:11px;border-collapse:collapse;">
        <thead><tr style="background:var(--panel);"><th>#</th><th>Name</th><th>Pos</th></tr></thead>
        <tbody>${rosterHtml}</tbody>
      </table>
    </div>
    <div style="margin-top:15px;">
      <label style="font-size:11px;">Import as:</label>
      <div style="display:flex;gap:8px;margin-top:5px;">
        <button class="btn-sm btn-primary" onclick="applyImportedRoster('home')" style="flex:1;">üè† Home Team</button>
        <button class="btn-sm btn-primary" onclick="applyImportedRoster('away')" style="flex:1;">‚úàÔ∏è Away Team</button>
      </div>
    </div>
    <div style="margin-top:10px;text-align:right;">
      <button class="btn-sm" onclick="closeModal()">Cancel</button>
    </div>
  `;
  
  // Store roster for apply function
  window._pendingRosterImport = roster;
  
  showModal(html);
}

/**
 * Apply imported roster to home or away team
 */
function applyImportedRoster(team) {
  const roster = window._pendingRosterImport;
  if (!roster) return;
  
  if (team === 'home') {
    S.homeRoster = roster;
    toast(`Imported ${roster.length} players to Home roster`, 'success');
  } else {
    S.awayRoster = roster;
    toast(`Imported ${roster.length} players to Away roster`, 'success');
  }
  
  window._pendingRosterImport = null;
  closeModal();
  renderQuickAdd();
}

/**
 * Show manual roster entry modal
 */
function showManualRosterEntry() {
  const html = `
    <h3>‚úèÔ∏è Manual Roster Entry</h3>
    <p style="font-size:11px;color:var(--muted);">Enter one player per line: <code>jersey_number, name</code></p>
    <p style="font-size:10px;color:var(--muted);">Example: <code>10, John Smith</code> or <code>10 John Smith</code></p>
    <textarea id="manualRosterText" style="width:100%;height:200px;font-family:monospace;font-size:11px;" placeholder="10, John Smith
23, Mike Johnson
88, Wayne Great
..."></textarea>
    <div style="margin-top:15px;">
      <label style="font-size:11px;">Import as:</label>
      <div style="display:flex;gap:8px;margin-top:5px;">
        <button class="btn-sm btn-primary" onclick="applyManualRoster('home')" style="flex:1;">üè† Home Team</button>
        <button class="btn-sm btn-primary" onclick="applyManualRoster('away')" style="flex:1;">‚úàÔ∏è Away Team</button>
      </div>
    </div>
    <div style="margin-top:10px;text-align:right;">
      <button class="btn-sm" onclick="closeModal()">Cancel</button>
    </div>
  `;
  
  showModal(html);
}

/**
 * Apply manually entered roster
 */
function applyManualRoster(team) {
  const text = document.getElementById('manualRosterText').value;
  if (!text.trim()) {
    toast('Enter roster data first', 'warning');
    return;
  }
  
  const lines = text.split(/\r?\n/).filter(l => l.trim());
  const roster = [];
  
  lines.forEach(line => {
    // Try to parse: "10, John Smith" or "10 John Smith" or "#10 John Smith"
    let match = line.match(/^#?(\d+)[,\s]+(.+)$/);
    if (match) {
      roster.push({
        num: parseInt(match[1]),
        name: match[2].trim(),
        pos: ''
      });
    }
  });
  
  if (roster.length === 0) {
    toast('Could not parse any players. Use format: 10, John Smith', 'error');
    return;
  }
  
  roster.sort((a, b) => a.num - b.num);
  
  if (team === 'home') {
    S.homeRoster = roster;
    toast(`Added ${roster.length} players to Home roster`, 'success');
  } else {
    S.awayRoster = roster;
    toast(`Added ${roster.length} players to Away roster`, 'success');
  }
  
  closeModal();
  renderQuickAdd();
}

// ============================================================
// v23.4: VALIDATION VS GAME DATA
// ============================================================

/**
 * Validate tracked data against fact_gameroster and dim_schedule
 */
async function validateAgainstGameData() {
  if (!S.supabase || !S.gameId) {
    toast('Connect to database and select game first', 'error');
    return;
  }
  
  const issues = [];
  const successes = [];
  
  try {
    // Fetch fact_gameroster for this game
    const { data: gameroster, error: grError } = await S.supabase
      .from('fact_gameroster')
      .select('*')
      .eq('game_id', S.gameId);
    
    if (grError) throw grError;
    
    // Fetch dim_schedule for this game
    const { data: schedule, error: schError } = await S.supabase
      .from('dim_schedule')
      .select('*')
      .eq('game_id', S.gameId)
      .single();
    
    if (schError && schError.code !== 'PGRST116') throw schError;
    
    // ===== GOAL VALIDATION =====
    const trackedGoals = S.events.filter(e => e.type === 'Goal' && e.detail1 === 'Goal_Scored');
    const homeTrackedGoals = trackedGoals.filter(e => e.team === 'home').length;
    const awayTrackedGoals = trackedGoals.filter(e => e.team === 'away').length;
    
    if (schedule) {
      // Check total goals by period
      const p1HomeGoals = trackedGoals.filter(e => e.team === 'home' && e.period == 1).length;
      const p2HomeGoals = trackedGoals.filter(e => e.team === 'home' && e.period == 2).length;
      const p3HomeGoals = trackedGoals.filter(e => e.team === 'home' && e.period == 3).length;
      
      const p1AwayGoals = trackedGoals.filter(e => e.team === 'away' && e.period == 1).length;
      const p2AwayGoals = trackedGoals.filter(e => e.team === 'away' && e.period == 2).length;
      const p3AwayGoals = trackedGoals.filter(e => e.team === 'away' && e.period == 3).length;
      
      // Compare with dim_schedule
      if (schedule.home_goals_p1 !== undefined) {
        if (p1HomeGoals !== schedule.home_goals_p1) {
          issues.push(`‚ùå P1 Home Goals: Tracked ${p1HomeGoals}, Expected ${schedule.home_goals_p1}`);
        } else {
          successes.push(`‚úì P1 Home Goals match: ${p1HomeGoals}`);
        }
      }
      if (schedule.home_goals_p2 !== undefined) {
        if (p2HomeGoals !== schedule.home_goals_p2) {
          issues.push(`‚ùå P2 Home Goals: Tracked ${p2HomeGoals}, Expected ${schedule.home_goals_p2}`);
        } else {
          successes.push(`‚úì P2 Home Goals match: ${p2HomeGoals}`);
        }
      }
      if (schedule.home_goals_p3 !== undefined) {
        if (p3HomeGoals !== schedule.home_goals_p3) {
          issues.push(`‚ùå P3 Home Goals: Tracked ${p3HomeGoals}, Expected ${schedule.home_goals_p3}`);
        } else {
          successes.push(`‚úì P3 Home Goals match: ${p3HomeGoals}`);
        }
      }
      
      // Away goals
      if (schedule.away_goals_p1 !== undefined) {
        if (p1AwayGoals !== schedule.away_goals_p1) {
          issues.push(`‚ùå P1 Away Goals: Tracked ${p1AwayGoals}, Expected ${schedule.away_goals_p1}`);
        } else {
          successes.push(`‚úì P1 Away Goals match: ${p1AwayGoals}`);
        }
      }
      if (schedule.away_goals_p2 !== undefined) {
        if (p2AwayGoals !== schedule.away_goals_p2) {
          issues.push(`‚ùå P2 Away Goals: Tracked ${p2AwayGoals}, Expected ${schedule.away_goals_p2}`);
        } else {
          successes.push(`‚úì P2 Away Goals match: ${p2AwayGoals}`);
        }
      }
      if (schedule.away_goals_p3 !== undefined) {
        if (p3AwayGoals !== schedule.away_goals_p3) {
          issues.push(`‚ùå P3 Away Goals: Tracked ${p3AwayGoals}, Expected ${schedule.away_goals_p3}`);
        } else {
          successes.push(`‚úì P3 Away Goals match: ${p3AwayGoals}`);
        }
      }
      
      // Total goals
      const expectedHomeTotal = (schedule.home_goals_p1 || 0) + (schedule.home_goals_p2 || 0) + (schedule.home_goals_p3 || 0) + (schedule.home_goals_ot || 0);
      const expectedAwayTotal = (schedule.away_goals_p1 || 0) + (schedule.away_goals_p2 || 0) + (schedule.away_goals_p3 || 0) + (schedule.away_goals_ot || 0);
      
      if (homeTrackedGoals !== expectedHomeTotal) {
        issues.push(`‚ùå Total Home Goals: Tracked ${homeTrackedGoals}, Expected ${expectedHomeTotal}`);
      } else {
        successes.push(`‚úì Total Home Goals match: ${homeTrackedGoals}`);
      }
      
      if (awayTrackedGoals !== expectedAwayTotal) {
        issues.push(`‚ùå Total Away Goals: Tracked ${awayTrackedGoals}, Expected ${expectedAwayTotal}`);
      } else {
        successes.push(`‚úì Total Away Goals match: ${awayTrackedGoals}`);
      }
    }
    
    // ===== GOAL SCORER VALIDATION =====
    if (gameroster && gameroster.length > 0) {
      // Get players who should have goals
      const playersWithGoals = gameroster.filter(p => (p.goals || 0) > 0);
      
      playersWithGoals.forEach(player => {
        // Count goals by this player in tracked events
        const trackedPlayerGoals = trackedGoals.filter(e => {
          const scorer = e.players?.find(p => p.role === 'event_team_player_1');
          return scorer && (scorer.num == player.jersey_number || scorer.num == player.player_id);
        }).length;
        
        if (trackedPlayerGoals !== player.goals) {
          issues.push(`‚ùå #${player.jersey_number} Goals: Tracked ${trackedPlayerGoals}, Expected ${player.goals}`);
        } else if (player.goals > 0) {
          successes.push(`‚úì #${player.jersey_number} Goals match: ${player.goals}`);
        }
      });
      
      // Get players who should have assists
      const playersWithAssists = gameroster.filter(p => (p.assists || 0) > 0);
      
      playersWithAssists.forEach(player => {
        // v23.4 FIX: Assists are tracked via playD1/playD2 containing "Assist_Primary" or "Assist_Secondary"
        // Count assists by this player in tracked goal events
        let trackedPlayerAssists = 0;
        
        trackedGoals.forEach(e => {
          e.players?.forEach(p => {
            // Check if this player has an assist detail
            const hasAssist = (p.playD1 && (p.playD1.includes('Assist_Primary') || p.playD1.includes('Assist_Secondary'))) ||
                             (p.playD2 && (p.playD2.includes('Assist_Primary') || p.playD2.includes('Assist_Secondary')));
            
            if (hasAssist && (p.num == player.jersey_number || p.num == player.player_id)) {
              trackedPlayerAssists++;
            }
          });
        });
        
        if (trackedPlayerAssists < player.assists) {
          issues.push(`‚ö†Ô∏è #${player.jersey_number} Assists: Tracked ${trackedPlayerAssists}, Expected ${player.assists}`);
        } else if (player.assists > 0) {
          successes.push(`‚úì #${player.jersey_number} has ${trackedPlayerAssists} assist(s)`);
        }
      });
    }
    
    // Show validation results
    showValidationResults(issues, successes);
    
  } catch (error) {
    console.error('Validation error:', error);
    toast(`Validation error: ${error.message}`, 'error');
  }
}

/**
 * Show validation results in a modal
 */
function showValidationResults(issues, successes) {
  let html = `
    <h3>üîç Data Validation Results</h3>
    <div style="margin:15px 0;">
  `;
  
  if (successes.length > 0) {
    html += `
      <div style="background:rgba(34,197,94,0.1);padding:10px;border-radius:4px;margin-bottom:10px;">
        <h4 style="color:var(--success);margin-bottom:8px;">‚úì Matches (${successes.length})</h4>
        <ul style="font-size:11px;margin-left:15px;color:var(--text);">
          ${successes.slice(0, 10).map(s => `<li>${s}</li>`).join('')}
          ${successes.length > 10 ? `<li>... and ${successes.length - 10} more</li>` : ''}
        </ul>
      </div>
    `;
  }
  
  if (issues.length > 0) {
    html += `
      <div style="background:rgba(239,68,68,0.1);padding:10px;border-radius:4px;">
        <h4 style="color:var(--danger);margin-bottom:8px;">‚ùå Issues (${issues.length})</h4>
        <ul style="font-size:11px;margin-left:15px;color:var(--text);">
          ${issues.map(i => `<li>${i}</li>`).join('')}
        </ul>
      </div>
    `;
  } else {
    html += `
      <div style="background:rgba(34,197,94,0.1);padding:10px;border-radius:4px;text-align:center;">
        <h4 style="color:var(--success);">üéâ All validations passed!</h4>
      </div>
    `;
  }
  
  html += `
    </div>
    <div class="modal-actions" style="margin-top:15px;">
      <button onclick="document.getElementById('validationModal').classList.remove('show')">Close</button>
    </div>
  `;
  
  // Show in modal
  let modal = document.getElementById('validationModal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'validationModal';
    modal.className = 'overlay';
    modal.innerHTML = `<div class="modal" style="min-width:400px;max-height:80vh;overflow-y:auto;"></div>`;
    document.body.appendChild(modal);
  }
  modal.querySelector('.modal').innerHTML = html;
  modal.classList.add('show');
}

// ============================================================
// v23.4: PLAYER XY SELECTION IMPROVEMENTS
// ============================================================

/**
 * Click on player chip to select for XY editing
 * (Already implemented in selectPlayer, but let's enhance it)
 */
function selectPlayerForXY(num) {
  const player = S.curr.players.find(p => p.num === num);
  if (player) {
    S.selectedPlayer = player;
    setXYMode('player');
    S.xySlot = (player.xy?.length || 0) + 1;
    renderQuickAdd();
    renderXYSlots();
    toast(`Selected #${num} for XY placement`, 'info');
  }
}

// ============================================================
// v23.4: PLACE ALL PLAYERS HERE (Same Location)
// ============================================================

/**
 * Place all event players at the last puck XY position
 * Useful for hits, battles, board play where everyone is at puck
 */
function placeAllHere() {
  // Get last puck XY
  const lastPuckXY = S.curr.puckXY[S.curr.puckXY.length - 1] || S.curr.puckXY[0];
  
  if (!lastPuckXY) {
    toast('Place puck first, then click "All Here"', 'warning');
    return;
  }
  
  // Place all players at puck location (with slight offset to not overlap)
  let count = 0;
  S.curr.players.forEach((player, idx) => {
    // Small offset based on index so they don't all stack exactly
    const offsetX = (idx % 3 - 1) * 2; // -2, 0, +2
    const offsetY = (Math.floor(idx / 3) - 0.5) * 2; // slight Y spread
    
    player.xy = player.xy || [];
    player.xy[0] = { 
      x: lastPuckXY.x + offsetX, 
      y: lastPuckXY.y + offsetY, 
      seq: 1 
    };
    count++;
  });
  
  if (count > 0) {
    toast(`Placed ${count} player(s) at puck location`, 'success');
  } else {
    toast('Add players first', 'warning');
  }
  
  renderXYSlots(); renderMarkers(); renderQuickAdd();
}

// ============================================================
// v23.4: TIMELINE SCRUB
// ============================================================

/**
 * Render the timeline scrub showing recent events
 */
function renderTimeline() {
  const container = document.getElementById('timelineEvents');
  if (!container) return;
  
  // Get events for current period
  const periodEvents = S.events.filter(e => e.period === S.period);
  
  // Show last 20 events max
  const recentEvents = periodEvents.slice(-20);
  
  if (recentEvents.length === 0) {
    container.innerHTML = '<span style="font-size:8px;color:var(--muted);">No events yet</span>';
    return;
  }
  
  // Color map for event types
  const typeColors = {
    Shot: '#ef4444',
    Goal: '#22c55e',
    Pass: '#3b82f6',
    Faceoff: '#8b5cf6',
    Turnover: '#f59e0b',
    Possession: '#06b6d4',
    Save: '#6366f1',
    Hit: '#ec4899',
    Penalty: '#dc2626',
    Zone_Entry_Exit: '#14b8a6',
    Stoppage: '#6b7280'
  };
  
  container.innerHTML = recentEvents.map((evt, idx) => {
    const color = typeColors[evt.type] || 'var(--muted)';
    const label = evt.type.substring(0, 2).toUpperCase();
    const time = evt.start_time || '';
    const isHighlight = evt.isHighlight ? '‚≠ê' : '';
    const title = `#${evt.idx + 1} ${evt.type} @ ${time}${isHighlight ? ' (highlight)' : ''}`;
    
    return `<button class="timeline-evt" onclick="jumpToEvent(${evt.idx})" title="${title}" style="min-width:18px;height:18px;padding:0 2px;font-size:7px;background:${color};color:#fff;border:none;border-radius:2px;cursor:pointer;">${label}${isHighlight}</button>`;
  }).join('');
}

/**
 * Jump to and edit a specific event
 */
function jumpToEvent(idx) {
  const evt = S.events.find(e => e.idx === idx);
  if (!evt) return;
  
  // Open edit modal for this event
  editEvent(S.events.indexOf(evt));
  
  // Also show it on the rink
  renderMarkers();
  
  toast(`Jumped to event #${idx + 1}`, 'info');
}

// ============================================================
// v23.4: ENHANCED QUICK EVENT CHAINS
// ============================================================

// Enhanced event chains with full workflow
const QUICK_CHAINS = {
  controlledEntry: {
    name: 'Controlled Entry',
    sequence: [
      { type: 'Zone_Entry_Exit', d1: 'Zone_Entry', d2: 'Entry_Carry', zone: 'o', autoPlayers: ['E1'] },
      { type: 'Possession', d1: 'Possession_Cycle', zone: 'o' }
    ]
  },
  dumpIn: {
    name: 'Dump In',
    sequence: [
      { type: 'Zone_Entry_Exit', d1: 'Zone_Entry', d2: 'Entry_Dump', zone: 'o', autoPlayers: ['E1'] },
      { type: 'Possession', d1: 'Possession_Forecheck', zone: 'o' }
    ]
  },
  shotSequence: {
    name: 'Shot ‚Üí Save ‚Üí Rebound',
    sequence: [
      { type: 'Shot', d1: 'Shot_OnNet', zone: 'o', autoPlayers: ['E1'] },
      { type: 'Save', d1: 'Save_Rebound', zone: 'o' },
      { type: 'Shot', d1: 'Shot_OnNet', zone: 'o' }
    ]
  },
  breakout: {
    name: 'Breakout to Rush',
    sequence: [
      { type: 'Possession', d1: 'Possession_Breakout', zone: 'd', autoPlayers: ['E1'] },
      { type: 'Pass', d1: 'Pass_Breakout', zone: 'd' },
      { type: 'Zone_Entry_Exit', d1: 'Zone_Exit', d2: 'Exit_Rush', zone: 'n' }
    ]
  },
  ppCycle: {
    name: 'PP Cycle',
    sequence: [
      { type: 'Possession', d1: 'Possession_Cycle', zone: 'o', strength: '5v4' },
      { type: 'Pass', d1: 'Pass_Cycle', zone: 'o', strength: '5v4' },
      { type: 'Shot', d1: 'Shot_OnNet', zone: 'o', strength: '5v4' }
    ]
  }
};

let currentChainIdx = 0;
let activeChain = null;

/**
 * Start a quick chain sequence
 */
function startQuickChain(chainKey) {
  const chain = QUICK_CHAINS[chainKey];
  if (!chain) return;
  
  activeChain = chain;
  currentChainIdx = 0;
  
  // Enable sequence mode
  if (!sequenceModeActive) toggleSequenceMode();
  
  // Apply first event in chain
  applyChainStep();
  
  toast(`Starting: ${chain.name} (${chain.sequence.length} steps)`, 'success');
}

/**
 * Apply current chain step
 */
function applyChainStep() {
  if (!activeChain || currentChainIdx >= activeChain.sequence.length) {
    // Chain complete
    activeChain = null;
    currentChainIdx = 0;
    toast('Chain complete!', 'success');
    return;
  }
  
  const step = activeChain.sequence[currentChainIdx];
  
  setEvtType(step.type);
  
  setTimeout(() => {
    if (step.d1) document.getElementById('evtD1').value = step.d1;
    if (step.d2) {
      onD1Change();
      setTimeout(() => {
        document.getElementById('evtD2').value = step.d2;
      }, 30);
    }
    if (step.zone) setZone(step.zone);
    if (step.strength) document.getElementById('evtStrength').value = step.strength;
    
    // Show progress
    const progress = `Step ${currentChainIdx + 1}/${activeChain.sequence.length}`;
    toast(`${activeChain.name}: ${progress}`, 'info');
  }, 50);
}

/**
 * Advance to next chain step (called after logging event)
 */
function advanceChain() {
  if (!activeChain) return;
  currentChainIdx++;
  applyChainStep();
}

// Hook into event logging to advance chain and auto-advance
const originalLogEventDirect = logEventDirect;
logEventDirect = function() {
  // v23.5: Push undo state before logging
  pushUndoState('Log event');
  
  originalLogEventDirect.apply(this, arguments);
  advanceChain();
  renderTimeline();
  if (typeof setupAutoAdvance === 'function') setupAutoAdvance();
  
  // v23.5: Update recent players
  if (S.curr && S.curr.players) {
    S.curr.players.forEach(p => addToRecentPlayers(p));
  }
  
  // v23.5: Update suggestions
  renderEventSuggestions();
};

// ============================================================
// v23.4: KEYBOARD NAVIGATION
// ============================================================

/**
 * Setup keyboard navigation for dropdowns
 */
function setupKeyboardNav() {
  // Tab order enhancement
  const focusableElements = [
    'evtD1', 'evtD2', 'evtZone', 'evtSuccess', 'evtStrength',
    'evtStartTime', 'evtEndTime'
  ];
  
  focusableElements.forEach((id, idx) => {
    const el = document.getElementById(id);
    if (el) {
      el.tabIndex = idx + 1;
    }
  });
}

// Initialize on load
document.addEventListener('DOMContentLoaded', () => {
  setTimeout(() => {
    startShiftMonitoring();
    setupKeyboardNav();
    loadCustomChainPresets();
    
    // Load video offset from storage
    const savedOffset = localStorage.getItem('benchsight_videoOffset');
    if (savedOffset) videoOffset = parseInt(savedOffset);
    
    // Load penalty minutes from storage (default 3 for rec league)
    const savedPenMins = localStorage.getItem('benchsight_penaltyMinutes');
    if (savedPenMins) {
      penaltyMinutes = parseInt(savedPenMins);
      const ppInput = document.getElementById('ppMinutes');
      if (ppInput) ppInput.value = penaltyMinutes;
    }
  }, 1000);
});

// ============================================================
// v23.3: SHOT CHART MODE
// ============================================================
let shotChartModeActive = false;

/**
 * Toggle shot chart mode - click rink to create shots
 */
function toggleShotChartMode() {
  shotChartModeActive = !shotChartModeActive;
  possessionModeActive = false; // Turn off possession mode
  
  const shotBtn = document.getElementById('shotChartModeBtn');
  const possBtn = document.getElementById('possessionModeBtn');
  
  if (shotBtn) shotBtn.classList.toggle('mode-active', shotChartModeActive);
  if (possBtn) possBtn.classList.remove('mode-active');
  
  if (shotChartModeActive) {
    setEvtType('Shot');
    toast('Shot Chart Mode ON: Click rink to place shots', 'success');
  } else {
    toast('Shot Chart Mode OFF', 'info');
  }
}

/**
 * Handle shot chart click - creates shot at click location
 */
function handleShotChartClick(svgX, svgY, relX, relY) {
  if (!shotChartModeActive) return false;
  
  // Determine shot type based on location
  const zone = getZoneFromClick(svgX);
  if (zone !== 'o') {
    toast('Click in offensive zone to place shot', 'warning');
    return true; // Consumed the click
  }
  
  // Set shot type
  setEvtType('Shot');
  document.getElementById('evtZone').value = 'o';
  
  // Set puck position
  S.curr.puckXY = [{ x: relX, y: relY, seq: 1 }];
  
  // Set time
  document.getElementById('evtStartTime').value = document.getElementById('clock').value;
  
  // Show shot type modal or default to Shot_OnNet
  setTimeout(() => {
    document.getElementById('evtD1').value = 'Shot_OnNet';
    onD1Change();
    
    // Open net modal for shot location
    document.getElementById('netModal').classList.add('show');
  }, 50);
  
  renderMarkers();
  toast('Shot placed - select net location', 'info');
  return true; // Consumed the click
}

// ============================================================
// v23.3: POSSESSION MODE (sequence tracking)
// ============================================================
let possessionModeActive = false;
let possessionModeStartTime = null;  // Renamed to avoid conflict with v23.5
let possessionModeTeam = null;       // Renamed to avoid conflict with v23.5

/**
 * Toggle possession tracking mode
 */
function togglePossessionMode() {
  possessionModeActive = !possessionModeActive;
  shotChartModeActive = false; // Turn off shot mode
  
  const shotBtn = document.getElementById('shotChartModeBtn');
  const possBtn = document.getElementById('possessionModeBtn');
  
  if (shotBtn) shotBtn.classList.remove('mode-active');
  if (possBtn) possBtn.classList.toggle('mode-active', possessionModeActive);
  
  if (possessionModeActive) {
    possessionModeStartTime = document.getElementById('clock').value;
    possessionModeTeam = S.evtTeam;
    setEvtType('Possession');
    toggleSequenceMode(); // Also turn on sequence mode
    toast('Possession Mode ON: Track possession chain', 'success');
  } else {
    possessionModeStartTime = null;
    possessionModeTeam = null;
    if (sequenceModeActive) toggleSequenceMode(); // Turn off sequence mode
    toast('Possession Mode OFF', 'info');
  }
}

/**
 * End possession and log a turnover/shot
 */
function endPossession(reason) {
  if (!possessionModeActive) return;
  
  const duration = calculatePossessionModeDuration();
  
  if (reason === 'shot') {
    setEvtType('Shot');
  } else if (reason === 'turnover') {
    setEvtType('Turnover');
    document.getElementById('evtD1').value = 'Turnover_Giveaway';
  } else if (reason === 'pass') {
    // Continue possession with pass
    setEvtType('Pass');
    return;
  }
  
  toast(`Possession ended: ${duration}s - ${reason}`, 'info');
}

/**
 * Calculate possession duration
 */
function calculatePossessionModeDuration() {
  if (!possessionModeStartTime) return 0;
  
  const startParts = possessionModeStartTime.split(':').map(Number);
  const startSec = startParts[0] * 60 + startParts[1];
  
  const currentTime = document.getElementById('clock').value;
  const currentParts = currentTime.split(':').map(Number);
  const currentSec = currentParts[0] * 60 + currentParts[1];
  
  // Clock counts down, so start > current
  return startSec - currentSec;
}

// ============================================================
// v23.3: SHIFT AUTO-END
// ============================================================

/**
 * Auto-end shift on stoppage events
 */
function checkAutoEndShift(evt) {
  if (!evt) return;
  
  // Events that typically end a shift
  const shiftEndingEvents = ['Stoppage', 'Faceoff', 'Penalty', 'Goal'];
  const shiftEndingDetails = ['Icing', 'Offside', 'PeriodEnd', 'Timeout'];
  
  if (shiftEndingEvents.includes(evt.type) || 
      shiftEndingDetails.some(d => (evt.detail1 || '').includes(d))) {
    
    // Auto-fill shift end time
    const shiftEndEl = document.getElementById('shiftEnd');
    if (shiftEndEl && !shiftEndEl.value) {
      shiftEndEl.value = evt.start_time;
      toast('Shift end time auto-filled', 'info');
    }
  }
}

// ============================================================
// v23.3: BATCH PLAYER PLACEMENT
// ============================================================
let batchPlacementPlayers = [];

/**
 * Select multiple players for batch placement
 */
function toggleBatchPlayer(num) {
  const idx = batchPlacementPlayers.indexOf(num);
  if (idx >= 0) {
    batchPlacementPlayers.splice(idx, 1);
  } else {
    batchPlacementPlayers.push(num);
  }
  renderQuickAdd(); // Re-render to show selection
}

/**
 * Place all batch-selected players at a position
 */
function placeBatchPlayers(x, y) {
  if (batchPlacementPlayers.length === 0) return false;
  
  batchPlacementPlayers.forEach((num, i) => {
    const player = S.curr.players.find(p => p.num === num);
    if (player) {
      // Offset each player slightly so they don't overlap
      const offsetX = (i % 3 - 1) * 3;
      const offsetY = Math.floor(i / 3) * 3;
      player.xy.push({ x: x + offsetX, y: y + offsetY, seq: 1 });
    }
  });
  
  batchPlacementPlayers = [];
  renderMarkers();
  renderQuickAdd();
  toast('Players placed', 'success');
  return true;
}

// ============================================================
// v23.3: AUTO-ADVANCE FEATURES
// ============================================================

/**
 * Auto-advance to next event after logging
 */
function setupAutoAdvance() {
  // After logging, check if we should auto-setup next event
  const lastEvt = S.events[S.events.length - 1];
  if (!lastEvt) return;
  
  const suggestion = getSuggestedNextEvent();
  if (suggestion && sequenceModeActive) {
    // Auto-set suggested event type
    setEvtType(suggestion.type);
  }
  
  // Check for shift auto-end
  checkAutoEndShift(lastEvt);
}

// Hook into event logging
const originalDoLogEvent = doLogEvent;
doLogEvent = function() {
  originalDoLogEvent();
  setupAutoAdvance();
};

// Update penalty player dropdown when team changes
const originalSetEvtTeam = setEvtTeam;
setEvtTeam = function(team) {
  originalSetEvtTeam(team);
  updateQuickPenaltyPlayers();
};

// Initialize penalty dropdown on load
document.addEventListener('DOMContentLoaded', () => {
  setTimeout(updateQuickPenaltyPlayers, 1000);
});

/**
 * Quick time entry: type 1530 and it becomes 15:30
 */
function setupTimeInputs() {
  ['evtStartTime', 'evtEndTime', 'clock', 'shiftStart', 'shiftEnd'].forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      el.addEventListener('blur', () => {
        let val = el.value.replace(/[^0-9:]/g, '');
        // If no colon and 3-4 digits, auto-format
        if (!val.includes(':') && val.length >= 3) {
          val = val.slice(0, -2) + ':' + val.slice(-2);
        }
        // Ensure seconds are padded
        if (val.includes(':')) {
          const [min, sec] = val.split(':');
          val = min + ':' + (sec || '00').padStart(2, '0');
        }
        el.value = val;
      });
    }
  });
}

// ============================================================
// EDIT EVENT MODAL
// ============================================================
function editEvent(idx) {
  S.editingEvtIdx = idx;
  const evt = S.events[idx];
  
  // Ensure players array exists
  if (!evt.players) evt.players = [];
  if (!evt.puckXY) evt.puckXY = [];
  
  document.getElementById('editEvtIdx').textContent = idx + 1;
  document.getElementById('editHighlightBadge').textContent = evt.isHighlight ? '‚≠ê' : '';
  document.getElementById('editType').value = evt.type;
  
  // Update team dropdown with actual team names
  const editTeamSel = document.getElementById('editTeam');
  editTeamSel.innerHTML = `<option value="home">${S.homeTeam || 'Home'}</option><option value="away">${S.awayTeam || 'Away'}</option>`;
  editTeamSel.value = evt.team;
  document.getElementById('editStartTime').value = evt.start_time || evt.time || '';
  document.getElementById('editEndTime').value = evt.end_time || evt.start_time || evt.time || '';
  document.getElementById('editZone').value = evt.zone || '';
  document.getElementById('editSuccess').value = evt.success || '';
  document.getElementById('editStrength').value = evt.strength || '5v5';
  document.getElementById('editHighlight').checked = evt.isHighlight || false;
  
  // Linked event index (editable)
  const linkedIdxEl = document.getElementById('editLinkedIdx');
  if (linkedIdxEl) {
    linkedIdxEl.value = (evt.linkedEventIdx !== null && evt.linkedEventIdx !== undefined) ? evt.linkedEventIdx + 1 : '';
  }
  
  // Sequence and play keys (display only)
  const seqKeyEl = document.getElementById('editSeqKey');
  const playKeyEl = document.getElementById('editPlayKey');
  if (seqKeyEl) seqKeyEl.textContent = evt.sequenceIdx || evt.seqIdx || evt.sequence_key || '--';
  if (playKeyEl) playKeyEl.textContent = evt.playIdx || evt.play_key || '--';
  
  // v15: Show event_id and event_index
  const eventIdEl = document.getElementById('editEventId');
  const eventIndexEl = document.getElementById('editEventIndex');
  if (eventIdEl) eventIdEl.textContent = evt.eventId || evt.event_id || '--';
  if (eventIndexEl) eventIndexEl.textContent = evt.idx || (idx + 1);
  
  // Show linked chain
  const chainText = evt.linkedEventChain?.length 
    ? `Chain: ${evt.linkedEventChain.map(i => `#${i+1}`).join(' ‚Üí ')} ‚Üí #${idx+1}`
    : (evt.linkedEventIdx !== null && evt.linkedEventIdx !== undefined ? `Linked to #${evt.linkedEventIdx + 1}` : '--');
  document.getElementById('editLinkedChain').textContent = chainText;
  
  onEditTypeChange();
  document.getElementById('editD1').value = evt.detail1 || '';
  // v16.06: Pass detail2 to preserve it in dropdown options
  onEditD1Change(evt.detail2 || '');
  
  renderEditPlayers(evt.players);
  renderEditPuckXY(evt.puckXY);
  
  // Populate XY target dropdown (puck + each player)
  const xyTargetSel = document.getElementById('editXYTarget');
  xyTargetSel.innerHTML = '<option value="puck">Puck</option>' + 
    (evt.players || []).map((p, i) => `<option value="player_${i}">#${p.num} ${p.name}</option>`).join('');
  
  renderEditRinkMarkers();
  
  // Show/hide net section for shots/goals
  const showNet = ['Shot', 'Goal'].includes(evt.type);
  document.getElementById('editNetSection').style.display = showNet ? 'block' : 'none';
  if (showNet) {
    renderEditNetMarker(evt.netXY);
    document.getElementById('editNetLocation').textContent = getNetLocationName(evt.netXY) || '--';
  }
  
  document.getElementById('editModal').classList.add('show');
}

function renderEditNetMarker(netXY) {
  const g = document.getElementById('editNetMarker');
  if (!g) return;
  
  if (netXY?.x != null && netXY?.y != null) {
    g.innerHTML = `<circle cx="${netXY.x}" cy="${netXY.y}" r="4" fill="#10b981" stroke="#fff" stroke-width="1"/>`;
  } else {
    g.innerHTML = '';
  }
}

function getNetLocationName(netXY) {
  if (!netXY?.x || !netXY?.y) return null;
  const x = netXY.x;
  const y = netXY.y;
  
  // Divide net into zones (72x48 viewbox)
  if (y < 16) {
    return x < 36 ? 'Top Left' : 'Top Right';
  } else if (y > 32) {
    return x < 36 ? 'Low Left' : 'Low Right';
  } else {
    return 'Five Hole';
  }
}

function handleEditNetClick(event) {
  if (S.editingEvtIdx === null) return;
  
  const svg = document.getElementById('editNetSvg');
  const pt = svg.createSVGPoint();
  pt.x = event.clientX; pt.y = event.clientY;
  const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
  
  const netXY = { x: Math.round(svgPt.x), y: Math.round(svgPt.y) };
  S.events[S.editingEvtIdx].netXY = netXY;
  
  renderEditNetMarker(netXY);
  document.getElementById('editNetLocation').textContent = getNetLocationName(netXY);
  toast('Net location set: ' + getNetLocationName(netXY), 'success');
}

function clearEditNetXY() {
  if (S.editingEvtIdx === null) return;
  S.events[S.editingEvtIdx].netXY = null;
  renderEditNetMarker(null);
  document.getElementById('editNetLocation').textContent = '--';
  toast('Net location cleared', 'info');
}

function renderEditRinkMarkers() {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  const g = document.getElementById('editRinkMarkers');
  if (!g) return;
  
  let markers = '';
  const target = document.getElementById('editXYTarget')?.value || 'puck';
  
  // Render puck XY
  (evt.puckXY || []).forEach((xy, i) => {
    const isActive = target === 'puck';
    markers += `<circle cx="${xy.x}" cy="${xy.y}" r="3" fill="${isActive ? '#ef4444' : '#666'}" stroke="#fff" stroke-width="0.5" style="cursor:pointer;" onclick="selectEditXY('puck', ${i})"/>`;
    markers += `<text x="${xy.x + 4}" y="${xy.y - 2}" font-size="4" fill="#fff">P${i+1}</text>`;
  });
  
  // Render player XYs
  (evt.players || []).forEach((p, pi) => {
    const isActive = target === `player_${pi}`;
    (p.xy || []).forEach((xy, i) => {
      const color = p.role?.startsWith('event') ? '#3b82f6' : '#ef4444';
      markers += `<circle cx="${xy.x}" cy="${xy.y}" r="2.5" fill="${isActive ? color : '#666'}" stroke="#fff" stroke-width="0.3" style="cursor:pointer;" onclick="selectEditXY('player_${pi}', ${i})"/>`;
      markers += `<text x="${xy.x + 3}" y="${xy.y - 1}" font-size="3" fill="#fff">${p.num}.${i+1}</text>`;
    });
  });
  
  g.innerHTML = markers;
}

function handleEditRinkClick(event) {
  if (S.editingEvtIdx === null) return;
  
  const svg = document.getElementById('editRinkSvg');
  const pt = svg.createSVGPoint();
  pt.x = event.clientX; pt.y = event.clientY;
  const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
  
  const xy = { x: Math.round(svgPt.x * 10) / 10, y: Math.round(svgPt.y * 10) / 10, seq: 1 };
  
  const evt = S.events[S.editingEvtIdx];
  const target = document.getElementById('editXYTarget').value;
  
  if (target === 'puck') {
    if (S.editingXYIdx !== null && evt.puckXY?.[S.editingXYIdx]) {
      evt.puckXY[S.editingXYIdx] = xy;
    } else {
      evt.puckXY = evt.puckXY || [];
      evt.puckXY.push(xy);
    }
    renderEditPuckXY(evt.puckXY);
  } else if (target.startsWith('player_')) {
    const pi = parseInt(target.split('_')[1]);
    if (evt.players?.[pi]) {
      if (S.editingXYIdx !== null && evt.players[pi].xy?.[S.editingXYIdx]) {
        evt.players[pi].xy[S.editingXYIdx] = xy;
      } else {
        evt.players[pi].xy = evt.players[pi].xy || [];
        evt.players[pi].xy.push(xy);
      }
    }
  }
  
  S.editingXYIdx = null;
  renderEditRinkMarkers();
  renderEditPlayers(evt.players);
}

function selectEditXY(target, idx) {
  document.getElementById('editXYTarget').value = target;
  S.editingXYIdx = idx;
  renderEditRinkMarkers();
  toast(`Selected ${target} point ${idx + 1} - click rink to move`, 'info');
}

function addEditXYPoint() {
  // Just click on rink to add
  toast('Click on rink to add XY point', 'info');
}

function onEditTypeChange() {
  const type = document.getElementById('editType').value;
  
  // v16.06: Use S.eventDetails1 from dim_event_detail if available
  let d1Options = [];
  if (S.eventDetails1?.length > 0) {
    d1Options = S.eventDetails1
      .filter(e => e.eventType === type)
      .map(e => e.name);
  }
  
  // Fall back to LISTS.details if no Supabase data
  if (d1Options.length === 0) {
    const opts = LISTS.details[type] || { d1: [], d2: [] };
    d1Options = opts.d1 || [];
  }
  
  document.getElementById('editD1').innerHTML = '<option value="">--</option>' + 
    d1Options.map(o => `<option value="${o}">${o}</option>`).join('');
  document.getElementById('editD2').innerHTML = '<option value="">--</option>';
}

function onEditD1Change(preserveD2Value = null) {
  const type = document.getElementById('editType').value;
  const d1 = document.getElementById('editD1').value;
  
  // Get current d2 value or use preserved value
  const currentD2 = preserveD2Value || document.getElementById('editD2').value;
  
  let d2Opts = [];
  
  // v16.08: Use S.eventDetails2 from dim_event_detail_2 - filter by code prefix
  if (S.eventDetails2?.length > 0) {
    // Determine code prefix based on detail1 value
    let codePrefix = null;
    if (d1.startsWith('Shot_')) codePrefix = 'Shot_';
    else if (d1.startsWith('Pass_')) codePrefix = 'Pass_';
    else if (d1.startsWith('Goal_')) codePrefix = 'Goal_';
    else if (d1.startsWith('Save_')) codePrefix = 'Save_';
    else if (d1.startsWith('Penalty_')) codePrefix = 'Penalty_';
    else if (d1.includes('Giveaway')) codePrefix = 'Giveaway_';
    else if (d1.includes('Takeaway')) codePrefix = 'Takeaway_';
    else if (d1.includes('Entry')) codePrefix = 'ZoneEntry_';
    else if (d1.includes('Exit') || d1.includes('Keepin')) codePrefix = 'ZoneExit_';
    else if (d1 === 'Stoppage_Play') codePrefix = 'Stoppage_';
    else if (d1 === 'Play_Offensive') codePrefix = 'PlayOffensive_';
    else if (d1 === 'Play_Defensive') codePrefix = 'PlayDefensive_';
    else if (d1.startsWith('Faceoff_')) codePrefix = 'Faceoff_';
    else if (d1.startsWith('Possession_')) codePrefix = 'Possession_';
    else if (d1.startsWith('Rebound_')) codePrefix = 'Rebound_';
    
    if (codePrefix) {
      d2Opts = S.eventDetails2
        .filter(e => e.code && e.code.startsWith(codePrefix))
        .map(e => e.name);
    }
  }
  
  // Fall back to LISTS.details if no Supabase data
  if (d2Opts.length === 0) {
    const opts = LISTS.details[type] || {};
    d2Opts = opts.d2 || [];
    if (d1.includes('Giveaway') && opts.d2_Giveaway) d2Opts = opts.d2_Giveaway;
    else if (d1.includes('Takeaway') && opts.d2_Takeaway) d2Opts = opts.d2_Takeaway;
    else if (d1.includes('Entry') && opts.d2_Entry) d2Opts = opts.d2_Entry;
    else if (d1.includes('Exit') && opts.d2_Exit) d2Opts = opts.d2_Exit;
    else if (d1.includes('Play') && opts.d2_Play) d2Opts = opts.d2_Play;
    else if (d1.includes('Offensive') && opts.d2_Offensive) d2Opts = opts.d2_Offensive;
    else if (d1.includes('Defensive') && opts.d2_Defensive) d2Opts = opts.d2_Defensive;
    else if (d1.includes('Keepin') && opts.d2_Exit) d2Opts = opts.d2_Exit;
  }
  
  // Build options HTML
  let optionsHtml = '<option value="">--</option>' + d2Opts.map(o => `<option value="${o}">${o}</option>`).join('');
  
  // If current/preserved value not in options, add it at top
  if (currentD2 && !d2Opts.includes(currentD2)) {
    optionsHtml = `<option value="">--</option><option value="${currentD2}">${currentD2} (loaded)</option>` + 
                  d2Opts.map(o => `<option value="${o}">${o}</option>`).join('');
  }
  
  document.getElementById('editD2').innerHTML = optionsHtml;
  
  // Restore selection if it existed
  if (currentD2) {
    document.getElementById('editD2').value = currentD2;
  }
}

function renderEditPlayers(players) {
  const container = document.getElementById('editPlayersContainer');
  
  // v16.06: Build options with player-specific selection
  const buildPD1Options = (playerValue) => {
    let opts = S.playDetails1.length > 0 
      ? S.playDetails1.map(p => `<option value="${p.name}" ${p.name === playerValue ? 'selected' : ''}>${p.name}</option>`).join('')
      : LISTS.playOffensive.concat(LISTS.playDefensive).map(o => `<option value="${o}" ${o === playerValue ? 'selected' : ''}>${o}</option>`).join('');
    
    // If player has a value not in options, add it
    if (playerValue && !S.playDetails1.find(pd => pd.name === playerValue)) {
      opts = `<option value="${playerValue}" selected>${playerValue}</option>` + opts;
    }
    return opts;
  };
  
  const buildPD2Options = (playerValue) => {
    let opts = S.playDetails2.length > 0 
      ? S.playDetails2.map(p => `<option value="${p.name}" ${p.name === playerValue ? 'selected' : ''}>${p.name}</option>`).join('')
      : '';
    
    // If player has a value not in options, add it
    if (playerValue && !S.playDetails2.find(pd => pd.name === playerValue)) {
      opts = `<option value="${playerValue}" selected>${playerValue}</option>` + opts;
    }
    return opts;
  };
  
  // Player role options
  const eventRoles = S.playerRoles.filter(r => r.type === 'event_team');
  const oppRoles = S.playerRoles.filter(r => r.type === 'opp_team');
  
  container.innerHTML = (players || []).map((p, i) => {
    const isOpp = p.role?.startsWith('opp');
    const roleOptions = isOpp ? oppRoles : eventRoles;
    const roleOpts = roleOptions.length > 0 
      ? roleOptions.map(r => `<option value="${r.code}" ${p.role===r.code?'selected':''}>${r.name}</option>`).join('')
      : `<option value="event_player_1">Event Player 1</option><option value="event_player_2">Event Player 2</option><option value="opp_player_1">Opp Player 1</option>`;
    
    // Build role select with current value highlighted
    const currentRole = p.role || '';
    const buildRoleOption = (val, label) => {
      const selected = currentRole === val ? 'selected' : '';
      return `<option value="${val}" ${selected}>${label}</option>`;
    };
    
    return `
    <div class="edit-player-row" data-idx="${i}" style="display:grid;grid-template-columns:80px 90px 130px 130px 60px 25px;gap:4px;align-items:center;margin-bottom:6px;padding:4px;background:var(--panel);border-radius:3px;">
      <span class="pnum" style="font-weight:bold;font-size:10px;">#${p.num} ${p.name?.split(' ').pop() || ''}</span>
      <select onchange="updateEditPlayer(${i}, 'role', this.value)" style="font-size:9px;" title="Player Role">
        <option value="">-- Role --</option>
        <optgroup label="Event Team">
          ${buildRoleOption('event_player_1', 'Event P1')}
          ${buildRoleOption('event_player_2', 'Event P2')}
          ${buildRoleOption('event_player_3', 'Event P3')}
          ${buildRoleOption('event_player_4', 'Event P4')}
          ${buildRoleOption('event_player_5', 'Event P5')}
          ${buildRoleOption('event_player_6', 'Event P6')}
          ${buildRoleOption('event_goalie', 'Event Goalie')}
        </optgroup>
        <optgroup label="Opponent">
          ${buildRoleOption('opp_player_1', 'Opp P1')}
          ${buildRoleOption('opp_player_2', 'Opp P2')}
          ${buildRoleOption('opp_player_3', 'Opp P3')}
          ${buildRoleOption('opp_player_4', 'Opp P4')}
          ${buildRoleOption('opp_player_5', 'Opp P5')}
          ${buildRoleOption('opp_player_6', 'Opp P6')}
          ${buildRoleOption('opp_goalie', 'Opp Goalie')}
        </optgroup>
      </select>
      <select onchange="updateEditPlayer(${i}, 'playD1', this.value)" style="font-size:9px;" title="Play Detail 1">
        <option value="">-- Play D1 --</option>
        ${buildPD1Options(p.playD1)}
      </select>
      <select onchange="updateEditPlayer(${i}, 'playD2', this.value)" style="font-size:9px;" title="Play Detail 2">
        <option value="">-- Play D2 --</option>
        ${buildPD2Options(p.playD2)}
      </select>
      <select onchange="updateEditPlayer(${i}, 'playSuccess', this.value)" style="font-size:9px;" title="Success">
        <option value="">Succ</option>
        <option value="s" ${p.playSuccess==='s'?'selected':''}>S</option>
        <option value="u" ${p.playSuccess==='u'?'selected':''}>U</option>
      </select>
      <button class="btn-sm btn-danger" onclick="removeEditPlayer(${i})" style="padding:2px 4px;">‚úï</button>
    </div>`;
  }).join('') || '<p style="color:var(--muted);font-size:9px;">No players - click + Add to add players</p>';
}

function renderEditPuckXY(puckXY) {
  const container = document.getElementById('editPuckXY');
  container.innerHTML = (puckXY || []).map((xy, i) => 
    `<button class="edit-xy-btn has" onclick="editXYPoint('puck', ${i})" title="(${xy.x}, ${xy.y})">${i+1}: (${Math.round(xy.x)}, ${Math.round(xy.y)})</button>
     <button class="btn-sm btn-danger" onclick="deleteXYPoint('puck', ${i})" style="padding:2px 4px;">‚úï</button>`
  ).join('') + '<button class="edit-xy-btn" onclick="addXYPoint(\'puck\')">+ Add XY</button>';
}

function renderEditPlayerXY(players) {
  // Add player XY display to edit modal
  const playerContainer = document.getElementById('editPlayersContainer');
  if (!playerContainer || !players?.length) return;
  
  // Append XY info to each player row (already in renderEditPlayers)
}

function editXYPoint(type, idx) {
  if (S.editingEvtIdx === null) return;
  S.editingXYType = type;
  S.editingXYIdx = idx;
  
  // Show mini rink modal for XY editing
  document.getElementById('xyEditModal').classList.add('show');
  renderXYEditRink();
}

function addXYPoint(type) {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  
  if (type === 'puck') {
    evt.puckXY = evt.puckXY || [];
    evt.puckXY.push({ x: 100, y: 42.5, seq: evt.puckXY.length + 1 });
    renderEditPuckXY(evt.puckXY);
  }
}

function deleteXYPoint(type, idx) {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  
  if (type === 'puck' && evt.puckXY) {
    evt.puckXY.splice(idx, 1);
    renderEditPuckXY(evt.puckXY);
  }
}

function renderXYEditRink() {
  // Highlight current point on mini rink
  const marker = document.getElementById('xyEditMarker');
  if (!marker) return;
  
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  
  let xy = null;
  if (S.editingXYType === 'puck' && evt.puckXY?.[S.editingXYIdx]) {
    xy = evt.puckXY[S.editingXYIdx];
  }
  
  if (xy) {
    marker.innerHTML = `<circle cx="${xy.x}" cy="${xy.y}" r="3" fill="#ef4444" stroke="#fff" stroke-width="0.5"/>`;
  } else {
    marker.innerHTML = '';
  }
}

function handleXYEditClick(event) {
  if (S.editingEvtIdx === null) return;
  
  const svg = document.getElementById('xyEditSvg');
  const rect = svg.getBoundingClientRect();
  const pt = svg.createSVGPoint();
  pt.x = event.clientX; pt.y = event.clientY;
  const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
  
  const xy = { x: Math.round(svgPt.x * 100) / 100, y: Math.round(svgPt.y * 100) / 100 };
  
  const evt = S.events[S.editingEvtIdx];
  
  if (S.editingXYType === 'puck' && evt.puckXY?.[S.editingXYIdx]) {
    evt.puckXY[S.editingXYIdx].x = xy.x;
    evt.puckXY[S.editingXYIdx].y = xy.y;
    renderEditPuckXY(evt.puckXY);
  }
  
  renderXYEditRink();
}

function closeXYEditModal() {
  document.getElementById('xyEditModal').classList.remove('show');
  S.editingXYType = null;
  S.editingXYIdx = null;
}

function updateEditPlayer(idx, field, val) {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  if (evt.players[idx]) evt.players[idx][field] = val;
}

function removeEditPlayer(idx) {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  evt.players.splice(idx, 1);
  renderEditPlayers(evt.players);
}

function addPlayerToEdit() {
  if (S.editingEvtIdx === null) {
    toast('No event being edited', 'error');
    return;
  }
  
  const evt = S.events[S.editingEvtIdx];
  
  // Update picker dropdown with team names
  const pickerTeamSel = document.getElementById('pickerTeam');
  pickerTeamSel.innerHTML = `<option value="home">${S.homeTeam || 'Home'}</option><option value="away">${S.awayTeam || 'Away'}</option>`;
  
  // Set team based on event being edited
  pickerTeamSel.value = evt.team || S.evtTeam;
  
  // Check if rosters are loaded
  if (!S.rosters.home?.length && !S.rosters.away?.length) {
    toast('No rosters loaded - select a game first', 'error');
    return;
  }
  
  renderPlayerPicker();
  document.getElementById('playerPickerModal').classList.add('show');
}

// ============================================================
// SAVE FOLDER MANAGEMENT (File System Access API)
// ============================================================
let saveFolderHandle = null;

async function pickSaveFolder() {
  try {
    // Check if File System Access API is supported
    if (!('showDirectoryPicker' in window)) {
      toast('Your browser does not support folder selection. Use Export to download files.', 'warn');
      document.getElementById('saveFolderStatus').textContent = '‚ö†Ô∏è Folder selection not supported in this browser';
      document.getElementById('saveFolderStatus').className = 'folder-status error';
      return;
    }
    
    saveFolderHandle = await window.showDirectoryPicker({
      mode: 'readwrite',
      startIn: 'documents'
    });
    
    // Update UI
    document.getElementById('saveFolderPath').textContent = saveFolderHandle.name;
    document.getElementById('saveFolderPath').classList.remove('empty');
    document.getElementById('saveFolderStatus').textContent = '‚úì Folder ready for Quick Save';
    document.getElementById('saveFolderStatus').className = 'folder-status ready';
    document.getElementById('quickSaveBtn').disabled = false;
    
    // Save folder name to localStorage (can't persist the handle itself)
    localStorage.setItem('bs_lastFolderName', saveFolderHandle.name);
    
    toast(`Folder selected: ${saveFolderHandle.name}`, 'success');
  } catch (err) {
    if (err.name === 'AbortError') {
      // User cancelled
      return;
    }
    console.error('Folder picker error:', err);
    toast('Could not select folder: ' + err.message, 'error');
    document.getElementById('saveFolderStatus').textContent = '‚ö†Ô∏è ' + err.message;
    document.getElementById('saveFolderStatus').className = 'folder-status error';
  }
}

function clearSaveFolder() {
  saveFolderHandle = null;
  document.getElementById('saveFolderPath').textContent = 'No folder selected - exports download to browser default';
  document.getElementById('saveFolderPath').classList.add('empty');
  document.getElementById('saveFolderStatus').textContent = 'üí° Select a folder to enable Quick Save directly to that location';
  document.getElementById('saveFolderStatus').className = 'folder-status';
  document.getElementById('quickSaveBtn').disabled = true;
  localStorage.removeItem('bs_lastFolderName');
}

async function quickSaveToFolder() {
  if (!saveFolderHandle) {
    toast('No folder selected. Click "Choose" to pick a save folder.', 'error');
    return;
  }
  
  if (!S.gameId) {
    toast('No game loaded', 'error');
    return;
  }
  
  try {
    // Verify we still have permission
    const permission = await saveFolderHandle.queryPermission({ mode: 'readwrite' });
    if (permission !== 'granted') {
      const request = await saveFolderHandle.requestPermission({ mode: 'readwrite' });
      if (request !== 'granted') {
        toast('Permission denied. Please select folder again.', 'error');
        clearSaveFolder();
        return;
      }
    }
    
    // Generate filename with timestamp
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
    const filename = `${S.gameId}_tracking_${timestamp}.xlsx`;
    
    // Build the workbook (reuse export logic)
    const wb = buildExportWorkbook();
    
    // Write to the selected folder
    const fileHandle = await saveFolderHandle.getFileHandle(filename, { create: true });
    const writable = await fileHandle.createWritable();
    const xlsxData = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
    await writable.write(xlsxData);
    await writable.close();
    
    toast(`Saved: ${filename}`, 'success');
    document.getElementById('saveFolderStatus').textContent = `‚úì Last saved: ${filename}`;
    
  } catch (err) {
    console.error('Quick save error:', err);
    if (err.name === 'NotAllowedError') {
      toast('Permission denied. Please select folder again.', 'error');
      clearSaveFolder();
    } else {
      toast('Save failed: ' + err.message, 'error');
    }
  }
}

// Initialize save folder UI on page load
function initSaveFolderUI() {
  const lastFolderName = localStorage.getItem('bs_lastFolderName');
  if (lastFolderName) {
    document.getElementById('saveFolderPath').textContent = `${lastFolderName} (re-select to enable)`;
    document.getElementById('saveFolderPath').classList.remove('empty');
    document.getElementById('saveFolderStatus').textContent = 'üí° Re-select folder to enable Quick Save (browser security)';
  }
  
  // Update autosave display
  const autoSaveInt = document.getElementById('autoSaveInt');
  if (autoSaveInt) {
    const display = document.getElementById('autoSaveDisplay');
    if (display) display.textContent = autoSaveInt.value || '30';
    autoSaveInt.addEventListener('change', () => {
      if (display) display.textContent = autoSaveInt.value;
    });
  }
}

function renderPlayerPicker() {
  const team = document.getElementById('pickerTeam').value;
  const roster = S.rosters[team] || [];
  
  document.getElementById('playerPickerList').innerHTML = roster.map(p => `
    <div class="picker-player" onclick="selectPlayerFromPicker('${p.num}', '${p.name}')" 
         style="padding:6px;margin:2px 0;background:var(--card);border-radius:3px;cursor:pointer;display:flex;justify-content:space-between;">
      <span><strong>#${p.num}</strong> ${p.name}</span>
      <span style="color:var(--muted);">${p.pos || 'F'}</span>
    </div>
  `).join('') || '<div style="color:var(--muted);">No players</div>';
}

function selectPlayerFromPicker(num, name) {
  if (S.editingEvtIdx === null) {
    toast('No event being edited', 'error');
    return;
  }
  const evt = S.events[S.editingEvtIdx];
  
  // Ensure players array exists
  if (!evt.players) evt.players = [];
  
  const role = document.getElementById('pickerRole').value;
  const team = document.getElementById('pickerTeam').value;
  
  // Check if player already in event
  if (evt.players.some(p => p.num === num)) {
    toast(`#${num} already in event`, 'error');
    return;
  }
  
  // Determine next role number
  const existingRoles = evt.players.filter(p => p.role?.startsWith(role)).length;
  const roleNum = existingRoles + 1;
  
  evt.players.push({
    num, name, 
    role: `${role}_${roleNum}`,
    roleNum,
    team,
    xy: [],
    playD1: '', playD2: '', playSuccess: '', pressure: '', sideOfPuck: ''
  });
  
  renderEditPlayers(evt.players);
  
  // Update XY target dropdown
  const xyTargetSel = document.getElementById('editXYTarget');
  xyTargetSel.innerHTML = '<option value="puck">Puck</option>' + 
    evt.players.map((p, i) => `<option value="player_${i}">#${p.num} ${p.name}</option>`).join('');
  
  closePlayerPicker();
  toast(`Added #${num} ${name}`, 'success');
}

function closePlayerPicker() {
  document.getElementById('playerPickerModal').classList.remove('show');
}

// ============================================================
// VERIFICATION PANEL
// ============================================================
async function openVerifyModal() {
  // Set noradhockey link
  const link = document.getElementById('noradGameLink');
  if (S.gameId) {
    link.href = `https://noradhockey.com/event/${S.gameId}/`;
    link.style.display = 'inline';
    
    // v15.02: Auto-populate official score from dim_schedule if connected
    if (S.connected) {
      try {
        console.log('Loading official score for game', S.gameId);
        const { data: schedData, error: schedError } = await S.sb.from('dim_schedule')
          .select('home_total_goals,away_total_goals,home_team_period1_goals,home_team_period2_goals,home_team_period3_goals,away_team_period1_goals,away_team_period2_goals,away_team_period3_goals')
          .eq('game_id', S.gameId)
          .single();
        
        if (schedError) {
          console.error('Error loading official score:', schedError);
        }
        
        console.log('Official score data:', schedData);
        
        if (schedData) {
          // Store in hidden fields
          document.getElementById('officialHomeGoals').value = schedData.home_total_goals ?? 0;
          document.getElementById('officialAwayGoals').value = schedData.away_total_goals ?? 0;
          
          // Display total goals
          document.getElementById('officialHomeGoalsDisplay').textContent = schedData.home_total_goals ?? 0;
          document.getElementById('officialAwayGoalsDisplay').textContent = schedData.away_total_goals ?? 0;
          
          // Display by period
          const hp1 = schedData.home_team_period1_goals ?? '-';
          const hp2 = schedData.home_team_period2_goals ?? '-';
          const hp3 = schedData.home_team_period3_goals ?? '-';
          const ap1 = schedData.away_team_period1_goals ?? '-';
          const ap2 = schedData.away_team_period2_goals ?? '-';
          const ap3 = schedData.away_team_period3_goals ?? '-';
          
          document.getElementById('officialHomeByPeriod').textContent = `P1: ${hp1} | P2: ${hp2} | P3: ${hp3}`;
          document.getElementById('officialAwayByPeriod').textContent = `P1: ${ap1} | P2: ${ap2} | P3: ${ap3}`;
          
          // Store period data for comparison
          S.officialPeriodGoals = {
            home: { 1: hp1, 2: hp2, 3: hp3 },
            away: { 1: ap1, 2: ap2, 3: ap3 }
          };
          
          console.log('Official score loaded successfully');
        } else {
          console.log('No schedule data found for game', S.gameId);
        }
        
        // v6: Load fact_gameroster for verification
        const { data: rosterData } = await S.sb.from('fact_gameroster')
          .select('player_game_number,player_full_name,goals,assist,team_venue')
          .eq('game_id', S.gameId);
        
        if (rosterData) {
          S.rosterStats = {};
          rosterData.forEach(p => {
            S.rosterStats[String(p.player_game_number)] = {
              name: p.player_full_name,
              goals: parseInt(p.goals) || 0,
              assists: parseInt(p.assist) || 0,
              team: (p.team_venue || '').toLowerCase() === 'home' ? 'home' : 'away'
            };
          });
        }
      } catch(e) { console.log('Could not auto-populate score:', e); }
    }
  } else {
    link.style.display = 'none';
  }
  
  runVerification();
  document.getElementById('verifyModal').classList.add('show');
}

function closeVerifyModal() {
  document.getElementById('verifyModal').classList.remove('show');
}

function runVerification() {
  // v6: Count tracked goals by team and period
  const homeGoals = S.events.filter(e => e.type === 'Goal' && e.detail1 === 'Goal_Scored' && e.team === 'home');
  const awayGoals = S.events.filter(e => e.type === 'Goal' && e.detail1 === 'Goal_Scored' && e.team === 'away');
  
  // Count by period
  const homeP1 = homeGoals.filter(g => g.period === 1 || g.period === '1').length;
  const homeP2 = homeGoals.filter(g => g.period === 2 || g.period === '2').length;
  const homeP3 = homeGoals.filter(g => g.period === 3 || g.period === '3').length;
  const awayP1 = awayGoals.filter(g => g.period === 1 || g.period === '1').length;
  const awayP2 = awayGoals.filter(g => g.period === 2 || g.period === '2').length;
  const awayP3 = awayGoals.filter(g => g.period === 3 || g.period === '3').length;
  
  document.getElementById('verifyHomeGoals').textContent = homeGoals.length;
  document.getElementById('verifyAwayGoals').textContent = awayGoals.length;
  document.getElementById('verifyHomeByPeriod').textContent = `P1: ${homeP1} | P2: ${homeP2} | P3: ${homeP3}`;
  document.getElementById('verifyAwayByPeriod').textContent = `P1: ${awayP1} | P2: ${awayP2} | P3: ${awayP3}`;
  
  // Compare to official
  const officialHome = parseInt(document.getElementById('officialHomeGoals').value) || 0;
  const officialAway = parseInt(document.getElementById('officialAwayGoals').value) || 0;
  
  const resultEl = document.getElementById('verifyResult');
  if (homeGoals.length === officialHome && awayGoals.length === officialAway) {
    resultEl.innerHTML = '‚úÖ VERIFIED - Goals match official score!';
    resultEl.style.background = 'rgba(16, 185, 129, 0.2)';
    resultEl.style.color = 'var(--success)';
  } else {
    const diff = `Home: ${homeGoals.length} vs ${officialHome}, Away: ${awayGoals.length} vs ${officialAway}`;
    resultEl.innerHTML = `‚ùå MISMATCH - ${diff}`;
    resultEl.style.background = 'rgba(239, 68, 68, 0.2)';
    resultEl.style.color = 'var(--danger)';
  }
  
  // v6: Build goal list with scorer # and assist # (from %assist% in play_detail)
  const allGoals = [...homeGoals, ...awayGoals].sort((a, b) => {
    if (a.period !== b.period) return a.period - b.period;
    return (b.start_time || '20:00').localeCompare(a.start_time || '20:00');
  });
  
  // Track for warnings
  const warnings = [];
  
  document.getElementById('verifyGoalsList').innerHTML = allGoals.map(g => {
    const scorer = g.players?.find(p => p.role === 'event_player_1');
    
    // v6: Find assists by checking for '%assist%' in play_detail1 or play_detail2
    const assisters = (g.players || []).filter(p => {
      const pd1 = (p.playD1 || '').toLowerCase();
      const pd2 = (p.playD2 || '').toLowerCase();
      return pd1.includes('assist') || pd2.includes('assist');
    });
    
    const scorerNum = scorer?.num || '';
    const scorerName = scorer?.name || '';
    const assistStr = assisters.length > 0 
      ? assisters.map(a => `#${a.num}`).join(', ')
      : 'Unassisted';
    
    // v6: Check against roster stats
    let rosterMatch = '‚úì';
    if (S.rosterStats && scorerNum) {
      const rosterPlayer = S.rosterStats[scorerNum];
      if (rosterPlayer) {
        // Check if roster shows this player has a goal
        if (rosterPlayer.goals === 0) {
          rosterMatch = '‚ö†Ô∏è';
          warnings.push(`#${scorerNum} ${scorerName} scored but roster shows 0 goals`);
        }
      } else {
        rosterMatch = '?';
        warnings.push(`#${scorerNum} ${scorerName} not found in roster`);
      }
      
      // Check assisters
      assisters.forEach(a => {
        const assistRoster = S.rosterStats[a.num];
        if (assistRoster && assistRoster.assists === 0) {
          warnings.push(`#${a.num} has assist but roster shows 0 assists`);
        }
      });
    }
    
    return `<tr>
      <td>P${g.period}</td>
      <td>${g.start_time || '--'}</td>
      <td style="color:${g.team === 'home' ? 'var(--home)' : 'var(--away)'};">${g.team === 'home' ? (S.homeTeam || 'HOME') : (S.awayTeam || 'AWAY')}</td>
      <td><strong>#${scorerNum}</strong> ${scorerName}</td>
      <td>${assistStr}</td>
      <td>${rosterMatch}</td>
    </tr>`;
  }).join('') || '<tr><td colspan="6" style="text-align:center;color:var(--muted);">No goals recorded</td></tr>';
  
  // v6: Additional warnings
  if (homeGoals.length !== officialHome) warnings.push(`Home goals off by ${Math.abs(homeGoals.length - officialHome)}`);
  if (awayGoals.length !== officialAway) warnings.push(`Away goals off by ${Math.abs(awayGoals.length - officialAway)}`);
  
  // Check period mismatches
  if (S.officialPeriodGoals) {
    if (S.officialPeriodGoals.home[1] !== '-' && homeP1 !== parseInt(S.officialPeriodGoals.home[1])) {
      warnings.push(`P1 home goals: ${homeP1} tracked vs ${S.officialPeriodGoals.home[1]} official`);
    }
    if (S.officialPeriodGoals.home[2] !== '-' && homeP2 !== parseInt(S.officialPeriodGoals.home[2])) {
      warnings.push(`P2 home goals: ${homeP2} tracked vs ${S.officialPeriodGoals.home[2]} official`);
    }
    if (S.officialPeriodGoals.away[1] !== '-' && awayP1 !== parseInt(S.officialPeriodGoals.away[1])) {
      warnings.push(`P1 away goals: ${awayP1} tracked vs ${S.officialPeriodGoals.away[1]} official`);
    }
    if (S.officialPeriodGoals.away[2] !== '-' && awayP2 !== parseInt(S.officialPeriodGoals.away[2])) {
      warnings.push(`P2 away goals: ${awayP2} tracked vs ${S.officialPeriodGoals.away[2]} official`);
    }
  }
  
  // Goals without scorers
  const goalsWithoutScorer = allGoals.filter(g => !g.players?.find(p => p.role === 'event_player_1'));
  if (goalsWithoutScorer.length > 0) warnings.push(`${goalsWithoutScorer.length} goal(s) missing scorer`);
  
  // v6: Display warnings in dedicated section
  const warningsEl = document.getElementById('verifyWarnings');
  const warningsListEl = document.getElementById('verifyWarningsList');
  if (warnings.length > 0) {
    warningsEl.style.display = 'block';
    warningsListEl.innerHTML = warnings.map(w => `<div>‚Ä¢ ${w}</div>`).join('');
  } else {
    warningsEl.style.display = 'none';
  }
}

// ============================================================
// LOAD EXISTING GAME
// ============================================================
function openLoadGameModal() {
  if (!S.connected) {
    toast('Connect to Supabase first', 'error');
    return;
  }
  populateLoadGameSelect();
  document.getElementById('loadGameModal').classList.add('show');
}

function closeLoadGameModal() {
  document.getElementById('loadGameModal').classList.remove('show');
}

async function populateLoadGameSelect() {
  const select = document.getElementById('loadGameSelect');
  select.innerHTML = '<option value="">Loading tracked games...</option>';
  
  try {
    // Paginate through fact_events to get ALL game_ids
    console.log('Load modal: Querying fact_events...');
    const allGameIds = new Set();
    let offset = 0;
    const pageSize = 1000;
    let hasMore = true;
    
    while (hasMore && offset < 50000) {
      const { data, error } = await S.sb.from('fact_events')
        .select('game_id')
        .range(offset, offset + pageSize - 1);
      
      if (error) break;
      if (!data || data.length === 0) {
        hasMore = false;
      } else {
        data.forEach(r => allGameIds.add(r.game_id));
        offset += pageSize;
        if (data.length < pageSize) hasMore = false;
      }
    }
    
    const trackedGameIds = Array.from(allGameIds);
    console.log('Load modal: Found game IDs:', trackedGameIds);
    
    if (trackedGameIds.length === 0) {
      select.innerHTML = '<option value="">No tracked games found</option>';
      return;
    }
    
    // Get game details for tracked games
    const { data: games } = await S.sb.from('dim_schedule')
      .select('game_id,date,home_team_name,away_team_name')
      .in('game_id', trackedGameIds)
      .order('date', { ascending: false });
    
    console.log('Load modal: Schedule returned', games?.length, 'rows');
    
    // Dedupe
    const seen = new Set();
    const uniqueGames = (games || []).filter(g => {
      if (seen.has(g.game_id)) return false;
      seen.add(g.game_id);
      return true;
    });
    
    select.innerHTML = '<option value="">Select tracked game (' + uniqueGames.length + ')</option>' + 
      uniqueGames.map(g => `<option value="${g.game_id}">${g.game_id} - ${g.date?.split('T')[0]} ${g.home_team_name} vs ${g.away_team_name}</option>`).join('');
      
    console.log('Load game modal:', uniqueGames.length, 'tracked games');
  } catch(e) {
    toast('Failed to load games', 'error');
    console.error(e);
  }
}

async function previewLoadGame() {
  const gameId = document.getElementById('loadGameSelect').value;
  if (!gameId) {
    document.getElementById('loadPreviewEvents').textContent = '--';
    document.getElementById('loadPreviewShifts').textContent = '--';
    return;
  }
  
  try {
    const { count: evtCount } = await S.sb.from('fact_events').select('*', { count: 'exact', head: true }).eq('game_id', gameId);
    const { count: shiftCount } = await S.sb.from('fact_shifts').select('*', { count: 'exact', head: true }).eq('game_id', gameId);
    
    document.getElementById('loadPreviewEvents').textContent = evtCount || 0;
    document.getElementById('loadPreviewShifts').textContent = shiftCount || 0;
  } catch(e) {
    console.error(e);
  }
}

async function confirmLoadGame() {
  const gameId = document.getElementById('loadGameSelect').value;
  if (!gameId) { toast('Select a game', 'error'); return; }
  
  try {
    toast('Loading game data from Supabase...', 'info');
    console.log('=== LOADING GAME:', gameId, '===');
    
    // First set the game ID and find game info
    S.gameId = parseInt(gameId);
    const g = S.games.find(x => x.game_id == gameId);
    if (g) {
      S.homeTeam = g.home_team_name;
      S.awayTeam = g.away_team_name;
      console.log('Game info:', S.homeTeam, 'vs', S.awayTeam);
      
      // v16: Load team colors and logos from S.teams (loaded in loadReferenceData)
      const homeTeamData = S.teams[S.homeTeam] || {};
      const awayTeamData = S.teams[S.awayTeam] || {};
      S.homeColor = homeTeamData.color1 || '#3b82f6';
      S.awayColor = awayTeamData.color1 || '#ef4444';
      S.homeLogo = homeTeamData.logo || null;
      S.awayLogo = awayTeamData.logo || null;
      console.log('Team colors:', S.homeColor, S.awayColor);
      console.log('Team logos:', S.homeLogo, S.awayLogo);
      
      // v16: Apply team colors to CSS variables
      document.documentElement.style.setProperty('--home', S.homeColor);
      document.documentElement.style.setProperty('--away', S.awayColor);
      
      // v16: Update UI labels with team names (not Home/Away)
      document.getElementById('homeLbl').textContent = S.homeTeam;
      document.getElementById('awayLbl').textContent = S.awayTeam;
      document.getElementById('evtHomeLbl').textContent = S.homeTeam;
      document.getElementById('evtAwayLbl').textContent = S.awayTeam;
      
      // v16: Update team logos if available
      updateTeamLogos();
      updateZoneLabels();
    }
    
    // Update the main game dropdown
    document.getElementById('gameSelect').value = gameId;
    
    // Load events with pagination (Supabase 1000 row limit)
    console.log('Loading events...');
    let allEvents = [];
    let offset = 0;
    let hasMore = true;
    
    while (hasMore) {
      const { data, error } = await S.sb.from('fact_events')
        .select('*')
        .eq('game_id', gameId)
        .order('event_id')
        .range(offset, offset + 999);
      
      if (error) {
        console.error('Event load error:', error);
        throw error;
      }
      
      if (!data || data.length === 0) {
        hasMore = false;
      } else {
        allEvents = allEvents.concat(data);
        console.log(`  Events page: ${data.length} (total: ${allEvents.length})`);
        offset += 1000;
        if (data.length < 1000) hasMore = false;
      }
    }
    console.log('Total events loaded:', allEvents.length);
    
    // Load shifts with pagination
    console.log('Loading shifts...');
    let allShifts = [];
    offset = 0;
    hasMore = true;
    
    while (hasMore) {
      const { data, error } = await S.sb.from('fact_shifts')
        .select('*')
        .eq('game_id', gameId)
        .order('shift_index')
        .range(offset, offset + 999);
      
      if (error) {
        console.error('Shift load error:', error);
        throw error;
      }
      
      if (!data || data.length === 0) {
        hasMore = false;
      } else {
        allShifts = allShifts.concat(data);
        console.log(`  Shifts page: ${data.length} (total: ${allShifts.length})`);
        offset += 1000;
        if (data.length < 1000) hasMore = false;
      }
    }
    console.log('Total shifts loaded:', allShifts.length);
    
    // Load event players for player details
    console.log('Loading event players...');
    let allPlayers = [];
    offset = 0;
    hasMore = true;
    
    while (hasMore) {
      const { data, error } = await S.sb.from('fact_event_players')
        .select('*')
        .eq('game_id', gameId)
        .range(offset, offset + 999);
      
      if (error) {
        console.error('Player load error:', error);
        throw error;
      }
      
      if (!data || data.length === 0) {
        hasMore = false;
      } else {
        allPlayers = allPlayers.concat(data);
        console.log(`  Players page: ${data.length} (total: ${allPlayers.length})`);
        offset += 1000;
        if (data.length < 1000) hasMore = false;
      }
    }
    console.log('Total player rows loaded:', allPlayers.length);
    
    // v16.02: Debug - log column names from first player row
    if (allPlayers.length > 0) {
      console.log('Player columns:', Object.keys(allPlayers[0]));
      // Find a player with play_detail data for debugging
      const playerWithPD = allPlayers.find(p => p.play_detail1 || p.play_detail_1 || p['play_detail1']);
      if (playerWithPD) {
        console.log('Sample player with play_detail:', {
          event_id: playerWithPD.event_id,
          player_game_number: playerWithPD.player_game_number,
          play_detail1: playerWithPD.play_detail1,
          'play_detail_1': playerWithPD.play_detail_1,
          play_detail_2: playerWithPD.play_detail_2,
          'play_detail2': playerWithPD.play_detail2
        });
      } else {
        console.log('No players with play_detail found in sample');
        // Log first 3 players to see all fields
        console.log('First 3 players:', allPlayers.slice(0, 3).map(p => ({...p})));
      }
    }
    
    // Group players by event_id
    const playersByEvent = {};
    allPlayers.forEach(p => {
      const evtId = p.event_id;
      if (!playersByEvent[evtId]) playersByEvent[evtId] = [];
      playersByEvent[evtId].push(p);
    });
    console.log('Events with players:', Object.keys(playersByEvent).length);
    
    // Convert events to tracker format
    console.log('Converting events to tracker format...');
    S.events = allEvents.map((e, i) => {
      const evtPlayers = playersByEvent[e.event_id] || [];
      
      // v15: Fix team loading - use player_team from event_player_1, compare to home_team
      // The team_venue column in fact_events is unreliable (often all 'Away')
      // Instead, find the event_player_1 and check their player_team vs home_team
      let isHome = false;
      const eventPlayer1 = evtPlayers.find(p => 
        p.player_role === 'event_player_1' || p.player_role === 'event_team_player_1'
      );
      if (eventPlayer1) {
        // Compare player_team to home_team to determine if home or away
        isHome = eventPlayer1.player_team === e.home_team || eventPlayer1.player_team === S.homeTeam;
      } else {
        // Fallback: try team_venue but normalize case
        const teamVenue = (e.team_venue || e.team || '').toLowerCase();
        isHome = teamVenue === 'home' || teamVenue === 'h';
      }
      
      return {
        idx: i + 1,
        eventId: e.event_id,
        game_id: e.game_id,
        period: e.period,
        start_time: `${e.event_start_min || 0}:${String(e.event_start_sec || 0).padStart(2, '0')}`,
        end_time: `${e.event_end_min || e.event_start_min || 0}:${String(e.event_end_sec || e.event_start_sec || 0).padStart(2, '0')}`,
        team: isHome ? 'home' : 'away',
        type: e.event_type,
        detail1: e.event_detail,
        detail2: e.event_detail_2,
        zone: e.event_team_zone?.charAt(0).toLowerCase() || '',
        success: e.event_successful,
        strength: e.strength || '5v5',
        isHighlight: e.is_highlight === 1 || e.is_highlight === true,
        linkedEventIdx: e.linked_event_key || null,
        sequenceIdx: e.sequence_key || null,
        playIdx: e.play_key || null,
        puckXY: (e.puck_x_start != null && e.puck_y_start != null) ? 
          [{ x: e.puck_x_start, y: e.puck_y_start }] : [],
        // v23.5: Load net target XY if available
        netXY: (e.net_x != null && e.net_y != null) ? 
          { x: e.net_x, y: e.net_y } : null,
        players: evtPlayers.map(p => {
          // v16.02: Debug play_detail mapping
          const pd1 = p.play_detail1 || p.play_detail_1 || p.player_play_detail_1 || '';
          const pd2 = p.play_detail_2 || p.play_detail2 || p.player_play_detail_2 || '';
          // v16.03: Target debug for specific event/player
          if (e.event_id === 'EV1896901058' || (pd1 && pd1.toLowerCase().includes('forced'))) {
            console.log(`üéØ TARGET DEBUG - Event ${e.event_id}, Player #${p.player_game_number}:`);
            console.log('  Raw play_detail1:', p.play_detail1);
            console.log('  Raw play_detail_2:', p.play_detail_2);
            console.log('  Mapped pd1:', pd1);
            console.log('  Mapped pd2:', pd2);
          }
          return {
          num: String(p.player_game_number || ''),
          name: p.player_name || '',
          role: p.player_role || 'event_team_player_1',
          roleNum: p.role_number || 1,
          // v16.02: Enhanced column checking with debug
          playD1: pd1,
          playD2: pd2,
          playSuccess: p.play_detail_successful || p.play_successful || '',
          pressure: p.pressured_pressurer || '',
          sideOfPuck: p.side_of_puck || '',
          teamVenue: p.team_venue || '',
          xy: (p.player_x != null && p.player_y != null) ? 
            [{ x: p.player_x, y: p.player_y }] : []
        };})
      };
    });
    console.log('Converted', S.events.length, 'events');
    
    // v16.03: Debug summary - count events with play_detail data
    const eventsWithPD = S.events.filter(e => e.players?.some(p => p.playD1 || p.playD2));
    console.log(`Events with play_detail data: ${eventsWithPD.length}/${S.events.length}`);
    if (eventsWithPD.length > 0) {
      console.log('Sample events with PD:', eventsWithPD.slice(0, 5).map(e => ({
        eventId: e.eventId,
        type: e.type,
        players: e.players?.map(p => ({ num: p.num, playD1: p.playD1, playD2: p.playD2 }))
      })));
    }
    // Check for specific event
    const targetEvent = S.events.find(e => e.eventId === 'EV1896901058');
    if (targetEvent) {
      console.log('üéØ Found EV1896901058:', targetEvent);
    } else {
      console.log('‚ö†Ô∏è EV1896901058 not found in loaded events');
    }
    
    // Convert shifts to tracker format
    console.log('Converting shifts to tracker format...');
    S.shifts = allShifts.map((sh, i) => ({
      idx: i + 1,
      shiftId: sh.shift_id,
      period: sh.period,
      start_time: `${sh.shift_start_min || 0}:${String(sh.shift_start_sec || 0).padStart(2, '0')}`,
      end_time: `${sh.shift_end_min || 0}:${String(sh.shift_end_sec || 0).padStart(2, '0')}`,
      start_type: sh.shift_start_type || 'OnTheFly',  // v17: Fixed to match LISTS format
      stop_type: sh.shift_stop_type || 'OnTheFly',    // v17: Fixed to match LISTS format
      strength: sh.strength || '5v5',
      stoppageTime: sh.stoppage_time || 0,
      home: {
        F1: sh.home_forward_1 ? { num: String(sh.home_forward_1) } : null,
        F2: sh.home_forward_2 ? { num: String(sh.home_forward_2) } : null,
        F3: sh.home_forward_3 ? { num: String(sh.home_forward_3) } : null,
        D1: sh.home_defense_1 ? { num: String(sh.home_defense_1) } : null,
        D2: sh.home_defense_2 ? { num: String(sh.home_defense_2) } : null,
        G: sh.home_goalie ? { num: String(sh.home_goalie) } : null,
        X: sh.home_xtra ? { num: String(sh.home_xtra) } : null
      },
      away: {
        F1: sh.away_forward_1 ? { num: String(sh.away_forward_1) } : null,
        F2: sh.away_forward_2 ? { num: String(sh.away_forward_2) } : null,
        F3: sh.away_forward_3 ? { num: String(sh.away_forward_3) } : null,
        D1: sh.away_defense_1 ? { num: String(sh.away_defense_1) } : null,
        D2: sh.away_defense_2 ? { num: String(sh.away_defense_2) } : null,
        G: sh.away_goalie ? { num: String(sh.away_goalie) } : null,
        X: sh.away_xtra ? { num: String(sh.away_xtra) } : null
      }
    }));
    console.log('Converted', S.shifts.length, 'shifts');
    
    S.evtIdx = S.events.length;
    S.shiftIdx = S.shifts.length;
    
    // Load rosters
    console.log('Loading rosters...');
    await loadRosters(gameId);
    
    // Close modal and render everything
    closeLoadGameModal();
    
    // Full render
    console.log('Rendering UI...');
    renderAll();
    renderRosters();
    renderEvents();
    renderShiftLog();
    updateScores();
    updateBoxScore();
    
    // Update localStorage
    localStorage.setItem('bs_lastGame', gameId);
    
    toast(`‚úÖ Loaded ${S.events.length} events, ${S.shifts.length} shifts`, 'success');
    console.log('=== LOAD COMPLETE ===');
    
  } catch(e) {
    toast('Failed to load game: ' + e.message, 'error');
    console.error('Load game error:', e);
  }
}

// ============================================================
// CLEAR ALL DATA
// ============================================================
function clearAllData() {
  if (!confirm('‚ö†Ô∏è Clear ALL events and shifts for this game?\n\nThis cannot be undone!')) return;
  if (!confirm('Are you REALLY sure? All tracking data will be lost.')) return;
  
  S.events = [];
  S.shifts = [];
  S.evtIdx = 0;
  S.shiftIdx = 0;
  S.lastSave = null;
  
  // Clear localStorage
  if (S.gameId) {
    localStorage.removeItem(`bs_${S.gameId}`);
  }
  
  renderAll();
  updateScores();
  updateBoxScore();
  
  toast('All data cleared', 'success');
  closeSettings();
}

/**
 * Clear all events (with confirmation)
 */
function clearAllEvents() {
  if (S.events.length === 0) {
    toast('No events to clear', 'info');
    return;
  }
  if (!confirm(`‚ö†Ô∏è Clear ALL ${S.events.length} events?\n\nThis cannot be undone!`)) return;
  
  S.events = [];
  S.evtIdx = 0;
  
  renderEvents();
  updateScores();
  updateBoxScore();
  renderMarkers();
  autoSave();
  
  toast(`Cleared all events`, 'success');
}

/**
 * Clear all shifts (with confirmation)
 */
function clearAllShifts() {
  if (S.shifts.length === 0) {
    toast('No shifts to clear', 'info');
    return;
  }
  if (!confirm(`‚ö†Ô∏è Clear ALL ${S.shifts.length} shifts?\n\nThis cannot be undone!`)) return;
  
  S.shifts = [];
  S.shiftIdx = 0;
  
  renderShiftLog();
  updateBoxScore();
  autoSave();
  
  toast(`Cleared all shifts`, 'success');
}

// ============================================================
// LINKED EVENT LOGIC
// ============================================================
function applyLinkedEventData() {
  // Copy XY data from linked event chain to current event
  // This applies to ALL linked event types
  if (S.linkedEventIdx === null && S.linkedEventIdx !== 0) return;
  
  const currType = S.curr.type;
  
  // ============================================================
  // FIND THE BEST SOURCE FOR XY DATA
  // Priority: 1) Most recent sibling (same linked_event), 2) Source event, 3) Previous event
  // ============================================================
  
  let sourceEvt = null;
  let sourceDesc = '';
  
  // 1. Check for sibling events (same linked_event) - get the most recent one with XY
  const siblings = S.events
    .filter(e => e.linkedEventIdx === S.linkedEventIdx && e.puckXY?.length)
    .sort((a, b) => b.idx - a.idx); // Most recent first
  
  if (siblings.length > 0) {
    sourceEvt = siblings[0];
    sourceDesc = `sibling #${sourceEvt.idx + 1} (${sourceEvt.type})`;
  }
  
  // 2. If no sibling has XY, check the source event itself
  if (!sourceEvt) {
    const linkedEvt = S.events.find(e => e.idx === S.linkedEventIdx);
    if (linkedEvt?.puckXY?.length) {
      sourceEvt = linkedEvt;
      sourceDesc = `source #${linkedEvt.idx + 1} (${linkedEvt.type})`;
    }
  }
  
  // 3. If still no XY, check the most recent event (regardless of linked_event)
  if (!sourceEvt && S.events.length > 0) {
    const lastEvt = S.events[S.events.length - 1];
    if (lastEvt?.puckXY?.length) {
      sourceEvt = lastEvt;
      sourceDesc = `previous #${lastEvt.idx + 1} (${lastEvt.type})`;
    }
  }
  
  // If no source found with XY, just copy zone from linked event
  if (!sourceEvt) {
    const linkedEvt = S.events.find(e => e.idx === S.linkedEventIdx);
    if (linkedEvt?.zone) {
      document.getElementById('evtZone').value = linkedEvt.zone;
    }
    toast(`Linked to #${S.linkedEventIdx + 1} (no XY to copy)`, 'info');
    return;
  }
  
  // ============================================================
  // COPY ALL XY DATA FROM SOURCE
  // ============================================================
  
  // Copy puck XY
  if (sourceEvt.puckXY?.length) {
    S.curr.puckXY = JSON.parse(JSON.stringify(sourceEvt.puckXY));
  }
  
  // Copy net XY if available
  if (sourceEvt.netXY) {
    S.curr.netXY = JSON.parse(JSON.stringify(sourceEvt.netXY));
  }
  
  // Copy ALL player positions from source event
  if (sourceEvt.players?.length) {
    // Determine if teams should swap roles (e.g., Shot‚ÜíSave)
    const shouldSwapTeams = (
      (currType === 'Save' && sourceEvt.type === 'Shot') ||
      (currType === 'Block' && sourceEvt.type === 'Shot')
    );
    
    sourceEvt.players.forEach(srcPlayer => {
      // Deep copy the player
      const newPlayer = JSON.parse(JSON.stringify(srcPlayer));
      
      // Map role if teams should swap
      if (shouldSwapTeams && newPlayer.role) {
        if (newPlayer.role.includes('event_team')) {
          newPlayer.role = newPlayer.role.replace('event_team', 'opp_team');
        } else if (newPlayer.role.includes('opp_team')) {
          newPlayer.role = newPlayer.role.replace('opp_team', 'event_team');
        }
      }
      
      // Check if this player already exists in current event
      const existingIdx = S.curr.players.findIndex(p => 
        p.num === newPlayer.num && p.team === newPlayer.team
      );
      
      if (existingIdx >= 0) {
        // Merge XY data into existing player
        if (newPlayer.xy?.length) {
          S.curr.players[existingIdx].xy = newPlayer.xy;
        }
      } else {
        // Add player with XY
        S.curr.players.push(newPlayer);
      }
    });
  }
  
  // Copy zone from source or linked event
  const zoneSource = sourceEvt.zone || S.events.find(e => e.idx === S.linkedEventIdx)?.zone;
  if (zoneSource) {
    document.getElementById('evtZone').value = zoneSource;
  }
  
  // Re-render to show copied data
  renderQuickAdd();
  renderMarkers();
  
  // Show confirmation
  toast(`Copied XY from ${sourceDesc}`, 'info');
}

// ============================================================
// EDIT SHIFT PLAYERS
// ============================================================
function editShiftPlayers(shiftIdx) {
  S.editingShiftIdx = shiftIdx;
  const shift = S.shifts[shiftIdx];
  if (!shift) return;
  
  // Open edit shift modal with player editing capability
  document.getElementById('editShiftIdx').textContent = shiftIdx + 1;
  document.getElementById('editShiftPeriod').value = shift.period;
  document.getElementById('editShiftStartTime').value = shift.start_time || '';
  document.getElementById('editShiftEndTime').value = shift.end_time || '';
  document.getElementById('editShiftStartType').value = shift.start_type || '';
  document.getElementById('editShiftStopType').value = shift.stop_type || '';
  document.getElementById('editShiftStrength').value = shift.strength || '5v5';
  
  // Render player slots in edit modal
  renderEditShiftPlayers(shift);
  
  document.getElementById('editShiftModal').classList.add('show');
}

function renderEditShiftPlayers(shift) {
  const container = document.getElementById('editShiftPlayersContainer');
  if (!container) return;
  
  // Build player options for each team
  const buildPlayerOptions = (team, currentNum) => {
    const roster = S.rosters[team] || [];
    // Convert currentNum to string for comparison (Excel imports as number, roster might be string)
    const currentNumStr = currentNum != null ? String(currentNum) : '';
    
    // If roster is empty but we have a current number, show it as an option
    if (roster.length === 0 && currentNumStr) {
      return `<option value="">--</option><option value="${currentNumStr}" selected>#${currentNumStr}</option>`;
    }
    
    return `<option value="">--</option>` + roster.map(p => {
      const numStr = String(p.num);
      const selected = numStr === currentNumStr ? 'selected' : '';
      return `<option value="${numStr}" ${selected}>#${p.num} ${p.name?.split(' ').pop() || ''}</option>`;
    }).join('');
  };
  
  let html = '<div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;">';
  
  // Home players
  html += `<div>
    <div style="font-size:10px;font-weight:bold;color:var(--home);margin-bottom:6px;border-bottom:1px solid var(--home);padding-bottom:2px;">HOME</div>
    <div style="display:grid;gap:4px;">`;
  
  // Forwards
  html += `<div style="font-size:8px;color:var(--muted);margin-top:4px;">Forwards</div>`;
  ['F1','F2','F3'].forEach(pos => {
    const p = shift.home?.[pos];
    html += `<div style="display:flex;align-items:center;gap:4px;">
      <span style="width:20px;font-size:9px;color:var(--accent);">${pos}</span>
      <select onchange="updateShiftPlayer('home','${pos}',this.value)" style="flex:1;font-size:9px;padding:2px;">
        ${buildPlayerOptions('home', p?.num)}
      </select>
    </div>`;
  });
  
  // Defense
  html += `<div style="font-size:8px;color:var(--muted);margin-top:4px;">Defense</div>`;
  ['D1','D2'].forEach(pos => {
    const p = shift.home?.[pos];
    html += `<div style="display:flex;align-items:center;gap:4px;">
      <span style="width:20px;font-size:9px;color:var(--accent);">${pos}</span>
      <select onchange="updateShiftPlayer('home','${pos}',this.value)" style="flex:1;font-size:9px;padding:2px;">
        ${buildPlayerOptions('home', p?.num)}
      </select>
    </div>`;
  });
  
  // Goalie & Extra
  html += `<div style="font-size:8px;color:var(--muted);margin-top:4px;">Goalie / Extra</div>`;
  ['G','X'].forEach(pos => {
    const p = shift.home?.[pos];
    html += `<div style="display:flex;align-items:center;gap:4px;">
      <span style="width:20px;font-size:9px;color:var(--accent);">${pos}</span>
      <select onchange="updateShiftPlayer('home','${pos}',this.value)" style="flex:1;font-size:9px;padding:2px;">
        ${buildPlayerOptions('home', p?.num)}
      </select>
    </div>`;
  });
  
  html += '</div></div>';
  
  // Away players  
  html += `<div>
    <div style="font-size:10px;font-weight:bold;color:var(--away);margin-bottom:6px;border-bottom:1px solid var(--away);padding-bottom:2px;">AWAY</div>
    <div style="display:grid;gap:4px;">`;
  
  // Forwards
  html += `<div style="font-size:8px;color:var(--muted);margin-top:4px;">Forwards</div>`;
  ['F1','F2','F3'].forEach(pos => {
    const p = shift.away?.[pos];
    html += `<div style="display:flex;align-items:center;gap:4px;">
      <span style="width:20px;font-size:9px;color:var(--accent);">${pos}</span>
      <select onchange="updateShiftPlayer('away','${pos}',this.value)" style="flex:1;font-size:9px;padding:2px;">
        ${buildPlayerOptions('away', p?.num)}
      </select>
    </div>`;
  });
  
  // Defense
  html += `<div style="font-size:8px;color:var(--muted);margin-top:4px;">Defense</div>`;
  ['D1','D2'].forEach(pos => {
    const p = shift.away?.[pos];
    html += `<div style="display:flex;align-items:center;gap:4px;">
      <span style="width:20px;font-size:9px;color:var(--accent);">${pos}</span>
      <select onchange="updateShiftPlayer('away','${pos}',this.value)" style="flex:1;font-size:9px;padding:2px;">
        ${buildPlayerOptions('away', p?.num)}
      </select>
    </div>`;
  });
  
  // Goalie & Extra
  html += `<div style="font-size:8px;color:var(--muted);margin-top:4px;">Goalie / Extra</div>`;
  ['G','X'].forEach(pos => {
    const p = shift.away?.[pos];
    html += `<div style="display:flex;align-items:center;gap:4px;">
      <span style="width:20px;font-size:9px;color:var(--accent);">${pos}</span>
      <select onchange="updateShiftPlayer('away','${pos}',this.value)" style="flex:1;font-size:9px;padding:2px;">
        ${buildPlayerOptions('away', p?.num)}
      </select>
    </div>`;
  });
  
  html += '</div></div></div>';
  
  container.innerHTML = html;
}

/**
 * Update a player in the shift being edited
 */
function updateShiftPlayer(team, pos, playerNum) {
  if (S.editingShiftIdx === null) return;
  const shift = S.shifts[S.editingShiftIdx];
  
  if (!shift[team]) shift[team] = {};
  
  if (playerNum) {
    // Find player in roster
    const roster = S.rosters[team] || [];
    const player = roster.find(p => p.num === playerNum);
    shift[team][pos] = player ? { num: player.num, name: player.name } : { num: playerNum };
  } else {
    shift[team][pos] = null;
  }
  
  // Update strength
  shift.strength = deriveStrengthFromShift(shift);
  document.getElementById('editShiftStrength').value = shift.strength;
}

/**
 * Derive strength from shift player counts
 */
function deriveStrengthFromShift(shift) {
  const countPlayers = (team) => {
    let count = 0;
    ['F1','F2','F3','D1','D2','X'].forEach(pos => {
      if (shift[team]?.[pos]?.num) count++;
    });
    return count;
  };
  
  const homeSkaters = countPlayers('home');
  const awaySkaters = countPlayers('away');
  
  // Check for empty net
  const homeEN = !shift.home?.G?.num;
  const awayEN = !shift.away?.G?.num;
  
  if (homeEN || awayEN) return 'ENG';
  if (homeSkaters === awaySkaters) return `${homeSkaters}v${awaySkaters}`;
  return `${homeSkaters}v${awaySkaters}`;
}

// ============================================================
// RENDER ALL (utility)
// ============================================================
// (renderAll is defined earlier - this is a comment placeholder)
// ============================================================

// ============================================================
// EDIT MODAL AUTO-CALCULATE FUNCTIONS
// ============================================================

/**
 * Auto-calculate zone from event's puckXY or player XY
 */
function autoEditZone() {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  
  // Get XY from puckXY or event_player_1
  let lastXY = null;
  if (evt.puckXY?.length) {
    lastXY = evt.puckXY[evt.puckXY.length - 1];
  } else {
    const evtP1 = (evt.players || []).find(p => 
      p.role === 'event_team_player_1' || p.role === 'event_player_1' || p.roleNum === 1
    );
    if (evtP1?.xy?.length) {
      lastXY = evtP1.xy[evtP1.xy.length - 1];
    }
  }
  
  if (!lastXY) {
    toast('Add XY coordinates to auto-detect zone', 'error');
    return;
  }
  
  // Calculate zone from X position
  const x = lastXY.x;
  const period = evt.period || 1;
  const isOddPeriod = period === 1 || period === 3 || period === 'OT';
  const homeOffensiveRight = isOddPeriod ? S.homeAttacksRightP1 : !S.homeAttacksRightP1;
  const team = evt.team || 'home';
  
  let zone = '';
  if (team === 'home') {
    if (homeOffensiveRight) {
      if (x > 125) zone = 'o';
      else if (x < 75) zone = 'd';
      else zone = 'n';
    } else {
      if (x < 75) zone = 'o';
      else if (x > 125) zone = 'd';
      else zone = 'n';
    }
  } else {
    if (homeOffensiveRight) {
      if (x < 75) zone = 'o';
      else if (x > 125) zone = 'd';
      else zone = 'n';
    } else {
      if (x > 125) zone = 'o';
      else if (x < 75) zone = 'd';
      else zone = 'n';
    }
  }
  
  document.getElementById('editZone').value = zone;
  toast(`Zone: ${zone === 'o' ? 'Offensive' : zone === 'd' ? 'Defensive' : 'Neutral'}`, 'success');
}

/**
 * Auto-calculate success from event type and detail
 */
function autoEditSuccess() {
  if (S.editingEvtIdx === null) return;
  
  const type = document.getElementById('editType').value;
  const d1 = document.getElementById('editD1').value;
  
  let success = '';
  
  if (type === 'Shot') {
    if (d1.includes('OnNet') || d1.includes('Goal')) success = 's';
    else if (d1.includes('Missed') || d1.includes('Blocked')) success = 'u';
  } else if (type === 'Pass') {
    if (d1.includes('Completed')) success = 's';
    else if (d1.includes('Missed') || d1.includes('Intercepted')) success = 'u';
  } else if (type === 'Zone_Entry_Exit') {
    if (d1.includes('Failed')) success = 'u';
    else if (d1.includes('Entry') || d1.includes('Exit') || d1.includes('Keepin')) success = 's';
  } else if (type === 'Turnover') {
    if (d1.includes('Takeaway')) success = 's';
    else if (d1.includes('Giveaway')) success = 'u';
  } else if (type === 'Goal' || type === 'Save') {
    success = 's';
  } else if (type === 'Faceoff') {
    if (d1.includes('Won')) success = 's';
    else if (d1.includes('Lost')) success = 'u';
  }
  
  if (success) {
    document.getElementById('editSuccess').value = success;
    toast(`Success: ${success === 's' ? 'Successful' : 'Unsuccessful'}`, 'success');
  } else {
    toast('Could not auto-derive success from type/detail', 'warning');
  }
}

/**
 * Auto-calculate strength from shift at event time
 */
function autoEditStrength() {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  
  // Find the shift that contains this event's time
  const eventTime = evt.start_time || evt.time;
  const eventPeriod = evt.period;
  
  const shift = S.shifts.find(s => 
    s.period === eventPeriod && isTimeBetween(eventTime, s.start_time, s.end_time)
  );
  
  if (shift) {
    const strength = deriveStrengthFromShift(shift);
    if (strength) {
      document.getElementById('editStrength').value = strength;
      toast(`Strength: ${strength} (from shift)`, 'success');
      return;
    }
  }
  
  // Fallback to current slot configuration
  const strength = deriveStrength();
  if (strength) {
    document.getElementById('editStrength').value = strength;
    toast(`Strength: ${strength} (from current slots)`, 'success');
  } else {
    toast('Could not determine strength', 'warning');
  }
}

function saveEditEvent() {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  
  evt.type = document.getElementById('editType').value;
  evt.team = document.getElementById('editTeam').value;
  evt.start_time = document.getElementById('editStartTime').value;
  evt.end_time = document.getElementById('editEndTime').value;
  evt.zone = document.getElementById('editZone').value;
  evt.success = document.getElementById('editSuccess').value;
  evt.strength = document.getElementById('editStrength').value;
  evt.detail1 = document.getElementById('editD1').value;
  evt.detail2 = document.getElementById('editD2').value;
  evt.isHighlight = document.getElementById('editHighlight').checked;
  
  // Save linked event index (convert from 1-based to 0-based)
  const linkedIdxEl = document.getElementById('editLinkedIdx');
  if (linkedIdxEl) {
    const linkedVal = linkedIdxEl.value ? parseInt(linkedIdxEl.value) - 1 : null;
    evt.linkedEventIdx = (linkedVal !== null && linkedVal >= 0) ? linkedVal : null;
  }
  
  closeEditModal();
  renderEvents(); updateScores(); updateBoxScore();
  autoSave();
  toast('Event updated', 'success');
}

function deleteEvent() {
  if (S.editingEvtIdx === null) return;
  if (!confirm('Delete this event?')) return;
  
  S.events.splice(S.editingEvtIdx, 1);
  closeEditModal();
  renderEvents(); updateScores(); updateBoxScore();
  autoSave();
  toast('Event deleted', 'success');
}

/**
 * v20.7: Insert a new event BEFORE the current one
 */
function insertEventBefore() {
  if (S.editingEvtIdx === null) return;
  
  const currentEvt = S.events[S.editingEvtIdx];
  
  // Create new blank event with same context
  const newEvt = {
    period: currentEvt.period,
    team: currentEvt.team,
    type: '',
    detail1: '',
    detail2: '',
    zone: currentEvt.zone || '',
    success: '',
    strength: currentEvt.strength || '5v5',
    start_time: currentEvt.start_time,
    end_time: '',
    players: [],
    puckXY: [],
    linkedEventIdx: null,
    isHighlight: false
  };
  
  // Insert at position
  S.events.splice(S.editingEvtIdx, 0, newEvt);
  
  const newIdx = S.editingEvtIdx;
  S.editingEvtIdx = null;
  
  closeEditModal();
  renderEvents(); updateScores(); updateBoxScore();
  autoSave();
  toast(`Inserted event #${newIdx + 1}`, 'success');
  
  // Open the new event for editing
  setTimeout(() => editEvent(newIdx), 100);
}

/**
 * v20.7: Insert a new event AFTER the current one
 */
function insertEventAfter() {
  if (S.editingEvtIdx === null) return;
  
  const currentEvt = S.events[S.editingEvtIdx];
  
  // Create new blank event with same context
  const newEvt = {
    period: currentEvt.period,
    team: currentEvt.team,
    type: '',
    detail1: '',
    detail2: '',
    zone: currentEvt.zone || '',
    success: '',
    strength: currentEvt.strength || '5v5',
    start_time: currentEvt.start_time,
    end_time: '',
    players: [],
    puckXY: [],
    linkedEventIdx: null,
    isHighlight: false
  };
  
  // Insert after current position
  const insertIdx = S.editingEvtIdx + 1;
  S.events.splice(insertIdx, 0, newEvt);
  
  S.editingEvtIdx = null;
  
  closeEditModal();
  renderEvents(); updateScores(); updateBoxScore();
  autoSave();
  toast(`Inserted event #${insertIdx + 1}`, 'success');
  
  // Open the new event for editing
  setTimeout(() => editEvent(insertIdx), 100);
}

/**
 * v20.7: Duplicate the current event
 */
function duplicateEvent() {
  if (S.editingEvtIdx === null) return;
  
  const currentEvt = S.events[S.editingEvtIdx];
  
  // Deep clone the event
  const newEvt = JSON.parse(JSON.stringify(currentEvt));
  // Clear linking to avoid confusion
  newEvt.linkedEventIdx = null;
  newEvt.eventId = null;
  newEvt.event_id = null;
  
  // Insert after current position
  const insertIdx = S.editingEvtIdx + 1;
  S.events.splice(insertIdx, 0, newEvt);
  
  S.editingEvtIdx = null;
  
  closeEditModal();
  renderEvents(); updateScores(); updateBoxScore();
  autoSave();
  toast(`Duplicated event ‚Üí #${insertIdx + 1}`, 'success');
  
  // Open the new event for editing
  setTimeout(() => editEvent(insertIdx), 100);
}

/**
 * v20.7: Add a new event at the end of the list
 */
function addNewEvent() {
  const lastEvt = S.events.length > 0 ? S.events[S.events.length - 1] : null;
  
  // Create new blank event
  const newEvt = {
    period: lastEvt ? lastEvt.period : S.period || 1,
    team: S.evtTeam || 'home',
    type: '',
    detail1: '',
    detail2: '',
    zone: '',
    success: '',
    strength: '5v5',
    start_time: lastEvt ? lastEvt.start_time : '',
    end_time: '',
    players: [],
    puckXY: [],
    linkedEventIdx: null,
    isHighlight: false
  };
  
  // Add to end
  S.events.push(newEvt);
  const newIdx = S.events.length - 1;
  
  renderEvents(); updateScores(); updateBoxScore();
  autoSave();
  toast(`Added event #${newIdx + 1}`, 'success');
  
  // Open the new event for editing
  setTimeout(() => editEvent(newIdx), 100);
}

function closeEditModal() {
  document.getElementById('editModal').classList.remove('show');
  S.editingEvtIdx = null;
}

/**
 * Navigate to previous/next event in edit modal
 * @param {number} dir - Direction (-1 for prev, 1 for next)
 */
function navEditEvent(dir) {
  if (S.editingEvtIdx === null) return;
  
  // Save current event first
  saveEditEventSilent();
  
  const newIdx = S.editingEvtIdx + dir;
  if (newIdx < 0 || newIdx >= S.events.length) {
    toast(dir < 0 ? 'First event' : 'Last event', 'info');
    return;
  }
  
  editEvent(newIdx);
}

/**
 * Navigate to previous/next shift in edit modal
 * @param {number} dir - Direction (-1 for prev, 1 for next)
 */
function navEditShift(dir) {
  if (S.editingShiftIdx === null) return;
  
  // Save current shift first
  saveEditShiftSilent();
  
  const newIdx = S.editingShiftIdx + dir;
  if (newIdx < 0 || newIdx >= S.shifts.length) {
    toast(dir < 0 ? 'First shift' : 'Last shift', 'info');
    return;
  }
  
  editShift(newIdx);
}

/**
 * Save event without closing modal or showing toast
 */
function saveEditEventSilent() {
  if (S.editingEvtIdx === null) return;
  const evt = S.events[S.editingEvtIdx];
  
  evt.type = document.getElementById('editType').value;
  evt.team = document.getElementById('editTeam').value;
  evt.start_time = document.getElementById('editStartTime').value;
  evt.end_time = document.getElementById('editEndTime').value;
  evt.zone = document.getElementById('editZone').value;
  evt.success = document.getElementById('editSuccess').value;
  evt.strength = document.getElementById('editStrength').value;
  evt.detail1 = document.getElementById('editD1').value;
  evt.detail2 = document.getElementById('editD2').value;
  evt.isHighlight = document.getElementById('editHighlight').checked;
  
  const linkedIdxEl = document.getElementById('editLinkedIdx');
  if (linkedIdxEl) {
    const linkedVal = linkedIdxEl.value ? parseInt(linkedIdxEl.value) - 1 : null;
    evt.linkedEventIdx = (linkedVal !== null && linkedVal >= 0) ? linkedVal : null;
  }
  
  autoSave();
}

/**
 * Save shift without closing modal or showing toast
 */
function saveEditShiftSilent() {
  if (S.editingShiftIdx === null) return;
  const shift = S.shifts[S.editingShiftIdx];
  
  shift.period = document.getElementById('editShiftPeriod').value;
  shift.start_time = document.getElementById('editShiftStartTime').value;
  shift.end_time = document.getElementById('editShiftEndTime').value;
  shift.start_type = document.getElementById('editShiftStartType').value;
  shift.stop_type = document.getElementById('editShiftStopType').value;
  
  autoSave();
}

/**
 * Clear all events (keep shifts)
 */
function clearAllEvents() {
  if (!S.gameId) { toast('No game loaded', 'error'); return; }
  if (!confirm(`‚ö†Ô∏è Clear ALL ${S.events.length} events?\n\nShifts will be kept. This cannot be undone!`)) return;
  
  S.events = [];
  S.evtIdx = 0;
  
  renderAll();
  autoSave();
  toast('All events cleared', 'success');
}

/**
 * Clear all shifts (keep events)
 */
function clearAllShifts() {
  if (!S.gameId) { toast('No game loaded', 'error'); return; }
  if (!confirm(`‚ö†Ô∏è Clear ALL ${S.shifts.length} shifts?\n\nEvents will be kept. This cannot be undone!`)) return;
  
  S.shifts = [];
  S.shiftIdx = 0;
  
  renderShiftLog();
  autoSave();
  toast('All shifts cleared', 'success');
}

// ============================================================
// SHIFTS
// ============================================================

/**
 * Calculate total stoppage duration during a shift
 * Looks for Stoppage/Clockstop events within the shift time window
 * @param {object} shift - Shift object with period, start_time, end_time
 * @returns {number} - Total stoppage time in seconds
 */
function calculateShiftStoppageTime(shift) {
  if (!shift.start_time || !shift.end_time) return 0;
  
  const parseTime = (t) => {
    if (!t) return 0;
    const [min, sec] = t.split(':').map(Number);
    return (min || 0) * 60 + (sec || 0);
  };
  
  const shiftStartSec = parseTime(shift.start_time);  // Time remaining at shift start
  const shiftEndSec = parseTime(shift.end_time);      // Time remaining at shift end
  
  // Find stoppage events in this shift's period and time window
  // Note: Higher time = earlier in period (clock counts down)
  let stoppageTotal = 0;
  
  S.events.forEach(evt => {
    if (evt.period !== shift.period) return;
    if (evt.type !== 'Stoppage' && evt.type !== 'Clockstop' && evt.type !== 'Timeout') return;
    
    const evtTimeSec = parseTime(evt.start_time);
    
    // Check if event falls within shift (between end and start because clock counts down)
    if (evtTimeSec <= shiftStartSec && evtTimeSec >= shiftEndSec) {
      // Get event duration
      const evtEndSec = parseTime(evt.end_time);
      const duration = Math.abs(evtTimeSec - evtEndSec);
      
      // If no end time, use default durations
      if (duration > 0) {
        stoppageTotal += duration;
      } else {
        // Default durations by type
        if (evt.type === 'Timeout') stoppageTotal += 60;
        else if (evt.detail1?.includes('Icing')) stoppageTotal += 15;
        else if (evt.detail1?.includes('Offside')) stoppageTotal += 10;
        else stoppageTotal += 5;  // Default 5 sec for other stoppages
      }
    }
  });
  
  return stoppageTotal;
}

/**
 * Calculate shift duration in seconds
 */
function calculateShiftDuration(shift) {
  if (!shift.start_time || !shift.end_time) return 0;
  
  const parseTime = (t) => {
    const [min, sec] = t.split(':').map(Number);
    return (min || 0) * 60 + (sec || 0);
  };
  
  // Clock counts down, so start > end
  return parseTime(shift.start_time) - parseTime(shift.end_time);
}

// Helper to check if event time falls within shift time range
// Clock counts DOWN (18:00 -> 0:00), so "between" means: start >= time >= end
function isTimeBetween(eventTime, shiftStart, shiftEnd) {
  if (!eventTime || !shiftStart || !shiftEnd) return false;
  
  const parseTime = (t) => {
    if (!t) return 0;
    const [min, sec] = String(t).split(':').map(Number);
    return (min || 0) * 60 + (sec || 0);
  };
  
  const evt = parseTime(eventTime);
  const start = parseTime(shiftStart);
  const end = parseTime(shiftEnd);
  
  // Clock counts down, so start > end (e.g., 18:00 to 16:30)
  return evt <= start && evt >= end;
}

function logShift() {
  const start = document.getElementById('shiftStart').value;
  const end = document.getElementById('shiftEnd').value || document.getElementById('clock').value;
  
  const shift = {
    idx: S.shiftIdx++,
    game_id: S.gameId,
    period: S.period,
    start_time: start,
    end_time: end,
    start_type: document.getElementById('shiftStartType').value,
    stop_type: document.getElementById('shiftStopType').value,
    strength: deriveStrength(),
    home: {...S.slots.home},
    away: {...S.slots.away}
  };
  
  // Calculate stoppage time during this shift
  shift.stoppageTime = calculateShiftStoppageTime(shift);
  
  // Calculate shift duration
  shift.duration = calculateShiftDuration(shift);
  
  S.shifts.push(shift);
  document.getElementById('shiftStart').value = end;
  document.getElementById('shiftEnd').value = '';
  S.lastEndTime = end;
  
  renderShiftLog();
  toast(`Shift #${shift.idx + 1} logged (${shift.stoppageTime}s stoppage)`, 'success');
  autoSave();
}

// Auto-update strength when slots change
function onSlotsChanged() {
  const strength = deriveStrength();
  document.getElementById('evtStrength').value = strength;
  updateQuickStats(); // v5
}

// ============================================================
// PERIOD & CLOCK
// ============================================================
function setPeriod(p) {
  S.period = p;
  document.querySelectorAll('.period-btn').forEach(b => b.classList.remove('active'));
  document.querySelector(`.period-btn[data-p="${p}"]`)?.classList.add('active');
  
  // Set clock based on period-specific length
  const periodLen = getPeriodLength(p);
  document.getElementById('clock').value = `${periodLen}:00`;
  
  // Update period length indicator
  updatePeriodLengthIndicator();
  
  // Update zone labels (they switch each period)
  updateZoneLabels();
}

/**
 * Flip which end home team attacks in P1
 * For beer league where benches aren't fixed home/away
 */
function flipZones() {
  S.homeAttacksRightP1 = !S.homeAttacksRightP1;
  updateZoneLabels();
  
  const direction = S.homeAttacksRightP1 ? 'RIGHT' : 'LEFT';
  const homeShort = (S.homeTeam || 'HOME').toUpperCase();
  toast(`${homeShort} attacks ${direction} in P1/P3`, 'info');
  
  // Update button visual
  const btn = document.getElementById('flipZonesBtn');
  if (btn) {
    btn.style.background = S.homeAttacksRightP1 ? '#374151' : '#7c3aed';
  }
  
  autoSave();
}

function updateClock() {
  // Just store the value, could trigger other updates
}

// ============================================================
// EXPORT
// ============================================================

// Build the export workbook (reusable for both Export and Quick Save)
function buildExportWorkbook() {
  // Build LONG format export (one row per player per event)
  // Format matches ETL expected input with underscore suffix for input columns
  const rows = [];
  
  // Track zone changes for zone_change_index
  let lastZone = null;
  let zoneChangeIdx = 0;
  
  S.events.forEach((evt, i) => {
    const startTime = evt.start_time || evt.time || '';
    const endTime = evt.end_time || evt.start_time || evt.time || '';
    const [startMin, startSec] = (startTime || '').split(':');
    const [endMin, endSec] = (endTime || '').split(':');
    
    // Map zone to abbreviation (o/d/n)
    const zoneAbbr = evt.zone || 'n';
    
    // Track zone changes
    if (zoneAbbr !== lastZone) {
      zoneChangeIdx++;
      lastZone = zoneAbbr;
    }
    
    // Calculate time totals (clock counts down from periodLength:00 to 0:00)
    // Time elapsed = total period time - remaining time
    const period = parseInt(evt.period) || 1;
    const periodLengthMin = getPeriodLength(evt.period);
    const periodLengthSec = periodLengthMin * 60;
    const startMinInt = parseInt(startMin) || 0;
    const startSecInt = parseInt(startSec) || 0;
    const endMinInt = parseInt(endMin) || startMinInt;
    const endSecInt = parseInt(endSec) || startSecInt;
    // Remaining time in seconds: min*60 + sec
    // Elapsed time = periodLength*60 - remaining
    const startTotalSec = periodLengthSec - (startMinInt * 60 + startSecInt);
    const endTotalSec = periodLengthSec - (endMinInt * 60 + endSecInt);
    
    // Running time calculations - sum all previous periods
    let periodOffset = 0;
    for (let p = 1; p < period; p++) {
      periodOffset += getPeriodLengthSeconds(p);
    }
    const eventRunningStart = periodOffset + startTotalSec;
    const eventRunningEnd = periodOffset + endTotalSec;
    
    // Calculate running video time WITH intermissions
    const runningVideoTime = evt.videoTime || calculateRunningVideoTime(period, startTime);
    
    // Calculate intermission duration up to this point
    const int1 = S.videoTiming?.intermission1 || 0;
    const int2 = S.videoTiming?.intermission2 || 0;
    const int3 = S.videoTiming?.intermission3 || 0;
    let intermissionDuration = 0;
    if (period >= 2) intermissionDuration += int1;
    if (period >= 3) intermissionDuration += int2;
    if (period >= 4) intermissionDuration += int3;
    
    // Duration
    const duration = endTotalSec - startTotalSec;
    
    const base = {
      // Input columns (underscore suffix for ETL)
      'event_index_flag_': i + 1,
      'sequence_index_flag_': evt.sequenceIdx || '',
      'play_index_flag_': evt.playIdx || '',
      'linked_event_index_flag_': evt.linkedEventIdx !== null ? evt.linkedEventIdx + 1 : '',
      'event_start_min_': startMin || '',
      'event_start_sec_': startSec || '',
      'event_end_min_': endMin || '',
      'event_end_sec_': endSec || '',
      'event_team_zone_': zoneAbbr,
      'event_type_': evt.type,
      'event_detail_': evt.detail1 || '',
      'event_detail_2_': evt.detail2 || '',
      'event_successful_': evt.success || '',
      'team_': evt.team === 'home' ? 'h' : 'a',
      // Additional derived columns
      'period': evt.period,
      'event_index': 1000 + i,  // ETL format: 1000-based
      'tracking_event_index': 1000 + i,  // Same as event_index
      'linked_event_index': evt.linkedEventIdx !== null ? 1000 + evt.linkedEventIdx : '',
      'game_id': S.gameId,
      'home_team': S.homeTeam,
      'away_team': S.awayTeam,
      'strength': evt.strength || '5v5',
      'event_team_zone': zoneAbbr === 'o' ? 'Offensive' : zoneAbbr === 'd' ? 'Defensive' : 'Neutral',
      // Non-underscore duplicates (ETL uses both)
      'event_start_min': startMin || '',
      'event_start_sec': startSec || '',
      'event_end_min': endMin || '',
      'event_end_sec': endSec || '',
      'event_detail': evt.detail1 || '',
      'event_detail_2': evt.detail2 || '',
      'event_successful': evt.success || '',
      // Calculated columns
      'time_start_total_seconds': startTotalSec,
      'time_end_total_seconds': endTotalSec,
      'duration': duration,
      'period_start_total_running_seconds': periodOffset,
      'running_video_time': runningVideoTime,
      'event_running_start': eventRunningStart,
      'event_running_end': eventRunningEnd,
      'running_intermission_duration': intermissionDuration,
      'zone_change_index': zoneChangeIdx,
      'shift_index': evt.shiftIdx || '',
      'is_highlight': evt.isHighlight ? 1 : 0,
      'Type': evt.type  // Legacy uppercase column
    };
    
    // Add puck XY
    (evt.puckXY || []).forEach((xy, j) => {
      base[`puck_x_${j+1}`] = xy.x;
      base[`puck_y_${j+1}`] = xy.y;
    });
    
    // Net XY
    if (evt.netXY) {
      base.net_x = evt.netXY.x;
      base.net_y = evt.netXY.y;
    }
    
    // One row per player
    if (evt.players?.length) {
      evt.players.forEach(p => {
        const row = {...base};
        row['player_game_number_'] = p.num;
        row['player_game_number'] = p.num;
        // role_abrev: e1, e2, o1, o2, etc.
        const isOpp = p.role?.includes('opp');
        const rolePrefix = isOpp ? 'o' : 'e';
        row['role_abrev'] = rolePrefix + (p.roleNum || 1);
        row['role_abrev_binary_'] = rolePrefix;  // Just 'e' or 'o'
        row.player_role = p.role;
        row.player_name = p.name;
        row['play_detail1_'] = p.playD1 || '';
        row['play_detail2_'] = p.playD2 || '';
        row['play_detail_successful_'] = p.playSuccess || '';
        row['pressured_pressurer_'] = p.pressure || '';
        row['side_of_puck_'] = p.sideOfPuck || '';  // v16
        row.play_detail1 = p.playD1 || '';
        row.play_detail_2 = p.playD2 || '';
        row.play_detail_successful = p.playSuccess || '';
        row.pressured_pressurer = p.pressure || '';
        row.side_of_puck = p.sideOfPuck || '';  // v16
        
        // Player XY
        (p.xy || []).forEach((xy, j) => {
          row[`player_x_${j+1}`] = xy.x;
          row[`player_y_${j+1}`] = xy.y;
        });
        
        rows.push(row);
      });
    } else {
      // Event with no players still needs a row
      base['player_game_number_'] = '';
      base['role_abrev'] = '';
      rows.push(base);
    }
  });
  
  // Create workbook
  const wb = XLSX.utils.book_new();
  
  // Metadata sheet (v19: includes zone orientation)
  const metadata = [{
    game_id: S.gameId,
    home_team: S.homeTeam,
    away_team: S.awayTeam,
    period_length_minutes: S.periodLength,
    home_attacks_right_p1: S.homeAttacksRightP1 ? 1 : 0,
    export_timestamp: new Date().toISOString(),
    tracker_version: 'v23.3'
  }];
  const wsMeta = XLSX.utils.json_to_sheet(metadata);
  XLSX.utils.book_append_sheet(wb, wsMeta, 'metadata');
  
  // Events sheet
  if (rows.length) {
    const ws = XLSX.utils.json_to_sheet(rows);
    XLSX.utils.book_append_sheet(wb, ws, 'events');
  }
  
  // Shifts sheet
  if (S.shifts.length) {
    // Calculate running goals from events AND per-shift goals
    let homeGoals = 0;
    let awayGoals = 0;
    
    // Pre-calculate goals by shift for running totals AND per-shift plus/minus
    const goalsByShift = [];
    S.shifts.forEach((s, i) => {
      // Store running total at shift START
      const goalsAtStart = { home: homeGoals, away: awayGoals };
      
      // Find goals that occurred IN this shift
      const shiftEvents = S.events.filter(e => 
        e.shiftIdx === i || 
        (e.period === s.period && isTimeBetween(e.start_time, s.start_time, s.end_time))
      );
      
      let homePlus = 0;  // Goals FOR home during this shift (EV/SH only)
      let awayPlus = 0;  // Goals FOR away during this shift (EV/SH only)
      
      // Get shift strength for PP determination
      const shiftStrength = s.strength || '5v5';
      const [homeStr, awayStr] = shiftStrength.split('v').map(n => parseInt(n) || 5);
      const homePP = homeStr > awayStr;  // Home on power play
      const awayPP = awayStr > homeStr;  // Away on power play
      
      shiftEvents.forEach(e => {
        if (e.type === 'Goal' && e.detail1 === 'Goal_Scored') {
          // Always update running total
          if (e.team === 'home') {
            homeGoals++;
            // Plus/minus: Only count if NOT a power play goal
            if (!homePP) {
              homePlus++;
            }
          } else {
            awayGoals++;
            // Away goal on away PP = no +/- change
            if (!awayPP) {
              awayPlus++;
            }
          }
        }
      });
      
      goalsByShift.push({ 
        startHome: goalsAtStart.home, 
        startAway: goalsAtStart.away,
        homePlus: homePlus,
        homeMinus: awayPlus,
        awayPlus: awayPlus,
        awayMinus: homePlus
      });
    });
    
    // Helper to determine zone from X coordinate
    const getZoneFromX = (x, team) => {
      if (x === null || x === undefined) return null;
      const isHome = team === 'home';
      if (x > 125) return isHome ? 'o' : 'd';
      if (x < 75) return isHome ? 'd' : 'o';
      return 'n';
    };
    
    const shiftRows = S.shifts.map((s, i) => {
      const stoppageTime = s.stoppageTime ?? calculateShiftStoppageTime(s);
      const duration = s.duration ?? calculateShiftDuration(s);
      
      const startMin = parseInt(s.start_time?.split(':')[0]) || 0;
      const startSec = parseInt(s.start_time?.split(':')[1]) || 0;
      const endMin = parseInt(s.end_time?.split(':')[0]) || startMin;
      const endSec = parseInt(s.end_time?.split(':')[1]) || startSec;
      
      const period = parseInt(s.period) || 1;
      const periodLengthSec = getPeriodLengthSeconds(s.period);
      // Time elapsed = period length - remaining time (clock counts down)
      const startTotalSec = periodLengthSec - (startMin * 60 + startSec);
      const endTotalSec = periodLengthSec - (endMin * 60 + endSec);
      
      // Running time calculations - sum all previous periods
      let periodOffset = 0;
      for (let p = 1; p < period; p++) {
        periodOffset += getPeriodLengthSeconds(p);
      }
      const startRunning = periodOffset + startTotalSec;
      const endRunning = periodOffset + endTotalSec;
      
      // Calculate running video time WITH intermissions
      const runningVideoTime = s.videoTime || calculateRunningVideoTime(period, s.start_time);
      
      // Calculate intermission duration up to this point
      const int1 = S.videoTiming?.intermission1 || 0;
      const int2 = S.videoTiming?.intermission2 || 0;
      const int3 = S.videoTiming?.intermission3 || 0;
      let shiftIntermissionDuration = 0;
      if (period >= 2) shiftIntermissionDuration += int1;
      if (period >= 3) shiftIntermissionDuration += int2;
      if (period >= 4) shiftIntermissionDuration += int3;
      
      // Determine zone from XY coordinates
      const startZone = s.start_xy?.x != null ? getZoneFromX(s.start_xy.x, 'home') : null;
      const endZone = s.end_xy?.x != null ? getZoneFromX(s.end_xy.x, 'home') : null;
      
      const goals = goalsByShift[i] || { startHome: 0, startAway: 0, homePlus: 0, homeMinus: 0, awayPlus: 0, awayMinus: 0 };
      
      return {
        shift_index: i,
        game_id: S.gameId,
        period: s.period,
        team: s.team,
        player_numbers: (s.players || []).join(','),
        start_time: s.start_time,
        end_time: s.end_time,
        start_type: s.start_type || '',
        stop_type: s.stop_type || '',
        strength: s.strength || '5v5',
        duration: duration,
        stoppage_time: stoppageTime,
        home_goals_start: goals.startHome,
        away_goals_start: goals.startAway,
        home_plus: goals.homePlus,
        home_minus: goals.homeMinus,
        away_plus: goals.awayPlus,
        away_minus: goals.awayMinus,
        start_x: s.start_xy?.x ?? '',
        start_y: s.start_xy?.y ?? '',
        end_x: s.end_xy?.x ?? '',
        end_y: s.end_xy?.y ?? '',
        start_zone: startZone || '',
        end_zone: endZone || '',
        home_ozone_start: startZone === 'o' ? 1 : 0,
        home_ozone_end: endZone === 'o' ? 1 : 0,
        home_dzone_start: startZone === 'd' ? 1 : 0,
        home_dzone_end: endZone === 'd' ? 1 : 0,
        home_nzone_start: startZone === 'n' ? 1 : 0,
        home_nzone_end: endZone === 'n' ? 1 : 0,
        period_start_total_running_seconds: periodOffset,
        running_video_time: runningVideoTime,
        running_intermission_duration: shiftIntermissionDuration,
        shift_start_running_time: startRunning,
        shift_end_running_time: endRunning
      };
    });
    const ws2 = XLSX.utils.json_to_sheet(shiftRows);
    XLSX.utils.book_append_sheet(wb, ws2, 'shifts');
  }
  
  return wb;
}

function exportData() {
  if (!S.gameId) { toast('No game loaded', 'error'); return; }
  
  const wb = buildExportWorkbook();
  XLSX.writeFile(wb, `${S.gameId}_tracking.xlsx`);
  toast('Exported!', 'success');
}

// ============================================================
// IMPORT EXCEL
// ============================================================
async function importExcel(file) {
  if (!file) return;
  
  try {
    const data = await file.arrayBuffer();
    const wb = XLSX.read(data, { type: 'array' });
    
    console.log('Import: Sheets found:', wb.SheetNames);
    
    // Check for required sheets
    const hasEvents = wb.SheetNames.includes('events');
    const hasShifts = wb.SheetNames.includes('shifts');
    const hasMetadata = wb.SheetNames.includes('metadata');
    
    if (!hasEvents && !hasShifts) {
      toast('No events or shifts sheet found', 'error');
      return;
    }
    
    // Read metadata sheet if present (v19: includes zone orientation)
    if (hasMetadata) {
      const metaSheet = XLSX.utils.sheet_to_json(wb.Sheets['metadata']);
      if (metaSheet.length > 0) {
        const meta = metaSheet[0];
        if (meta.home_attacks_right_p1 !== undefined) {
          S.homeAttacksRightP1 = meta.home_attacks_right_p1 === 1 || meta.home_attacks_right_p1 === true;
          updateZoneLabels();
          const btn = document.getElementById('flipZonesBtn');
          if (btn) btn.style.background = S.homeAttacksRightP1 ? '#374151' : '#7c3aed';
        }
        if (meta.period_length_minutes) {
          S.periodLength = meta.period_length_minutes;
        }
        console.log('Import: Loaded metadata - homeAttacksRightP1:', S.homeAttacksRightP1);
      }
    }
    
    // Parse events sheet
    let importedEvents = [];
    let gameId = null;
    let homeTeam = null;
    let awayTeam = null;
    
    if (hasEvents) {
      const eventsSheet = XLSX.utils.sheet_to_json(wb.Sheets['events']);
      console.log('Import: Raw events rows:', eventsSheet.length);
      
      // Get game info from first row
      if (eventsSheet.length > 0) {
        gameId = eventsSheet[0].game_id;
        homeTeam = eventsSheet[0].home_team;
        awayTeam = eventsSheet[0].away_team;
      }
      
      // Group rows by event_index to reconstruct events with multiple players
      // The Excel is in LONG format (one row per player per event)
      const eventGroups = {};
      
      eventsSheet.forEach(row => {
        // Get event index - try multiple column names
        const eventIdx = row.event_index || row['event_index_flag_'] || row.event_index_ || row.tracking_event_index || 0;
        if (!eventIdx) return;
        
        // Get event type - prefer event_type_ over Type (Type is often sparse/calculated)
        const eventType = row.event_type_ || row['event_type_'] || row.Type || '';
        if (!eventType) return; // Skip rows without event type
        
        // Get times - check non-underscore columns first (they have actual data), then underscore versions
        const startMin = row.event_start_min ?? row['event_start_min_'] ?? '';
        const startSec = row.event_start_sec ?? row['event_start_sec_'] ?? '';
        const endMin = row.event_end_min ?? row['event_end_min_'] ?? '';
        const endSec = row.event_end_sec ?? row['event_end_sec_'] ?? '';
        
        if (!eventGroups[eventIdx]) {
          eventGroups[eventIdx] = {
            rows: [],
            period: row.period,
            type: eventType,
            team: parseTeam(row.team_ || row['team_'] || row.team_venue || row.team_venue_abv),
            zone: parseZone(row.event_team_zone_ || row['event_team_zone_'] || row.event_team_zone),
            success: parseSuccess(row.event_successful_ || row['event_successful_'] || row.event_successful),
            detail1: row.event_detail_ || row['event_detail_'] || row.event_detail || '',
            detail2: row.event_detail_2_ || row['event_detail_2_'] || row.event_detail_2 || '',
            start_time: formatTime(startMin, startSec),
            end_time: formatTime(endMin, endSec),
            strength: row.strength || '5v5',
            linkedEventIdx: row.linked_event_index_ || row['linked_event_index_'] || row.linked_event_index || null,
            sequenceIdx: row.sequence_index_ || row['sequence_index_'] || row.sequence_index || null,
            playIdx: row.play_index_ || row['play_index_'] || row.play_index || null
          };
        }
        eventGroups[eventIdx].rows.push(row);
      });
      
      // Convert groups to events
      Object.keys(eventGroups).sort((a, b) => parseInt(a) - parseInt(b)).forEach((idx, i) => {
        const group = eventGroups[idx];
        const evt = {
          idx: i,
          period: parseInt(group.period) || 1,
          type: group.type || 'Unknown',
          team: group.team,
          zone: group.zone,
          success: group.success,
          detail1: group.detail1,
          detail2: group.detail2,
          start_time: group.start_time,
          end_time: group.end_time || group.start_time,
          strength: group.strength,
          linkedEventIdx: group.linkedEventIdx ? parseInt(group.linkedEventIdx) - 1 : null,
          sequenceIdx: group.sequenceIdx,
          playIdx: group.playIdx,
          players: [],
          puckXY: [],
          netXY: null,  // v23.5: Import net target location
          isHighlight: false
        };
        
        // Add players from rows
        group.rows.forEach(row => {
          const playerNum = row.player_game_number_ || row['player_game_number_'] || row.player_game_number;
          if (playerNum && !isNaN(parseInt(playerNum))) {
            const roleAbrev = row.role_abrev || '';
            const playerRoleRaw = row.player_role || '';
            const playerRole = parseRoleFromRaw(playerRoleRaw, roleAbrev);
            const numInt = parseInt(playerNum);
            
            // Determine player team based on role
            // event_team_player = same team as event
            // opp_team_player = opposite team
            const isOppPlayer = playerRoleRaw.includes('opp') || roleAbrev.toLowerCase().startsWith('o');
            const playerTeam = isOppPlayer 
              ? (group.team === 'home' ? 'away' : 'home')
              : group.team;
            
            // Try to get name from roster
            const roster = S.rosters?.[playerTeam] || [];
            const rosterPlayer = roster.find(p => parseInt(p.num) === numInt);
            const playerName = rosterPlayer?.name || row.player_name || `#${numInt}`;
            
            evt.players.push({
              num: numInt,
              name: playerName,
              team: playerTeam,
              role: playerRole,
              roleNum: parseRoleNum(roleAbrev),
              playD1: row.play_detail1_ || row['play_detail1_'] || row.play_detail1 || '',
              playD2: row.play_detail2_ || row['play_detail2_'] || row.play_detail_2 || '',
              playSuccess: row.play_detail_successful_ || row['play_detail_successful_'] || row.play_detail_successful || '',
              pressure: row.pressured_pressurer_ || row['pressured_pressurer_'] || row.pressured_pressurer || '',
              sideOfPuck: row.side_of_puck_ || row['side_of_puck_'] || row.side_of_puck || '',
              xy: []
            });
            
            // v23.5: Extract player XY coordinates for this player
            const lastPlayer = evt.players[evt.players.length - 1];
            for (let k = 1; k <= 10; k++) {
              const plx = row[`player_x_${k}`];
              const ply = row[`player_y_${k}`];
              if (plx !== undefined && ply !== undefined && !isNaN(plx) && !isNaN(ply)) {
                lastPlayer.xy.push({ x: parseFloat(plx), y: parseFloat(ply), seq: k });
              }
            }
          }
          
          // Extract puck XY coordinates
          for (let j = 1; j <= 10; j++) {
            const px = row[`puck_x_${j}`];
            const py = row[`puck_y_${j}`];
            if (px !== undefined && py !== undefined && !isNaN(px) && !isNaN(py)) {
              // Only add if not already present (since it's repeated per player row)
              if (!evt.puckXY.find(p => p.x === px && p.y === py)) {
                evt.puckXY.push({ x: parseFloat(px), y: parseFloat(py) });
              }
            }
          }
          
          // v23.5: Extract net XY coordinates (shot target)
          if (!evt.netXY) {
            const nx = row.net_x ?? row['net_x'];
            const ny = row.net_y ?? row['net_y'];
            if (nx !== undefined && ny !== undefined && !isNaN(nx) && !isNaN(ny)) {
              evt.netXY = { x: parseFloat(nx), y: parseFloat(ny) };
            }
          }
        });
        
        importedEvents.push(evt);
      });
      
      console.log('Import: Parsed events:', importedEvents.length);
    }
    
    // Parse shifts sheet
    let importedShifts = [];
    
    if (hasShifts) {
      const shiftsSheet = XLSX.utils.sheet_to_json(wb.Sheets['shifts']);
      console.log('Import: Raw shifts rows:', shiftsSheet.length);
      
      // Get game info if not already set
      if (!gameId && shiftsSheet.length > 0) {
        gameId = shiftsSheet[0].game_id;
        homeTeam = shiftsSheet[0].home_team;
        awayTeam = shiftsSheet[0].away_team;
      }
      
      shiftsSheet.forEach((row, i) => {
        // Handle NaN values for stop_type
        let stopType = row.shift_stop_type;
        if (stopType === null || stopType === undefined || (typeof stopType === 'number' && isNaN(stopType)) || stopType === 'nan') {
          stopType = '';
        }
        
        const shift = {
          period: parseInt(row.Period) || 1,
          start_time: formatTime(row.shift_start_min, row.shift_start_sec),
          end_time: formatTime(row.shift_end_min, row.shift_end_sec),
          start_type: row.shift_start_type || 'OnTheFly',
          stop_type: stopType,
          strength: row.strength || '5v5',
          duration: row.shift_duration || null,
          stoppageTime: row.stoppage_time || 0,
          home: {
            F1: parsePlayer(row.home_forward_1, 'home'),
            F2: parsePlayer(row.home_forward_2, 'home'),
            F3: parsePlayer(row.home_forward_3, 'home'),
            D1: parsePlayer(row.home_defense_1, 'home'),
            D2: parsePlayer(row.home_defense_2, 'home'),
            G: parsePlayer(row.home_goalie, 'home'),
            X: parsePlayer(row.home_xtra, 'home')
          },
          away: {
            F1: parsePlayer(row.away_forward_1, 'away'),
            F2: parsePlayer(row.away_forward_2, 'away'),
            F3: parsePlayer(row.away_forward_3, 'away'),
            D1: parsePlayer(row.away_defense_1, 'away'),
            D2: parsePlayer(row.away_defense_2, 'away'),
            G: parsePlayer(row.away_goalie, 'away'),
            X: parsePlayer(row.away_xtra, 'away')
          }
        };
        importedShifts.push(shift);
      });
      
      console.log('Import: Parsed shifts:', importedShifts.length);
    }
    
    // Confirm import
    const evtCount = importedEvents.length;
    const shiftCount = importedShifts.length;
    const msg = `Import ${evtCount} events and ${shiftCount} shifts from game ${gameId}?\n\nThis will REPLACE current data.\n\nNote: Select the game in dropdown FIRST to load rosters for player name lookup.`;
    
    if (!confirm(msg)) {
      toast('Import cancelled', 'info');
      document.getElementById('importFileInput').value = '';
      return;
    }
    
    // Try to select the game if we have a gameId
    if (gameId) {
      S.gameId = parseInt(gameId);
      S.homeTeam = homeTeam;
      S.awayTeam = awayTeam;
      
      // Try to select the game in dropdown and load roster
      const gameSelect = document.getElementById('gameSelect');
      if (gameSelect && gameSelect.querySelector(`option[value="${gameId}"]`)) {
        gameSelect.value = gameId;
        // Try to load roster for this game
        try {
          await selectGame(gameId);
          // Re-process players with loaded roster
          importedShifts = importedShifts.map(shift => ({
            ...shift,
            home: {
              F1: shift.home.F1 ? parsePlayer(shift.home.F1.num, 'home') : null,
              F2: shift.home.F2 ? parsePlayer(shift.home.F2.num, 'home') : null,
              F3: shift.home.F3 ? parsePlayer(shift.home.F3.num, 'home') : null,
              D1: shift.home.D1 ? parsePlayer(shift.home.D1.num, 'home') : null,
              D2: shift.home.D2 ? parsePlayer(shift.home.D2.num, 'home') : null,
              G: shift.home.G ? parsePlayer(shift.home.G.num, 'home') : null,
              X: shift.home.X ? parsePlayer(shift.home.X.num, 'home') : null
            },
            away: {
              F1: shift.away.F1 ? parsePlayer(shift.away.F1.num, 'away') : null,
              F2: shift.away.F2 ? parsePlayer(shift.away.F2.num, 'away') : null,
              F3: shift.away.F3 ? parsePlayer(shift.away.F3.num, 'away') : null,
              D1: shift.away.D1 ? parsePlayer(shift.away.D1.num, 'away') : null,
              D2: shift.away.D2 ? parsePlayer(shift.away.D2.num, 'away') : null,
              G: shift.away.G ? parsePlayer(shift.away.G.num, 'away') : null,
              X: shift.away.X ? parsePlayer(shift.away.X.num, 'away') : null
            }
          }));
        } catch (e) {
          console.log('Could not load game roster:', e);
        }
      }
    }
    
    // v20.5: Load dim values and check for mapping needs
    await loadDimValuesForValidation();
    const mappingsNeeded = analyzeImportMappings(importedEvents);
    
    // Function to complete import (called after mappings are applied or skipped)
    const completeImport = (events, shifts) => {
      S.events = events;
      S.shifts = shifts;
      S.evtIdx = events.length;
      S.shiftIdx = shifts.length;
      
      // POST-IMPORT: Propagate XY data to linked events missing it
      propagateXYToLinkedEvents();
      
      // Render
      renderAll();
      autoSave();
      
      toast(`Imported ${events.length} events, ${shifts.length} shifts`, 'success');
      console.log('Import complete:', { events: S.events.length, shifts: S.shifts.length });
    };
    
    // If mappings needed, show modal
    if (mappingsNeeded.length > 0) {
      console.log('Import: Found', mappingsNeeded.length, 'values needing mapping review');
      showMappingModal(
        mappingsNeeded,
        // onAccept - apply mappings then complete
        (finalMappings) => {
          const mappedEvents = applyMappingsToEvents(importedEvents, finalMappings);
          completeImport(mappedEvents, importedShifts);
        },
        // onSkip - complete without mappings
        () => {
          toast('Skipped value mapping - using original values', 'info');
          completeImport(importedEvents, importedShifts);
        }
      );
    } else {
      // No mappings needed - all values match
      console.log('Import: All values match dim tables');
      completeImport(importedEvents, importedShifts);
    }
    
  } catch (e) {
    console.error('Import error:', e);
    toast('Import failed: ' + e.message, 'error');
  }
  
  // Reset file input
  document.getElementById('importFileInput').value = '';
}

/**
 * POST-IMPORT: Propagate XY data to linked events missing it
 * For each event without puckXY, find a sibling (same linkedEventIdx) that has XY and copy it
 */
function propagateXYToLinkedEvents() {
  if (!S.events?.length) return;
  
  let propagatedCount = 0;
  
  // Group events by linkedEventIdx
  const linkedGroups = {};
  S.events.forEach((evt, idx) => {
    if (evt.linkedEventIdx !== null && evt.linkedEventIdx !== undefined) {
      const key = evt.linkedEventIdx;
      if (!linkedGroups[key]) linkedGroups[key] = [];
      linkedGroups[key].push({ evt, idx });
    }
  });
  
  // For each linked group, find events with XY and propagate to those without
  Object.values(linkedGroups).forEach(group => {
    // Find events in this group that have XY data
    const withXY = group.filter(g => g.evt.puckXY?.length > 0);
    const withoutXY = group.filter(g => !g.evt.puckXY?.length);
    
    if (withXY.length === 0 || withoutXY.length === 0) return;
    
    // Use the most recent event with XY as source
    const source = withXY.sort((a, b) => b.idx - a.idx)[0].evt;
    
    // Copy XY to events missing it
    withoutXY.forEach(({ evt, idx }) => {
      // Copy puck XY
      if (source.puckXY?.length) {
        S.events[idx].puckXY = JSON.parse(JSON.stringify(source.puckXY));
      }
      // Copy net XY
      if (source.netXY) {
        S.events[idx].netXY = JSON.parse(JSON.stringify(source.netXY));
      }
      // Copy player XY (without role swapping for simplicity during import)
      if (source.players?.length) {
        source.players.forEach(srcPlayer => {
          if (!srcPlayer.xy?.length) return;
          
          const existingIdx = S.events[idx].players?.findIndex(p => 
            p.num === srcPlayer.num && p.team === srcPlayer.team
          );
          
          if (existingIdx >= 0) {
            S.events[idx].players[existingIdx].xy = JSON.parse(JSON.stringify(srcPlayer.xy));
          } else {
            if (!S.events[idx].players) S.events[idx].players = [];
            S.events[idx].players.push(JSON.parse(JSON.stringify(srcPlayer)));
          }
        });
      }
      propagatedCount++;
    });
  });
  
  if (propagatedCount > 0) {
    console.log(`Propagated XY data to ${propagatedCount} linked events`);
    toast(`Filled XY for ${propagatedCount} linked events`, 'info');
  }
}

// Helper functions for import
function parseTeam(value) {
  if (!value) return 'home';
  const v = String(value).toLowerCase().trim();
  if (v === 'h' || v === 'home' || v.includes('home')) return 'home';
  if (v === 'a' || v === 'away' || v.includes('away')) return 'away';
  return 'home';
}

function parseZone(value) {
  if (!value) return 'n';
  const v = String(value).toLowerCase().trim();
  if (v === 'o' || v === 'off' || v.includes('offensive')) return 'o';
  if (v === 'd' || v === 'def' || v.includes('defensive')) return 'd';
  if (v === 'n' || v === 'neu' || v.includes('neutral')) return 'n';
  return 'n';
}

function parseSuccess(value) {
  if (value === null || value === undefined || value === '') return null;
  const v = String(value).toLowerCase().trim();
  if (v === 's' || v === 'y' || v === 'yes' || v === 'true' || v === '1') return true;
  if (v === 'u' || v === 'n' || v === 'no' || v === 'false' || v === '0') return false;
  return null;
}

function formatTime(min, sec) {
  if (min === null || min === undefined || min === '') return '';
  const m = String(min).padStart(2, '0');
  const s = String(sec || 0).padStart(2, '0');
  return `${m}:${s}`;
}

function parsePlayer(num, team) {
  if (!num || isNaN(parseInt(num))) return null;
  const numInt = parseInt(num);
  
  // Try to find player name from roster
  const roster = S.rosters?.[team] || [];
  const rosterPlayer = roster.find(p => parseInt(p.num) === numInt);
  
  return { 
    num: numInt, 
    name: rosterPlayer?.name || `#${numInt}` 
  };
}

function parseRoleFromRaw(rawRole, abrev) {
  // Convert Excel role format to tracker format
  // Excel: event_team_player_1, opp_team_player_1
  // Tracker: event_player_1, opp_player_1
  if (rawRole) {
    // Replace event_team_player with event_player
    if (rawRole.includes('event_team_player')) {
      return rawRole.replace('event_team_player', 'event_player');
    }
    // Replace opp_team_player with opp_player
    if (rawRole.includes('opp_team_player')) {
      return rawRole.replace('opp_team_player', 'opp_player');
    }
    // Already in correct format
    if (rawRole.includes('event_player') || rawRole.includes('opp_player')) {
      return rawRole;
    }
  }
  
  // Fall back to parsing from abbreviation
  return parseRoleFromAbrev(abrev);
}

function parseRoleFromAbrev(abrev) {
  if (!abrev) return 'event_player_1';
  const a = String(abrev).toLowerCase().trim();
  
  // e, e1, e2 -> event_player_X
  if (a === 'e' || a.startsWith('e')) {
    const num = parseInt(a.substring(1)) || 1;
    return `event_player_${num}`;
  }
  // o, o1, o2 -> opp_player_X
  if (a === 'o' || a.startsWith('o')) {
    const num = parseInt(a.substring(1)) || 1;
    return `opp_player_${num}`;
  }
  // h1, h2 -> event_player (home)
  if (a.startsWith('h')) {
    const num = parseInt(a.substring(1)) || 1;
    return `event_player_${num}`;
  }
  // a1, a2 -> could be either depending on context
  if (a.startsWith('a')) {
    const num = parseInt(a.substring(1)) || 1;
    return `event_player_${num}`;
  }
  
  return 'event_player_1';
}

function parseRoleNum(abrev) {
  if (!abrev) return 1;
  const match = String(abrev).match(/\d+/);
  return match ? parseInt(match[0]) : 1;
}

// ============================================================
// KEYBOARD
// ============================================================
function setupKeys() {
  document.addEventListener('keydown', e => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
    
    const key = e.key.toUpperCase();
    
    // Event type hotkeys - flash indicator on activation (v5)
    const typeMap = { F:'Faceoff', S:'Shot', P:'Pass', G:'Goal', T:'Turnover', Z:'Zone_Entry_Exit', N:'Penalty', X:'Stoppage', O:'Possession', V:'Save', R:'Rebound', D:'DeadIce', Y:'Play' };
    if (typeMap[key]) { 
      setEvtType(typeMap[key]); 
      flashHotkeyIndicator(key);
      return; 
    }
    
    // Enter = log event (with confirmation), Shift+Enter = quick log (no confirmation)
    if (e.key === 'Enter') { 
      if (e.shiftKey) {
        logEventDirect(); // Quick log without confirmation
      } else {
        logEvent(); // Normal log (shows confirmation if not skipped)
      }
      return; 
    }
    
    // Escape = clear or close modals
    if (e.key === 'Escape') { 
      // Close any open modals first
      const modals = document.querySelectorAll('.overlay.show');
      if (modals.length > 0) {
        modals.forEach(m => m.classList.remove('show'));
        return;
      }
      clearEvent(); 
      return; 
    }
    
    // L = log shift
    if (key === 'L') { logShift(); return; }
    
    // E = end shift (v5)
    if (key === 'E') { endShift(); return; }
    
    // Tab = switch XY mode
    if (e.key === 'Tab') { e.preventDefault(); setXYMode(S.xyMode === 'puck' ? 'player' : 'puck'); return; }
    
    // v16.06: P = switch to puck XY mode
    if (key === 'P' && !e.ctrlKey && !e.altKey) { setXYMode('puck'); toast('üèí Puck XY mode', 'info'); return; }
    
    // H/A = set team
    if (key === 'H') { setEvtTeam('home'); return; }
    if (key === 'A') { setEvtTeam('away'); return; }
    
    // Shift+S = swap event/opp teams (v23.3)
    if (e.shiftKey && key === 'S') { swapEvtTeam(); return; }
    
    // ` (backtick) = switch to puck XY mode (v16.06)
    if (e.key === '`') { 
      setXYMode('puck'); 
      toast('Switched to Puck XY mode', 'info'); 
      return; 
    }
    
    // v6: 1-6 = select event player slot (not period anymore)
    // Use Alt+1-6 for opponent players (Ctrl+1-6 conflicts with browser tab switching)
    // v23.3: If player is selected, reassign their role instead of adding new
    if (['1','2','3','4','5','6'].includes(e.key)) {
      e.preventDefault();
      const num = parseInt(e.key);
      
      // If Shift is held, force ADD new player (bypass role reassignment)
      if (e.shiftKey) {
        selectEventPlayerSlot(e.altKey ? 'opp' : 'evt', num);
        return;
      }
      
      // If a player is selected, reassign their role
      if (S.selectedPlayer) {
        const newRole = e.altKey ? 'opp_team_player_' + num : 'event_team_player_' + num;
        const oldRole = S.selectedPlayer.role;
        
        // Check if another player already has this role
        const existing = S.curr.players.find(p => p !== S.selectedPlayer && 
          (p.role === newRole || p.role === newRole.replace('_team', '') || p.roleNum === num));
        
        if (existing) {
          // Swap roles with existing player
          existing.role = oldRole;
          existing.roleNum = S.selectedPlayer.roleNum;
        }
        
        S.selectedPlayer.role = newRole;
        S.selectedPlayer.roleNum = num;
        renumberPlayers();
        renderQuickAdd();
        toast(`Reassigned #${S.selectedPlayer.num} to ${e.altKey ? 'O' : 'E'}${num}`, 'success');
        return;
      }
      
      // No player selected - use slot-based add/select
      if (e.altKey || e.ctrlKey) {
        selectEventPlayerSlot('opp', num);
      } else {
        selectEventPlayerSlot('evt', num);
      }
      return;
    }
    
    // Q = quick line change (v6)
    if (key === 'Q') { quickLineChange(); return; }
    
    // W = cycle forward presets, Shift+W = cycle D presets (v6)
    if (key === 'W') {
      if (e.shiftKey) {
        cyclePreset(S.evtTeam, 'D');
      } else {
        cyclePreset(S.evtTeam, 'F');
      }
      return;
    }
    
    // * = toggle highlight (v5)
    if (e.key === '*' || (e.shiftKey && e.key === '8')) {
      const hl = document.getElementById('isHighlight');
      if (hl) { hl.checked = !hl.checked; toast(hl.checked ? '‚≠ê Highlight ON' : 'Highlight OFF', 'info'); }
      return;
    }
    
    // Ctrl+Z = smart undo (XY if points exist, otherwise events)
    if (e.ctrlKey && key === 'Z' && !e.shiftKey) { 
      e.preventDefault(); 
      // If there are XY points to undo, undo those first
      if (S.curr && S.curr.puckXY && S.curr.puckXY.length > 0) {
        undoLastXY();
      } else if (undoStack && undoStack.length > 0) {
        undo();
      } else {
        undoLastXY(); // Fallback
      }
      return; 
    }
    
    // Ctrl+Shift+Z = force undo event (v23.5)
    if (e.ctrlKey && e.shiftKey && key === 'Z') { e.preventDefault(); undo(); return; }
    
    // Arrow keys in edit modals (v5)
    if (e.key === 'ArrowLeft' && S.editingEvtIdx !== null) { navEditEvent(-1); return; }
    if (e.key === 'ArrowRight' && S.editingEvtIdx !== null) { navEditEvent(1); return; }
    if (e.key === 'ArrowLeft' && S.editingShiftIdx !== null) { navEditShift(-1); return; }
    if (e.key === 'ArrowRight' && S.editingShiftIdx !== null) { navEditShift(1); return; }
    
    // ? = open help
    if (e.key === '?') { openHelp(); return; }
  });
}

/**
 * Flash hotkey indicator for visual feedback (v5)
 */
function flashHotkeyIndicator(key) {
  const btn = document.querySelector(`.evt-btn[data-hotkey="${key}"]`);
  if (btn) {
    btn.classList.add('hotkey-flash');
    setTimeout(() => btn.classList.remove('hotkey-flash'), 300);
  }
}

/**
 * End current shift with current clock time (v5)
 */
function endShift() {
  const clock = document.getElementById('clock').value;
  document.getElementById('shiftEnd').value = clock;
  toast(`Shift end set to ${clock}`, 'info');
}

// ============================================================
// V6 FEATURES: LINE PRESETS, PERIOD FILTERS, COMPACT MODE
// ============================================================

// Line preset storage
S.linePresets = JSON.parse(localStorage.getItem('bs_line_presets') || '{}');
S.shiftLogFilter = 'all';
S.eventLogFilter = 'all';
// v20.4: Advanced event filters
S.eventFilters = {
  type: '',
  detail1: '',
  detail2: '',
  playDetail1: '',
  playDetail2: '',
  team: '',
  eventIdx: null,
  linkedIdx: null,
  shiftIdx: null
};
S.selectedPlayerSlot = null;
S.compactMode = false;

// v20.5: Dim table value cache for import validation
S.dimValues = {
  event_type: [],
  event_detail: [],
  event_detail_2: [],
  play_detail: [],
  play_detail_2: [],
  loaded: false
};
S.pendingMappings = null; // Holds mappings during modal review

/**
 * v20.5: Load dim table values from Supabase for import validation
 * v22.1: Fixed to load ALL values and better fallback
 */
async function loadDimValuesForValidation() {
  if (S.dimValues.loaded) return true;
  
  try {
    // Try Supabase first
    if (typeof supabase !== 'undefined' && S.sb) {
      const tables = [
        { name: 'dim_event_type', field: 'event_type', col: 'event_type_code' },
        { name: 'dim_event_detail', field: 'event_detail', col: 'event_detail_code' },
        { name: 'dim_event_detail_2', field: 'event_detail_2', col: 'event_detail_2_code' },
        { name: 'dim_play_detail', field: 'play_detail', col: 'play_detail_code' },
        { name: 'dim_play_detail_2', field: 'play_detail_2', col: 'play_detail_2_code' }
      ];
      
      let loadedCount = 0;
      for (const t of tables) {
        // v22.1: Load ALL rows (up to 1000) - use .limit(1000) to ensure we get everything
        const { data, error } = await S.sb.from(t.name).select(t.col).limit(1000);
        if (!error && data && data.length > 0) {
          S.dimValues[t.field] = data.map(r => r[t.col]).filter(Boolean);
          loadedCount++;
          console.log(`Loaded ${S.dimValues[t.field].length} values from ${t.name}`);
        } else {
          console.warn(`Failed to load ${t.name}:`, error || 'no data');
        }
      }
      
      if (loadedCount >= 3) {
        S.dimValues.loaded = true;
        console.log('Loaded dim values from Supabase:', Object.keys(S.dimValues).map(k => `${k}: ${S.dimValues[k]?.length || 0}`).join(', '));
        return true;
      }
    }
  } catch (e) {
    console.warn('Supabase dim load failed, using fallback:', e);
  }
  
  // v22.1: Comprehensive fallback values (if Supabase load fails)
  S.dimValues.event_type = ['Shot', 'Save', 'Pass', 'Faceoff', 'Turnover', 'Zone_Entry_Exit', 'Possession', 'Penalty', 'Hit', 'Block', 'Stoppage', 'Goal', 'GameStart', 'GameEnd', 'PeriodStart', 'PeriodEnd', 'Rebound', 'DeadIce', 'Play', 'Intermission', 'Clockstop', 'Timeout', 'LoosePuck', 'PenaltyShot_Shootout', 'Penalty_Delayed'];
  
  S.dimValues.event_detail = ['Shot_OnNetSaved', 'Shot_Goal', 'Goal_Scored', 'Shot_Missed', 'Shot_MissedWide', 'Shot_MissedHigh', 'Shot_HitPost', 'Shot_Blocked', 'Shot_TippedOnNetSaved', 'Shot_OnNetGoal', 'Shot_BlockedSameTeam', 'Shot_Deflected', 'Pass_Completed', 'Pass_Missed', 'Pass_Intercepted', 'Pass_Deflected', 'Turnover_Giveaway', 'Turnover_Takeaway', 'Zone_Entry', 'Zone_Exit', 'Zone_Keepin', 'Zone_EntryFailed', 'Zone_ExitFailed', 'Faceoff_Won', 'Faceoff_Lost', 'Faceoff_PeriodStart', 'Faceoff_GameStart', 'Faceoff_AfterGoal', 'Faceoff_AfterPenalty', 'Faceoff_AfterStoppage', 'Save_Rebound', 'Save_Freeze', 'Save_Played', 'Stoppage_PeriodEnd', 'Stoppage_Play', 'Stoppage_Other', 'Stoppage_GameEnd', 'Penalty_Minor', 'Penalty_Major', 'Penalty_Misconduct', 'Goal_Shootout', 'Goal_PenaltyShot', 'Rebound_TeamRecovered', 'Rebound_OppRecovered', 'Rebound_ShotGenerated', 'DeadIce_Icing', 'DeadIce_Offside', 'DeadIce_PuckOut', 'Play_Offensive', 'Play_Defensive', 'Breakaway', 'PuckRetrieval', 'PuckRecovery', 'Regroup', 'LoosePuck'];
  
  // v22.1: Full list of event_detail_2 values
  S.dimValues.event_detail_2 = [
    // Pass modifiers
    'Pass_Forehand', 'Pass_Backhand', 'Pass_Bank', 'Pass_Stretch', 'Pass_Rim/Wrap', 'Pass_Drop', 'Pass_Dump', 'Pass_OneTouch', 'Pass_Lob', 'Pass_Reverse', 'Pass_QuickUp', 'Pass_GiveAndGo', 'Pass_SecondTouch', 'Pass_Tipped', 'Pass_Deflected/TippedShot', 'Pass_ReceiverMissed', 'Pass_Other',
    // Shot modifiers
    'Shot_Wrist', 'Shot_Slap', 'Shot_Backhand', 'Shot_Snap', 'Shot_WrapAround', 'Shot_Bat', 'Shot_Poke', 'Shot_OneTime', 'Shot_Tip', 'Shot_Deflection', 'Shot_Other', 'Shot_BetweenLegs', 'Shot_Cradle',
    // Goal modifiers
    'Goal_Wrist', 'Goal_Slap', 'Goal_Backhand', 'Goal_Snap', 'Goal_WrapAround', 'Goal_Bat', 'Goal_Poke', 'Goal_OneTime', 'Goal_Tip', 'Goal_Deflection', 'Goal_Dumpin', 'Goal_Other', 'Goal_BetweenLegs', 'Goal_Cradle',
    // Save modifiers
    'Save_Glove', 'Save_Blocker', 'Save_Pad', 'Save_Stick', 'Save_Butterfly', 'Save_Other',
    // Zone entry modifiers
    'ZoneEntry_Rush', 'ZoneEntry_Carry', 'ZoneEntry_Pass', 'ZoneEntry_DumpIn', 'ZoneEntry_Chip', 'ZoneEntry_OppTeam', 'ZoneEntry_PassMiss/Misplay',
    // Zone exit modifiers  
    'ZoneExit_Rush', 'ZoneExit_Carry', 'ZoneExit_Pass', 'ZoneExit_Clear', 'ZoneExit_Chip', 'ZoneExit_PassMiss/Misplay',
    // Giveaway modifiers
    'Giveaway_Misplayed', 'Giveaway_BattleLost', 'Giveaway_PassIntercepted', 'Giveaway_PassMissed', 'Giveaway_PassBlocked', 'Giveaway_PassReceiverMissed', 'Giveaway_ShotBlocked', 'Giveaway_ShotMissed', 'Giveaway_DumpInZone', 'Giveaway_ZoneClear/Dump', 'Giveaway_ZoneEntry/ExitMisplay', 'Giveaway_AttemptedZoneClear/Dump', 'Giveaway_Other',
    // Takeaway modifiers
    'Takeaway_BattleWon', 'Takeaway_PokeCheck', 'Takeaway_PassIntercepted', 'Takeaway_PassBlocked', 'Takeaway_Other',
    // Stoppage modifiers
    'Stoppage_Icing', 'Stoppage_Offsides', 'Stoppage_GoalieStoppage', 'Stoppage_PuckOut', 'Stoppage_Penalty', 'Stoppage_Goal', 'Stoppage_HandPass', 'Stoppage_NetOff', 'Stoppage_Injury',
    // Penalty modifiers
    'Penalty_Tripping', 'Penalty_Hooking', 'Penalty_Slashing', 'Penalty_Interference', 'Penalty_Holding', 'Penalty_Roughing', 'Penalty_HighSticking', 'Penalty_CrossChecking', 'Penalty_Boarding', 'Penalty_Other',
    // Play context modifiers
    'Deke', 'DriveMiddle', 'DriveWide', 'DumpChase', 'Rush', 'Cycle', 'Rebound', 'OneTimer', 'Tip', 'Deflection', 'Breakaway', 'OddManRush', 'CrashNet', 'Forecheck', 'Backcheck', 'NetFront', 'PointShot', 'Screen',
    // Zone keep-in
    'Zone_KeepIn', 'ZoneEntry_KeepIn'
  ];
  
  // v22.1: Comprehensive play_detail fallback (111 values from dim_play_detail)
  S.dimValues.play_detail = ['AssistPrimary','AssistSecondary','AssistTertiary','AttemptedBlockedShot','AttemptedBreakOutClear','AttemptedBreakOutPass','AttemptedBreakOutRush','AttemptedEntryDumpIn','AttemptedEntryPass','AttemptedEntryRush','AttemptedKeepin','AttemptedPass','AttemptedShot','AttemptedTip/Deflection','Backcheck','BeatDeke','BeatFake','BeatMiddle','BeatSpeed','BeatWide','BlockedShot','BoxOut','Breakout','CededZoneEntry','CededZoneExit','Chip','ClearingAttempt','Contain','CrashNet','CutBack','Cycle','DeflectedShot','Deke','Delay','DelayedOffside','DriveCorner','DriveMiddle','DriveNetMiddle','DriveNetWide','DriveWide','Dump/RimInZone','DumpChase','DumpInAttempt','EndToEndRush','FakeShot','ForcedDumpin/Clear','ForcedLostPossession','ForcedMissedPass','ForcedMissedShot','ForcedTurnover','ForceWide','ForecedOutside','Forecheck','FrontofNet','GapControl','GiveAndGo','InShotPassLane','LoosePuckBattleLost','LoosePuckBattleWon','LostPuck','ManOnMan','MisplayedPuck','OpenIceDeke','Other','PassDeflected','PassForTip','PassIntercepted','PenaltyKillClear','PokeCheck','Pressure','PuckRecoveryRetreivalAttemptedClear','PuckRecoveryRetreivalClear','PuckRecoveryRetreivalDumpIn','PuckRecoveryRetreivalFaceoff','PuckRecoveryRetreivalLoosePuckBattle','PuckRecoveryRetreivalOther','PuckRecoveryRetreivalPass','PuckRecoveryRetreivalRebound','PuckRecoveryRetreivalShot','PuckRecoveryRetreivalTurnover','PuckRetrievalDumpIn','PuckRetrievalRebound','PuckRetrievalShot','QuickUp','ReceiverMissed','RecoveryRetreivalDumpIn','RecoveryRetreivalFaceoff','RecoveryRetreivalOther','RecoveryRetreivalPass','RecoveryRetreivalRebound','RecoveryRetreivalShot','RecoveryRetreivalTurnover','RecoveryRetrievalDumpIn','RecoveryRetrievalShot','Regroup','RegroupClear','RegroupDumpin','Reverse','Screen','SecondTouch','SeperateFromPuck','Speed','StickCheck','StoppedDeke','Surf','Tracker','Wheel','Zone','ZoneEntryDenial','ZoneExitDenial','ZoneKeepin'];
  
  // v22.1: Comprehensive play_detail_2 fallback (111 values from dim_play_detail_2)
  S.dimValues.play_detail_2 = ['AssistPrimary','AssistSecondary','AssistTertiary','AttemptedBlockedShot','AttemptedBreakOutClear','AttemptedBreakOutPass','AttemptedBreakOutRush','AttemptedEntryDumpIn','AttemptedEntryPass','AttemptedEntryRush','AttemptedKeepin','AttemptedPass','AttemptedShot','AttemptedTip/Deflection','Backcheck','BeatDeke','BeatFake','BeatMiddle','BeatSpeed','BeatWide','BlockedShot','BoxOut','Breakout','CededZoneEntry','CededZoneExit','Chip','ClearingAttempt','Contain','CrashNet','CutBack','Cycle','DeflectedShot','Deke','Delay','DelayedOffside','DriveCorner','DriveMiddle','DriveNetMiddle','DriveNetWide','DriveWide','Dump/RimInZone','DumpChase','DumpInAttempt','EndToEndRush','FakeShot','ForcedDumpin/Clear','ForcedLostPossession','ForcedMissedPass','ForcedMissedShot','ForcedTurnover','ForceWide','ForecedOutside','Forecheck','FrontofNet','GapControl','GiveAndGo','InShotPassLane','LoosePuckBattleLost','LoosePuckBattleWon','LostPuck','ManOnMan','MisplayedPuck','OpenIceDeke','Other','PassDeflected','PassForTip','PassIntercepted','PenaltyKillClear','PokeCheck','Pressure','PuckRecoveryRetreivalAttemptedClear','PuckRecoveryRetreivalClear','PuckRecoveryRetreivalDumpIn','PuckRecoveryRetreivalFaceoff','PuckRecoveryRetreivalLoosePuckBattle','PuckRecoveryRetreivalOther','PuckRecoveryRetreivalPass','PuckRecoveryRetreivalRebound','PuckRecoveryRetreivalShot','PuckRecoveryRetreivalTurnover','PuckRetrievalDumpIn','PuckRetrievalRebound','PuckRetrievalShot','QuickUp','ReceiverMissed','RecoveryRetreivalDumpIn','RecoveryRetreivalFaceoff','RecoveryRetreivalOther','RecoveryRetreivalPass','RecoveryRetreivalRebound','RecoveryRetreivalShot','RecoveryRetreivalTurnover','RecoveryRetrievalDumpIn','RecoveryRetrievalShot','Regroup','RegroupClear','RegroupDumpin','Reverse','Screen','SecondTouch','SeperateFromPuck','Speed','StickCheck','StoppedDeke','Surf','Tracker','Wheel','Zone','ZoneEntryDenial','ZoneExitDenial','ZoneKeepin'];
  
  S.dimValues.loaded = true;
  console.log('Loaded fallback dim values (Supabase unavailable)');
  return true;
}

/**
 * v20.5: Normalize string for fuzzy matching
 * Handles: case, underscores vs hyphens vs spaces, common prefixes
 */
function normalizeForMatch(str) {
  if (!str) return '';
  return str
    .toLowerCase()
    .replace(/[-_ ]/g, '')  // Remove separators
    .replace(/^(play|shot|pass|zone|turnover|giveaway|takeaway|save|faceoff|goal)[_-]?/i, '')  // Remove common prefixes for matching
    .trim();
}

/**
 * v23.5: Synonym map for fuzzy matching old data formats
 * Maps old terminology to current terminology (from Supabase dim tables)
 */
const VALUE_SYNONYMS = {
  // Zone Entry/Exit Rush = Carried (with puck control)
  'ZoneEntry_Rush': 'ZoneEntry_Carried',
  'ZoneEntry-Rush': 'ZoneEntry-Carried',
  'ZoneEntry Rush': 'ZoneEntry Carried',
  'Entry_Rush': 'Entry_Carried',
  'Entry-Rush': 'Entry-Carried',
  'Rush': 'Carried',
  
  'ZoneExit_Rush': 'ZoneExit_Carried', 
  'ZoneExit-Rush': 'ZoneExit-Carried',
  'ZoneExit Rush': 'ZoneExit Carried',
  'Exit_Rush': 'Exit_Carried',
  'Exit-Rush': 'Exit-Carried',
  
  // Other common mappings
  'Shot_OnNet': 'Shot_OnNetSaved',
  'Shot On Net': 'Shot_OnNetSaved',
  'Blocked': 'Shot_Blocked',
  'Missed': 'Shot_Missed'
};

/**
 * v23.5: Apply synonyms before fuzzy matching
 */
function applySynonyms(value) {
  if (!value) return value;
  
  // Check exact synonym match
  if (VALUE_SYNONYMS[value]) {
    return VALUE_SYNONYMS[value];
  }
  
  // Check case-insensitive
  const lower = value.toLowerCase();
  for (const [key, replacement] of Object.entries(VALUE_SYNONYMS)) {
    if (key.toLowerCase() === lower) {
      return replacement;
    }
  }
  
  // Check if value contains Rush (for zone entries/exits)
  if (value.toLowerCase().includes('rush') && 
      (value.toLowerCase().includes('entry') || value.toLowerCase().includes('exit') || value.toLowerCase().includes('zone'))) {
    return value.replace(/rush/gi, 'Carried');
  }
  
  return value;
}

/**
 * v20.5: Calculate match score between two strings (0-100)
 */
function matchScore(a, b) {
  if (!a || !b) return 0;
  
  // v23.5: Apply synonyms first
  const aSyn = applySynonyms(a);
  const bSyn = applySynonyms(b);
  
  const na = normalizeForMatch(aSyn);
  const nb = normalizeForMatch(bSyn);
  
  // Exact match (normalized)
  if (na === nb) return 100;
  
  // One contains the other
  if (na.includes(nb) || nb.includes(na)) return 85;
  
  // Levenshtein-ish: count common chars
  const setA = new Set(na.split(''));
  const setB = new Set(nb.split(''));
  const intersection = [...setA].filter(c => setB.has(c)).length;
  const union = new Set([...setA, ...setB]).size;
  const similarity = union > 0 ? (intersection / union) * 100 : 0;
  
  return Math.round(similarity);
}

/**
 * v20.5: Find best match from valid values
 * v23.5: Added synonym support for old data formats
 */
function findBestMatch(value, validValues, threshold = 60) {
  if (!value || !validValues?.length) return { match: null, score: 0, type: 'none' };
  
  // v23.5: Apply synonyms first (e.g., Rush -> Carry)
  const synonymValue = applySynonyms(value);
  
  // Check exact match first (case-insensitive) - with synonym applied
  const exactMatch = validValues.find(v => 
    v.toLowerCase() === value.toLowerCase() || 
    v.toLowerCase() === synonymValue.toLowerCase()
  );
  if (exactMatch) return { match: exactMatch, score: 100, type: 'exact' };
  
  // Fuzzy match using synonym-applied value
  let best = { match: null, score: 0 };
  for (const candidate of validValues) {
    const score = matchScore(synonymValue, candidate);
    if (score > best.score) {
      best = { match: candidate, score };
    }
  }
  
  if (best.score >= threshold) {
    return { ...best, type: 'fuzzy' };
  }
  
  return { match: null, score: best.score, type: 'none' };
}

/**
 * v20.5: Analyze imported events and find mappings needed
 */
function analyzeImportMappings(events) {
  const fields = [
    { key: 'type', dimKey: 'event_type', label: 'Event Type' },
    { key: 'detail1', dimKey: 'event_detail', label: 'Event Detail' },
    { key: 'detail', dimKey: 'event_detail', label: 'Event Detail' },  // Alias
    { key: 'detail2', dimKey: 'event_detail_2', label: 'Event Detail 2' }
  ];
  
  // Also check player play details
  const playerFields = [
    { key: 'playD1', dimKey: 'play_detail', label: 'Play Detail 1' },
    { key: 'playD2', dimKey: 'play_detail_2', label: 'Play Detail 2' }
  ];
  
  const mappings = [];
  const seenValues = new Set();
  
  // Collect unique values from events
  for (const evt of events) {
    for (const f of fields) {
      const val = evt[f.key];
      if (val && !seenValues.has(`${f.dimKey}:${val}`)) {
        seenValues.add(`${f.dimKey}:${val}`);
        const result = findBestMatch(val, S.dimValues[f.dimKey]);
        if (result.type !== 'exact') {
          mappings.push({
            field: f.label,
            dimKey: f.dimKey,
            eventKey: f.key,
            original: val,
            ...result
          });
        }
      }
    }
    
    // Check player play details
    for (const player of (evt.players || [])) {
      for (const f of playerFields) {
        const val = player[f.key];
        if (val && !seenValues.has(`${f.dimKey}:${val}`)) {
          seenValues.add(`${f.dimKey}:${val}`);
          const result = findBestMatch(val, S.dimValues[f.dimKey]);
          if (result.type !== 'exact') {
            mappings.push({
              field: f.label,
              dimKey: f.dimKey,
              eventKey: f.key,
              isPlayerField: true,
              original: val,
              ...result
            });
          }
        }
      }
    }
  }
  
  return mappings;
}

/**
 * v20.5: Show mapping modal for user review
 * v22.1: Added "Show More" functionality and ensured correct dim table per field
 */
function showMappingModal(mappings, onAccept, onSkip) {
  // Create modal HTML
  const fuzzyCount = mappings.filter(m => m.type === 'fuzzy').length;
  const noMatchCount = mappings.filter(m => m.type === 'none').length;
  
  let tableRows = mappings.map((m, i) => {
    // v22.1: Get options ONLY from the correct dim table for this field
    const allOptions = S.dimValues[m.dimKey] || [];
    const dimTableName = m.dimKey; // e.g., "event_detail_2"
    
    // v22.1: Sort options by relevance to the original value
    const scoredOptions = allOptions.map(o => ({
      value: o,
      score: matchScore(m.original, o)
    })).sort((a, b) => b.score - a.score);
    
    // v22.1: Show top 8 matches initially, with "Show More" to expand
    const topOptions = scoredOptions.slice(0, 8);
    const hasMore = scoredOptions.length > 8;
    
    // Build select HTML with top matches first
    let selectHtml = '<select id="mapping_' + i + '" class="mapping-select" onchange="handleMappingSelect(this, ' + i + ', \'' + m.dimKey + '\')">';
    selectHtml += '<option value="">-- No mapping --</option>';
    
    // Add suggested match first if it exists and not in top options
    if (m.match && !topOptions.find(o => o.value === m.match)) {
      const mScore = scoredOptions.find(o => o.value === m.match)?.score || m.score;
      selectHtml += '<option value="' + m.match + '" selected>‚úì ' + m.match + ' (' + mScore + '%)</option>';
    }
    
    // Add top scored options
    for (const opt of topOptions) {
      const selected = opt.value === m.match ? 'selected' : '';
      const scoreLabel = opt.score > 0 ? ' (' + opt.score + '%)' : '';
      selectHtml += '<option value="' + opt.value + '" ' + selected + '>' + opt.value + scoreLabel + '</option>';
    }
    
    // Add "Show More" option if there are more values
    if (hasMore) {
      selectHtml += '<option value="__SHOW_MORE__">‚ñº Show all ' + allOptions.length + ' from ' + dimTableName + '...</option>';
    }
    
    selectHtml += '</select>';
    
    const typeIcon = m.type === 'fuzzy' ? '‚âà' : '?';
    
    return '<tr data-dimkey="' + m.dimKey + '">' +
      '<td class="field">' + m.field + '</td>' +
      '<td class="original">' + m.original + '</td>' +
      '<td>' + typeIcon + '</td>' +
      '<td>' + selectHtml + '</td>' +
      '<td class="score">' + m.score + '%</td>' +
    '</tr>';
  }).join('');
  
  const modalHtml = 
    '<div class="modal mapping-modal" id="mappingModal">' +
      '<h3>üìã Import Value Mapping</h3>' +
      '<p class="summary">' +
        'Found <strong>' + mappings.length + '</strong> values needing review: ' +
        '<span style="color:var(--accent)">' + fuzzyCount + ' fuzzy matches</span>, ' +
        '<span style="color:var(--danger)">' + noMatchCount + ' no matches</span>' +
      '</p>' +
      '<p style="font-size:10px;color:var(--muted);">Each dropdown shows top matches from its correct dim table. Click "Show all" to see all options.</p>' +
      '<div class="mapping-legend">' +
        '<span><span class="dot exact"></span> Exact (auto-mapped)</span>' +
        '<span><span class="dot fuzzy"></span> Fuzzy (suggested)</span>' +
        '<span><span class="dot none"></span> No match (select manually)</span>' +
      '</div>' +
      '<table class="mapping-table">' +
        '<thead>' +
          '<tr><th>Field</th><th>Original Value</th><th>Type</th><th>Map To</th><th>Score</th></tr>' +
        '</thead>' +
        '<tbody>' + tableRows + '</tbody>' +
      '</table>' +
      '<div class="modal-actions">' +
        '<button class="btn-cancel" onclick="closeMappingModal(false)">Skip (Keep Original)</button>' +
        '<button class="btn-success" onclick="closeMappingModal(true)">Apply Mappings</button>' +
      '</div>' +
    '</div>' +
    '<div class="modal-overlay" onclick="closeMappingModal(false)"></div>';
  
  // Store callbacks
  S.pendingMappings = { mappings, onAccept, onSkip };
  
  // Show modal
  const container = document.createElement('div');
  container.id = 'mappingModalContainer';
  container.innerHTML = modalHtml;
  document.body.appendChild(container);
}

/**
 * v22.1: Handle mapping select change - expand to show all options when "Show More" selected
 */
function handleMappingSelect(select, idx, dimKey) {
  if (select.value === '__SHOW_MORE__') {
    // Get all options from the correct dim table
    const allOptions = S.dimValues[dimKey] || [];
    const original = S.pendingMappings?.mappings[idx]?.original || '';
    
    // Sort by match score
    const scoredOptions = allOptions.map(o => ({
      value: o,
      score: matchScore(original, o)
    })).sort((a, b) => b.score - a.score);
    
    // Rebuild select with ALL options
    let newHtml = '<option value="">-- No mapping --</option>';
    for (const opt of scoredOptions) {
      const scoreLabel = opt.score > 0 ? ' (' + opt.score + '%)' : '';
      newHtml += '<option value="' + opt.value + '">' + opt.value + scoreLabel + '</option>';
    }
    
    select.innerHTML = newHtml;
    select.value = ''; // Reset selection so user can pick
    
    // Update the row to show it's expanded
    const row = select.closest('tr');
    if (row) {
      row.style.backgroundColor = 'rgba(100, 200, 255, 0.1)';
    }
    
    toast('Showing all ' + allOptions.length + ' values from ' + dimKey, 'info');
  }
}

function closeMappingModal(apply) {
  const container = document.getElementById('mappingModalContainer');
  if (!container) return;
  
  if (apply && S.pendingMappings) {
    // Read user selections
    const finalMappings = S.pendingMappings.mappings.map((m, i) => {
      const select = document.getElementById(`mapping_${i}`);
      return {
        ...m,
        mappedTo: select?.value || null
      };
    }).filter(m => m.mappedTo); // Only include ones with a mapping
    
    if (S.pendingMappings.onAccept) {
      S.pendingMappings.onAccept(finalMappings);
    }
  } else {
    if (S.pendingMappings?.onSkip) {
      S.pendingMappings.onSkip();
    }
  }
  
  container.remove();
  S.pendingMappings = null;
}

/**
 * v20.5: Apply mappings to events array
 */
function applyMappingsToEvents(events, mappings) {
  if (!mappings?.length) return events;
  
  // Build lookup: original -> mapped
  const lookup = {};
  for (const m of mappings) {
    const key = `${m.eventKey}:${m.original}`;
    lookup[key] = m.mappedTo;
  }
  
  // Apply to events
  let changeCount = 0;
  for (const evt of events) {
    // Event-level fields
    for (const field of ['type', 'detail', 'detail1', 'detail2']) {
      const key = `${field}:${evt[field]}`;
      if (lookup[key]) {
        console.log(`Mapping ${field}: ${evt[field]} ‚Üí ${lookup[key]}`);
        evt[field] = lookup[key];
        changeCount++;
      }
    }
    
    // Player-level fields
    for (const player of (evt.players || [])) {
      for (const field of ['playD1', 'playD2']) {
        const key = `${field}:${player[field]}`;
        if (lookup[key]) {
          console.log(`Mapping player ${field}: ${player[field]} ‚Üí ${lookup[key]}`);
          player[field] = lookup[key];
          changeCount++;
        }
      }
    }
  }
  
  toast(`Applied ${changeCount} value mappings`, 'success');
  return events;
}

/**
 * Load a line preset into slots
 */
function loadPreset(team, preset) {
  const key = `${team}_${preset}`;
  const presetData = S.linePresets[key];
  if (!presetData || !presetData.players || presetData.players.length === 0) {
    toast(`No ${preset} preset saved for ${team}`, 'info');
    return;
  }
  
  // Determine which slots to fill based on preset type
  const isForward = preset.startsWith('F');
  const slots = isForward ? ['F1','F2','F3'] : ['D1','D2'];
  
  // Clear relevant slots first
  slots.forEach(slot => { S.slots[team][slot] = null; });
  
  // Fill slots with preset players
  presetData.players.forEach((num, i) => {
    if (i < slots.length) {
      const player = S.rosters[team].find(p => String(p.num) === String(num));
      if (player) {
        S.slots[team][slots[i]] = player;
      }
    }
  });
  
  renderSlots();
  renderRosters();
  onSlotsChanged();
  toast(`Loaded ${team} ${preset}: ${presetData.players.join(', ')}`, 'success');
}

/**
 * Save current slots as a preset
 */
function savePreset(team, preset) {
  const isForward = preset.startsWith('F');
  const slots = isForward ? ['F1','F2','F3'] : ['D1','D2'];
  
  const players = slots
    .map(slot => S.slots[team]?.[slot]?.num)
    .filter(num => num);
  
  if (players.length === 0) {
    toast(`No players in ${preset} slots`, 'warning');
    return;
  }
  
  const key = `${team}_${preset}`;
  S.linePresets[key] = { name: preset, players };
  localStorage.setItem('bs_line_presets', JSON.stringify(S.linePresets));
  toast(`Saved ${team} ${preset}: ${players.join(', ')}`, 'success');
}

/**
 * Cycle through forward or defense presets
 */
function cyclePreset(team, type) {
  const presets = type === 'F' ? ['F1','F2','F3'] : ['D1','D2'];
  const currentIdx = S.cycleIdx?.[team]?.[type] || 0;
  const nextIdx = (currentIdx + 1) % presets.length;
  
  if (!S.cycleIdx) S.cycleIdx = {};
  if (!S.cycleIdx[team]) S.cycleIdx[team] = {};
  S.cycleIdx[team][type] = nextIdx;
  
  loadPreset(team, presets[nextIdx]);
}

/**
 * Open line preset configuration modal
 */
function openLinePresetModal() {
  // Build modal content showing current presets
  let html = '<div style="max-height:400px;overflow-y:auto;">';
  
  ['home', 'away'].forEach(team => {
    html += `<h4 style="color:var(--accent);margin:8px 0 4px;">${team.toUpperCase()} PRESETS</h4>`;
    
    // Forward lines
    ['F1','F2','F3'].forEach(preset => {
      const key = `${team}_${preset}`;
      const data = S.linePresets[key];
      const players = data?.players?.join(', ') || 'Not set';
      html += `
        <div style="display:flex;gap:8px;align-items:center;margin:4px 0;">
          <span style="width:30px;font-weight:bold;">${preset}:</span>
          <span style="flex:1;color:var(--muted);">${players}</span>
          <button class="btn-sm" onclick="savePreset('${team}','${preset}')">Save Current</button>
          <button class="btn-sm" onclick="clearPreset('${team}','${preset}')">Clear</button>
        </div>`;
    });
    
    // Defense pairs
    ['D1','D2'].forEach(preset => {
      const key = `${team}_${preset}`;
      const data = S.linePresets[key];
      const players = data?.players?.join(', ') || 'Not set';
      html += `
        <div style="display:flex;gap:8px;align-items:center;margin:4px 0;">
          <span style="width:30px;font-weight:bold;">${preset}:</span>
          <span style="flex:1;color:var(--muted);">${players}</span>
          <button class="btn-sm" onclick="savePreset('${team}','${preset}')">Save Current</button>
          <button class="btn-sm" onclick="clearPreset('${team}','${preset}')">Clear</button>
        </div>`;
    });
  });
  
  html += '</div>';
  
  // Use a simple alert-style modal
  const modal = document.createElement('div');
  modal.className = 'overlay show';
  modal.id = 'linePresetModal';
  modal.innerHTML = `
    <div class="modal" style="min-width:400px;">
      <h3>‚öôÔ∏è Line Presets Configuration</h3>
      ${html}
      <p style="font-size:9px;color:var(--muted);margin-top:8px;">
        Fill slots with players, then click "Save Current" to save as a preset.
        Use preset buttons or W/Shift+W to cycle presets.
      </p>
      <div class="modal-actions" style="margin-top:16px;">
        <button class="btn-primary" onclick="closeLinePresetModal()">Close</button>
      </div>
    </div>`;
  document.body.appendChild(modal);
}

function closeLinePresetModal() {
  const modal = document.getElementById('linePresetModal');
  if (modal) modal.remove();
}

function clearPreset(team, preset) {
  const key = `${team}_${preset}`;
  delete S.linePresets[key];
  localStorage.setItem('bs_line_presets', JSON.stringify(S.linePresets));
  closeLinePresetModal();
  openLinePresetModal();
  toast(`Cleared ${team} ${preset}`, 'info');
}

/**
 * Filter shift log by period
 */
function filterShiftLog(period) {
  S.shiftLogFilter = period;
  
  // Update tab styles
  document.querySelectorAll('#leftPanel .period-filter-tab').forEach(tab => {
    tab.classList.toggle('active', tab.dataset.filter === period);
  });
  
  renderShiftLog();
}

/**
 * Filter event log by period
 */
function filterEventLog(period) {
  S.eventLogFilter = period;
  
  // Update tab styles
  document.querySelectorAll('.evt-list .period-filter-tab').forEach(tab => {
    tab.classList.toggle('active', tab.dataset.filter === period);
  });
  
  renderEvents();
}

/**
 * v20.4: Populate filter dropdowns with unique values from events
 */
function populateEventFilterDropdowns() {
  if (!S.events?.length) return;
  
  // Collect unique values
  const types = new Set();
  const detail1s = new Set();
  const detail2s = new Set();
  const pd1s = new Set();
  const pd2s = new Set();
  
  S.events.forEach(e => {
    if (e.type) types.add(e.type);
    if (e.detail1 || e.detail) detail1s.add(e.detail1 || e.detail);
    if (e.detail2) detail2s.add(e.detail2);
    
    // Get play details from primary player
    const primaryPlayer = (e.players || []).find(p => p.role?.startsWith('event') || !p.role?.startsWith('opp'));
    if (primaryPlayer?.playD1) pd1s.add(primaryPlayer.playD1);
    if (primaryPlayer?.playD2) pd2s.add(primaryPlayer.playD2);
  });
  
  // Helper to populate a select
  const populateSelect = (id, values) => {
    const sel = document.getElementById(id);
    if (!sel) return;
    const current = sel.value;
    sel.innerHTML = '<option value="">All</option>' + 
      [...values].sort().map(v => `<option value="${v}">${v.substring(0,15)}</option>`).join('');
    sel.value = current; // Restore selection
  };
  
  populateSelect('filterEvtType', types);
  populateSelect('filterEvtDetail1', detail1s);
  populateSelect('filterEvtDetail2', detail2s);
  populateSelect('filterPlayDetail1', pd1s);
  populateSelect('filterPlayDetail2', pd2s);
}

/**
 * v20.4: Apply event filters from UI
 */
function applyEventFilters() {
  S.eventFilters.type = document.getElementById('filterEvtType')?.value || '';
  S.eventFilters.detail1 = document.getElementById('filterEvtDetail1')?.value || '';
  S.eventFilters.detail2 = document.getElementById('filterEvtDetail2')?.value || '';
  S.eventFilters.playDetail1 = document.getElementById('filterPlayDetail1')?.value || '';
  S.eventFilters.playDetail2 = document.getElementById('filterPlayDetail2')?.value || '';
  S.eventFilters.team = document.getElementById('filterEvtTeam')?.value || '';
  
  const evtIdxVal = document.getElementById('filterEvtIdx')?.value;
  S.eventFilters.eventIdx = evtIdxVal ? parseInt(evtIdxVal) : null;
  
  const linkIdxVal = document.getElementById('filterLinkIdx')?.value;
  S.eventFilters.linkedIdx = linkIdxVal ? parseInt(linkIdxVal) : null;
  
  const shiftIdxVal = document.getElementById('filterShiftIdx')?.value;
  S.eventFilters.shiftIdx = shiftIdxVal ? parseInt(shiftIdxVal) : null;
  
  renderEvents();
}

/**
 * v20.4: Clear all event filters
 */
function clearEventFilters() {
  S.eventFilters = {
    type: '',
    detail1: '',
    detail2: '',
    playDetail1: '',
    playDetail2: '',
    team: '',
    eventIdx: null,
    linkedIdx: null,
    shiftIdx: null
  };
  
  // Clear UI elements
  ['filterEvtType', 'filterEvtDetail1', 'filterEvtDetail2', 'filterPlayDetail1', 
   'filterPlayDetail2', 'filterEvtTeam'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.value = '';
  });
  ['filterEvtIdx', 'filterLinkIdx', 'filterShiftIdx'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.value = '';
  });
  
  renderEvents();
  toast('Filters cleared', 'info');
}

/**
 * Toggle compact mode
 */
function toggleCompactMode() {
  S.compactMode = !S.compactMode;
  document.body.classList.toggle('compact-mode', S.compactMode);
  toast(S.compactMode ? 'Compact mode ON' : 'Compact mode OFF', 'info');
}

/**
 * Toggle event log visibility (v17)
 */
function toggleEventLog() {
  const section = document.getElementById('eventLogSection');
  const body = document.getElementById('evtListBody');
  const tabs = section?.querySelector('.period-filter-tabs');
  
  if (body) {
    const isHidden = body.style.display === 'none';
    body.style.display = isHidden ? 'block' : 'none';
    if (tabs) tabs.style.display = isHidden ? 'flex' : 'none';
    toast(isHidden ? 'Event log shown' : 'Event log hidden', 'info');
  }
}

/**
 * Select event player slot for XY/details editing (v6)
 */
function selectEventPlayerSlot(type, num) {
  const rolePrefix1 = type === 'evt' ? 'event_team_player_' : 'opp_team_player_';
  const rolePrefix2 = type === 'evt' ? 'event_player_' : 'opp_player_';
  
  // Check if player with this role already exists (check both role formats)
  let player = S.curr.players.find(p => 
    p.role === rolePrefix1 + num || 
    p.role === rolePrefix2 + num ||
    (p.roleNum === num && p.role?.startsWith(type === 'evt' ? 'event' : 'opp'))
  );
  
  if (player) {
    // Player exists - just SELECT them (don't add duplicate)
    S.selectedPlayer = player;
    setXYMode('player');
    S.xySlot = (player.xy?.length || 0) + 1; // Start at next XY slot
    renderXYSlots();
    renderQuickAdd(); // Highlight selected player
    toast(`Selected ${type === 'evt' ? 'E' : 'O'}${num}: #${player.num}`, 'info');
    return;
  }
  
  // Player doesn't exist - try to add from slots
  const team = type === 'evt' ? S.evtTeam : (S.evtTeam === 'home' ? 'away' : 'home');
  const slots = S.slots[team];
  
  // Map slot positions to player numbers (F1, F2, F3, D1, D2)
  const slotMap = { 1: 'F1', 2: 'F2', 3: 'F3', 4: 'D1', 5: 'D2', 6: 'G' };
  const slotKey = slotMap[num];
  const slotPlayer = slots[slotKey];
  
  if (slotPlayer) {
    // Add player to current event
    player = {
      num: slotPlayer.num,
      name: slotPlayer.name,
      team: team,
      role: rolePrefix1 + num,
      roleNum: num,
      xy: [],
      playD1: '',
      playD2: '',
      playSuccess: '',
      pressuredBy: '',
      sideOfPuck: ''
    };
    S.curr.players.push(player);
    S.selectedPlayer = player;
    setXYMode('player');
    S.xySlot = 1;
    renderXYSlots();
    renderQuickAdd();
    toast(`Added ${type === 'evt' ? 'E' : 'O'}${num}: #${slotPlayer.num} ${slotPlayer.name}`, 'success');
  } else {
    toast(`${type === 'evt' ? 'Event' : 'Opp'} Player ${num} - No player in slot ${slotKey}`, 'warning');
    return;
  }
}

/**
 * Quick line change - ends all current shifts and starts new ones (v6)
 */
function quickLineChange() {
  const clock = document.getElementById('clock').value;
  
  // Log current shift with end time
  document.getElementById('shiftEnd').value = clock;
  logShift();
  
  // Start new shift immediately
  document.getElementById('shiftStart').value = clock;
  document.getElementById('shiftEnd').value = '';
  
  toast('Quick line change recorded', 'success');
}

// ============================================================
// RESIZE PANELS
// ============================================================
let resizing = null;
function startResize(e, panel) {
  resizing = { panel, startX: e.clientX, startWidth: document.getElementById(panel + 'Panel').offsetWidth };
  document.addEventListener('mousemove', doResize);
  document.addEventListener('mouseup', stopResize);
}
function doResize(e) {
  if (!resizing) return;
  const diff = e.clientX - resizing.startX;
  const newWidth = resizing.panel === 'left' ? resizing.startWidth + diff : resizing.startWidth - diff;
  document.getElementById(resizing.panel + 'Panel').style.width = Math.max(150, Math.min(400, newWidth)) + 'px';
}
function stopResize() { resizing = null; document.removeEventListener('mousemove', doResize); document.removeEventListener('mouseup', stopResize); }

// ============================================================
// v23.4: GENERIC MODAL
// ============================================================

/**
 * Show generic modal with HTML content
 */
function showModal(html) {
  const overlay = document.getElementById('genericModal');
  const content = document.getElementById('genericModalContent');
  if (!overlay || !content) return;
  
  content.innerHTML = html;
  overlay.classList.add('show');
}

/**
 * Close generic modal
 */
function closeModal() {
  const overlay = document.getElementById('genericModal');
  if (overlay) overlay.classList.remove('show');
}

// ============================================================
// TOAST
// ============================================================
function toast(msg, type = '') {
  const el = document.getElementById('toast');
  el.textContent = msg;
  el.className = 'toast show ' + type;
  setTimeout(() => el.classList.remove('show'), 2000);
}

// ============================================================
// START
// ============================================================
document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
