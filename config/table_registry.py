#!/usr/bin/env python3
"""
TABLE REGISTRY - Single Source of Truth for All Tables
=======================================================

This module maintains a registry of ALL tables in the BenchSight system,
including their generation source, dependencies, and protection status.

RULES:
1. NEVER delete a table without checking this registry
2. ALWAYS update this registry when adding new tables
3. Tables marked as PROTECTED cannot be auto-deleted
4. Run validate() before any cleanup operation

Usage:
    from config.table_registry import TableRegistry
    
    registry = TableRegistry()
    
    # Check if table exists and is protected
    if registry.is_protected("fact_h2h"):
        print("Cannot delete - table is protected!")
    
    # Get generation source
    source = registry.get_source("fact_player_game_stats")
    print(f"Generated by: {source}")
    
    # Validate all tables exist
    missing = registry.validate()
    if missing:
        print(f"Missing tables: {missing}")
"""

from dataclasses import dataclass, field
from typing import List, Dict, Optional
from pathlib import Path
from enum import Enum
import json
import logging

logger = logging.getLogger(__name__)


class TableType(Enum):
    DIMENSION = "dim"
    FACT = "fact"
    QA = "qa"
    OTHER = "other"


class ProtectionLevel(Enum):
    NONE = 0          # Can be deleted freely
    LOW = 1           # Warn before deleting
    MEDIUM = 2        # Require confirmation
    HIGH = 3          # Cannot be auto-deleted
    CRITICAL = 4      # System will not function without this


@dataclass
class TableDefinition:
    name: str
    table_type: TableType
    source_module: str
    source_function: Optional[str] = None
    protection: ProtectionLevel = ProtectionLevel.LOW
    dependencies: List[str] = field(default_factory=list)
    description: str = ""
    min_rows: int = 0


class TableRegistry:
    """Registry of all BenchSight tables."""
    
    OUTPUT_DIR = Path("data/output")
    
    def __init__(self):
        self.tables: Dict[str, TableDefinition] = {}
        self._register_all_tables()
    
    def _register_all_tables(self):
        """Register all known tables."""
        
        # CORE DIMENSIONS
        for name in ["dim_period", "dim_venue", "dim_zone", "dim_strength", "dim_situation",
                     "dim_position", "dim_event_type", "dim_event_detail", "dim_event_detail_2",
                     "dim_play_detail", "dim_play_detail_2", "dim_shot_type", "dim_pass_type",
                     "dim_zone_entry_type", "dim_zone_exit_type", "dim_giveaway_type",
                     "dim_takeaway_type", "dim_turnover_type", "dim_stoppage_type", "dim_success",
                     "dim_shift_start_type", "dim_shift_stop_type", "dim_shift_slot",
                     "dim_player_role", "dim_season", "dim_league", "dim_team", "dim_player",
                     "dim_schedule", "dim_playerurlref", "dim_danger_level", "dim_shot_outcome",
                     "dim_save_outcome", "dim_pass_outcome", "dim_zone_outcome",
                     "dim_turnover_quality", "dim_competition_tier"]:
            self._register(TableDefinition(
                name=name, table_type=TableType.DIMENSION,
                source_module="src/core/base_etl.py",
                protection=ProtectionLevel.HIGH
            ))
        
        # EXTENDED DIMENSIONS
        for name, source in [
            ("dim_assist_type", "src/advanced/extended_tables.py"),
            ("dim_game_state", "src/advanced/extended_tables.py"),
            ("dim_time_bucket", "src/advanced/extended_tables.py"),
            ("dim_shift_quality_tier", "src/advanced/extended_tables.py"),
            ("dim_stat_category", "src/advanced/create_additional_tables.py"),
            ("dim_micro_stat", "src/advanced/create_additional_tables.py"),
            ("dim_danger_zone", "src/advanced/enhance_all_stats.py"),
            ("dim_composite_rating", "src/advanced/enhance_all_stats.py"),
        ]:
            self._register(TableDefinition(
                name=name, table_type=TableType.DIMENSION,
                source_module=source, protection=ProtectionLevel.MEDIUM
            ))
        
        # CORE FACTS
        critical_facts = ["fact_events", "fact_shifts_player", "fact_gameroster", "fact_player_game_stats"]
        for name in critical_facts:
            self._register(TableDefinition(
                name=name, table_type=TableType.FACT,
                source_module="src/core/base_etl.py",
                protection=ProtectionLevel.CRITICAL, min_rows=50
            ))
        
        high_facts = ["fact_event_players", "fact_shift_players",
                      "fact_sequences", "fact_plays", "fact_zone_entries", "fact_zone_exits",
                      "fact_scoring_chances_detailed", "fact_goalie_game_stats", "fact_team_game_stats",
                      "fact_h2h", "fact_wowy", "fact_line_combos"]
        for name in high_facts:
            self._register(TableDefinition(
                name=name, table_type=TableType.FACT,
                source_module="src/core/base_etl.py",
                protection=ProtectionLevel.HIGH, min_rows=10
            ))
        
        # ADVANCED FACTS
        advanced_facts = [
            ("fact_player_career_stats", "src/advanced/extended_tables.py"),
            ("fact_team_season_stats", "src/advanced/extended_tables.py"),
            ("fact_season_summary", "src/advanced/extended_tables.py"),
            ("fact_player_trends", "src/advanced/extended_tables.py"),
            ("fact_zone_entry_summary", "src/advanced/extended_tables.py"),
            ("fact_zone_exit_summary", "src/advanced/extended_tables.py"),
            ("fact_player_position_splits", "src/advanced/extended_tables.py"),
            ("fact_period_momentum", "src/advanced/extended_tables.py"),
            ("fact_special_teams_summary", "src/advanced/extended_tables.py"),
            ("fact_player_stats_long", "src/advanced/create_additional_tables.py"),
            ("fact_matchup_summary", "src/advanced/create_additional_tables.py"),
            ("fact_shift_quality", "src/advanced/create_additional_tables.py"),
            ("fact_scoring_chances", "src/advanced/create_additional_tables.py"),
            ("fact_player_micro_stats", "src/advanced/create_additional_tables.py"),
            ("fact_player_period_stats", "src/advanced/enhance_all_stats.py"),
            ("fact_shot_danger", "src/advanced/enhance_all_stats.py"),
            ("fact_team_zone_time", "src/advanced/create_additional_tables.py"),
        ]
        for name, source in advanced_facts:
            self._register(TableDefinition(
                name=name, table_type=TableType.FACT,
                source_module=source, protection=ProtectionLevel.HIGH
            ))
        
        # OTHER FACTS
        other_facts = ["fact_tracking", "fact_breakouts", "fact_rushes", "fact_turnovers_detailed",
                       "fact_penalties", "fact_registration", "fact_leadership",
                       "fact_player_game_position", "fact_player_boxscore_all",
                       "fact_player_pair_stats", "fact_player_event_chains"]
        for name in other_facts:
            self._register(TableDefinition(
                name=name, table_type=TableType.FACT,
                source_module="src/core/base_etl.py",
                protection=ProtectionLevel.MEDIUM
            ))
        
        # QA TABLES
        for name in ["qa_goal_accuracy", "qa_data_completeness", "qa_validation_summary"]:
            self._register(TableDefinition(
                name=name, table_type=TableType.QA,
                source_module="src/advanced/extended_tables.py",
                protection=ProtectionLevel.LOW
            ))
    
    def _register(self, table: TableDefinition):
        self.tables[table.name] = table
    
    def get(self, name: str) -> Optional[TableDefinition]:
        return self.tables.get(name)
    
    def get_source(self, name: str) -> str:
        table = self.get(name)
        return table.source_module if table else "UNKNOWN"
    
    def is_protected(self, name: str) -> bool:
        table = self.get(name)
        return table.protection.value >= ProtectionLevel.HIGH.value if table else False
    
    def validate(self) -> List[str]:
        """Return list of missing table names."""
        return [name for name in self.tables if not (self.OUTPUT_DIR / f"{name}.csv").exists()]
    
    def get_by_type(self, table_type: TableType) -> List[str]:
        return [name for name, t in self.tables.items() if t.table_type == table_type]
    
    def get_critical_tables(self) -> List[str]:
        return [name for name, t in self.tables.items() if t.protection == ProtectionLevel.CRITICAL]
    
    def can_delete(self, name: str, force: bool = False) -> tuple:
        table = self.get(name)
        if not table:
            return (True, "Not in registry")
        if table.protection == ProtectionLevel.CRITICAL:
            return (False, "CRITICAL - System requires this")
        if table.protection == ProtectionLevel.HIGH and not force:
            return (False, "HIGH protection - use force=True")
        return (True, "OK")
    
    def save_to_json(self, path: str = "config/table_registry.json"):
        Path(path).parent.mkdir(parents=True, exist_ok=True)
        data = {name: {"type": t.table_type.value, "source": t.source_module,
                       "protection": t.protection.name}
                for name, t in self.tables.items()}
        with open(path, 'w') as f:
            json.dump(data, f, indent=2)
    
    def __len__(self):
        return len(self.tables)


def main():
    """Test the registry."""
    print("=" * 60)
    print("TABLE REGISTRY VALIDATION")
    print("=" * 60)
    
    registry = TableRegistry()
    print(f"\nRegistered: {len(registry)} tables")
    print(f"  Dimensions: {len(registry.get_by_type(TableType.DIMENSION))}")
    print(f"  Facts: {len(registry.get_by_type(TableType.FACT))}")
    print(f"  QA: {len(registry.get_by_type(TableType.QA))}")
    print(f"\nCritical: {registry.get_critical_tables()}")
    
    missing = registry.validate()
    if missing:
        print(f"\n❌ Missing {len(missing)} tables:")
        for t in missing[:10]:
            print(f"  - {t}")
    else:
        print("\n✅ All tables exist")
    
    registry.save_to_json()
    print(f"\nSaved to config/table_registry.json")


if __name__ == "__main__":
    main()
